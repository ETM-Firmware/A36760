Disassembly Listing for A34760
Generated From:
C:/Users/DPARKER/Documents/GitHub/A36760/A34760.X/dist/default/production/A34760.X.production.elf
Oct 5, 2020 11:08:37 AM

---  C:/Users/DPARKER/Documents/GitHub/A36760/faults.c  -------------------------------------------------
1:                 #include "A34760.h"
2:                 #include "faults.h"
3:                 #include "A34760_PINS.h"
4:                 #include <libpic30.h>
5:                 #include "Config.h"
6:                 #include "MCP23017.h"
7:                 
8:                 
9:                 TYPE_DEBUG_COUNTER global_debug_counter;
10:                
11:                unsigned int CalculatePulseEnergyMilliJoules(unsigned int lambda_voltage);
12:                
13:                void StorePulseData(POWERSUPPLY* ptr);
14:                
15:                // The status register used for debug purposes
16:                unsigned int debug_status_register;
17:                
18:                // MAGNETRON CONTROL FAULT REGISTERS
19:                unsigned int faults_magnetron_status_reg;
20:                unsigned int faults_magnetron_fault_reg;
21:                unsigned int faults_magnetron_warning_reg;
22:                
23:                // HIGH VOLTAGE FAULT REGISTERS
24:                unsigned int faults_high_voltage_status_reg;
25:                unsigned int faults_high_voltage_fault_reg;
26:                unsigned int faults_high_voltage_warning_reg;
27:                
28:                
29:                #define EOC_MAX_COUNT	    3
30:                #define EOC_TIMER_WINDOW   	100	  /* 1s in 10ms step */
31:                unsigned char lambda_eoc_fault = 0;
32:                unsigned char eoc_counts = 0;
33:                int eoc_max_reached_timer = 0;
34:                int eoc_10ms_timer[EOC_MAX_COUNT];
35:                unsigned int eoc_counts_total = 0;
36:                
37:                
38:                // THYRATRON HEATER FAULT REGISTERS
39:                unsigned int faults_thyratron_status_reg;
40:                unsigned int faults_thyratron_fault_reg;
41:                unsigned int faults_thyratron_warning_reg;
42:                
43:                
44:                // CONTROL BOARD FAULT REGISTERS
45:                unsigned int faults_control_board_status_reg;
46:                unsigned int faults_control_board_fault_reg;
47:                unsigned int faults_control_board_warning_reg;
48:                
49:                
50:                
51:                // Variables to save the active fault/warning masks for this control loop state
52:                unsigned int magnetron_fault_mask;
53:                unsigned int high_voltage_fault_mask;
54:                unsigned int thyratron_fault_mask;
55:                unsigned int control_board_fault_mask;
56:                
57:                unsigned int magnetron_warning_mask;
58:                unsigned int high_voltage_warning_mask;
59:                unsigned int thyratron_warning_mask;
60:                unsigned int control_board_warning_mask;
61:                
62:                
63:                void LoadFaultMaskRegisters(void);
64:                void WriteToEventLog(unsigned char fault_register, unsigned int fault_bit);
65:                unsigned char CheckOverVoltFault(POWERSUPPLY* ptr);
66:                unsigned char CheckUnderVoltFault(POWERSUPPLY* ptr);
67:                unsigned char CheckOverCurrentFault(POWERSUPPLY* ptr);
68:                unsigned char CheckUnderCurrentFault(POWERSUPPLY* ptr);
69:                
70:                
71:                /*
72:                  FAULT EVALUATION
73:                  
74:                  10_ms_tic_toc
75:                  Once every 10ms, the internal ADC is read and faults are updated
76:                
77:                  After Every Pulse
78:                
79:                  DPARKER give a big description of each fault here - How the input is measured, how the data is filtered, how the fault is generated (delay if included)
80:                
81:                */
82:                
83:                
84:                /*
85:                  In each State, Each fault input can do one of the following . . .
86:                
87:                  1) It can be totally ignored (This is the default behavior - If the warning mask & the fault mask are NOT set)
88:                  2) It can cause a fault  (This is set by the fault MASK)
89:                     There are no "warm" or "cold" faults.  Any fault in state warm_ready or hv_on will go to state warm fault.
90:                     If the fault is still active in the warm state fault then it will move to cold fault.
91:                  3) It can cause a latched warning (This is set the warning MASK)
92:                     NOTE: the warning register is independent of the fault mask.  To be latched as a warning, the fault input MUST BE IN THE WARNING REGISTER
93:                  4) Special state at startup to handle board level failures . . . ????
94:                */
95:                
96:                /*  
97:                    Fault Log
98:                    
99:                    Each entry in the fault log contains the following information
100:                   4 bits for fault register bit
101:                   2 bits for fault register select
102:                   2 bits for the calling state (HV_ON, WARM_READY, FAULT, STARTUP)
103:               */
104:               
105:               /*
106:                 For each state there are three fault masks for each fault register.
107:                 Warning Ignore Mask - This shows which fault inputs will NOT generate a warning (this is mainly for debugging and and is used to filter out non-events, if a fault is in the warning ignore mask and in the warm or cold fault mask it will still generate a fault)
108:                 Faul Mask - this shows which fault inputs will generate a fault in the current state
109:               
110:               
111:               */
112:               
113:               /*
114:               
115:                 Status_Register -> This register shows the current states of all the Inputs.  It IS NOT LATCHED.
116:                 Fault_Register -> This register latches any fault input that matches the fault_mask for the current state.
117:                 Warning_Latch_Regisiter -> Any fault input that matches the fault_mask or the warning_mask will be latched in this register.
118:               
119:                 How faults are checked . . .
120:                 
121:                 Every time through a control loop, 50us->500us depending upon the state, all faults registeres are updated and checked.
122:                 Faults like magnetron_heater_over_current - The limit is compared to the filtered data in RAM every time, even though the filtered data in ram is only update once every 10mS
123:                 The fault status register is then compared to the masks to generate the warnings and faults.
124:               
125:                */
126:               
127:               /* ----------------------FAULT MANAGEMENT ----------------------*/
128:               
129:               /*
130:                 There are lots of Fault Conditions, see A34335.h for a list of fault registeres and faults.
131:                 For a given state a particular Input may
132:                 1) No Action - But set a non latching status bit indicating the state of the fault input
133:                 2) No Action - But set a latching "warning" bit 
134:                 3) Generate a fault Condition - This will change the state to warm fault (or cold fault if the fault is globably defined as a cold fault)
135:                
136:               
137:                 How are faults handeled . . .
138:                 There a 3 data storage locations for each fault register.
139:                 Status_Register -> This register shows the current states of all the Inputs.  It IS NOT LATCHED.
140:                 Latch_Regisiter -> This is a latched version of the the status register.
141:                 Fault_Register  -> If the Input is a Fault (it matches the warm_fault OR cold_fault mask) it is latched into the Fault Register
142:                 
143:                 How external data and faults are processesed . . . 
144:               
145:                 Data is read from the external ADCs and inernal ADCs on a regular 10ms interval or after a pulse (for pulse data types).
146:                 This inerval is scheduled to occur directly proceding a pulse if possible (pulse rate > 100 Hz).
147:                 At PRF less than 100Hz (or in any other state) the readings will take place at opproximate 10ms intervals
148:                 ADC values are filtered with software RC/glitch filters when they are read.
149:                
150:                
151:                 Faults are evaluated durring the 10ms_tic_toc the occurs once every (approximatly) 10mS
152:                 The following steps occur
153:                 1) Status registers are reset to zero
154:                 2) The input condition is tested, if it is a "logical fault" then (record_this_xxxxx_fault) is called which does the following
155:                   a) Sets the appropriate bit in the status register
156:                   b) If the bit matches the fault_mask, 
157:                      ^ The appropriate bit in the fault register is set
158:                      ^ The fault is added to the error log - TO BE IMPLEMENTED
159:                   c) If the bit matches the warning_mask, the appropriate bit in the warning register is set 
160:                 
161:                 STEP 2 is repeated for all fault conditions.
162:               
163:                 Some faults can not be tested durring the 10ms TicToc.
164:                 These faults will have record_this_xxxxx_fault called when the fault is checked.
165:                 These faults are . . .
166:                 FAULT_HV_LAMBDA_EOC_TIMEOUT - this is evaluated in the TMR1 interrupt and set there.
167:               
168:               
169:                 After all the faults have been tested and the fault registers updated the following action occurs
170:                 
171:                 + A cold shutdown occurs
172:                 + A warm shutdown occurs
173:                 
174:                 + The fault is added to the Log
175:                 + For *some* important faults, the fault counter is incremented.
176:               
177:                 + The fault is added to the Log
178:                 + For *some* important faults, the fault counter is incremented.
179:                 
180:               */
181:               
182:               
183:               
184:               // DPARKER update pulse fault must be called at 10ms Interval or the sections that count "out of range" counts will be arbitrary time lengths
185:               
186:               void UpdateFaults(void) {
0041BE  FA0002     LNK #0x2
187:                 // See h file for documentation
188:                 unsigned int temp_u16int;
189:               
190:                 // The status registers are not latched so they are reset to zero each time the faults are evaluated
191:                 faults_magnetron_status_reg = 0;  
0041C0  EB0200     CLR W4
0041C2  88BA04     MOV W4, faults_magnetron_status_reg
192:                 faults_high_voltage_status_reg = 0;
0041C4  EB0200     CLR W4
0041C6  88BA34     MOV W4, faults_high_voltage_status_reg
193:                 faults_thyratron_status_reg = 0;
0041C8  EB0200     CLR W4
0041CA  88BAC4     MOV W4, faults_thyratron_status_reg
194:                 faults_control_board_status_reg = 0;
0041CC  EB0200     CLR W4
0041CE  88BAF4     MOV W4, faults_control_board_status_reg
195:                 
196:                 
197:                 // Load the fault masks for the current state
198:                 LoadFaultMaskRegisters();
0041D0  07026E     RCALL LoadFaultMaskRegisters
199:                 
200:                 //------------------------- START MAGNETRON FAULTS ------------------------------//
201:                 
202:                 // Check External Magnetron Heater Over Voltage Latch
203:                 if (PIN_FILAMENT_OV_LATCH == ILL_FILAMENT_OV_FAULT) {
0041D2  8016A5     MOV PORTD, W5
0041D4  220004     MOV #0x2000, W4
0041D6  628204     AND W5, W4, W4
0041D8  520FE0     SUB W4, #0x0, [W15]
0041DA  3A0002     BRA NZ, .L2, .LSM8
204:                   RecordThisMagnetronFault(FAULT_HW_MAGNETRON_FILAMENT_OV);
0041DC  200010     MOV #0x1, W0
0041DE  070314     RCALL RecordThisMagnetronFault
205:                 } 
206:                 
207:                 // Check that the magnetron heater voltage ADC reading has exceed fixed value set Config.h 
208:                 if (ps_filament.v_adc_reading > ps_filament.v_adc_over_abs) {
0041E0  805845     MOV 0xB08, W5
0041E2  805884     MOV 0xB10, W4
0041E4  528F84     SUB W5, W4, [W15]
0041E6  360002     BRA LEU, .L3, .LSM10
209:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OV_HARD_LIMIT);
0041E8  200020     MOV #0x2, W0
0041EA  07030E     RCALL RecordThisMagnetronFault
210:                 }
211:                 
212:                 // Check that the magnetron heater voltage ADC reading is not greater than X% of its program point (set in Config.h)
213:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
214:                 if (CheckOverVoltFault(&ps_filament)) {
0041EC  20AF80     MOV #0xAF8, W0
0041EE  0703A5     RCALL CheckOverVoltFault
0041F0  784200     MOV.B W0, W4
0041F2  524FE0     SUB.B W4, #0x0, [W15]
0041F4  320002     BRA Z, .L4, .LSM12
215:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OV);
0041F6  200040     MOV #0x4, W0
0041F8  070307     RCALL RecordThisMagnetronFault
216:                 }
217:                 
218:                 // Check that the magnetron heater voltage ADC reading is not less than X% of its program point (set in Config.h)
219:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
220:                 if (CheckUnderVoltFault(&ps_filament)) {
0041FA  20AF80     MOV #0xAF8, W0
0041FC  0703C5     RCALL CheckUnderVoltFault
0041FE  784200     MOV.B W0, W4
004200  524FE0     SUB.B W4, #0x0, [W15]
004202  320002     BRA Z, .L5, .LSM14
221:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_UV);
004204  200080     MOV #0x8, W0
004206  070300     RCALL RecordThisMagnetronFault
222:                 }
223:                 
224:                 // Check that the magnetron heater current ADC reading is not greater than X% of its expected point (set in Config.h)
225:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
226:                 if (CheckOverCurrentFault(&ps_filament)) {
004208  20AF80     MOV #0xAF8, W0
00420A  0703EC     RCALL CheckOverCurrentFault
00420C  784200     MOV.B W0, W4
00420E  524FE0     SUB.B W4, #0x0, [W15]
004210  320002     BRA Z, .L6, .LSM16
227:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OC);
004212  200100     MOV #0x10, W0
004214  0702F9     RCALL RecordThisMagnetronFault
228:                 }
229:                 
230:                 
231:                 // Check that the magnetron heater current ADC reading is not less than X% of its expected point (set in Config.h)
232:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
233:                 if (CheckUnderCurrentFault(&ps_filament)) {
004216  20AF80     MOV #0xAF8, W0
004218  07040C     RCALL CheckUnderCurrentFault
00421A  784200     MOV.B W0, W4
00421C  524FE0     SUB.B W4, #0x0, [W15]
00421E  320002     BRA Z, .L7, .LSM18
234:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_UC);
004220  200200     MOV #0x20, W0
004222  0702F2     RCALL RecordThisMagnetronFault
235:                 }
236:                 
237:                 
238:                 // Check External Magnetron Magnet Current Out of Range Latch
239:                 if (PIN_MAGNET_CURRENT_OOR_LATCH == ILL_MAGNET_CURRENT_OOR_FAULT) {
004224  8016A5     MOV PORTD, W5
004226  210004     MOV #0x1000, W4
004228  628204     AND W5, W4, W4
00422A  520FE0     SUB W4, #0x0, [W15]
00422C  3A0002     BRA NZ, .L8, .LSM20
240:                   RecordThisMagnetronFault(FAULT_HW_MAGNETRON_MAGNET_COOR);
00422E  201000     MOV #0x100, W0
004230  0702EB     RCALL RecordThisMagnetronFault
241:                 }
242:                 
243:                 // Check that the magnetron magnet current ADC reading has no exceeded fixed value set Config.h 
244:                 if (ps_magnet.i_adc_reading > ps_magnet.i_adc_over_abs) {
004232  8056D5     MOV .LSM109, W5
004234  805714     MOV 0xAE2, W4
004236  528F84     SUB W5, W4, [W15]
004238  360002     BRA LEU, .L9, .LSM22
245:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OC_HARD_LIMIT);
00423A  202000     MOV #0x200, W0
00423C  0702E5     RCALL RecordThisMagnetronFault
246:                 }
247:                 
248:                 // Check that the magnetron magnet current ADC reading is not greater than X% of its program point (set in Config.h)
249:                 if (CheckOverCurrentFault(&ps_magnet)) {
00423E  20A9E0     MOV #0xA9E, W0
004240  0703D1     RCALL CheckOverCurrentFault
004242  784200     MOV.B W0, W4
004244  524FE0     SUB.B W4, #0x0, [W15]
004246  320002     BRA Z, .L10, .LSM24
250:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OC);
004248  204000     MOV #0x400, W0
00424A  0702DE     RCALL RecordThisMagnetronFault
251:                 }
252:                 
253:                 // Check that the magnetron magnet current ADC reading is not less than X% of its program point (set in Config.h)
254:                 if (CheckUnderCurrentFault(&ps_magnet)) {
00424C  20A9E0     MOV #0xA9E, W0
00424E  0703F1     RCALL CheckUnderCurrentFault
004250  784200     MOV.B W0, W4
004252  524FE0     SUB.B W4, #0x0, [W15]
004254  320002     BRA Z, .L11, .LSM26
255:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_UC);
004256  208000     MOV #0x800, W0
004258  0702D7     RCALL RecordThisMagnetronFault
256:                 }
257:                 
258:                 // Check that the magnetron magnet voltage ADC reading is not greater than X% of its expected value (set in Config.h)
259:                 if (CheckOverVoltFault(&ps_magnet)) {
00425A  20A9E0     MOV #0xA9E, W0
00425C  07036E     RCALL CheckOverVoltFault
00425E  784200     MOV.B W0, W4
004260  524FE0     SUB.B W4, #0x0, [W15]
004262  320002     BRA Z, .L12, .LSM28
260:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OV);
004264  210000     MOV #0x1000, W0
004266  0702D0     RCALL RecordThisMagnetronFault
261:                 }
262:                 
263:                 // Check that the magnetron magnet voltage ADC reading is not less than X% of its expected value (set in Config.h)
264:                 if (CheckUnderVoltFault(&ps_magnet)) {
004268  20A9E0     MOV #0xA9E, W0
00426A  07038E     RCALL CheckUnderVoltFault
00426C  784200     MOV.B W0, W4
00426E  524FE0     SUB.B W4, #0x0, [W15]
004270  320002     BRA Z, .L13, .LSM30
265:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_UV);
004272  220000     MOV #0x2000, W0
004274  0702C9     RCALL RecordThisMagnetronFault
266:                 }
267:                 
268:                 
269:                 //------------------------- START HIGH VOLTAGE FAULTS ------------------------------//
270:                 
271:                 // THE ARC FAULTS ARE CURRENTLY SET IN UpdatePulseData()
272:                 // UpdatesPulseData() is called after every pulse.
273:                 
274:                 // Check the digital fault outputs from from HV LAMBDA -
275:                 // The sum fault line must be set for HV_LAMBDA_SUM_FAULT_COUNTER_TRIP_POINT consective readings before a trip will occur
276:                 
277:                 
278:                 
279:                 if (PIN_HV_LAMBDA_SUM_FAULT == ILL_HV_LAMBDA_SUM_FAULT_FAULTED) {
004276  801675     MOV PORTC, W5
004278  240004     MOV #0x4000, W4
00427A  628204     AND W5, W4, W4
00427C  520FE0     SUB W4, #0x0, [W15]
00427E  3A003C     BRA NZ, .L14, .LSM46
280:                   // Record the sum fault and check the other fault lines
281:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_SUM_FAULT);
004280  201000     MOV #0x100, W0
004282  0702DE     RCALL RecordThisHighVoltageFault
282:                       
283:                   temp_u16int = MCP23017ReadSingleByte(&U64_MCP23017, MCP23017_REGISTER_GPIOA);
004284  B3C121     MOV.B #0x12, W1
004286  2092A0     MOV #0x92A, W0
004288  070AB0     RCALL MCP23017ReadSingleByte
00428A  780200     MOV W0, W4
00428C  780F04     MOV W4, [W14]
284:                   if (temp_u16int >= 0xFA00) {
00428E  2F9FF4     MOV #0xF9FF, W4
004290  78029E     MOV [W14], W5
004292  528F84     SUB W5, W4, [W15]
004294  360004     BRA LEU, .L15, .LSM35
285:                     global_debug_counter.i2c_bus_error++;
004296  80B964     MOV .LSM629, W4
004298  E80204     INC W4, W4
00429A  88B964     MOV W4, .LSM629
00429C  370027     BRA .L16, .LSM44
286:                   } else {
287:                     U64_MCP23017.input_port_a_in_ram = temp_u16int & 0xFF;
00429E  78021E     MOV [W14], W4
0042A0  784204     MOV.B W4, W4
0042A2  FD0200     EXCH W0, W4
0042A4  B7E934     MOV.B WREG, 0x934
0042A6  FD0200     EXCH W0, W4
288:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_OVER_TEMP) {
0042A8  209344     MOV #0x934, W4
0042AA  784214     MOV.B [W4], W4
0042AC  FB8284     ZE W4, W5
0042AE  200404     MOV #0x40, W4
0042B0  628204     AND W5, W4, W4
0042B2  520FE0     SUB W4, #0x0, [W15]
0042B4  320002     BRA Z, .L17, .LSM38
289:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_OVER_TEMP);
0042B6  210000     MOV #0x1000, W0
0042B8  0702C3     RCALL RecordThisHighVoltageFault
290:                     }
291:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_INTERLOCK_FAULT) {
0042BA  209344     MOV #0x934, W4
0042BC  784214     MOV.B [W4], W4
0042BE  FB8284     ZE W4, W5
0042C0  200204     MOV #0x20, W4
0042C2  628204     AND W5, W4, W4
0042C4  520FE0     SUB W4, #0x0, [W15]
0042C6  320002     BRA Z, .L18, .LSM40
292:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_INTERLOCK_FAULT);
0042C8  220000     MOV #0x2000, W0
0042CA  0702BA     RCALL RecordThisHighVoltageFault
293:                     }
294:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_LOAD_FLT) {
0042CC  209344     MOV #0x934, W4
0042CE  784214     MOV.B [W4], W4
0042D0  FB8204     ZE W4, W4
0042D2  620270     AND W4, #0x10, W4
0042D4  520FE0     SUB W4, #0x0, [W15]
0042D6  320002     BRA Z, .L19, .LSM42
295:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_LOAD_FAULT);
0042D8  240000     MOV #0x4000, W0
0042DA  0702B2     RCALL RecordThisHighVoltageFault
296:                     }
297:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_PHASE_LOSS) {
0042DC  209344     MOV #0x934, W4
0042DE  784214     MOV.B [W4], W4
0042E0  FB8204     ZE W4, W4
0042E2  620268     AND W4, #0x8, W4
0042E4  520FE0     SUB W4, #0x0, [W15]
0042E6  320002     BRA Z, .L16, .LSM44
298:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_PHASE_LOSS);
0042E8  280000     MOV #0x8000, W0
0042EA  0702AA     RCALL RecordThisHighVoltageFault
299:                     }
300:                     
301:                   }
302:                   
303:                   if (lambda_eoc_fault) {
0042EC  2174C4     MOV #0x174C, W4
0042EE  784214     MOV.B [W4], W4
0042F0  524FE0     SUB.B W4, #0x0, [W15]
0042F2  320002     BRA Z, .L14, .LSM46
304:                 	  	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_EOC_TIMEOUT);	// report eoc fault after sum fault happened
0042F4  202000     MOV #0x200, W0
0042F6  0702A4     RCALL RecordThisHighVoltageFault
305:                   }
306:                  
307:                 }
308:                 
309:                 if (lambda_eoc_fault && (eoc_max_reached_timer <= 0)) {
0042F8  2174C4     MOV #0x174C, W4
0042FA  784214     MOV.B [W4], W4
0042FC  524FE0     SUB.B W4, #0x0, [W15]
0042FE  320005     BRA Z, .L20, .LSM48
004300  80BA74     MOV eoc_max_reached_timer, W4
004302  520FE0     SUB W4, #0x0, [W15]
004304  3C0002     BRA GT, .L20, .LSM48
310:                 	  RecordThisHighVoltageFault(FAULT_HV_LAMBDA_EOC_TIMEOUT);	// report eoc fault after 1s delay
004306  202000     MOV #0x200, W0
004308  07029B     RCALL RecordThisHighVoltageFault
311:                 }
312:               
313:                /*
314:                   FAULT_LAMBDA_EOC_TIMEOUT is checked/set by the TMR1 Interrupt
315:                 */
316:               
317:               
318:                 // DPARKER these vpeak readings . . . do we need them?  do they serve any purpose????
319:                 /*
320:               
321:                 // Check that the lambda vpeak ADC reading is not greater than X% of its set point (set in Config.h)
322:                 // It must remain outside this range for at least HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT before a fault is generated
323:                 if (hv_lambda_vpeak_adc_reading > hv_lambda_vpeak_adc_over_trip_point) {
324:                   hv_lambda_vpeak_over_voltage_count++;
325:                 } else if (hv_lambda_vpeak_over_voltage_count >= 1) {
326:                   hv_lambda_vpeak_over_voltage_count--;
327:                 }
328:                 if (hv_lambda_vpeak_over_voltage_count > HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT) {
329:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_VPEAK_OVER_VOLTAGE);
330:                 }
331:               
332:                 // Check that the lambda vpeak ADC reading is not less than X% of its set point (set in Config.h)
333:                 // It must remain outside this range for at least HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT before a fault is generated
334:                 if (hv_lambda_vpeak_adc_reading < hv_lambda_vpeak_adc_under_trip_point) {
335:                   hv_lambda_vpeak_under_voltage_count++;
336:                 } else if (hv_lambda_vpeak_under_voltage_count >= 1) {
337:                   hv_lambda_vpeak_under_voltage_count--;
338:                 }
339:                 if (hv_lambda_vpeak_under_voltage_count > HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT) {
340:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_VPEAK_UNDER_VOLTAGE);
341:                 }
342:                 */
343:                 
344:                 //------------------------- START THYRATRON FAULTS ------------------------------//
345:                
346:                 // Check that the thyratron cathode heater voltage ADC reading has exceed fixed value set Config.h 
347:                 if (ps_thyr_cathode_htr.v_adc_reading > ps_thyr_cathode_htr.v_adc_over_abs) {
00430A  805B15     MOV 0xB62, W5
00430C  805B54     MOV .LSM134, W4
00430E  528F84     SUB W5, W4, [W15]
004310  360002     BRA LEU, .L21, .LSM50
348:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_OV_HARD_LIMIT);
004312  200010     MOV #0x1, W0
004314  0702B1     RCALL RecordThisThyratronFault
349:                 }
350:                   
351:                 // Check that the thyratron heater voltage ADC reading is not greater than X% of its program point (set in Config.h)
352:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated  
353:                 if (CheckOverVoltFault(&ps_thyr_cathode_htr)) {
004316  20B520     MOV #0xB52, W0
004318  070310     RCALL CheckOverVoltFault
00431A  784200     MOV.B W0, W4
00431C  524FE0     SUB.B W4, #0x0, [W15]
00431E  320002     BRA Z, .L22, .LSM52
354:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_OV);
004320  200020     MOV #0x2, W0
004322  0702AA     RCALL RecordThisThyratronFault
355:                 }
356:               
357:                 // Check that the thyratron heater voltage ADC reading is not less than X% of its program point (set in Config.h)
358:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated
359:                 if (CheckUnderVoltFault(&ps_thyr_cathode_htr)) {
004324  20B520     MOV #0xB52, W0
004326  070330     RCALL CheckUnderVoltFault
004328  784200     MOV.B W0, W4
00432A  524FE0     SUB.B W4, #0x0, [W15]
00432C  320002     BRA Z, .L23, .LSM54
360:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_UV);
00432E  200040     MOV #0x4, W0
004330  0702A3     RCALL RecordThisThyratronFault
361:                 }
362:                   
363:                 // Check if the 4-20ma Driver has reported a fault
364:                 if (PIN_4_20_DRVR_FLT == ILL_4_20_DRIVER_FAULT) {
004332  801615     MOV PORTA, W5
004334  204004     MOV #0x400, W4
004336  628204     AND W5, W4, W4
004338  520FE0     SUB W4, #0x0, [W15]
00433A  3A0002     BRA NZ, .L24, .LSM56
365:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_DRVR_FLT);
00433C  200080     MOV #0x8, W0
00433E  07029C     RCALL RecordThisThyratronFault
366:                 }
367:               
368:                 // Check to see if the control loop has saturated.
369:                 // If it has that means that the SCR controller is no longer responding and it should be shut down
370:                 temp_u16int = thyratron_cathode_heater_PID.controlOutput;
004340  804474     MOV 0x88E, W4
004342  780F04     MOV W4, [W14]
371:                 if (temp_u16int & 0x8000) {
004344  78021E     MOV [W14], W4
004346  520FE0     SUB W4, #0x0, [W15]
004348  3D0002     BRA GE, .L25, .LSM59
372:                   temp_u16int = 0x0000;
00434A  EB0200     CLR W4
00434C  780F04     MOV W4, [W14]
373:                 }
374:                 temp_u16int = temp_u16int << 1;
00434E  78021E     MOV [W14], W4
004350  420204     ADD W4, W4, W4
004352  780F04     MOV W4, [W14]
375:                 if (temp_u16int >= THYRATRON_DAC_SATURATED) {
004354  27CFF4     MOV #0x7CFF, W4
004356  78029E     MOV [W14], W5
004358  528F84     SUB W5, W4, [W15]
00435A  360002     BRA LEU, .L26, .LSM62
376:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_CONTROL_SAT);
00435C  200100     MOV #0x10, W0
00435E  07028C     RCALL RecordThisThyratronFault
377:                 }
378:                 
379:               
380:               
381:                 // Check if the thyratron reservoir ADC reading has exceed fixed value set Config.h 
382:                 if (ps_thyr_reservoir_htr.v_adc_reading > ps_thyr_reservoir_htr.v_adc_over_abs) {
004360  805DE5     MOV 0xBBC, W5
004362  805E24     MOV 0xBC4, W4
004364  528F84     SUB W5, W4, [W15]
004366  360002     BRA LEU, .L27, .LSM64
383:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_OV_HARD_LIMIT);
004368  200200     MOV #0x20, W0
00436A  070286     RCALL RecordThisThyratronFault
384:                 }
385:               
386:               
387:                 // Check that the thyratron reservoir voltage ADC reading is not greater than X% of its program point (set in Config.h)
388:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated  
389:                 if (CheckOverVoltFault(&ps_thyr_reservoir_htr)) {
00436C  20BAC0     MOV #0xBAC, W0
00436E  0702E5     RCALL CheckOverVoltFault
004370  784200     MOV.B W0, W4
004372  524FE0     SUB.B W4, #0x0, [W15]
004374  320002     BRA Z, .L28, .LSM66
390:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_OV);
004376  200400     MOV #0x40, W0
004378  07027F     RCALL RecordThisThyratronFault
391:                 }
392:               
393:                 // Check that the thyratron reservoir voltage ADC reading is not less than X% of its program point (set in Config.h)
394:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated
395:                 if (CheckUnderVoltFault(&ps_thyr_reservoir_htr)) {
00437A  20BAC0     MOV #0xBAC, W0
00437C  070305     RCALL CheckUnderVoltFault
00437E  784200     MOV.B W0, W4
004380  524FE0     SUB.B W4, #0x0, [W15]
004382  320002     BRA Z, .L29, .LSM68
396:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_UV);
004384  200800     MOV #0x80, W0
004386  070278     RCALL RecordThisThyratronFault
397:                 }
398:               
399:                 // Check if the 4-20ma Driver has reported a fault
400:                 if (PIN_4_20_DRVR_FLT == ILL_4_20_DRIVER_FAULT) {
004388  801615     MOV PORTA, W5
00438A  204004     MOV #0x400, W4
00438C  628204     AND W5, W4, W4
00438E  520FE0     SUB W4, #0x0, [W15]
004390  3A0002     BRA NZ, .L30, .LSM70
401:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_DRVR_FLT);
004392  201000     MOV #0x100, W0
004394  070271     RCALL RecordThisThyratronFault
402:                 }
403:                 
404:                 // Check to see if the control loop has saturated.
405:                 // If it has that means that the SCR controller is no longer responding and it should be shut down
406:                 temp_u16int = thyratron_reservoir_heater_PID.controlOutput;
004396  8043F4     MOV 0x87E, W4
004398  780F04     MOV W4, [W14]
407:                 if (temp_u16int & 0x8000) {
00439A  78021E     MOV [W14], W4
00439C  520FE0     SUB W4, #0x0, [W15]
00439E  3D0002     BRA GE, .L31, .LSM73
408:                   temp_u16int = 0x0000;
0043A0  EB0200     CLR W4
0043A2  780F04     MOV W4, [W14]
409:                 }
410:                 temp_u16int = temp_u16int << 1;
0043A4  78021E     MOV [W14], W4
0043A6  420204     ADD W4, W4, W4
0043A8  780F04     MOV W4, [W14]
411:                 if (temp_u16int >= THYRATRON_DAC_SATURATED) {
0043AA  27CFF4     MOV #0x7CFF, W4
0043AC  78029E     MOV [W14], W5
0043AE  528F84     SUB W5, W4, [W15]
0043B0  360002     BRA LEU, .L32, .LSM76
412:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_CONTROL_SAT);
0043B2  202000     MOV #0x200, W0
0043B4  070261     RCALL RecordThisThyratronFault
413:                 }
414:               
415:               
416:                 //------------------------- START CONTROL BOARD FAULTS ------------------------------//
417:               
418:               
419:                 // Check that the lambda supply powered up
420:                 if (PIN_HV_LAMBDA_POWER_UP == ILL_PIN_HV_LAMBDA_DID_NOT_POWER_UP) {
0043B6  8016A4     MOV PORTD, W4
0043B8  620262     AND W4, #0x2, W4
0043BA  520FE0     SUB W4, #0x0, [W15]
0043BC  320002     BRA Z, .L33, .LSM78
421:                   RecordThisControlBoardFault(FAULT_LAMBDA_OFF);
0043BE  200010     MOV #0x1, W0
0043C0  070277     RCALL RecordThisControlBoardFault
422:                 }
423:                 
424:                 // Check to see if digital interlock 1 is open  
425:                 if (PIN_INTERLOCK_1 == ILL_INTERLOCK_OPEN) {
0043C2  801674     MOV PORTC, W4
0043C4  620268     AND W4, #0x8, W4
0043C6  520FE0     SUB W4, #0x0, [W15]
0043C8  320002     BRA Z, .L34, .LSM80
426:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_1);
0043CA  200020     MOV #0x2, W0
0043CC  070271     RCALL RecordThisControlBoardFault
427:                 }
428:                 
429:                 // Check to see if digital interlock 2 is open  
430:                 if (PIN_INTERLOCK_2 == ILL_INTERLOCK_OPEN) {
0043CE  801674     MOV PORTC, W4
0043D0  620270     AND W4, #0x10, W4
0043D2  520FE0     SUB W4, #0x0, [W15]
0043D4  320002     BRA Z, .L35, .LSM82
431:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_2);
0043D6  200040     MOV #0x4, W0
0043D8  07026B     RCALL RecordThisControlBoardFault
432:                 }
433:                 
434:                 // Check to see if digital interlock 3 is open  
435:                 if (PIN_INTERLOCK_3 == ILL_INTERLOCK_OPEN) {
0043DA  801735     MOV PORTG, W5
0043DC  201004     MOV #0x100, W4
0043DE  628204     AND W5, W4, W4
0043E0  520FE0     SUB W4, #0x0, [W15]
0043E2  320002     BRA Z, .L36, .LSM84
436:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_3);
0043E4  200080     MOV #0x8, W0
0043E6  070264     RCALL RecordThisControlBoardFault
437:                 }
438:                 
439:                 // Check to see if digital interlock 4 is open  
440:                 if (PIN_INTERLOCK_4 == ILL_INTERLOCK_OPEN) {
0043E8  801735     MOV PORTG, W5
0043EA  202004     MOV #0x200, W4
0043EC  628204     AND W5, W4, W4
0043EE  520FE0     SUB W4, #0x0, [W15]
0043F0  320002     BRA Z, .L1, .LSM86
441:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_4);
0043F2  200100     MOV #0x10, W0
0043F4  07025D     RCALL RecordThisControlBoardFault
442:                 }
443:                 
444:               }
0043F6  FA8000     ULNK
0043F8  060000     RETURN
445:               
446:               void ResetPulseLatches(void) {
0043FA  FA0000     LNK #0x0
447:                 PIN_PULSE_LATCH_RESET = OLL_PULSE_LATCH_RESET;
0043FC  A9A2E2     BCLR LATF, #5
448:                 __delay32(DELAY_PULSE_LATCH_RESET);
0043FE  20BB80     MOV #0xBB8, W0
004400  200001     MOV #0x0, W1
004402  070B45     RCALL ___delay32
449:                 PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
004404  A8A2E2     BSET LATF, #5
450:               }
004406  FA8000     ULNK
004408  060000     RETURN
451:               
452:               
453:               void ResetHWLatches(void) {
00440A  FA0000     LNK #0x0
454:                 // Reset the latches
455:                 PIN_LATCH_RESET = OLL_RESET_LATCH;
00440C  A962D6     BCLR LATD, #3
456:                 __delay32(DELAY_LATCH_RESET);
00440E  2003C0     MOV #0x3C, W0
004410  200001     MOV #0x0, W1
004412  070B3D     RCALL ___delay32
457:                 PIN_LATCH_RESET = !OLL_RESET_LATCH;
004414  A862D6     BSET LATD, #3
458:               }
004416  FA8000     ULNK
004418  060000     RETURN
459:               
460:               void ResetAllFaults(void) {
00441A  FA0000     LNK #0x0
461:                 ResetHWLatches();
00441C  07FFF6     RCALL ResetHWLatches
462:               
463:                 // Clear all fault registers
464:               
465:                 // MAGNETRON CONTROL FAULT REGISTERS
466:                 faults_magnetron_fault_reg       = 0;
00441E  EB0200     CLR W4
004420  88BA14     MOV W4, faults_magnetron_fault_reg
467:                 faults_magnetron_warning_reg     = 0;
004422  EB0200     CLR W4
004424  88BA24     MOV W4, faults_magnetron_warning_reg
468:                 
469:                 // HIGH VOLTAGE FAULT REGISTERS
470:                 faults_high_voltage_fault_reg    = 0;
004426  EB0200     CLR W4
004428  88BA44     MOV W4, faults_high_voltage_fault_reg
471:                 faults_high_voltage_warning_reg  = 0;
00442A  EB0200     CLR W4
00442C  88BA54     MOV W4, faults_high_voltage_warning_reg
472:                 
473:                 lambda_eoc_fault = 0;
00442E  EB4200     CLR.B W4
004430  780004     MOV W4, W0
004432  B7F74C     MOV.B WREG, lambda_eoc_fault
474:                 eoc_counts = 0;
004434  EB4200     CLR.B W4
004436  780004     MOV W4, W0
004438  B7F74D     MOV.B WREG, eoc_counts
475:                 
476:                 // THYRATRON HEATER FAULT REGISTERS
477:                 faults_thyratron_fault_reg       = 0;
00443A  EB0200     CLR W4
00443C  88BAD4     MOV W4, faults_thyratron_fault_reg
478:                 faults_thyratron_warning_reg     = 0;
00443E  EB0200     CLR W4
004440  88BAE4     MOV W4, faults_thyratron_warning_reg
479:                   
480:                 // CONTROL BOARD FAULT REGISTERS
481:                 faults_control_board_fault_reg   = 0;
004442  EB0200     CLR W4
004444  88BB04     MOV W4, faults_control_board_fault_reg
482:                 faults_control_board_warning_reg = 0;
004446  EB0200     CLR W4
004448  88BB14     MOV W4, faults_control_board_warning_reg
483:               }
00444A  FA8000     ULNK
00444C  060000     RETURN
484:               
485:               
486:               void UpdatePulseData(unsigned char mode) {
00444E  FA0004     LNK #0x4
004450  984720     MOV.B W0, [W14+2]
487:                 unsigned int pulse_energy_milli_joules;
488:               
489:                 /*
490:                   FAULT_PFN_TRIGGER_PERIOD_TOO_SHORT is evaluated by the TMR1 Interrupt
491:                 */
492:                 
493:                 /* 
494:                    First Perform Data itegrity checks on the data from the AD converter
495:                    
496:                    Arc detection is the responsibility of the HW circuits.
497:               
498:                    In the event of an ARC the current readback IS NOT INCLUDED in the filtered Values.
499:               
500:                    If there was NOT AN ARC, further checking is done on the current readback to insure it is valid.
501:                    
502:                    If the current is inside a specified value (ADC_PULSE_CURRENT_UNDER_GLITCH -> ADC_PULSE_CURRENT_OVER_GLITCH) it is included in filtering math.
503:                    If not the value is ignored from a filtering point of view
504:               
505:                    Sowftware over/under current/voltage detection.
506:                       
507:                 */
508:               
509:                 /*
510:                   Tracking  Arcs
511:               
512:               
513:                   Hardware Arc is defined as 
514:                        (1) setting Overcurrent Latch 
515:                     OR (2) failing to set Undercurrent Latch
516:               
517:               
518:                   Software Glitch is defined as 
519:                        (1) Not setting the ( Hardware ARC OR Software ARC)
520:                    AND (2) Reading outside the Hardware range limits
521:               
522:                   There is an Arc Counter that increments with every Hardware Arc (this is stored in EEPROM) (32 bit)
523:                   There is an Arc Counter in RAM that counts number of Hardware arc since the last HV_ON Command (32 bit)
524:               
525:               
526:                   If (overcurrent latch is set) OR (undercurrent latch is not set)
527:                      Then Hardware Arc
528:                   Else if (ADC reading > overcurrent set point) OR (ADC reading < undercurrent set point)
529:                      Then Software Glitch
530:                   Else 
531:                      The Pulse was good, record the pulse info into the A or B register
532:               
533:               
534:                   Hardware Arcs can generate faults in the following ways.
535:                   1) Too many consecutive arcs.
536:                   2) Too many arcs per 300 pulses (per second 300 Hz)
537:                   3) Too many arcs per 18000 pulses (per minute at 300 Hz)
538:                   
539:                 */
540:                 
541:                 if (arc_detected == 1) {
004452  8040B4     MOV arc_detected, W4
004454  520FE1     SUB W4, #0x1, [W15]
004456  3A0015     BRA NZ, .L42, .LSM118
542:                   // The high voltage tank current was too high (indicating an arc) or was too low (indicating a short in the modulator)
543:                   // Record and arc and throw away the data from the ADC
544:                   arc_detected = 0;
004458  EB0200     CLR W4
00445A  8840B4     MOV W4, arc_detected
545:                   arc_counter_persistent++;
00445C  80BD64     MOV arc_counter_persistent, W4
00445E  80BD75     MOV 0x17AE, W5
004460  420261     ADD W4, #0x1, W4
004462  4A82E0     ADDC W5, #0x0, W5
004464  88BD64     MOV W4, arc_counter_persistent
004466  88BD75     MOV W5, 0x17AE
546:                   arc_counter_this_hv_on++;
004468  80BE14     MOV arc_counter_this_hv_on, W4
00446A  E80204     INC W4, W4
00446C  88BE14     MOV W4, arc_counter_this_hv_on
547:                   
548:                   arc_counter_consecutive++;
00446E  804304     MOV arc_counter_consecutive, W4
004470  E80204     INC W4, W4
004472  884304     MOV W4, arc_counter_consecutive
549:                   arc_counter_fast++;
004474  804314     MOV arc_counter_fast, W4
004476  E80204     INC W4, W4
004478  884314     MOV W4, arc_counter_fast
550:                   arc_counter_slow++;
00447A  804324     MOV arc_counter_slow, W4
00447C  E80204     INC W4, W4
00447E  884324     MOV W4, arc_counter_slow
004480  37001A     BRA .L43, .LSM125
551:                 } else {
552:                   // Hardware did not detect an arc.  Software appears to have read a valid pulse.  Update all data
553:                   
554:                   arc_counter_consecutive = 0;
004482  EB0200     CLR W4
004484  884304     MOV W4, arc_counter_consecutive
555:                   
556:                   if (mode == PULSE_MODE_A) {
004486  90422E     MOV.B [W14+2], W4
004488  524FE0     SUB.B W4, #0x0, [W15]
00448A  3A0008     BRA NZ, .L44, .LSM122
557:                     StorePulseData(&ps_magnetron_mode_A);
00448C  209900     MOV #0x990, W0
00448E  070090     RCALL StorePulseData
558:                     pulse_energy_milli_joules = CalculatePulseEnergyMilliJoules(ps_hv_lambda_mode_A.v_command_set_point);
004490  8049C4     MOV 0x938, W4
004492  780004     MOV W4, W0
004494  0700C3     RCALL CalculatePulseEnergyMilliJoules
004496  780200     MOV W0, W4
004498  780F04     MOV W4, [W14]
00449A  370007     BRA .L45, .LSM124
559:                   } else {
560:                     StorePulseData(&ps_magnetron_mode_B);
00449C  20A440     MOV #0xA44, W0
00449E  070088     RCALL StorePulseData
561:                     pulse_energy_milli_joules = CalculatePulseEnergyMilliJoules(ps_hv_lambda_mode_B.v_command_set_point);
0044A0  804F64     MOV 0x9EC, W4
0044A2  780004     MOV W4, W0
0044A4  0700BB     RCALL CalculatePulseEnergyMilliJoules
0044A6  780200     MOV W0, W4
0044A8  780F04     MOV W4, [W14]
562:                   }
563:                   average_energy_per_pulse_milli_joules = RCFilter64Tau(average_energy_per_pulse_milli_joules, pulse_energy_milli_joules);
0044AA  804284     MOV average_energy_per_pulse_milli_joules, W4
0044AC  78009E     MOV [W14], W1
0044AE  780004     MOV W4, W0
0044B0  07F3C8     RCALL RCFilter64Tau
0044B2  780200     MOV W0, W4
0044B4  884284     MOV W4, average_energy_per_pulse_milli_joules
564:                 }   
565:                 
566:                 
567:                 if ((pulse_magnetron_current_adc_reading > ADC_PULSE_CURRENT_OVER_GLITCH) || (pulse_magnetron_current_adc_reading < ADC_PULSE_CURRENT_UNDER_GLITCH)) {
0044B6  8043B5     MOV pulse_magnetron_current_adc_reading, W5
0044B8  2FA004     MOV #0xFA00, W4
0044BA  528F84     SUB W5, W4, [W15]
0044BC  3E0004     BRA GTU, .L46, .LSM126
0044BE  8043B5     MOV pulse_magnetron_current_adc_reading, W5
0044C0  22FFF4     MOV #0x2FFF, W4
0044C2  528F84     SUB W5, W4, [W15]
0044C4  3E0003     BRA GTU, .L47, .LSM127
568:                   // The current readback was outside of the "GLITCH" limits.  Assume it was an error with the ADC and record an ADC error
569:                   global_debug_counter.magnetron_current_adc_glitch++;
0044C6  80B944     MOV global_debug_counter, W4
0044C8  E80204     INC W4, W4
0044CA  88B944     MOV W4, global_debug_counter
570:                 }
571:               
572:                 if ((pulse_magnetron_voltage_adc_reading > ADC_PULSE_VOLTAGE_OVER_GLITCH) || (pulse_magnetron_voltage_adc_reading < ADC_PULSE_VOLTAGE_UNDER_GLITCH)) {
0044CC  8043C5     MOV pulse_magnetron_voltage_adc_reading, W5
0044CE  2F0004     MOV #0xF000, W4
0044D0  528F84     SUB W5, W4, [W15]
0044D2  3E0004     BRA GTU, .L48, .LSM128
0044D4  8043C5     MOV pulse_magnetron_voltage_adc_reading, W5
0044D6  207FF4     MOV #0x7FF, W4
0044D8  528F84     SUB W5, W4, [W15]
0044DA  3E0003     BRA GTU, .L49, .LSM129
573:                   global_debug_counter.magnetron_voltage_adc_glitch++;
0044DC  80B954     MOV .LSM628, W4
0044DE  E80204     INC W4, W4
0044E0  88B954     MOV W4, .LSM628
574:                 }
575:                 
576:                 //ResetPulseLatches();  // This must be called to clear the over/under current latches.  //DPARKER the pulse latches are now reset in the pulse interrupt
577:                 
578:                 // Decrement the arc_counter_fast if we need to
579:                 pulse_counter_fast++;
0044E2  804334     MOV pulse_counter_fast, W4
0044E4  E80204     INC W4, W4
0044E6  884334     MOV W4, pulse_counter_fast
580:                 if (pulse_counter_fast > ARC_COUNTER_FAST_DECREMENT_INTERVAL) {
0044E8  804334     MOV pulse_counter_fast, W4
0044EA  520FF9     SUB W4, #0x19, [W15]
0044EC  360008     BRA LEU, .L50, .LSM134
581:                   pulse_counter_fast = 0;
0044EE  EB0200     CLR W4
0044F0  884334     MOV W4, pulse_counter_fast
582:                   if (arc_counter_fast) {
0044F2  804314     MOV arc_counter_fast, W4
0044F4  520FE0     SUB W4, #0x0, [W15]
0044F6  320003     BRA Z, .L50, .LSM134
583:                     arc_counter_fast--;
0044F8  804314     MOV arc_counter_fast, W4
0044FA  E90204     DEC W4, W4
0044FC  884314     MOV W4, arc_counter_fast
584:                   }
585:                 }
586:                 
587:                 // decrement the arc_counter_slow if we need to
588:                 pulse_counter_slow++;
0044FE  804344     MOV pulse_counter_slow, W4
004500  E80204     INC W4, W4
004502  884344     MOV W4, pulse_counter_slow
589:                 if (pulse_counter_slow > ARC_COUNTER_SLOW_DECREMENT_INTERVAL) {
004504  804344     MOV pulse_counter_slow, W4
004506  520FF4     SUB W4, #0x14, [W15]
004508  360008     BRA LEU, .L51, .LSM139
590:                   pulse_counter_slow = 0;
00450A  EB0200     CLR W4
00450C  884344     MOV W4, pulse_counter_slow
591:                   if (arc_counter_slow) {
00450E  804324     MOV arc_counter_slow, W4
004510  520FE0     SUB W4, #0x0, [W15]
004512  320003     BRA Z, .L51, .LSM139
592:                     arc_counter_slow--;
004514  804324     MOV arc_counter_slow, W4
004516  E90204     DEC W4, W4
004518  884324     MOV W4, arc_counter_slow
593:                   }
594:                 }
595:                 
596:               
597:                 // CHECK FOR PULSE FAULTS - Too many arcs, voltage/current out of range
598:                 
599:                 // Check for too many consecutive arcs
600:                 if (arc_counter_consecutive > ARC_COUNTER_MAX_CONSECUTIVE) {
00451A  804304     MOV arc_counter_consecutive, W4
00451C  520FE5     SUB W4, #0x5, [W15]
00451E  360002     BRA LEU, .L52, .LSM141
601:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_CONSECUTIVE);
004520  200010     MOV #0x1, W0
004522  07018E     RCALL RecordThisHighVoltageFault
602:                 }
603:                 
604:                 // Check for too many arcs in a short amount of time
605:                 if (arc_counter_fast > ARC_COUNTER_FAST_MAX_ARCS) {
004524  804315     MOV arc_counter_fast, W5
004526  201904     MOV #0x190, W4
004528  528F84     SUB W5, W4, [W15]
00452A  360002     BRA LEU, .L53, .LSM143
606:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_FAST);
00452C  200020     MOV #0x2, W0
00452E  070188     RCALL RecordThisHighVoltageFault
607:                 }
608:                 
609:                 // Check for too many arc is a long amount of time
610:                 if (arc_counter_slow > ARC_COUNTER_SLOW_MAX_ARCS) {
004530  804325     MOV arc_counter_slow, W5
004532  201F44     MOV #0x1F4, W4
004534  528F84     SUB W5, W4, [W15]
004536  360002     BRA LEU, .L54, .LSM145
611:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_SLOW);
004538  200040     MOV #0x4, W0
00453A  070182     RCALL RecordThisHighVoltageFault
612:                 }
613:                 
614:               
615:                 // Check that the magnetron voltage ADC reading is not greater than X% of its program point (set in Config.h)
616:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
617:                 if (CheckOverVoltFault(&ps_magnetron_mode_A)) {
00453C  209900     MOV #0x990, W0
00453E  0701FD     RCALL CheckOverVoltFault
004540  784200     MOV.B W0, W4
004542  524FE0     SUB.B W4, #0x0, [W15]
004544  320002     BRA Z, .L55, .LSM147
618:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_A);
004546  200400     MOV #0x40, W0
004548  07017B     RCALL RecordThisHighVoltageFault
619:                 }
620:                 
621:                 // Check that the magnetron voltage ADC reading is not less than X% of its program point (set in Config.h)
622:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
623:                 if (CheckUnderVoltFault(&ps_magnetron_mode_A)) {
00454A  209900     MOV #0x990, W0
00454C  07021D     RCALL CheckUnderVoltFault
00454E  784200     MOV.B W0, W4
004550  524FE0     SUB.B W4, #0x0, [W15]
004552  320002     BRA Z, .L56, .LSM149
624:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_A);
004554  200400     MOV #0x40, W0
004556  070174     RCALL RecordThisHighVoltageFault
625:                 }
626:               
627:                 // Check that the magnetron current ADC reading is not greater than X% of its program point (set in Config.h)
628:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
629:                 if (CheckOverCurrentFault(&ps_magnetron_mode_A)) {
004558  209900     MOV #0x990, W0
00455A  070244     RCALL CheckOverCurrentFault
00455C  784200     MOV.B W0, W4
00455E  524FE0     SUB.B W4, #0x0, [W15]
004560  320002     BRA Z, .L57, .LSM151
630:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_A);
004562  200100     MOV #0x10, W0
004564  07016D     RCALL RecordThisHighVoltageFault
631:                 }
632:                 
633:                 // Check that the magnetron current ADC reading is not less than X% of its program point (set in Config.h)
634:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
635:                 if (CheckUnderCurrentFault(&ps_magnetron_mode_A)) {
004566  209900     MOV #0x990, W0
004568  070264     RCALL CheckUnderCurrentFault
00456A  784200     MOV.B W0, W4
00456C  524FE0     SUB.B W4, #0x0, [W15]
00456E  320002     BRA Z, .L58, .LSM153
636:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_A);
004570  200100     MOV #0x10, W0
004572  070166     RCALL RecordThisHighVoltageFault
637:                 }
638:               
639:               
640:                 // Check that the magnetron voltage ADC reading is not greater than X% of its program point (set in Config.h)
641:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
642:                 if (CheckOverVoltFault(&ps_magnetron_mode_B)) {
004574  20A440     MOV #0xA44, W0
004576  0701E1     RCALL CheckOverVoltFault
004578  784200     MOV.B W0, W4
00457A  524FE0     SUB.B W4, #0x0, [W15]
00457C  320002     BRA Z, .L59, .LSM155
643:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_B);
00457E  200800     MOV #0x80, W0
004580  07015F     RCALL RecordThisHighVoltageFault
644:                 }
645:                 
646:                 // Check that the magnetron voltage ADC reading is not less than X% of its program point (set in Config.h)
647:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
648:                 if (CheckUnderVoltFault(&ps_magnetron_mode_B)) {
004582  20A440     MOV #0xA44, W0
004584  070201     RCALL CheckUnderVoltFault
004586  784200     MOV.B W0, W4
004588  524FE0     SUB.B W4, #0x0, [W15]
00458A  320002     BRA Z, .L60, .LSM157
649:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_B);
00458C  200800     MOV #0x80, W0
00458E  070158     RCALL RecordThisHighVoltageFault
650:                 }
651:                 
652:                 // Check that the magnetron current ADC reading is not greater than X% of its program point (set in Config.h)
653:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
654:                 if (CheckOverCurrentFault(&ps_magnetron_mode_B)) {
004590  20A440     MOV #0xA44, W0
004592  070228     RCALL CheckOverCurrentFault
004594  784200     MOV.B W0, W4
004596  524FE0     SUB.B W4, #0x0, [W15]
004598  320002     BRA Z, .L61, .LSM159
655:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_B);
00459A  200200     MOV #0x20, W0
00459C  070151     RCALL RecordThisHighVoltageFault
656:                 }
657:                 
658:                 // Check that the magnetron current ADC reading is not less than X% of its program point (set in Config.h)
659:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
660:                 if (CheckUnderCurrentFault(&ps_magnetron_mode_B)) {
00459E  20A440     MOV #0xA44, W0
0045A0  070248     RCALL CheckUnderCurrentFault
0045A2  784200     MOV.B W0, W4
0045A4  524FE0     SUB.B W4, #0x0, [W15]
0045A6  320002     BRA Z, .L41, .LSM161
661:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_B);
0045A8  200200     MOV #0x20, W0
0045AA  07014A     RCALL RecordThisHighVoltageFault
662:                 }
663:                 
664:               
665:                 // DPARKER NEED TO IMPLEMENT and TEST the PFN fault current input Logic
666:               }
0045AC  FA8000     ULNK
0045AE  060000     RETURN
667:               
668:               void StorePulseData(POWERSUPPLY* ptr) {
0045B0  FA0002     LNK #0x2
0045B2  780F00     MOV W0, [W14]
669:                 
670:                 ptr->i_adc_reading = RCFilter16Tau(ptr->i_adc_reading, pulse_magnetron_current_adc_reading);
0045B4  8043B5     MOV pulse_magnetron_current_adc_reading, W5
0045B6  78021E     MOV [W14], W4
0045B8  901A64     MOV [W4+60], W4
0045BA  780085     MOV W5, W1
0045BC  780004     MOV W4, W0
0045BE  07F37D     RCALL RCFilter16Tau
0045C0  780200     MOV W0, W4
0045C2  78029E     MOV [W14], W5
0045C4  981AE4     MOV W4, [W5+60]
671:                 ptr->v_adc_reading = RCFilter16Tau(ptr->v_adc_reading, pulse_magnetron_voltage_adc_reading);
0045C6  8043C5     MOV pulse_magnetron_voltage_adc_reading, W5
0045C8  78021E     MOV [W14], W4
0045CA  900A04     MOV [W4+16], W4
0045CC  780085     MOV W5, W1
0045CE  780004     MOV W4, W0
0045D0  07F374     RCALL RCFilter16Tau
0045D2  780200     MOV W0, W4
0045D4  78029E     MOV [W14], W5
0045D6  980A84     MOV W4, [W5+16]
672:                 
673:                 // record min/max current
674:                 if (pulse_magnetron_current_adc_reading > ptr->i_adc_max_reading) {
0045D8  78021E     MOV [W14], W4
0045DA  902AB4     MOV [W4+86], W5
0045DC  8043B4     MOV pulse_magnetron_current_adc_reading, W4
0045DE  528F84     SUB W5, W4, [W15]
0045E0  310003     BRA C, .L64, .LSM167
675:                   ptr->i_adc_max_reading = pulse_magnetron_current_adc_reading;
0045E2  8043B5     MOV pulse_magnetron_current_adc_reading, W5
0045E4  78021E     MOV [W14], W4
0045E6  982A35     MOV W5, [W4+86]
676:                 }
677:                 if (pulse_magnetron_current_adc_reading < ptr->i_adc_min_reading) {
0045E8  78021E     MOV [W14], W4
0045EA  902AC4     MOV [W4+88], W5
0045EC  8043B4     MOV pulse_magnetron_current_adc_reading, W4
0045EE  528F84     SUB W5, W4, [W15]
0045F0  360003     BRA LEU, .L65, .LSM169
678:                   ptr->i_adc_min_reading = pulse_magnetron_current_adc_reading;
0045F2  8043B5     MOV pulse_magnetron_current_adc_reading, W5
0045F4  78021E     MOV [W14], W4
0045F6  982A45     MOV W5, [W4+88]
679:                 }
680:               
681:                 // record min/max voltage
682:                 if (pulse_magnetron_voltage_adc_reading > ptr->v_adc_max_reading) {
0045F8  78021E     MOV [W14], W4
0045FA  9012D4     MOV [W4+42], W5
0045FC  8043C4     MOV pulse_magnetron_voltage_adc_reading, W4
0045FE  528F84     SUB W5, W4, [W15]
004600  310003     BRA C, .L66, .LSM171
683:                   ptr->v_adc_max_reading = pulse_magnetron_voltage_adc_reading;
004602  8043C5     MOV pulse_magnetron_voltage_adc_reading, W5
004604  78021E     MOV [W14], W4
004606  981255     MOV W5, [W4+42]
684:                 }
685:                 if (pulse_magnetron_voltage_adc_reading < ptr->v_adc_min_reading) {
004608  78021E     MOV [W14], W4
00460A  9012E4     MOV [W4+44], W5
00460C  8043C4     MOV pulse_magnetron_voltage_adc_reading, W4
00460E  528F84     SUB W5, W4, [W15]
004610  360003     BRA LEU, .L63, .LSM173
686:                   ptr->v_adc_min_reading = pulse_magnetron_voltage_adc_reading;
004612  8043C5     MOV pulse_magnetron_voltage_adc_reading, W5
004614  78021E     MOV [W14], W4
004616  981265     MOV W5, [W4+44]
687:                 }
688:               
689:               }
004618  FA8000     ULNK
00461A  060000     RETURN
690:               
691:               unsigned int CalculatePulseEnergyMilliJoules(unsigned int lambda_voltage) {
00461C  FA000C     LNK #0xC
00461E  980750     MOV W0, [W14+10]
692:                 unsigned long long power_milli_joule;
693:                 unsigned int return_data;
694:               
695:                 /*
696:                   The Pulse Energy is Calculated for Each Pulse
697:                   The Pulse Energy is Filtered/Averaged with a 64 pulse/tau filter
698:                   The Average Pulse Energy is then multiplied by the PRF to generate the power.
699:                   The filament heater voltage is generated from the power.
700:               
701:                   Power = 1/2 * C * V^2
702:                   C = 90nF
703:                   In Floating Point Math
704:                   power(milli_joule) = .5 * 90e-9 * V^2 * 1000
705:               
706:                   power_milli_joule = .5 * 90e-9 * V^2 * 1000
707:                                     = v^2/22222.22
708:               		      = v*v / 2^6 / 347.22
709:               		      = v*v / 2^6 * 47 / 2^14 (.4% fixed point error)
710:               		      
711:               
712:                   Based on MagneTX changing it to  = v^2/27275
713:                                                    = v*v * 4920 / 2^27
714:               
715:                 */
716:               
717:                 power_milli_joule = lambda_voltage;
004620  90025E     MOV [W14+10], W4
004622  200005     MOV #0x0, W5
004624  200006     MOV #0x0, W6
004626  200007     MOV #0x0, W7
004628  BE9F04     MOV.D W4, [W14++]
00462A  BE9706     MOV.D W6, [W14--]
718:                 power_milli_joule *= lambda_voltage;
00462C  90025E     MOV [W14+10], W4
00462E  200005     MOV #0x0, W5
004630  200006     MOV #0x0, W6
004632  200007     MOV #0x0, W7
004634  BE003E     MOV.D [W14++], W0
004636  BE012E     MOV.D [W14--], W2
004638  07DE91     RCALL ___muldi3
00463A  BE0302     MOV.D W2, W6
00463C  BE0200     MOV.D W0, W4
00463E  BE9F04     MOV.D W4, [W14++]
004640  BE9706     MOV.D W6, [W14--]
719:                 /*
720:                   power_milli_joule >>= 6;
721:                   power_milli_joule *= 47;
722:                   power_milli_joule >>= 14;
723:                 */
724:               
725:               #ifdef __PFN_800_HZ
726:                 //power_milli_joule *= 3280; // 2/3 the capacitance of normal PFN
727:                 power_milli_joule *= 2800; // Futher decreasing the capacitance to try and keep the Heater Resistance Flat 
004642  20AF04     MOV #0xAF0, W4
004644  200005     MOV #0x0, W5
004646  B83360     MUL.UU W6, #0, W6
004648  BE003E     MOV.D [W14++], W0
00464A  BE012E     MOV.D [W14--], W2
00464C  07DE87     RCALL ___muldi3
00464E  BE0302     MOV.D W2, W6
004650  BE0200     MOV.D W0, W4
004652  BE9F04     MOV.D W4, [W14++]
004654  BE9706     MOV.D W6, [W14--]
728:               #else
729:                 power_milli_joule *= 4920;
730:               #endif
731:                 
732:                 power_milli_joule >>= 27;
004656  BE023E     MOV.D [W14++], W4
004658  BE032E     MOV.D [W14--], W6
00465A  DE2A4B     LSR W5, #11, W4
00465C  DD30C5     SL W6, #5, W1
00465E  708204     IOR W1, W4, W4
004660  DE32CB     LSR W6, #11, W5
004662  DD38C5     SL W7, #5, W1
004664  708285     IOR W1, W5, W5
004666  DE3B4B     LSR W7, #11, W6
004668  EB0380     CLR W7
00466A  BE9F04     MOV.D W4, [W14++]
00466C  BE9706     MOV.D W6, [W14--]
733:                 
734:                 if (power_milli_joule >= 0xFFFF) {
00466E  2FFFE4     MOV #0xFFFE, W4
004670  200005     MOV #0x0, W5
004672  B83360     MUL.UU W6, #0, W6
004674  BE003E     MOV.D [W14++], W0
004676  BE012E     MOV.D [W14--], W2
004678  E10004     CP.W W0, W4
00467A  E18805     CPB.W W1, W5
00467C  E19006     CPB.W W2, W6
00467E  E19807     CPB.W W3, W7
004680  360005     BRA LEU, .L69, .LSM181
735:                   power_milli_joule = 0xFFFF;
004682  2FFFF4     MOV #0xFFFF, W4
004684  200005     MOV #0x0, W5
004686  B83360     MUL.UU W6, #0, W6
004688  BE9F04     MOV.D W4, [W14++]
00468A  BE9706     MOV.D W6, [W14--]
736:                 }
737:                 power_milli_joule &= 0xFFFF;
00468C  BE003E     MOV.D [W14++], W0
00468E  BE012E     MOV.D [W14--], W2
004690  2FFFF4     MOV #0xFFFF, W4
004692  200005     MOV #0x0, W5
004694  B83360     MUL.UU W6, #0, W6
004696  620200     AND W4, W0, W4
004698  628281     AND W5, W1, W5
00469A  630302     AND W6, W2, W6
00469C  638383     AND W7, W3, W7
00469E  BE9F04     MOV.D W4, [W14++]
0046A0  BE9706     MOV.D W6, [W14--]
738:               
739:                 return_data = power_milli_joule;
0046A2  78021E     MOV [W14], W4
0046A4  980744     MOV W4, [W14+8]
740:               
741:                 return return_data;
0046A6  90024E     MOV [W14+8], W4
742:               }
0046A8  780004     MOV W4, W0
0046AA  FA8000     ULNK
0046AC  060000     RETURN
743:               
744:               
745:               void LoadFaultMaskRegisters(void) {
0046AE  FA0000     LNK #0x0
746:                 
747:                 switch(control_state) {
0046B0  208584     MOV #0x858, W4
0046B2  784214     MOV.B [W4], W4
0046B4  FB8204     ZE W4, W4
0046B6  200345     MOV #0x34, W5
0046B8  520F85     SUB W4, W5, [W15]
0046BA  32004F     BRA Z, .L75, .LSM214
0046BC  200345     MOV #0x34, W5
0046BE  520F85     SUB W4, W5, [W15]
0046C0  3C0008     BRA GT, .L80
0046C2  520FF4     SUB W4, #0x14, [W15]
0046C4  320028     BRA Z, .L73, .LSM196
0046C6  200245     MOV #0x24, W5
0046C8  520F85     SUB W4, W5, [W15]
0046CA  320036     BRA Z, .L74, .LSM205
0046CC  520FE4     SUB W4, #0x4, [W15]
0046CE  320012     BRA Z, .L72, .LSM187
0046D0  370099     BRA .L70, .LSM259
0046D2  200445     MOV #0x44, W5
0046D4  520F85     SUB W4, W5, [W15]
0046D6  320063     BRA Z, .L77, .LSM232
0046D8  200445     MOV #0x44, W5
0046DA  520F85     SUB W4, W5, [W15]
0046DC  3C0004     BRA GT, .L81
0046DE  200355     MOV #0x35, W5
0046E0  520F85     SUB W4, W5, [W15]
0046E2  32004C     BRA Z, .L76, .LSM223
0046E4  37008F     BRA .L70, .LSM259
0046E6  200A45     MOV #0xA4, W5
0046E8  520F85     SUB W4, W5, [W15]
0046EA  32007B     BRA Z, .L78, .LSM250
0046EC  200A85     MOV #0xA8, W5
0046EE  520F85     SUB W4, W5, [W15]
0046F0  320067     BRA Z, .L79, .LSM241
0046F2  370088     BRA .L70, .LSM259
748:                   
749:                 case STATE_START_UP:
750:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_START_UP;
0046F4  EB0200     CLR W4
0046F6  88BB24     MOV W4, magnetron_fault_mask
751:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_START_UP;
0046F8  EB0200     CLR W4
0046FA  88BB44     MOV W4, thyratron_fault_mask
752:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_START_UP;
0046FC  EB0200     CLR W4
0046FE  88BB34     MOV W4, high_voltage_fault_mask
753:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_START_UP;
004700  EB0200     CLR W4
004702  88BB54     MOV W4, control_board_fault_mask
754:                
755:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_START_UP;
004704  EB0200     CLR W4
004706  88BB64     MOV W4, magnetron_warning_mask
756:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_START_UP;
004708  EB0200     CLR W4
00470A  88BB84     MOV W4, thyratron_warning_mask
757:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_START_UP;
00470C  EB0200     CLR W4
00470E  88BB74     MOV W4, high_voltage_warning_mask
758:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_START_UP;
004710  EB0200     CLR W4
004712  88BB94     MOV W4, control_board_warning_mask
759:                   break;  
004714  370077     BRA .L70, .LSM259
760:               
761:                 case STATE_SYSTEM_COLD_READY:
762:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_COLD_READY;
004716  EB0200     CLR W4
004718  88BB24     MOV W4, magnetron_fault_mask
763:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_COLD_READY;
00471A  EB0200     CLR W4
00471C  88BB44     MOV W4, thyratron_fault_mask
764:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_COLD_READY;
00471E  EB0200     CLR W4
004720  88BB34     MOV W4, high_voltage_fault_mask
765:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_COLD_READY;
004722  EB0200     CLR W4
004724  88BB54     MOV W4, control_board_fault_mask
766:                
767:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_COLD_READY;
004726  EB0200     CLR W4
004728  88BB64     MOV W4, magnetron_warning_mask
768:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_COLD_READY;
00472A  EB0200     CLR W4
00472C  88BB84     MOV W4, thyratron_warning_mask
769:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_COLD_READY;
00472E  EB0200     CLR W4
004730  88BB74     MOV W4, high_voltage_warning_mask
770:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_COLD_READY;
004732  EB0200     CLR W4
004734  88BB94     MOV W4, control_board_warning_mask
771:                   break;
004736  370066     BRA .L70, .LSM259
772:                   
773:                 case STATE_WARM_UP:
774:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_UP;
004738  202034     MOV #0x203, W4
00473A  88BB24     MOV W4, magnetron_fault_mask
775:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_UP;
00473C  EB0200     CLR W4
00473E  88BB44     MOV W4, thyratron_fault_mask
776:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_UP;
004740  EB0200     CLR W4
004742  88BB34     MOV W4, high_voltage_fault_mask
777:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_UP;
004744  EB0200     CLR W4
004746  88BB54     MOV W4, control_board_fault_mask
778:                
779:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_UP;
004748  EB0200     CLR W4
00474A  88BB64     MOV W4, magnetron_warning_mask
780:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_UP;
00474C  EB0200     CLR W4
00474E  88BB84     MOV W4, thyratron_warning_mask
781:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_UP;
004750  EB0200     CLR W4
004752  88BB74     MOV W4, high_voltage_warning_mask
782:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_UP;
004754  EB0200     CLR W4
004756  88BB94     MOV W4, control_board_warning_mask
783:                   break;
004758  370055     BRA .L70, .LSM259
784:               
785:                 case STATE_SYSTEM_WARM_READY:
786:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_READY;
00475A  2013F4     MOV #0x13F, W4
00475C  88BB24     MOV W4, magnetron_fault_mask
787:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_READY;
00475E  EB0200     CLR W4
004760  88BB44     MOV W4, thyratron_fault_mask
788:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
004762  EB0200     CLR W4
004764  88BB34     MOV W4, high_voltage_fault_mask
789:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_READY;
004766  EB0200     CLR W4
004768  88BB54     MOV W4, control_board_fault_mask
790:                
791:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_READY;
00476A  EB0200     CLR W4
00476C  88BB64     MOV W4, magnetron_warning_mask
792:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_READY;
00476E  EB0200     CLR W4
004770  88BB84     MOV W4, thyratron_warning_mask
793:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
004772  EB0200     CLR W4
004774  88BB74     MOV W4, high_voltage_warning_mask
794:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_READY;
004776  EB0200     CLR W4
004778  88BB94     MOV W4, control_board_warning_mask
795:                   break;
00477A  370044     BRA .L70, .LSM259
796:               
797:               
798:                 case STATE_HV_STARTUP:
799:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_READY;
00477C  2013F4     MOV #0x13F, W4
00477E  88BB24     MOV W4, magnetron_fault_mask
800:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_READY;
004780  EB0200     CLR W4
004782  88BB44     MOV W4, thyratron_fault_mask
801:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
004784  EB0200     CLR W4
004786  88BB34     MOV W4, high_voltage_fault_mask
802:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_READY;
004788  EB0200     CLR W4
00478A  88BB54     MOV W4, control_board_fault_mask
803:                
804:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_READY;
00478C  EB0200     CLR W4
00478E  88BB64     MOV W4, magnetron_warning_mask
805:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_READY;
004790  EB0200     CLR W4
004792  88BB84     MOV W4, thyratron_warning_mask
806:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
004794  EB0200     CLR W4
004796  88BB74     MOV W4, high_voltage_warning_mask
807:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_READY;
004798  EB0200     CLR W4
00479A  88BB94     MOV W4, control_board_warning_mask
808:                   break;
00479C  370033     BRA .L70, .LSM259
809:               
810:               
811:                 case STATE_HV_ON:
812:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_HV_ON;
00479E  2013F4     MOV #0x13F, W4
0047A0  88BB24     MOV W4, magnetron_fault_mask
813:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_HV_ON;
0047A2  EB0200     CLR W4
0047A4  88BB44     MOV W4, thyratron_fault_mask
814:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_HV_ON;
0047A6  2F3064     MOV #0xF306, W4
0047A8  88BB34     MOV W4, high_voltage_fault_mask
815:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_HV_ON;
0047AA  200014     MOV #0x1, W4
0047AC  88BB54     MOV W4, control_board_fault_mask
816:                
817:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_HV_ON;
0047AE  EB0200     CLR W4
0047B0  88BB64     MOV W4, magnetron_warning_mask
818:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_HV_ON;
0047B2  EB0200     CLR W4
0047B4  88BB84     MOV W4, thyratron_warning_mask
819:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_HV_ON;
0047B6  EB0200     CLR W4
0047B8  88BB74     MOV W4, high_voltage_warning_mask
820:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_HV_ON;
0047BA  EB0200     CLR W4
0047BC  88BB94     MOV W4, control_board_warning_mask
821:                   break;
0047BE  370022     BRA .L70, .LSM259
822:               
823:                 case STATE_FAULT_WARM_FAULT:
824:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_FAULT;
0047C0  202004     MOV #0x200, W4
0047C2  88BB24     MOV W4, magnetron_fault_mask
825:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_FAULT;
0047C4  EB0200     CLR W4
0047C6  88BB44     MOV W4, thyratron_fault_mask
826:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_FAULT;
0047C8  EB0200     CLR W4
0047CA  88BB34     MOV W4, high_voltage_fault_mask
827:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_FAULT;
0047CC  EB0200     CLR W4
0047CE  88BB54     MOV W4, control_board_fault_mask
828:                
829:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_FAULT;
0047D0  EB0200     CLR W4
0047D2  88BB64     MOV W4, magnetron_warning_mask
830:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_FAULT;
0047D4  EB0200     CLR W4
0047D6  88BB84     MOV W4, thyratron_warning_mask
831:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_FAULT;
0047D8  EB0200     CLR W4
0047DA  88BB74     MOV W4, high_voltage_warning_mask
832:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_FAULT;
0047DC  EB0200     CLR W4
0047DE  88BB94     MOV W4, control_board_warning_mask
833:                   break;
0047E0  370011     BRA .L70, .LSM259
834:                   
835:                 case STATE_FAULT_COLD_FAULT:
836:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_COLD_FAULT;
0047E2  EB0200     CLR W4
0047E4  88BB24     MOV W4, magnetron_fault_mask
837:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_COLD_FAULT;
0047E6  EB0200     CLR W4
0047E8  88BB44     MOV W4, thyratron_fault_mask
838:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_COLD_FAULT;
0047EA  EB0200     CLR W4
0047EC  88BB34     MOV W4, high_voltage_fault_mask
839:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_COLD_FAULT;
0047EE  EB0200     CLR W4
0047F0  88BB54     MOV W4, control_board_fault_mask
840:                
841:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_COLD_FAULT;
0047F2  EB0200     CLR W4
0047F4  88BB64     MOV W4, magnetron_warning_mask
842:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_COLD_FAULT;
0047F6  EB0200     CLR W4
0047F8  88BB84     MOV W4, thyratron_warning_mask
843:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_COLD_FAULT;
0047FA  EB0200     CLR W4
0047FC  88BB74     MOV W4, high_voltage_warning_mask
844:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_COLD_FAULT;
0047FE  EB0200     CLR W4
004800  88BB94     MOV W4, control_board_warning_mask
845:                   break;
004802  000000     NOP
846:                 }
847:               }
004804  FA8000     ULNK
004806  060000     RETURN
848:               
849:               
850:               
851:               void RecordThisMagnetronFault(unsigned int fault_bit) {  
004808  FA0002     LNK #0x2
00480A  780F00     MOV W0, [W14]
852:               
853:                 faults_magnetron_status_reg |= fault_bit;
00480C  80BA04     MOV faults_magnetron_status_reg, W4
00480E  72021E     IOR W4, [W14], W4
004810  88BA04     MOV W4, faults_magnetron_status_reg
854:               
855:                 if (fault_bit & magnetron_warning_mask) {
004812  80BB64     MOV magnetron_warning_mask, W4
004814  62021E     AND W4, [W14], W4
004816  520FE0     SUB W4, #0x0, [W15]
004818  320003     BRA Z, .L83, .LSM264
856:                   faults_magnetron_warning_reg |= fault_bit;
00481A  80BA24     MOV faults_magnetron_warning_reg, W4
00481C  72021E     IOR W4, [W14], W4
00481E  88BA24     MOV W4, faults_magnetron_warning_reg
857:                 }
858:               
859:                 if (fault_bit & magnetron_fault_mask) {
004820  80BB24     MOV magnetron_fault_mask, W4
004822  62021E     AND W4, [W14], W4
004824  520FE0     SUB W4, #0x0, [W15]
004826  32000A     BRA Z, .L82, .LSM268
860:                   if (!(faults_magnetron_fault_reg & fault_bit)) {
004828  80BA14     MOV faults_magnetron_fault_reg, W4
00482A  62021E     AND W4, [W14], W4
00482C  520FE0     SUB W4, #0x0, [W15]
00482E  3A0006     BRA NZ, .L82, .LSM268
861:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
862:                     // Set the coresponding bit and save the fault
863:                     faults_magnetron_fault_reg |= fault_bit;
004830  80BA14     MOV faults_magnetron_fault_reg, W4
004832  72021E     IOR W4, [W14], W4
004834  88BA14     MOV W4, faults_magnetron_fault_reg
864:                     WriteToEventLog(MAGNETRON_FAULT,fault_bit);
004836  78009E     MOV [W14], W1
004838  EB4000     CLR.B W0
00483A  070056     RCALL WriteToEventLog
865:                   }
866:                 }
867:               }
00483C  FA8000     ULNK
00483E  060000     RETURN
868:               
869:               
870:               
871:               void RecordThisHighVoltageFault(unsigned int fault_bit) {
004840  FA0002     LNK #0x2
004842  780F00     MOV W0, [W14]
872:               
873:                 faults_high_voltage_status_reg |= fault_bit;
004844  80BA34     MOV faults_high_voltage_status_reg, W4
004846  72021E     IOR W4, [W14], W4
004848  88BA34     MOV W4, faults_high_voltage_status_reg
874:               
875:                 if (fault_bit & high_voltage_warning_mask) {
00484A  80BB74     MOV high_voltage_warning_mask, W4
00484C  62021E     AND W4, [W14], W4
00484E  520FE0     SUB W4, #0x0, [W15]
004850  320003     BRA Z, .L86, .LSM273
876:                   faults_high_voltage_warning_reg |= fault_bit;
004852  80BA54     MOV faults_high_voltage_warning_reg, W4
004854  72021E     IOR W4, [W14], W4
004856  88BA54     MOV W4, faults_high_voltage_warning_reg
877:                 }
878:               
879:                 if (fault_bit & high_voltage_fault_mask) {
004858  80BB34     MOV high_voltage_fault_mask, W4
00485A  62021E     AND W4, [W14], W4
00485C  520FE0     SUB W4, #0x0, [W15]
00485E  32000A     BRA Z, .L85, .LSM277
880:                   if (!(faults_high_voltage_fault_reg & fault_bit)) {
004860  80BA44     MOV faults_high_voltage_fault_reg, W4
004862  62021E     AND W4, [W14], W4
004864  520FE0     SUB W4, #0x0, [W15]
004866  3A0006     BRA NZ, .L85, .LSM277
881:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
882:                     // Set the coresponding bit and save the fault
883:                     faults_high_voltage_fault_reg |= fault_bit;
004868  80BA44     MOV faults_high_voltage_fault_reg, W4
00486A  72021E     IOR W4, [W14], W4
00486C  88BA44     MOV W4, faults_high_voltage_fault_reg
884:                     WriteToEventLog(HIGH_VOLTAGE_FAULT,fault_bit);
00486E  78009E     MOV [W14], W1
004870  B3C010     MOV.B #0x1, W0
004872  07003A     RCALL WriteToEventLog
885:                   }
886:                 }
887:               }
004874  FA8000     ULNK
004876  060000     RETURN
888:               
889:               void RecordThisThyratronFault(unsigned int fault_bit) {
004878  FA0002     LNK #0x2
00487A  780F00     MOV W0, [W14]
890:                 
891:                 faults_thyratron_status_reg |= fault_bit;
00487C  80BAC4     MOV faults_thyratron_status_reg, W4
00487E  72021E     IOR W4, [W14], W4
004880  88BAC4     MOV W4, faults_thyratron_status_reg
892:                 
893:                 if (fault_bit & thyratron_warning_mask) {
004882  80BB84     MOV thyratron_warning_mask, W4
004884  62021E     AND W4, [W14], W4
004886  520FE0     SUB W4, #0x0, [W15]
004888  320003     BRA Z, .L89, .LSM282
894:                   faults_thyratron_warning_reg |= fault_bit;
00488A  80BAE4     MOV faults_thyratron_warning_reg, W4
00488C  72021E     IOR W4, [W14], W4
00488E  88BAE4     MOV W4, faults_thyratron_warning_reg
895:                 }
896:               
897:                 if (fault_bit & thyratron_fault_mask) {
004890  80BB44     MOV thyratron_fault_mask, W4
004892  62021E     AND W4, [W14], W4
004894  520FE0     SUB W4, #0x0, [W15]
004896  32000A     BRA Z, .L88, .LSM286
898:                   if (!(faults_thyratron_fault_reg & fault_bit)) {
004898  80BAD4     MOV faults_thyratron_fault_reg, W4
00489A  62021E     AND W4, [W14], W4
00489C  520FE0     SUB W4, #0x0, [W15]
00489E  3A0006     BRA NZ, .L88, .LSM286
899:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
900:                     // Set the coresponding bit and save the fault
901:                     faults_thyratron_fault_reg |= fault_bit;
0048A0  80BAD4     MOV faults_thyratron_fault_reg, W4
0048A2  72021E     IOR W4, [W14], W4
0048A4  88BAD4     MOV W4, faults_thyratron_fault_reg
902:                     WriteToEventLog(THYRATRON_FAULT,fault_bit);
0048A6  78009E     MOV [W14], W1
0048A8  B3C020     MOV.B #0x2, W0
0048AA  07001E     RCALL WriteToEventLog
903:                   }
904:                 }
905:               }
0048AC  FA8000     ULNK
0048AE  060000     RETURN
906:               
907:               
908:               void RecordThisControlBoardFault(unsigned int fault_bit) { 
0048B0  FA0002     LNK #0x2
0048B2  780F00     MOV W0, [W14]
909:               
910:                 faults_control_board_status_reg |= fault_bit;
0048B4  80BAF4     MOV faults_control_board_status_reg, W4
0048B6  72021E     IOR W4, [W14], W4
0048B8  88BAF4     MOV W4, faults_control_board_status_reg
911:               
912:                 if (fault_bit & control_board_warning_mask) {
0048BA  80BB94     MOV control_board_warning_mask, W4
0048BC  62021E     AND W4, [W14], W4
0048BE  520FE0     SUB W4, #0x0, [W15]
0048C0  320003     BRA Z, .L92, .LSM291
913:                   faults_control_board_warning_reg |= fault_bit;
0048C2  80BB14     MOV faults_control_board_warning_reg, W4
0048C4  72021E     IOR W4, [W14], W4
0048C6  88BB14     MOV W4, faults_control_board_warning_reg
914:                 }
915:               
916:                 if (fault_bit & control_board_fault_mask) {
0048C8  80BB54     MOV control_board_fault_mask, W4
0048CA  62021E     AND W4, [W14], W4
0048CC  520FE0     SUB W4, #0x0, [W15]
0048CE  32000A     BRA Z, .L91, .LSM295
917:                   if (!(faults_control_board_fault_reg & fault_bit)) {
0048D0  80BB04     MOV faults_control_board_fault_reg, W4
0048D2  62021E     AND W4, [W14], W4
0048D4  520FE0     SUB W4, #0x0, [W15]
0048D6  3A0006     BRA NZ, .L91, .LSM295
918:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
919:                     // Set the coresponding bit and save the fault
920:                     faults_control_board_fault_reg |= fault_bit;
0048D8  80BB04     MOV faults_control_board_fault_reg, W4
0048DA  72021E     IOR W4, [W14], W4
0048DC  88BB04     MOV W4, faults_control_board_fault_reg
921:                     WriteToEventLog(CONTROL_BOARD_FAULT,fault_bit);
0048DE  78009E     MOV [W14], W1
0048E0  B3C030     MOV.B #0x3, W0
0048E2  070002     RCALL WriteToEventLog
922:                   }
923:                 }
924:               }
0048E4  FA8000     ULNK
0048E6  060000     RETURN
925:               
926:               
927:               void WriteToEventLog(unsigned char fault_register, unsigned int fault_bit) {
0048E8  FA0004     LNK #0x4
0048EA  784F00     MOV.B W0, [W14]
0048EC  980711     MOV W1, [W14+2]
928:                 // DPARKER this function should write to the event log in ram and update the fault counter in RAM
929:                 // These values are moved to EEPROM later on  . . . like programmed later on
930:               }
0048EE  FA8000     ULNK
0048F0  060000     RETURN
931:               
932:               
933:               unsigned int CheckStartupFailed(void) {
0048F2  FA0000     LNK #0x0
934:                 return 0;
0048F4  EB0200     CLR W4
935:               }
0048F6  780004     MOV W4, W0
0048F8  FA8000     ULNK
0048FA  060000     RETURN
936:               
937:               unsigned int CheckFaultActive(void) {
0048FC  FA0000     LNK #0x0
938:                 if (eeprom_write_failure_count > 0) {
0048FE  804084     MOV eeprom_write_failure_count, W4
004900  520FE0     SUB W4, #0x0, [W15]
004902  320002     BRA Z, .L97, .LSM304
939:                   return 1;
004904  200014     MOV #0x1, W4
004906  37000B     BRA .L98, .LSM305
940:                 }
941:                 
942:                 return (faults_control_board_fault_reg | faults_thyratron_fault_reg | faults_magnetron_fault_reg | faults_high_voltage_fault_reg);
004908  80BB05     MOV faults_control_board_fault_reg, W5
00490A  80BAD4     MOV faults_thyratron_fault_reg, W4
00490C  780304     MOV W4, W6
00490E  730305     IOR W6, W5, W6
004910  780286     MOV W6, W5
004912  80BA14     MOV faults_magnetron_fault_reg, W4
004914  780304     MOV W4, W6
004916  730305     IOR W6, W5, W6
004918  780286     MOV W6, W5
00491A  80BA44     MOV faults_high_voltage_fault_reg, W4
00491C  720205     IOR W4, W5, W4
943:               }
00491E  780004     MOV W4, W0
004920  FA8000     ULNK
004922  060000     RETURN
944:               
945:               
946:               unsigned int CheckColdFaultActive(void) {
004924  FA0002     LNK #0x2
947:                 unsigned int temp;
948:                 temp = (faults_control_board_fault_reg & MASK_CONTROL_BOARD_COLD_FAULTS);
004926  EB0200     CLR W4
004928  780F04     MOV W4, [W14]
949:                 temp |= (faults_thyratron_fault_reg & MASK_THYRATRON_COLD_FAULTS);
950:                 temp |= (faults_magnetron_fault_reg & MASK_MAGNETRON_COLD_FAULTS);
00492A  80BA15     MOV faults_magnetron_fault_reg, W5
00492C  202034     MOV #0x203, W4
00492E  628204     AND W5, W4, W4
004930  720F1E     IOR W4, [W14], [W14]
951:                 temp |= (faults_high_voltage_fault_reg & MASK_HIGH_VOLTAGE_COLD_FAULTS);
952:                 return temp;
004932  78021E     MOV [W14], W4
953:               }
004934  780004     MOV W4, W0
004936  FA8000     ULNK
004938  060000     RETURN
954:               
955:               
956:               
957:               unsigned char CheckOverVoltFault(POWERSUPPLY* ptr) {
00493A  FA0002     LNK #0x2
00493C  780F00     MOV W0, [W14]
958:                 if (ptr->v_adc_reading > ptr->v_adc_over_rel) {
00493E  78021E     MOV [W14], W4
004940  900A84     MOV [W4+16], W5
004942  78021E     MOV [W14], W4
004944  900A54     MOV [W4+26], W4
004946  528F84     SUB W5, W4, [W15]
004948  360012     BRA LEU, .L101, .LSM317
959:                   ptr->v_adc_over_count++;
00494A  78021E     MOV [W14], W4
00494C  901234     MOV [W4+38], W4
00494E  E80284     INC W4, W5
004950  78021E     MOV [W14], W4
004952  981235     MOV W5, [W4+38]
960:                   if (ptr->v_adc_over_count > ptr->v_adc_max_oor) {
004954  78021E     MOV [W14], W4
004956  9012B4     MOV [W4+38], W5
004958  78021E     MOV [W14], W4
00495A  901224     MOV [W4+36], W4
00495C  528F84     SUB W5, W4, [W15]
00495E  360010     BRA LEU, .L102, .LSM319
961:                     ptr->v_adc_over_count = ptr->v_adc_max_oor + 10;
004960  78021E     MOV [W14], W4
004962  901224     MOV [W4+36], W4
004964  4202EA     ADD W4, #0xA, W5
004966  78021E     MOV [W14], W4
004968  981235     MOV W5, [W4+38]
962:                     return 1;
00496A  B3C014     MOV.B #0x1, W4
00496C  37000A     BRA .L103, .LSM320
963:                   }
964:                 } else if (ptr->v_adc_over_count >= 1) {
00496E  78021E     MOV [W14], W4
004970  901234     MOV [W4+38], W4
004972  520FE0     SUB W4, #0x0, [W15]
004974  320005     BRA Z, .L102, .LSM319
965:                   ptr->v_adc_over_count--;
004976  78021E     MOV [W14], W4
004978  901234     MOV [W4+38], W4
00497A  E90284     DEC W4, W5
00497C  78021E     MOV [W14], W4
00497E  981235     MOV W5, [W4+38]
966:                 }
967:                 return 0;
004980  EB4200     CLR.B W4
968:               }
004982  784004     MOV.B W4, W0
004984  FA8000     ULNK
004986  060000     RETURN
969:               
970:               unsigned char CheckUnderVoltFault(POWERSUPPLY* ptr) {
004988  FA0004     LNK #0x4
00498A  980710     MOV W0, [W14+2]
971:                 unsigned int mod_v_adc_reading;
972:               
973:                 mod_v_adc_reading = ptr->v_adc_reading;
00498C  90021E     MOV [W14+2], W4
00498E  900A84     MOV [W4+16], W5
004990  780F05     MOV W5, [W14]
974:                 if (mod_v_adc_reading < 0x0100) {
004992  200FF4     MOV #0xFF, W4
004994  78029E     MOV [W14], W5
004996  528F84     SUB W5, W4, [W15]
004998  3E0002     BRA GTU, .L105, .LSM325
975:                   mod_v_adc_reading = 0x0100; // DPARKER add parameter
00499A  201004     MOV #0x100, W4
00499C  780F04     MOV W4, [W14]
976:                 }
977:                 if (mod_v_adc_reading < ptr->v_adc_under_rel) {
00499E  90021E     MOV [W14+2], W4
0049A0  900A64     MOV [W4+28], W4
0049A2  520F9E     SUB W4, [W14], [W15]
0049A4  360012     BRA LEU, .L106, .LSM330
978:                   ptr->v_adc_under_count++;
0049A6  90021E     MOV [W14+2], W4
0049A8  901244     MOV [W4+40], W4
0049AA  E80284     INC W4, W5
0049AC  90021E     MOV [W14+2], W4
0049AE  981245     MOV W5, [W4+40]
979:                   if (ptr->v_adc_under_count > ptr->v_adc_max_oor) {
0049B0  90021E     MOV [W14+2], W4
0049B2  9012C4     MOV [W4+40], W5
0049B4  90021E     MOV [W14+2], W4
0049B6  901224     MOV [W4+36], W4
0049B8  528F84     SUB W5, W4, [W15]
0049BA  360010     BRA LEU, .L107, .LSM332
980:                     ptr->v_adc_under_count = ptr->v_adc_max_oor + 10;
0049BC  90021E     MOV [W14+2], W4
0049BE  901224     MOV [W4+36], W4
0049C0  4202EA     ADD W4, #0xA, W5
0049C2  90021E     MOV [W14+2], W4
0049C4  981245     MOV W5, [W4+40]
981:                     return 1;
0049C6  B3C014     MOV.B #0x1, W4
0049C8  37000A     BRA .L108, .LSM333
982:                   }
983:                 } else if (ptr->v_adc_under_count >= 1) {
0049CA  90021E     MOV [W14+2], W4
0049CC  901244     MOV [W4+40], W4
0049CE  520FE0     SUB W4, #0x0, [W15]
0049D0  320005     BRA Z, .L107, .LSM332
984:                   ptr->v_adc_under_count--;
0049D2  90021E     MOV [W14+2], W4
0049D4  901244     MOV [W4+40], W4
0049D6  E90284     DEC W4, W5
0049D8  90021E     MOV [W14+2], W4
0049DA  981245     MOV W5, [W4+40]
985:                 }
986:                 return 0;
0049DC  EB4200     CLR.B W4
987:               }
0049DE  784004     MOV.B W4, W0
0049E0  FA8000     ULNK
0049E2  060000     RETURN
988:               
989:               
990:               unsigned char CheckOverCurrentFault(POWERSUPPLY* ptr) {
0049E4  FA0002     LNK #0x2
0049E6  780F00     MOV W0, [W14]
991:                 if (ptr->i_adc_reading > ptr->i_adc_over_rel) {
0049E8  78021E     MOV [W14], W4
0049EA  901AE4     MOV [W4+60], W5
0049EC  78021E     MOV [W14], W4
0049EE  902234     MOV [W4+70], W4
0049F0  528F84     SUB W5, W4, [W15]
0049F2  360012     BRA LEU, .L110, .LSM340
992:                   ptr->i_adc_over_count++;
0049F4  78021E     MOV [W14], W4
0049F6  902A14     MOV [W4+82], W4
0049F8  E80284     INC W4, W5
0049FA  78021E     MOV [W14], W4
0049FC  982A15     MOV W5, [W4+82]
993:                   if (ptr->i_adc_over_count > ptr->i_adc_max_oor) {
0049FE  78021E     MOV [W14], W4
004A00  902A94     MOV [W4+82], W5
004A02  78021E     MOV [W14], W4
004A04  902A04     MOV [W4+80], W4
004A06  528F84     SUB W5, W4, [W15]
004A08  360010     BRA LEU, .L111, .LSM342
994:                     ptr->i_adc_over_count = ptr->i_adc_max_oor + 10;
004A0A  78021E     MOV [W14], W4
004A0C  902A04     MOV [W4+80], W4
004A0E  4202EA     ADD W4, #0xA, W5
004A10  78021E     MOV [W14], W4
004A12  982A15     MOV W5, [W4+82]
995:                     return 1; 
004A14  B3C014     MOV.B #0x1, W4
004A16  37000A     BRA .L112, .LSM343
996:                   }
997:                 } else if (ptr->i_adc_over_count >= 1) {
004A18  78021E     MOV [W14], W4
004A1A  902A14     MOV [W4+82], W4
004A1C  520FE0     SUB W4, #0x0, [W15]
004A1E  320005     BRA Z, .L111, .LSM342
998:                   ptr->i_adc_over_count--;
004A20  78021E     MOV [W14], W4
004A22  902A14     MOV [W4+82], W4
004A24  E90284     DEC W4, W5
004A26  78021E     MOV [W14], W4
004A28  982A15     MOV W5, [W4+82]
999:                 }
1000:                return 0;
004A2A  EB4200     CLR.B W4
1001:              }
004A2C  784004     MOV.B W4, W0
004A2E  FA8000     ULNK
004A30  060000     RETURN
1002:              
1003:              unsigned char CheckUnderCurrentFault(POWERSUPPLY* ptr) {
004A32  FA0004     LNK #0x4
004A34  980710     MOV W0, [W14+2]
1004:                unsigned int mod_i_adc_reading;
1005:              
1006:                mod_i_adc_reading = ptr->i_adc_reading;
004A36  90021E     MOV [W14+2], W4
004A38  901AE4     MOV [W4+60], W5
004A3A  780F05     MOV W5, [W14]
1007:                if (mod_i_adc_reading < 0x0100) {
004A3C  200FF4     MOV #0xFF, W4
004A3E  78029E     MOV [W14], W5
004A40  528F84     SUB W5, W4, [W15]
004A42  3E0002     BRA GTU, .L114, .LSM348
1008:                  mod_i_adc_reading = 0x0100;  // DPARKER add parameter
004A44  201004     MOV #0x100, W4
004A46  780F04     MOV W4, [W14]
1009:                }
1010:                if (mod_i_adc_reading < ptr->i_adc_under_rel) {
004A48  90021E     MOV [W14+2], W4
004A4A  902244     MOV [W4+72], W4
004A4C  520F9E     SUB W4, [W14], [W15]
004A4E  360012     BRA LEU, .L115, .LSM353
1011:                  ptr->i_adc_under_count++;
004A50  90021E     MOV [W14+2], W4
004A52  902A24     MOV [W4+84], W4
004A54  E80284     INC W4, W5
004A56  90021E     MOV [W14+2], W4
004A58  982A25     MOV W5, [W4+84]
1012:                  if (ptr->i_adc_under_count > ptr->i_adc_max_oor) {
004A5A  90021E     MOV [W14+2], W4
004A5C  902AA4     MOV [W4+84], W5
004A5E  90021E     MOV [W14+2], W4
004A60  902A04     MOV [W4+80], W4
004A62  528F84     SUB W5, W4, [W15]
004A64  360010     BRA LEU, .L116, .LSM355
1013:                    ptr->i_adc_under_count = ptr->i_adc_max_oor + 10;
004A66  90021E     MOV [W14+2], W4
004A68  902A04     MOV [W4+80], W4
004A6A  4202EA     ADD W4, #0xA, W5
004A6C  90021E     MOV [W14+2], W4
004A6E  982A25     MOV W5, [W4+84]
1014:                    return 1;
004A70  B3C014     MOV.B #0x1, W4
004A72  37000A     BRA .L117, .LSM356
1015:                  }
1016:                } else if (ptr->i_adc_under_count >= 1) {
004A74  90021E     MOV [W14+2], W4
004A76  902A24     MOV [W4+84], W4
004A78  520FE0     SUB W4, #0x0, [W15]
004A7A  320005     BRA Z, .L116, .LSM355
1017:                  ptr->i_adc_under_count--;
004A7C  90021E     MOV [W14+2], W4
004A7E  902A24     MOV [W4+84], W4
004A80  E90284     DEC W4, W5
004A82  90021E     MOV [W14+2], W4
004A84  982A25     MOV W5, [W4+84]
1018:                }
1019:                return 0;
004A86  EB4200     CLR.B W4
1020:              }
004A88  784004     MOV.B W4, W0
004A8A  FA8000     ULNK
004A8C  060000     RETURN
1021:              
1022:              
1023:              
---  C:/Users/DPARKER/Documents/GitHub/A36760/eeprom.c  -------------------------------------------------
1:                 #include <xc.h>
2:                 #include <libpic30.h>
3:                 #include "EEPROM.h"
4:                 #include "ETM_CRC.h"
5:                 
6:                 
7:                 #if defined(__dsPIC30F6014A__)
8:                 //#define INTERNAL_EEPROM_SIZE_WORDS  2048
9:                 #define INTERNAL_EEPROM_SIZE_WORDS  1024
10:                #endif
11:                
12:                #if defined(__dsPIC30F6010A__)
13:                #define INTERNAL_EEPROM_SIZE_WORDS  2048
14:                #endif
15:                
16:                #ifndef INTERNAL_EEPROM_SIZE_WORDS
17:                #define INTERNAL_EEPROM_SIZE_WORDS 0
18:                #endif
19:                
20:                
21:                static unsigned long long alternate_page_data;
22:                
23:                typedef struct {
24:                  unsigned int read_internal_error;
25:                  unsigned int read_spi_error;
26:                  unsigned int read_i2c_error;
27:                  unsigned int write_internal_error;
28:                  unsigned int write_spi_error;
29:                  unsigned int write_i2c_error;
30:                  unsigned int page_read_count_internal;
31:                  unsigned int page_read_count_spi;
32:                  unsigned int page_read_count_i2c;
33:                  unsigned int page_write_count_internal;
34:                  unsigned int page_write_count_spi;
35:                  unsigned int page_write_count_i2c;
36:                  unsigned int crc_error;
37:                
38:                } TYPE_EEPROM_DEBUG_DATA;
39:                
40:                static TYPE_EEPROM_DEBUG_DATA eeprom_debug_data;
41:                
42:                
43:                unsigned int ETMEEPromPrivateReadSinglePage(unsigned int page_number, unsigned int *page_data);
44:                // This function is used by P1395_CAN_SLAVE
45:                
46:                static unsigned int ETMEEPromPrivateWriteSinglePage(unsigned int page_number, unsigned int *page_data);
47:                static unsigned int ETMEEPromPrivateWritePageInternal(unsigned int page_number, unsigned int *data);
48:                static unsigned int ETMEEPromPrivateReadPageInternal(unsigned int page_number, unsigned int *data);
49:                
50:                
51:                unsigned int ETMEEPromReadPage(unsigned int page_number, unsigned int *page_data) {
004A8E  FA0004     LNK #0x4
004A90  780F00     MOV W0, [W14]
004A92  980711     MOV W1, [W14+2]
52:                  /*
53:                    Data will be returned in *page_data
54:                    If the function return is 0xFFFF the data is valid
55:                    If the function return is 0, the data is NOT valid
56:                  */
57:                
58:                  page_number = page_number * 2;
004A94  78021E     MOV [W14], W4
004A96  420204     ADD W4, W4, W4
004A98  780F04     MOV W4, [W14]
59:                  if (ETMEEPromPrivateReadSinglePage(page_number, &page_data[0])) {
004A9A  90009E     MOV [W14+2], W1
004A9C  78001E     MOV [W14], W0
004A9E  07010D     RCALL ETMEEPromPrivateReadSinglePage
004AA0  780200     MOV W0, W4
004AA2  520FE0     SUB W4, #0x0, [W15]
004AA4  320002     BRA Z, .L2, .LSM4
60:                    return 0xFFFF;
004AA6  EB8200     SETM W4
004AA8  37000A     BRA .L3, .LSM7
61:                  }
62:                  
63:                  if (ETMEEPromPrivateReadSinglePage(page_number + 1, &page_data[0])) {
004AAA  E8021E     INC [W14], W4
004AAC  90009E     MOV [W14+2], W1
004AAE  780004     MOV W4, W0
004AB0  070104     RCALL ETMEEPromPrivateReadSinglePage
004AB2  780200     MOV W0, W4
004AB4  520FE0     SUB W4, #0x0, [W15]
004AB6  320002     BRA Z, .L4, .LSM6
64:                    return 0xFFFF;
004AB8  EB8200     SETM W4
004ABA  370001     BRA .L3, .LSM7
65:                  }
66:                
67:                  return 0;
004ABC  EB0200     CLR W4
68:                }
004ABE  780004     MOV W4, W0
004AC0  FA8000     ULNK
004AC2  060000     RETURN
69:                
70:                
71:                unsigned int ETMEEPromWritePage(unsigned int page_number, unsigned int *page_data) {
004AC4  FA0006     LNK #0x6
004AC6  980710     MOV W0, [W14+2]
004AC8  980721     MOV W1, [W14+4]
72:                  /* 
73:                     Will return 0xFFFF if there were no write errors
74:                     Will return 0 if there was a write error to one (or both) registers
75:                  */
76:                  unsigned int error_check = 0xFFFF;
004ACA  EB8200     SETM W4
004ACC  780F04     MOV W4, [W14]
77:                
78:                  page_number = page_number * 2;
004ACE  90021E     MOV [W14+2], W4
004AD0  420204     ADD W4, W4, W4
004AD2  980714     MOV W4, [W14+2]
79:                  
80:                  error_check &= ETMEEPromPrivateWriteSinglePage(page_number, &page_data[0]);
004AD4  9000AE     MOV [W14+4], W1
004AD6  90001E     MOV [W14+2], W0
004AD8  070114     RCALL _ETMEEPromPrivateWriteSinglePage, .LFE5, .LFB6, .LSM69
004ADA  780200     MOV W0, W4
004ADC  620F1E     AND W4, [W14], [W14]
81:                  
82:                  error_check &= ETMEEPromPrivateWriteSinglePage(page_number+1, &page_data[0]);
004ADE  90021E     MOV [W14+2], W4
004AE0  E80204     INC W4, W4
004AE2  9000AE     MOV [W14+4], W1
004AE4  780004     MOV W4, W0
004AE6  07010D     RCALL _ETMEEPromPrivateWriteSinglePage, .LFE5, .LFB6, .LSM69
004AE8  780200     MOV W0, W4
004AEA  620F1E     AND W4, [W14], [W14]
83:                  
84:                  return error_check;
004AEC  78021E     MOV [W14], W4
85:                }
004AEE  780004     MOV W4, W0
004AF0  FA8000     ULNK
004AF2  060000     RETURN
86:                
87:                
88:                unsigned int ETMEEPromWritePageFast(unsigned int page_number, unsigned int *page_data) {
004AF4  FA000E     LNK #0xE
004AF6  980750     MOV W0, [W14+10]
004AF8  980761     MOV W1, [W14+12]
89:                  unsigned long long alternate_test = 0;
004AFA  B82260     MUL.UU W4, #0, W4
004AFC  B83360     MUL.UU W6, #0, W6
004AFE  980714     MOV W4, [W14+2]
004B00  980725     MOV W5, [W14+4]
004B02  980736     MOV W6, [W14+6]
004B04  980747     MOV W7, [W14+8]
90:                  unsigned int actual_page;
91:                  /*
92:                    Alternate writing between pages
93:                    This should be used for something like pulse counter or off time where it doesn't cause a problem if we miss a single update
94:                    Will return 0xFFFF if there were no write errors
95:                    Will return 0 if there was a write error
96:                  */
97:                  
98:                  actual_page = page_number * 2;
004B06  90025E     MOV [W14+10], W4
004B08  420204     ADD W4, W4, W4
004B0A  780F04     MOV W4, [W14]
99:                
100:                 if (page_number <= 63) {
004B0C  9002DE     MOV [W14+10], W5
004B0E  2003F4     MOV #0x3F, W4
004B10  528F84     SUB W5, W4, [W15]
004B12  3E004F     BRA GTU, .L7, .LSM26
101:                   alternate_test = alternate_page_data >> page_number;
004B14  217744     MOV #0x1774, W4
004B16  BE0354     MOV.D [++W4], W6
004B18  BE0244     MOV.D [--W4], W4
004B1A  90005E     MOV [W14+10], W0
004B1C  780080     MOV W0, W1
004B1E  E90081     DEC W1, W1
004B20  330005     BRA N, .LE104
004B22  D10387     LSR W7, W7
004B24  D38306     RRC W6, W6
004B26  D38285     RRC W5, W5
004B28  D38204     RRC W4, W4
004B2A  37FFF9     BRA .LB104
004B2C  980714     MOV W4, [W14+2]
004B2E  980725     MOV W5, [W14+4]
004B30  980736     MOV W6, [W14+6]
004B32  980747     MOV W7, [W14+8]
102:                   alternate_test &= 1;
004B34  90001E     MOV [W14+2], W0
004B36  9000AE     MOV [W14+4], W1
004B38  90013E     MOV [W14+6], W2
004B3A  9001CE     MOV [W14+8], W3
004B3C  200014     MOV #0x1, W4
004B3E  200005     MOV #0x0, W5
004B40  B83360     MUL.UU W6, #0, W6
004B42  620200     AND W4, W0, W4
004B44  628281     AND W5, W1, W5
004B46  630302     AND W6, W2, W6
004B48  638383     AND W7, W3, W7
004B4A  980714     MOV W4, [W14+2]
004B4C  980725     MOV W5, [W14+4]
004B4E  980736     MOV W6, [W14+6]
004B50  980747     MOV W7, [W14+8]
103:               
104:                   if (alternate_test) {
004B52  90021E     MOV [W14+2], W4
004B54  9002AE     MOV [W14+4], W5
004B56  90033E     MOV [W14+6], W6
004B58  9003CE     MOV [W14+8], W7
004B5A  520FE0     SUB W4, #0x0, [W15]
004B5C  5A8FE0     SUBB W5, #0x0, [W15]
004B5E  5B0FE0     SUBB W6, #0x0, [W15]
004B60  5B8FE0     SUBB W7, #0x0, [W15]
004B62  320001     BRA Z, .L8, .LSM23
105:                     // use the alternate page register
106:                     actual_page++;
004B64  E80F1E     INC [W14], [W14]
107:                   }
108:                   
109:                   alternate_test = 1;
004B66  200014     MOV #0x1, W4
004B68  200005     MOV #0x0, W5
004B6A  B83360     MUL.UU W6, #0, W6
004B6C  980714     MOV W4, [W14+2]
004B6E  980725     MOV W5, [W14+4]
004B70  980736     MOV W6, [W14+6]
004B72  980747     MOV W7, [W14+8]
110:                   alternate_test <<= page_number;
004B74  90005E     MOV [W14+10], W0
004B76  90021E     MOV [W14+2], W4
004B78  9002AE     MOV [W14+4], W5
004B7A  90033E     MOV [W14+6], W6
004B7C  9003CE     MOV [W14+8], W7
004B7E  780080     MOV W0, W1
004B80  E90081     DEC W1, W1
004B82  330005     BRA N, .LE122
004B84  D00204     SL W4, W4
004B86  D28285     RLC W5, W5
004B88  D28306     RLC W6, W6
004B8A  D28387     RLC W7, W7
004B8C  37FFF9     BRA .LB122
004B8E  980714     MOV W4, [W14+2]
004B90  980725     MOV W5, [W14+4]
004B92  980736     MOV W6, [W14+6]
004B94  980747     MOV W7, [W14+8]
111:                   alternate_page_data ^= alternate_test;
004B96  217744     MOV #0x1774, W4
004B98  BE0034     MOV.D [W4++], W0
004B9A  BE0124     MOV.D [W4--], W2
004B9C  90021E     MOV [W14+2], W4
004B9E  9002AE     MOV [W14+4], W5
004BA0  90033E     MOV [W14+6], W6
004BA2  9003CE     MOV [W14+8], W7
004BA4  6A0200     XOR W4, W0, W4
004BA6  6A8281     XOR W5, W1, W5
004BA8  6B0302     XOR W6, W2, W6
004BAA  6B8383     XOR W7, W3, W7
004BAC  217740     MOV #0x1774, W0
004BAE  BE9804     MOV.D W4, [W0++]
004BB0  BE9006     MOV.D W6, [W0--]
112:                 } 
113:                 
114:                 return (ETMEEPromPrivateWriteSinglePage(actual_page, &page_data[0]));
004BB2  9000EE     MOV [W14+12], W1
004BB4  78001E     MOV [W14], W0
004BB6  0700A5     RCALL _ETMEEPromPrivateWriteSinglePage, .LFE5, .LFB6, .LSM69
004BB8  780200     MOV W0, W4
115:               }
004BBA  780004     MOV W4, W0
004BBC  FA8000     ULNK
004BBE  060000     RETURN
116:               
117:               
118:               unsigned int ETMEEPromWritePageWithConfirmation(unsigned int page_number, unsigned int *page_data) {
004BC0  FA0026     LNK #0x26
004BC2  981710     MOV W0, [W14+34]
004BC4  981721     MOV W1, [W14+36]
119:                 /*
120:                   Writes to the A and B pages and confirms the values after writing
121:                   This could take a long time to execute
122:                   Will return 0xFFFF if the page data is confirmed in both registers
123:                   Will return 0 if there were any errors (write/read/crc/confirmation)
124:                 */
125:               
126:                 unsigned int n;
127:                 unsigned int page_read[16];
128:                 page_number = page_number * 2;
004BC6  90121E     MOV [W14+34], W4
004BC8  420204     ADD W4, W4, W4
004BCA  981714     MOV W4, [W14+34]
129:                 
130:                 // Write and check page A, abort on error
131:                 if (ETMEEPromPrivateWriteSinglePage(page_number, &page_data[0]) == 0) {
004BCC  9010AE     MOV [W14+36], W1
004BCE  90101E     MOV [W14+34], W0
004BD0  070098     RCALL _ETMEEPromPrivateWriteSinglePage, .LFE5, .LFB6, .LSM69
004BD2  780200     MOV W0, W4
004BD4  520FE0     SUB W4, #0x0, [W15]
004BD6  3A0002     BRA NZ, .L10, .LSM32
132:                   return 0;
004BD8  EB0200     CLR W4
004BDA  370047     BRA .L11, .LSM47
133:                 }
134:                 
135:                 if (ETMEEPromPrivateReadSinglePage(page_number, &page_read[0]) == 0) {
004BDC  E8820E     INC2 W14, W4
004BDE  780084     MOV W4, W1
004BE0  90101E     MOV [W14+34], W0
004BE2  07006B     RCALL ETMEEPromPrivateReadSinglePage
004BE4  780200     MOV W0, W4
004BE6  520FE0     SUB W4, #0x0, [W15]
004BE8  3A0002     BRA NZ, .L12, .LSM34
136:                   return 0;
004BEA  EB0200     CLR W4
004BEC  37003E     BRA .L11, .LSM47
137:                 }
138:                 
139:               
140:                 for (n=0; n<16; n++) {
004BEE  EB0200     CLR W4
004BF0  780F04     MOV W4, [W14]
004BF2  37000E     BRA .L13
004C0E  E80F1E     INC [W14], [W14]
004C10  78021E     MOV [W14], W4
004C12  520FEF     SUB W4, #0xF, [W15]
004C14  36FFEF     BRA LEU, .L15, .LSM35
141:                   if (page_data[n] != page_read[n]) {
004BF4  78021E     MOV [W14], W4
004BF6  420204     ADD W4, W4, W4
004BF8  9012AE     MOV [W14+36], W5
004BFA  428204     ADD W5, W4, W4
004BFC  780294     MOV [W4], W5
004BFE  78021E     MOV [W14], W4
004C00  420204     ADD W4, W4, W4
004C02  470204     ADD W14, W4, W4
004C04  900214     MOV [W4+2], W4
004C06  528F84     SUB W5, W4, [W15]
004C08  320002     BRA Z, .L14, .LSM37
142:                     return 0;
004C0A  EB0200     CLR W4
004C0C  37002E     BRA .L11, .LSM47
143:                   }
144:                 }
145:                 
146:                 // Repeat for B register
147:                 if (ETMEEPromPrivateWriteSinglePage(page_number + 1, &page_data[0]) == 0) {
004C16  90121E     MOV [W14+34], W4
004C18  E80204     INC W4, W4
004C1A  9010AE     MOV [W14+36], W1
004C1C  780004     MOV W4, W0
004C1E  070071     RCALL _ETMEEPromPrivateWriteSinglePage, .LFE5, .LFB6, .LSM69
004C20  780200     MOV W0, W4
004C22  520FE0     SUB W4, #0x0, [W15]
004C24  3A0002     BRA NZ, .L16, .LSM40
148:                   return 0;
004C26  EB0200     CLR W4
004C28  370020     BRA .L11, .LSM47
149:                 }
150:                 
151:                 if (ETMEEPromPrivateReadSinglePage(page_number + 1, &page_read[0]) == 0) {
004C2A  90121E     MOV [W14+34], W4
004C2C  E80204     INC W4, W4
004C2E  E8828E     INC2 W14, W5
004C30  780085     MOV W5, W1
004C32  780004     MOV W4, W0
004C34  070042     RCALL ETMEEPromPrivateReadSinglePage
004C36  780200     MOV W0, W4
004C38  520FE0     SUB W4, #0x0, [W15]
004C3A  3A0002     BRA NZ, .L17, .LSM42
152:                   return 0;
004C3C  EB0200     CLR W4
004C3E  370015     BRA .L11, .LSM47
153:                 }
154:               
155:               
156:                 for (n = 0; n<16; n++) {
004C40  EB0200     CLR W4
004C42  780F04     MOV W4, [W14]
004C44  37000E     BRA .L18
004C60  E80F1E     INC [W14], [W14]
004C62  78021E     MOV [W14], W4
004C64  520FEF     SUB W4, #0xF, [W15]
004C66  36FFEF     BRA LEU, .L20, .LSM43
157:                   if (page_data[n] != page_read[n]) {
004C46  78021E     MOV [W14], W4
004C48  420204     ADD W4, W4, W4
004C4A  9012AE     MOV [W14+36], W5
004C4C  428204     ADD W5, W4, W4
004C4E  780294     MOV [W4], W5
004C50  78021E     MOV [W14], W4
004C52  420204     ADD W4, W4, W4
004C54  470204     ADD W14, W4, W4
004C56  900214     MOV [W4+2], W4
004C58  528F84     SUB W5, W4, [W15]
004C5A  320002     BRA Z, .L19, .LSM45
158:                     return 0;
004C5C  EB0200     CLR W4
004C5E  370005     BRA .L11, .LSM47
159:                   }
160:                 }
161:               
162:               
163:                 return 0xFFFF; // The write operation was sucessful
004C68  EB8200     SETM W4
164:               }
004C6A  780004     MOV W4, W0
004C6C  FA8000     ULNK
004C6E  060000     RETURN
165:               
166:               
167:               unsigned int ETMEEPromWriteWordWithConfirmation(unsigned int register_location, unsigned int data) {
004C70  FA0026     LNK #0x26
004C72  981710     MOV W0, [W14+34]
004C74  981721     MOV W1, [W14+36]
168:                 unsigned int page_read[16];
169:                 unsigned int page_number;
170:               
171:                 page_number = (register_location >> 4);
004C76  90121E     MOV [W14+34], W4
004C78  DE2244     LSR W4, #4, W4
004C7A  780F04     MOV W4, [W14]
172:                 register_location &= 0x0F;
004C7C  90121E     MOV [W14+34], W4
004C7E  62026F     AND W4, #0xF, W4
004C80  981714     MOV W4, [W14+34]
173:                 
174:                 // Load the existing contents of the register
175:                 if (ETMEEPromReadPage(page_number, &page_read[0]) == 0) {
004C82  E8820E     INC2 W14, W4
004C84  780084     MOV W4, W1
004C86  78001E     MOV [W14], W0
004C88  07FF02     RCALL ETMEEPromReadPage
004C8A  780200     MOV W0, W4
004C8C  520FE0     SUB W4, #0x0, [W15]
004C8E  3A0002     BRA NZ, .L22, .LSM53
176:                   return 0;
004C90  EB0200     CLR W4
004C92  370010     BRA .L23, .LSM57
177:                 }
178:                 
179:                 // Modify the value being changed
180:                 *(&page_read[0] + register_location) = data;
004C94  90121E     MOV [W14+34], W4
004C96  420204     ADD W4, W4, W4
004C98  E8828E     INC2 W14, W5
004C9A  428204     ADD W5, W4, W4
004C9C  9012AE     MOV [W14+36], W5
004C9E  780A05     MOV W5, [W4]
181:                 
182:                 // Write the data back to EEProm
183:                 if (ETMEEPromWritePageWithConfirmation(page_number, &page_read[0])) {
004CA0  E8820E     INC2 W14, W4
004CA2  780084     MOV W4, W1
004CA4  78001E     MOV [W14], W0
004CA6  07FF8C     RCALL ETMEEPromWritePageWithConfirmation
004CA8  780200     MOV W0, W4
004CAA  520FE0     SUB W4, #0x0, [W15]
004CAC  320002     BRA Z, .L24, .LSM56
184:                   return 0xFFFF;
004CAE  EB8200     SETM W4
004CB0  370001     BRA .L23, .LSM57
185:                 }
186:                 
187:                 return 0;
004CB2  EB0200     CLR W4
188:               }
004CB4  780004     MOV W4, W0
004CB6  FA8000     ULNK
004CB8  060000     RETURN
189:               
190:               
191:               unsigned int ETMEEPromPrivateReadSinglePage(unsigned int page_number, unsigned int *page_data) {
004CBA  FA0006     LNK #0x6
004CBC  980710     MOV W0, [W14+2]
004CBE  980721     MOV W1, [W14+4]
192:                 unsigned int crc_check;
193:               
194:                 eeprom_debug_data.page_read_count_internal++;
004CC0  80BC44     MOV 0x1788, W4
004CC2  E80204     INC W4, W4
004CC4  88BC44     MOV W4, 0x1788
195:                 if (ETMEEPromPrivateReadPageInternal(page_number, &page_data[0]) == 0) {
004CC6  9000AE     MOV [W14+4], W1
004CC8  90001E     MOV [W14+2], W0
004CCA  07007A     RCALL _ETMEEPromPrivateReadPageInternal, .LFE7, .LFB8, .LSM95
004CCC  780200     MOV W0, W4
004CCE  520FE0     SUB W4, #0x0, [W15]
004CD0  3A0005     BRA NZ, .L26, .LSM63
196:                   eeprom_debug_data.read_internal_error++;
004CD2  80BBE4     MOV eeprom_debug_data, W4
004CD4  E80204     INC W4, W4
004CD6  88BBE4     MOV W4, eeprom_debug_data
197:                   return 0;
004CD8  EB0200     CLR W4
004CDA  370010     BRA .L27, .LSM68
198:                 } 
199:                 
200:                 crc_check = ETMCRCModbus(&page_data[0], 30);
004CDC  2001E1     MOV #0x1E, W1
004CDE  90002E     MOV [W14+4], W0
004CE0  07062C     RCALL ETMCRCModbus
004CE2  780200     MOV W0, W4
004CE4  780F04     MOV W4, [W14]
201:                 if (crc_check != page_data[15]) {
004CE6  90022E     MOV [W14+4], W4
004CE8  42027E     ADD W4, #0x1E, W4
004CEA  780214     MOV [W4], W4
004CEC  520F9E     SUB W4, [W14], [W15]
004CEE  320005     BRA Z, .L28, .LSM67
202:                   eeprom_debug_data.crc_error++;
004CF0  80BCA4     MOV 0x1794, W4
004CF2  E80204     INC W4, W4
004CF4  88BCA4     MOV W4, 0x1794
203:                   return 0;
004CF6  EB0200     CLR W4
004CF8  370001     BRA .L27, .LSM68
204:                 }
205:                 return 0xFFFF;
004CFA  EB8200     SETM W4
206:               }
004CFC  780004     MOV W4, W0
004CFE  FA8000     ULNK
004D00  060000     RETURN
207:               
208:               
209:               unsigned int ETMEEPromPrivateWriteSinglePage(unsigned int page_number, unsigned int *page_data) {
004D02  FA0006     LNK #0x6
004D04  980710     MOV W0, [W14+2]
004D06  980721     MOV W1, [W14+4]
210:                 unsigned int crc;
211:                 crc = ETMCRCModbus(&page_data[0], 30);
004D08  2001E1     MOV #0x1E, W1
004D0A  90002E     MOV [W14+4], W0
004D0C  070616     RCALL ETMCRCModbus
004D0E  780200     MOV W0, W4
004D10  780F04     MOV W4, [W14]
212:                 page_data[15] = crc;
004D12  90022E     MOV [W14+4], W4
004D14  42027E     ADD W4, #0x1E, W4
004D16  780A1E     MOV [W14], [W4]
213:               
214:                 
215:                 eeprom_debug_data.page_write_count_internal++;
004D18  80BC74     MOV .LSM666, W4
004D1A  E80204     INC W4, W4
004D1C  88BC74     MOV W4, .LSM666
216:                 if (ETMEEPromPrivateWritePageInternal(page_number, &page_data[0])) {
004D1E  9000AE     MOV [W14+4], W1
004D20  90001E     MOV [W14+2], W0
004D22  07000C     RCALL _ETMEEPromPrivateWritePageInternal, .LFE6, .LFB7, .LSM78
004D24  780200     MOV W0, W4
004D26  520FE0     SUB W4, #0x0, [W15]
004D28  320002     BRA Z, .L30, .LSM75
217:                   return 0xFFFF;
004D2A  EB8200     SETM W4
004D2C  370004     BRA .L31, .LSM77
218:                 } else {
219:                   eeprom_debug_data.write_internal_error++;
004D2E  80BC14     MOV .LSM664, W4
004D30  E80204     INC W4, W4
004D32  88BC14     MOV W4, .LSM664
220:                   return 0;
004D34  EB0200     CLR W4
221:                 } 
222:                 
223:                 return 0;
224:               }
004D36  780004     MOV W4, W0
004D38  FA8000     ULNK
004D3A  060000     RETURN
225:               
226:               
227:               
228:               
229:               #if INTERNAL_EEPROM_SIZE_WORDS == 0
230:               unsigned int ETMEEPromPrivateWritePageInternal(unsigned int page_number, unsigned int *data) {
231:                 return 0;
232:               }
233:               
234:               unsigned int ETMEEPromPrivateReadPageInternal(unsigned int page_number, unsigned int *data) {
235:                 return 0;
236:               }
237:               
238:               #else
239:               
240:               __eds__ unsigned int internal_eeprom[INTERNAL_EEPROM_SIZE_WORDS] __attribute__ ((space(eedata))) = {};
241:               
242:               unsigned int ETMEEPromPrivateWritePageInternal(unsigned int page_number, unsigned int *data) {
004D3C  FA002C     LNK #0x2C
004D3E  981740     MOV W0, [W14+40]
004D40  981751     MOV W1, [W14+42]
243:                 _prog_addressT write_address;
244:                 unsigned int n = 0;
004D42  EB0200     CLR W4
004D44  780F04     MOV W4, [W14]
245:                 int data_ram[16];
246:                 unsigned int words_to_write;
247:               
248:                 // DPARKER, remove the data_ram variable and write directly with data pointer
249:               
250:                 words_to_write = 16;
004D46  200104     MOV #0x10, W4
004D48  980714     MOV W4, [W14+2]
251:                 
252:                 while (n < words_to_write) {
004D4A  37000C     BRA .L33, .LSM84
004D64  90021E     MOV [W14+2], W4
004D66  78029E     MOV [W14], W5
004D68  528F84     SUB W5, W4, [W15]
004D6A  39FFF0     BRA NC, .L34, .LSM82
253:                   data_ram[n] = (int)data[n];
004D4C  78021E     MOV [W14], W4
004D4E  420204     ADD W4, W4, W4
004D50  9012DE     MOV [W14+42], W5
004D52  428204     ADD W5, W4, W4
004D54  780214     MOV [W4], W4
004D56  780284     MOV W4, W5
004D58  78021E     MOV [W14], W4
004D5A  420204     ADD W4, W4, W4
004D5C  470204     ADD W14, W4, W4
004D5E  420268     ADD W4, #0x8, W4
004D60  780A05     MOV W5, [W4]
254:                   n++;
004D62  E80F1E     INC [W14], [W14]
255:                 }
256:                 
257:                 if (page_number > (INTERNAL_EEPROM_SIZE_WORDS >> 4)) {
004D6C  9012CE     MOV [W14+40], W5
004D6E  200404     MOV #0x40, W4
004D70  528F84     SUB W5, W4, [W15]
004D72  360002     BRA LEU, .L35, .LSM87
258:                   return 0;
004D74  EB0200     CLR W4
004D76  370021     BRA .L36, .LSM94
259:                 }
260:                   
261:                 write_address = __builtin_tbladdress(internal_eeprom);
004D78  2F0004     MOV #0xF000, W4
004D7A  2007F5     MOV #0x7F, W5
004D7C  980724     MOV W4, [W14+4]
004D7E  980735     MOV W5, [W14+6]
262:                 write_address += page_number << 5;
004D80  90124E     MOV [W14+40], W4
004D82  DD2245     SL W4, #5, W4
004D84  200005     MOV #0x0, W5
004D86  90032E     MOV [W14+4], W6
004D88  9003BE     MOV [W14+6], W7
004D8A  420206     ADD W4, W6, W4
004D8C  4A8287     ADDC W5, W7, W5
004D8E  980724     MOV W4, [W14+4]
004D90  980735     MOV W5, [W14+6]
263:                 _wait_eedata();
004D92  803B05     MOV NVMCON, W5
004D94  280004     MOV #0x8000, W4
004D96  628204     AND W5, W4, W4
004D98  520FE0     SUB W4, #0x0, [W15]
004D9A  3AFFFB     BRA NZ, .L37, .LSM89
264:                 _erase_eedata(write_address, _EE_ROW);
004D9C  200202     MOV #0x20, W2
004D9E  90002E     MOV [W14+4], W0
004DA0  9000BE     MOV [W14+6], W1
004DA2  07DA3A     RCALL __eedata_helper1
265:                 _wait_eedata();
004DA4  803B05     MOV NVMCON, W5
004DA6  280004     MOV #0x8000, W4
004DA8  628204     AND W5, W4, W4
004DAA  520FE0     SUB W4, #0x0, [W15]
004DAC  3AFFFB     BRA NZ, .L38, .LSM91
266:                 _write_eedata_row(write_address, data_ram);
004DAE  470268     ADD W14, #0x8, W4
004DB0  780104     MOV W4, W2
004DB2  90002E     MOV [W14+4], W0
004DB4  9000BE     MOV [W14+6], W1
004DB6  07DA4F     RCALL __eedata_helper4
267:                 
268:                 return 0xFFFF;
004DB8  EB8200     SETM W4
269:               }
004DBA  780004     MOV W4, W0
004DBC  FA8000     ULNK
004DBE  060000     RETURN
270:               
271:               
272:               unsigned int ETMEEPromPrivateReadPageInternal(unsigned int page_number, unsigned int *data) {
004DC0  FA000A     LNK #0xA
004DC2  980730     MOV W0, [W14+6]
004DC4  980741     MOV W1, [W14+8]
273:                 unsigned int starting_register;
274:                 unsigned int n;
275:                 unsigned int words_to_read;
276:               
277:                 words_to_read = 16;
004DC6  200106     MOV #0x10, W6
004DC8  980716     MOV W6, [W14+2]
278:                 starting_register = page_number*16;
004DCA  90033E     MOV [W14+6], W6
004DCC  DD3344     SL W6, #4, W6
004DCE  980726     MOV W6, [W14+4]
279:                 _wait_eedata();
004DD0  803B07     MOV NVMCON, W7
004DD2  280006     MOV #0x8000, W6
004DD4  638306     AND W7, W6, W6
004DD6  530FE0     SUB W6, #0x0, [W15]
004DD8  3AFFFB     BRA NZ, .L40, .LSM98
280:                
281:                 if (page_number > (INTERNAL_EEPROM_SIZE_WORDS >> 4)) {
004DDA  9003BE     MOV [W14+6], W7
004DDC  200406     MOV #0x40, W6
004DDE  538F86     SUB W7, W6, [W15]
004DE0  360002     BRA LEU, .L41, .LSM101
282:                   return 0;
004DE2  EB0200     CLR W4
004DE4  370023     BRA .L42, .LSM105
283:                 }
284:                  
285:                 for (n = 0; n < words_to_read ; n++) {
004DE6  EB0300     CLR W6
004DE8  780F06     MOV W6, [W14]
004DEA  37001B     BRA .L43
004E20  E80F1E     INC [W14], [W14]
004E22  90031E     MOV [W14+2], W6
004E24  78039E     MOV [W14], W7
004E26  538F86     SUB W7, W6, [W15]
004E28  39FFE1     BRA NC, .L44, .LSM102
286:                   data[n] = internal_eeprom[starting_register + n];
004DEC  78031E     MOV [W14], W6
004DEE  430306     ADD W6, W6, W6
004DF0  9003CE     MOV [W14+8], W7
004DF2  438006     ADD W7, W6, W0
004DF4  90032E     MOV [W14+4], W6
004DF6  43031E     ADD W6, [W14], W6
004DF8  430306     ADD W6, W6, W6
004DFA  B93361     MUL.SU W6, #1, W6
004DFC  2F0004     MOV #0xF000, W4
004DFE  200FF5     MOV #0xFF, W5
004E00  D00086     SL W6, W1
004E02  D00104     SL W4, W2
004E04  408302     ADD W1, W2, W6
004E06  A82042     BSET SR, #1
004E08  4B8385     ADDC W7, W5, W7
004E0A  A90042     BCLR SR, #0
004E0C  AE2042     BTSS SR, #1
004E0E  A80042     BSET SR, #0
004E10  D38306     RRC W6, W6
004E12  8001A1     MOV PSVPAG, W1
004E14  780107     MOV W7, W2
004E16  8801A2     MOV W2, PSVPAG
004E18  780306     MOV W6, W6
004E1A  780316     MOV [W6], W6
004E1C  8801A1     MOV W1, PSVPAG
004E1E  780806     MOV W6, [W0]
287:                 }
288:                 
289:                 return 0xFFFF;
004E2A  EB8200     SETM W4
290:               }
004E2C  780004     MOV W4, W0
004E2E  FA8000     ULNK
004E30  060000     RETURN
291:               
292:               #endif
293:               
294:               
295:               unsigned int ETMEEPromReturnDebugData(unsigned int debug_data_index) {
004E32  FA0004     LNK #0x4
004E34  980710     MOV W0, [W14+2]
296:                 unsigned int error_return;
297:                 switch (debug_data_index) {
004E36  90021E     MOV [W14+2], W4
004E38  200005     MOV #0x0, W5
004E3A  2000C6     MOV #0xC, W6
004E3C  200007     MOV #0x0, W7
004E3E  520F86     SUB W4, W6, [W15]
004E40  5A8F87     SUBB W5, W7, [W15]
004E42  3E0035     BRA GTU, .L46, .LSM134
004E44  016004     BRA W4
004E46  37000F     BRA .L47, .LSM110
004E48  37000B     BRA .L48, .LSM108
004E4A  370013     BRA .L49, .LSM114
004E4C  37000F     BRA .L50, .LSM112
004E4E  370023     BRA .L51, .LSM126
004E50  37001F     BRA .L52, .LSM124
004E52  370027     BRA .L53, .LSM130
004E54  370023     BRA .L54, .LSM128
004E56  370013     BRA .L55, .LSM118
004E58  37000F     BRA .L56, .LSM116
004E5A  370017     BRA .L57, .LSM122
004E5C  370013     BRA .L58, .LSM120
004E5E  370024     BRA .L59, .LSM132
298:                   
299:                 case ETM_EEPROM_DEBUG_DATA_READ_INTERNAL_ERROR:
300:                   error_return = eeprom_debug_data.read_internal_error;
004E60  80BBE4     MOV eeprom_debug_data, W4
004E62  780F04     MOV W4, [W14]
301:                   break;
004E64  370024     BRA .L46, .LSM134
302:               
303:                 case ETM_EEPROM_DEBUG_DATA_READ_INTERNAL_COUNT:
304:                   error_return = eeprom_debug_data.page_read_count_internal;
004E66  80BC44     MOV 0x1788, W4
004E68  780F04     MOV W4, [W14]
305:                   break;
004E6A  370021     BRA .L46, .LSM134
306:               
307:                 case ETM_EEPROM_DEBUG_DATA_WRITE_INTERNAL_ERROR:
308:                   error_return = eeprom_debug_data.write_internal_error;
004E6C  80BC14     MOV .LSM664, W4
004E6E  780F04     MOV W4, [W14]
309:                   break;
004E70  37001E     BRA .L46, .LSM134
310:               
311:                 case ETM_EEPROM_DEBUG_DATA_WRITE_INTERNAL_COUNT:
312:                   error_return = eeprom_debug_data.page_write_count_internal;
004E72  80BC74     MOV .LSM666, W4
004E74  780F04     MOV W4, [W14]
313:                   break;
004E76  37001B     BRA .L46, .LSM134
314:               
315:                 case ETM_EEPROM_DEBUG_DATA_READ_SPI_ERROR:
316:                   error_return = eeprom_debug_data.read_spi_error;
004E78  80BBF4     MOV .LSM662, W4
004E7A  780F04     MOV W4, [W14]
317:                   break;
004E7C  370018     BRA .L46, .LSM134
318:               
319:                 case ETM_EEPROM_DEBUG_DATA_READ_SPI_COUNT:
320:                   error_return = eeprom_debug_data.page_read_count_spi;
004E7E  80BC54     MOV 0x178A, W4
004E80  780F04     MOV W4, [W14]
321:                   break;
004E82  370015     BRA .L46, .LSM134
322:               
323:                 case ETM_EEPROM_DEBUG_DATA_WRITE_SPI_ERROR:
324:                   error_return = eeprom_debug_data.write_spi_error;
004E84  80BC24     MOV 0x1784, W4
004E86  780F04     MOV W4, [W14]
325:                   break;
004E88  370012     BRA .L46, .LSM134
326:               
327:                 case ETM_EEPROM_DEBUG_DATA_WRITE_SPI_COUNT:
328:                   error_return = eeprom_debug_data.page_write_count_spi;
004E8A  80BC84     MOV .LSM667, W4
004E8C  780F04     MOV W4, [W14]
329:                   break;
004E8E  37000F     BRA .L46, .LSM134
330:               
331:                 case ETM_EEPROM_DEBUG_DATA_READ_I2C_ERROR:
332:                   error_return = eeprom_debug_data.read_i2c_error;
004E90  80BC04     MOV .LSM663, W4
004E92  780F04     MOV W4, [W14]
333:                   break;
004E94  37000C     BRA .L46, .LSM134
334:               
335:                 case ETM_EEPROM_DEBUG_DATA_READ_I2C_COUNT:
336:                   error_return = eeprom_debug_data.page_read_count_i2c;
004E96  80BC64     MOV .LSM665, W4
004E98  780F04     MOV W4, [W14]
337:                   break;
004E9A  370009     BRA .L46, .LSM134
338:               
339:                 case ETM_EEPROM_DEBUG_DATA_WRITE_I2C_ERROR:
340:                   error_return = eeprom_debug_data.write_i2c_error;
004E9C  80BC34     MOV 0x1786, W4
004E9E  780F04     MOV W4, [W14]
341:                   break;
004EA0  370006     BRA .L46, .LSM134
342:               
343:                 case ETM_EEPROM_DEBUG_DATA_WRITE_I2C_COUNT:
344:                   error_return = eeprom_debug_data.page_write_count_i2c;
004EA2  80BC94     MOV .LSM668, W4
004EA4  780F04     MOV W4, [W14]
345:                   break;
004EA6  370003     BRA .L46, .LSM134
346:               
347:                 case ETM_EEPROM_DEBUG_DATA_CRC_ERROR:
348:                   error_return = eeprom_debug_data.crc_error;
004EA8  80BCA4     MOV 0x1794, W4
004EAA  780F04     MOV W4, [W14]
349:                   break;
004EAC  000000     NOP
350:               
351:                 }
352:                 return error_return;
004EAE  78021E     MOV [W14], W4
353:               
354:               }
004EB0  780004     MOV W4, W0
004EB2  FA8000     ULNK
004EB4  060000     RETURN
355:               
---  C:/Users/DPARKER/Documents/GitHub/A36760/Serial.c  -------------------------------------------------
1:                 #include "Serial.h"
2:                 #include "A34760_PINS.h"
3:                 #include "Buffer64.h"
4:                 #include "A34760.h"
5:                 #include "config.h"
6:                 #include "faults.h"
7:                 #include "Version.h"
8:                 #include <libpic30.h>
9:                 #include "eeprom.h"
10:                /*
11:                  Serial Commands
12:                
13:                  A single command is stored in command_string
14:                  If there is a valid command stored in command_string, then the command_string.data_state = COMMAND_BUFFER_FULL
15:                  If there is NOT a volid command stored in command_string, then command_string.data_state = COMMAND_BUFFER_EMPTY
16:                  
17:                  
18:                  When a byte is received on the UART it is transfered to the "uart1_input_buffer" by the UART receive interrupt - the input buffer is a circular buffer that is 64 Bytes deep
19:                  (see buffer64.h for more infor on the buffer)
20:                  
21:                  Every time through the command loop (200us to 1ms) DoSerialCommand() will be called
22:                  If the command_string is empty, then the input buffer is searched for a valid command (the oldest valid command will be moved to command_string)
23:                
24:                  If a command was found OR the command_string was already full, then the command is executed.
25:                
26:                  Assume an average execution cycle of 1mS and 9 bytes per command.  A command rate of 72 K Baund can be sustained. (57.6 K Baud Standard will work)
27:                  
28:                  Assume an average execution cycle of 500uS and 9 bytes per command, A command rate of 144 K Baud can be sustained (115.2 K Baud Standard should be safe) 
29:                
30:                */
31:                
32:                void LookForCommand(void);
33:                void ExecuteCommand(void);
34:                unsigned char CheckCRC(unsigned int crc);
35:                unsigned int MakeCRC(unsigned char command_byte, unsigned char register_byte, unsigned int data_word);
36:                unsigned int ReadFromRam(unsigned int ram_location);
37:                void SendCommand(unsigned char command_byte, unsigned char register_byte, unsigned int data_word);
38:                
39:                unsigned int GenerateFilamentIprog(unsigned int vprog);
40:                unsigned int GenerateLambdaIprog(unsigned int vprog);
41:                
42:                unsigned int GenerateMagnetronVprog(unsigned int iprog);
43:                
44:                struct CommandStringStruct command_string;
45:                
46:                unsigned char data_logging_to_uart;
47:                
48:                unsigned int ReturnPowerSupplyADCScaledVoltage(POWERSUPPLY* ptr, unsigned int value);
49:                unsigned int ReturnPowerSupplyADCScaledCurrent(POWERSUPPLY* ptr, unsigned int value);
50:                
51:                
52:                unsigned int ReverseScale16Bit(unsigned int value, unsigned int scale);
53:                
54:                
55:                unsigned int prf_mult = 1;
56:                unsigned int prf_divider = 1;
57:                
58:                
59:                void CalculatePRFDivider(unsigned int requested_prf);
60:                
61:                void DoSerialCommand(void) {
00332E  FA0000     LNK #0x0
62:                  /* 
63:                     Look for a command and execute it.
64:                  */
65:                  if (_OERR) {
003330  801074     MOV U1STA, W4
003332  620262     AND W4, #0x2, W4
003334  520FE0     SUB W4, #0x0, [W15]
003336  320001     BRA Z, .L2, .LSM3
66:                    _OERR = 0;
003338  A9220E     BCLR U1STA, #1
67:                  }
68:                
69:                  if (command_string.data_state != COMMAND_BUFFER_FULL) {
00333A  217AA4     MOV #0x17AA, W4
00333C  784214     MOV.B [W4], W4
00333E  524FE2     SUB.B W4, #0x2, [W15]
003340  320001     BRA Z, .L3, .LSM5
70:                    LookForCommand();
003342  070007     RCALL LookForCommand
71:                  }
72:                  if (command_string.data_state == COMMAND_BUFFER_FULL) {
003344  217AA4     MOV #0x17AA, W4
003346  784214     MOV.B [W4], W4
003348  524FE2     SUB.B W4, #0x2, [W15]
00334A  3A0001     BRA NZ, .L1, .LSM7
73:                    ExecuteCommand();
00334C  070102     RCALL ExecuteCommand
74:                  }
75:                }
00334E  FA8000     ULNK
003350  060000     RETURN
76:                
77:                
78:                
79:                void LookForCommand(void) {
003352  FA0004     LNK #0x4
003354  781F88     MOV W8, [W15++]
80:                  unsigned char read_byte;
81:                  unsigned int crc;
82:                  /*
83:                    If the state is "waitng for command" then it looks for a command in the buffer, if the state is "executing command" it does nothing
84:                    
85:                    To look for a command in the buffer.
86:                    1) See if there are enough bytes in the buffer to contain a command.
87:                    2) If there are look for command sync
88:                       2b) If there are less bytes in the buffer than it takes to make a command, exit
89:                    3) If command Syncs, check the checksum ^ increment the read_position as each byte is read
90:                       3b) If command does not sync, increment the the read positon and return to step 1    
91:                    4) If the checksum checks out, move the command data into the command data structure
92:                    4b) If the checksum fails, return to step 1     
93:                  */
94:                  
95:                  while ((command_string.data_state == COMMAND_BUFFER_EMPTY) && (Buffer64BytesInBuffer(&uart1_input_buffer) >= COMMAND_LENGTH)) {
003356  37003F     BRA .L6, .LSM24
0033D6  217AA4     MOV #0x17AA, W4
0033D8  784214     MOV.B [W4], W4
0033DA  524FE0     SUB.B W4, #0x0, [W15]
0033DC  3A0005     BRA NZ, .L5, .LSM25
0033DE  2089A0     MOV #0x89A, W0
0033E0  071287     RCALL Buffer64BytesInBuffer
0033E2  784200     MOV.B W0, W4
0033E4  524FE8     SUB.B W4, #0x8, [W15]
0033E6  3EFFB8     BRA GTU, .L8, .LSM10
96:                    // Look for a command
97:                    read_byte = Buffer64ReadByte(&uart1_input_buffer);
003358  2089A0     MOV #0x89A, W0
00335A  0712AC     RCALL Buffer64ReadByte
00335C  784200     MOV.B W0, W4
00335E  784F04     MOV.B W4, [W14]
98:                    if (read_byte == SYNC_BYTE_1) {
003360  78421E     MOV.B [W14], W4
003362  424FEF     ADD.B W4, #0xF, [W15]
003364  3A0038     BRA NZ, .L6, .LSM24
99:                      read_byte = Buffer64ReadByte(&uart1_input_buffer);
003366  2089A0     MOV #0x89A, W0
003368  0712A5     RCALL Buffer64ReadByte
00336A  784200     MOV.B W0, W4
00336C  784F04     MOV.B W4, [W14]
100:                     if (read_byte == SYNC_BYTE_2) {
00336E  78421E     MOV.B [W14], W4
003370  424FEE     ADD.B W4, #0xE, [W15]
003372  3A0031     BRA NZ, .L6, .LSM24
101:               	read_byte = Buffer64ReadByte(&uart1_input_buffer);
003374  2089A0     MOV #0x89A, W0
003376  07129E     RCALL Buffer64ReadByte
003378  784200     MOV.B W0, W4
00337A  784F04     MOV.B W4, [W14]
102:               	if (read_byte == SYNC_BYTE_3_RECEIVE) {
00337C  78421E     MOV.B [W14], W4
00337E  424FED     ADD.B W4, #0xD, [W15]
003380  3A002A     BRA NZ, .L6, .LSM24
103:               	  // All of the sync bytes matched, this should be a valid command
104:               	  command_string.command_byte   = Buffer64ReadByte(&uart1_input_buffer);
003382  2089A0     MOV #0x89A, W0
003384  071297     RCALL Buffer64ReadByte
003386  784200     MOV.B W0, W4
003388  780004     MOV W4, W0
00338A  B7F7A6     MOV.B WREG, command_string
105:               	  command_string.data_high_byte = Buffer64ReadByte(&uart1_input_buffer);
00338C  2089A0     MOV #0x89A, W0
00338E  071292     RCALL Buffer64ReadByte
003390  784200     MOV.B W0, W4
003392  780004     MOV W4, W0
003394  B7F7A8     MOV.B WREG, .LSM671
106:               	  command_string.data_low_byte  = Buffer64ReadByte(&uart1_input_buffer);
003396  2089A0     MOV #0x89A, W0
003398  07128D     RCALL Buffer64ReadByte
00339A  784200     MOV.B W0, W4
00339C  780004     MOV W4, W0
00339E  B7F7A9     MOV.B WREG, 0x17A9
107:               	  command_string.register_byte  = Buffer64ReadByte(&uart1_input_buffer);
0033A0  2089A0     MOV #0x89A, W0
0033A2  071288     RCALL Buffer64ReadByte
0033A4  784200     MOV.B W0, W4
0033A6  780004     MOV W4, W0
0033A8  B7F7A7     MOV.B WREG, 0x17A7
108:               	  crc                           = Buffer64ReadByte(&uart1_input_buffer);
0033AA  2089A0     MOV #0x89A, W0
0033AC  071283     RCALL Buffer64ReadByte
0033AE  784200     MOV.B W0, W4
0033B0  FB8204     ZE W4, W4
0033B2  980714     MOV W4, [W14+2]
109:               	  crc                           = (crc << 8) + Buffer64ReadByte(&uart1_input_buffer);
0033B4  90021E     MOV [W14+2], W4
0033B6  DD2448     SL W4, #8, W8
0033B8  2089A0     MOV #0x89A, W0
0033BA  07127C     RCALL Buffer64ReadByte
0033BC  784200     MOV.B W0, W4
0033BE  FB8204     ZE W4, W4
0033C0  440204     ADD W8, W4, W4
0033C2  980714     MOV W4, [W14+2]
110:               	  if (CheckCRC(crc)) {
0033C4  90001E     MOV [W14+2], W0
0033C6  070514     RCALL CheckCRC
0033C8  784200     MOV.B W0, W4
0033CA  524FE0     SUB.B W4, #0x0, [W15]
0033CC  320004     BRA Z, .L6, .LSM24
111:               	    command_string.data_state = COMMAND_BUFFER_FULL;
0033CE  B3C024     MOV.B #0x2, W4
0033D0  FD0200     EXCH W0, W4
0033D2  B7F7AA     MOV.B WREG, .LSM672
0033D4  FD0200     EXCH W0, W4
112:               	  }
113:               	}
114:                     }
115:                   }
116:                 }
117:               }
0033E8  78044F     MOV [--W15], W8
0033EA  FA8000     ULNK
0033EC  060000     RETURN
118:               
119:               
120:               void SendLoggingDataToUart() {
0033EE  FA0000     LNK #0x0
121:                 /* 
122:                    Data that we need to log with each pulse
123:                    byte 0,1    = 0xFE, 0xF1 - used to sync message
124:                    byte 2,3    = low_energy_target_current_set_point_derived (low 16 bits)
125:                    byte 4,5    = linac_high_energy_target_current_adc_reading
126:                    byte 6,7    = linac_low_energy_target_current_adc_reading
127:                    byte 8,9    = linac_high_energy_program_offset
128:                    byte 10,11    = linac_low_energy_program_offset
129:                    
130:               
131:                    byte 12,13    = pulse_counter_this_run
132:                    byte 14,15   = pulse_magnetron_current_adc_reading
133:                    
134:                 */
135:               
136:                 if (data_logging_to_uart) {
0033F0  217AB4     MOV #0x17AB, W4
0033F2  784214     MOV.B [W4], W4
0033F4  524FE0     SUB.B W4, #0x0, [W15]
0033F6  320067     BRA Z, .L9, .LSM46
137:               
138:                   Buffer64WriteByte(&uart1_output_buffer, 0xFE);
0033F8  B3CFE1     MOV.B #0xFE, W1
0033FA  208DC0     MOV #0x8DC, W0
0033FC  071236     RCALL Buffer64WriteByte
139:                   Buffer64WriteByte(&uart1_output_buffer, 0xF1);
0033FE  B3CF11     MOV.B #0xF1, W1
003400  208DC0     MOV #0x8DC, W0
003402  071233     RCALL Buffer64WriteByte
140:               
141:                   Buffer64WriteByte(&uart1_output_buffer, (low_energy_target_current_set_point_derived >> 8));
003404  8040C4     MOV low_energy_target_current_set_point_derived, W4
003406  8040D5     MOV .LSM11, W5
003408  DD2B48     SL W5, #8, W6
00340A  DE2248     LSR W4, #8, W4
00340C  730204     IOR W6, W4, W4
00340E  DE2AC8     LSR W5, #8, W5
003410  784204     MOV.B W4, W4
003412  784084     MOV.B W4, W1
003414  208DC0     MOV #0x8DC, W0
003416  071229     RCALL Buffer64WriteByte
142:                   Buffer64WriteByte(&uart1_output_buffer, (low_energy_target_current_set_point_derived & 0xFF));
003418  8040C4     MOV low_energy_target_current_set_point_derived, W4
00341A  8040D5     MOV .LSM11, W5
00341C  784204     MOV.B W4, W4
00341E  784084     MOV.B W4, W1
003420  208DC0     MOV #0x8DC, W0
003422  071223     RCALL Buffer64WriteByte
143:               
144:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_target_current_adc_reading >> 8));
003424  804144     MOV linac_high_energy_target_current_adc_reading, W4
003426  DE2248     LSR W4, #8, W4
003428  784204     MOV.B W4, W4
00342A  784084     MOV.B W4, W1
00342C  208DC0     MOV #0x8DC, W0
00342E  07121D     RCALL Buffer64WriteByte
145:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_target_current_adc_reading & 0x00FF));
003430  804144     MOV linac_high_energy_target_current_adc_reading, W4
003432  784204     MOV.B W4, W4
003434  784084     MOV.B W4, W1
003436  208DC0     MOV #0x8DC, W0
003438  071218     RCALL Buffer64WriteByte
146:               
147:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_target_current_adc_reading >> 8));
00343A  804164     MOV linac_low_energy_target_current_adc_reading, W4
00343C  DE2248     LSR W4, #8, W4
00343E  784204     MOV.B W4, W4
003440  784084     MOV.B W4, W1
003442  208DC0     MOV #0x8DC, W0
003444  071212     RCALL Buffer64WriteByte
148:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_target_current_adc_reading & 0x00FF));
003446  804164     MOV linac_low_energy_target_current_adc_reading, W4
003448  784204     MOV.B W4, W4
00344A  784084     MOV.B W4, W1
00344C  208DC0     MOV #0x8DC, W0
00344E  07120D     RCALL Buffer64WriteByte
149:               
150:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_program_offset >> 8));
003450  8041A4     MOV linac_high_energy_program_offset, W4
003452  DEA248     ASR W4, #8, W4
003454  784204     MOV.B W4, W4
003456  784084     MOV.B W4, W1
003458  208DC0     MOV #0x8DC, W0
00345A  071207     RCALL Buffer64WriteByte
151:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_program_offset & 0x00FF));
00345C  8041A4     MOV linac_high_energy_program_offset, W4
00345E  784204     MOV.B W4, W4
003460  784084     MOV.B W4, W1
003462  208DC0     MOV #0x8DC, W0
003464  071202     RCALL Buffer64WriteByte
152:               
153:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_program_offset >> 8));
003466  8041B4     MOV linac_low_energy_program_offset, W4
003468  DEA248     ASR W4, #8, W4
00346A  784204     MOV.B W4, W4
00346C  784084     MOV.B W4, W1
00346E  208DC0     MOV #0x8DC, W0
003470  0711FC     RCALL Buffer64WriteByte
154:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_program_offset & 0x00FF));
003472  8041B4     MOV linac_low_energy_program_offset, W4
003474  784204     MOV.B W4, W4
003476  784084     MOV.B W4, W1
003478  208DC0     MOV #0x8DC, W0
00347A  0711F7     RCALL Buffer64WriteByte
155:               
156:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_counter_this_run >> 8));
00347C  8041D4     MOV pulse_counter_this_run, W4
00347E  DE2248     LSR W4, #8, W4
003480  784204     MOV.B W4, W4
003482  784084     MOV.B W4, W1
003484  208DC0     MOV #0x8DC, W0
003486  0711F1     RCALL Buffer64WriteByte
157:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_counter_this_run & 0x00FF));
003488  8041D4     MOV pulse_counter_this_run, W4
00348A  784204     MOV.B W4, W4
00348C  784084     MOV.B W4, W1
00348E  208DC0     MOV #0x8DC, W0
003490  0711EC     RCALL Buffer64WriteByte
158:               
159:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_magnetron_current_adc_reading >> 8));
003492  8043B4     MOV pulse_magnetron_current_adc_reading, W4
003494  DE2248     LSR W4, #8, W4
003496  784204     MOV.B W4, W4
003498  784084     MOV.B W4, W1
00349A  208DC0     MOV #0x8DC, W0
00349C  0711E6     RCALL Buffer64WriteByte
160:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_magnetron_current_adc_reading & 0x00FF));
00349E  8043B4     MOV pulse_magnetron_current_adc_reading, W4
0034A0  784204     MOV.B W4, W4
0034A2  784084     MOV.B W4, W1
0034A4  208DC0     MOV #0x8DC, W0
0034A6  0711E1     RCALL Buffer64WriteByte
161:               
162:               
163:                   if ((!U1STAbits.UTXBF) && (Buffer64IsNotEmpty(&uart1_output_buffer))) {
0034A8  801075     MOV U1STA, W5
0034AA  202004     MOV #0x200, W4
0034AC  628204     AND W5, W4, W4
0034AE  520FE0     SUB W4, #0x0, [W15]
0034B0  3A000A     BRA NZ, .L9, .LSM46
0034B2  208DC0     MOV #0x8DC, W0
0034B4  071228     RCALL Buffer64IsNotEmpty
0034B6  784200     MOV.B W0, W4
0034B8  524FE0     SUB.B W4, #0x0, [W15]
0034BA  320005     BRA Z, .L9, .LSM46
164:                     /*
165:               	There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
166:               	Move a byte from the output buffer into the transmit buffer
167:               	All subsequent bytes will be moved from the output buffer to the transmit buffer by the U1 TX Interrupt
168:                     */
169:                     U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
0034BC  208DC0     MOV #0x8DC, W0
0034BE  0711FA     RCALL Buffer64ReadByte
0034C0  784200     MOV.B W0, W4
0034C2  FB8204     ZE W4, W4
0034C4  881084     MOV W4, U1TXREG
170:                   }
171:                 }
172:               }
0034C6  FA8000     ULNK
0034C8  060000     RETURN
173:               
174:               
175:               
176:               void SendCommand(unsigned char command_byte, unsigned char register_byte, unsigned int data_word) {
0034CA  FA0006     LNK #0x6
0034CC  984720     MOV.B W0, [W14+2]
0034CE  984731     MOV.B W1, [W14+3]
0034D0  980722     MOV W2, [W14+4]
177:                 unsigned int crc;
178:                 if (!data_logging_to_uart) {
0034D2  217AB4     MOV #0x17AB, W4
0034D4  784214     MOV.B [W4], W4
0034D6  524FE0     SUB.B W4, #0x0, [W15]
0034D8  3A003A     BRA NZ, .L11, .LSM61
179:                   crc = MakeCRC(command_byte, register_byte, data_word);
0034DA  90012E     MOV [W14+4], W2
0034DC  9040BE     MOV.B [W14+3], W1
0034DE  90402E     MOV.B [W14+2], W0
0034E0  070470     RCALL MakeCRC
0034E2  780200     MOV W0, W4
0034E4  780F04     MOV W4, [W14]
180:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_1);
0034E6  B3CF11     MOV.B #0xF1, W1
0034E8  208DC0     MOV #0x8DC, W0
0034EA  0711BF     RCALL Buffer64WriteByte
181:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_2);
0034EC  B3CF21     MOV.B #0xF2, W1
0034EE  208DC0     MOV #0x8DC, W0
0034F0  0711BC     RCALL Buffer64WriteByte
182:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_3_SEND);
0034F2  B3CF41     MOV.B #0xF4, W1
0034F4  208DC0     MOV #0x8DC, W0
0034F6  0711B9     RCALL Buffer64WriteByte
183:                   Buffer64WriteByte(&uart1_output_buffer, command_byte);
0034F8  9040AE     MOV.B [W14+2], W1
0034FA  208DC0     MOV #0x8DC, W0
0034FC  0711B6     RCALL Buffer64WriteByte
184:                   Buffer64WriteByte(&uart1_output_buffer, (data_word >> 8));
0034FE  90022E     MOV [W14+4], W4
003500  DE2248     LSR W4, #8, W4
003502  784204     MOV.B W4, W4
003504  784084     MOV.B W4, W1
003506  208DC0     MOV #0x8DC, W0
003508  0711B0     RCALL Buffer64WriteByte
185:                   Buffer64WriteByte(&uart1_output_buffer, (data_word & 0x00FF));
00350A  90022E     MOV [W14+4], W4
00350C  784204     MOV.B W4, W4
00350E  784084     MOV.B W4, W1
003510  208DC0     MOV #0x8DC, W0
003512  0711AB     RCALL Buffer64WriteByte
186:                   Buffer64WriteByte(&uart1_output_buffer, register_byte);
003514  9040BE     MOV.B [W14+3], W1
003516  208DC0     MOV #0x8DC, W0
003518  0711A8     RCALL Buffer64WriteByte
187:                   Buffer64WriteByte(&uart1_output_buffer, (crc >> 8));
00351A  78021E     MOV [W14], W4
00351C  DE2248     LSR W4, #8, W4
00351E  784204     MOV.B W4, W4
003520  784084     MOV.B W4, W1
003522  208DC0     MOV #0x8DC, W0
003524  0711A2     RCALL Buffer64WriteByte
188:                   Buffer64WriteByte(&uart1_output_buffer, (crc & 0x00FF));
003526  78021E     MOV [W14], W4
003528  784204     MOV.B W4, W4
00352A  784084     MOV.B W4, W1
00352C  208DC0     MOV #0x8DC, W0
00352E  07119D     RCALL Buffer64WriteByte
189:                   
190:                   if ((!U1STAbits.UTXBF) && (Buffer64IsNotEmpty(&uart1_output_buffer))) {
003530  801075     MOV U1STA, W5
003532  202004     MOV #0x200, W4
003534  628204     AND W5, W4, W4
003536  520FE0     SUB W4, #0x0, [W15]
003538  3A000A     BRA NZ, .L11, .LSM61
00353A  208DC0     MOV #0x8DC, W0
00353C  0711E4     RCALL Buffer64IsNotEmpty
00353E  784200     MOV.B W0, W4
003540  524FE0     SUB.B W4, #0x0, [W15]
003542  320005     BRA Z, .L11, .LSM61
191:                     /*
192:               	There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
193:               	Move a byte from the output buffer into the transmit buffer
194:               	All subsequent bytes will be moved from the output buffer to the transmit buffer by the U1 TX Interrupt
195:                     */
196:                     U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
003544  208DC0     MOV #0x8DC, W0
003546  0711B6     RCALL Buffer64ReadByte
003548  784200     MOV.B W0, W4
00354A  FB8204     ZE W4, W4
00354C  881084     MOV W4, U1TXREG
197:                   }
198:                 }
199:               }
00354E  FA8000     ULNK
003550  060000     RETURN
200:               
201:               void ExecuteCommand(void) {
003552  FA000E     LNK #0xE
202:                 unsigned int itemp;
203:                 unsigned int vtemp;
204:                 unsigned int data_word;
205:                 unsigned int return_data_word;
206:                 unsigned int return_command_byte;
207:                 
208:                 unsigned int eeprom_write_complete;
209:                 unsigned int eeprom_write_attempt;
210:               
211:                 
212:                 data_word = command_string.data_high_byte;
003554  217A84     MOV #0x17A8, W4
003556  784214     MOV.B [W4], W4
003558  FB8204     ZE W4, W4
00355A  980734     MOV W4, [W14+6]
213:                 data_word = data_word << 8;
00355C  90023E     MOV [W14+6], W4
00355E  DD2248     SL W4, #8, W4
003560  980734     MOV W4, [W14+6]
214:                 data_word = data_word + command_string.data_low_byte;
003562  217A94     MOV #0x17A9, W4
003564  784214     MOV.B [W4], W4
003566  FB8204     ZE W4, W4
003568  9002BE     MOV [W14+6], W5
00356A  428204     ADD W5, W4, W4
00356C  980734     MOV W4, [W14+6]
215:                 
216:                 return_data_word = data_word;
00356E  90023E     MOV [W14+6], W4
003570  780F04     MOV W4, [W14]
217:                 return_command_byte = command_string.command_byte;
003572  217A64     MOV #0x17A6, W4
003574  784214     MOV.B [W4], W4
003576  FB8204     ZE W4, W4
003578  980744     MOV W4, [W14+8]
218:                 switch (command_string.command_byte) 
00357A  217A64     MOV #0x17A6, W4
00357C  784214     MOV.B [W4], W4
00357E  FB8204     ZE W4, W4
003580  200305     MOV #0x30, W5
003582  520F85     SUB W4, W5, [W15]
003584  32006F     BRA Z, .L23, .LSM88
003586  200305     MOV #0x30, W5
003588  520F85     SUB W4, W5, [W15]
00358A  3C001B     BRA GT, .L33
00358C  520FF3     SUB W4, #0x13, [W15]
00358E  32004D     BRA Z, .L18, .LSM77
003590  520FF3     SUB W4, #0x13, [W15]
003592  3C0007     BRA GT, .L34
003594  520FF1     SUB W4, #0x11, [W15]
003596  32003E     BRA Z, .L16, .LSM71
003598  520FF1     SUB W4, #0x11, [W15]
00359A  3C0041     BRA GT, .L17, .LSM73
00359C  520FF0     SUB W4, #0x10, [W15]
00359E  320035     BRA Z, .L15, .LSM69
0035A0  370154     BRA .L14, .LSM190
0035A2  2002B5     MOV #0x2B, W5
0035A4  520F85     SUB W4, W5, [W15]
0035A6  32004F     BRA Z, .L20, .LSM83
0035A8  2002B5     MOV #0x2B, W5
0035AA  520F85     SUB W4, W5, [W15]
0035AC  3C0003     BRA GT, .L35
0035AE  520FF4     SUB W4, #0x14, [W15]
0035B0  320043     BRA Z, .L19, .LSM80
0035B2  37014B     BRA .L14, .LSM190
0035B4  2002E5     MOV #0x2E, W5
0035B6  520F85     SUB W4, W5, [W15]
0035B8  320100     BRA Z, .L21, .LSM155
0035BA  2002F5     MOV #0x2F, W5
0035BC  520F85     SUB W4, W5, [W15]
0035BE  320032     BRA Z, .L22, .LSM75
0035C0  370144     BRA .L14, .LSM190
0035C2  200595     MOV #0x59, W5
0035C4  520F85     SUB W4, W5, [W15]
0035C6  3200D4     BRA Z, .L28, .LSM140
0035C8  200595     MOV #0x59, W5
0035CA  520F85     SUB W4, W5, [W15]
0035CC  3C0011     BRA GT, .L36
0035CE  200505     MOV #0x50, W5
0035D0  520F85     SUB W4, W5, [W15]
0035D2  320050     BRA Z, .L25, .LSM90
0035D4  200505     MOV #0x50, W5
0035D6  520F85     SUB W4, W5, [W15]
0035D8  3C0004     BRA GT, .L37
0035DA  200405     MOV #0x40, W5
0035DC  520F85     SUB W4, W5, [W15]
0035DE  320112     BRA Z, .L24, .LSM169
0035E0  370134     BRA .L14, .LSM190
0035E2  200575     MOV #0x57, W5
0035E4  520F85     SUB W4, W5, [W15]
0035E6  3200A4     BRA Z, .L26, .LSM126
0035E8  200585     MOV #0x58, W5
0035EA  520F85     SUB W4, W5, [W15]
0035EC  3200A4     BRA Z, .L27, .LSM128
0035EE  37012D     BRA .L14, .LSM190
0035F0  200A15     MOV #0xA1, W5
0035F2  520F85     SUB W4, W5, [W15]
0035F4  3200DA     BRA Z, .L30, .LSM152
0035F6  200A15     MOV #0xA1, W5
0035F8  520F85     SUB W4, W5, [W15]
0035FA  340112     BRA LE, .L67, .LSM180
0035FC  200E85     MOV #0xE8, W5
0035FE  520F85     SUB W4, W5, [W15]
003600  320047     BRA Z, .L31, .LSM95
003602  200E95     MOV #0xE9, W5
003604  520F85     SUB W4, W5, [W15]
003606  320085     BRA Z, .L32, .LSM120
003608  370120     BRA .L14, .LSM190
219:                   {
220:               
221:               
222:                     
223:               #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
224:                     // We have compiled in the mode that untilizes the serial port to set the magnetron operating parameters (instead of the analong interface)
225:                   case CMD_PAC_SET_MODE_A:
226:                     itemp = data_word;
227:                     vtemp = GenerateMagnetronVprog(itemp);
228:                     SetPowerSupplyTarget(&ps_magnetron_mode_A, vtemp, itemp);
229:                     /*
230:                     ps_magnetron_mode_A_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnetron_mode_A.v_command_set_point;
231:                     ps_magnetron_mode_A_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnetron_mode_A.i_command_set_point;
232:                     _wait_eedata();
233:                     _erase_eedata(EE_address_ps_magnetron_mode_A_config_in_EEPROM, _EE_ROW);
234:                     _wait_eedata();
235:                     _write_eedata_row(EE_address_ps_magnetron_mode_A_config_in_EEPROM, ps_magnet_config_ram_copy);
236:                     */
237:                     break;
238:               
239:                   case CMD_PAC_SET_MODE_B:
240:                     itemp = data_word;
241:                     vtemp = GenerateMagnetronVprog(itemp);
242:                     SetPowerSupplyTarget(&ps_magnetron_mode_B, vtemp, itemp);
243:                     /*
244:                     ps_magnetron_mode_B_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnetron_mode_B.v_command_set_point;
245:                     ps_magnetron_mode_B_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnetron_mode_B.i_command_set_point;
246:                     _wait_eedata();
247:                     _erase_eedata(EE_address_ps_magnetron_mode_B_config_in_EEPROM, _EE_ROW);
248:                     _wait_eedata();
249:                     _write_eedata_row(EE_address_ps_magnetron_mode_B_config_in_EEPROM, ps_magnet_config_ram_copy);
250:                     */
251:                     break;
252:               #endif
253:               
254:               
255:               
256:               #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
257:                     // The lambda voltage is set directly over the serial interface.
258:                   case CMD_SET_LAMBDA_VOLTAGE_MODE_A:
259:                     vtemp = data_word;
260:                     itemp = GenerateLambdaIprog(vtemp);
261:                     SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp, itemp);
262:                     /*
263:                     ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_SET_POINT] = ps_hv_lambda_mode_A.v_command_set_point;
264:                     ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_SET_POINT] = ps_hv_lambda_mode_A.i_command_set_point;
265:                     _wait_eedata();
266:                     _erase_eedata(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, _EE_ROW);
267:                     _wait_eedata();
268:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, ps_hv_lambda_mode_A_config_ram_copy);
269:                     */
270:                     break;
271:               
272:                   case CMD_SET_LAMBDA_VOLTAGE_MODE_B:
273:                     vtemp = data_word;
274:                     itemp = GenerateLambdaIprog(vtemp);
275:                     SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, itemp);
276:                     /*
277:                     ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_SET_POINT] = ps_hv_lambda_mode_B.v_command_set_point;
278:                     ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_SET_POINT] = ps_hv_lambda_mode_B.i_command_set_point;
279:                     _wait_eedata();
280:                     _erase_eedata(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, _EE_ROW);
281:                     _wait_eedata();
282:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, ps_hv_lambda_mode_B_config_ram_copy);
283:                     */
284:                     break;
285:               
286:               #endif // #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
287:                   case CMD_SET_MAGNETRON_CURRENT_REMOTE_MODE:
288:                     ram_config_set_magnetron_magnet_current_from_GUI = 0;
00360A  EB4200     CLR.B W4
00360C  FD0200     EXCH W0, W4
00360E  B7E844     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
003610  FD0200     EXCH W0, W4
289:                     break;
003612  37011B     BRA .L14, .LSM190
290:                     
291:                   case CMD_SET_MAGNETRON_CURRENT_LOCAL_MODE:
292:                     ram_config_set_magnetron_magnet_current_from_GUI = 1;
003614  B3C014     MOV.B #0x1, W4
003616  FD0200     EXCH W0, W4
003618  B7E844     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
00361A  FD0200     EXCH W0, W4
293:                     break;
00361C  370116     BRA .L14, .LSM190
294:               
295:                   case CMD_SET_PRF_REQUESTED_FREQ:
296:                     CalculatePRFDivider(data_word);
00361E  90003E     MOV [W14+6], W0
003620  070508     RCALL CalculatePRFDivider
297:                     break;
003622  370113     BRA .L14, .LSM190
298:               
299:                   case CMD_SET_MAGNETRON_FILAMENT_CONTROL_MODE:
300:                     magnetron_filament_control_mode = data_word;
003624  90023E     MOV [W14+6], W4
003626  884374     MOV W4, magnetron_filament_control_mode
301:                     break;
003628  370110     BRA .L14, .LSM190
302:               
303:                   case CMD_SET_MAGNETRON_FILAMENT_OFF_RESISTANCE:
304:                     if (data_word > 10000) {
00362A  9002BE     MOV [W14+6], W5
00362C  227104     MOV #0x2710, W4
00362E  528F84     SUB W5, W4, [W15]
003630  3600F9     BRA LEU, .L68, .LSM181
305:               	magnetron_filament_off_resistance = data_word;
003632  90023E     MOV [W14+6], W4
003634  884384     MOV W4, magnetron_filament_off_resistance
306:                     }
307:                     break;
003636  370109     BRA .L14, .LSM190
003824  000000     NOP
003826  370011     BRA .L14, .LSM190
308:               
309:                   case CMD_SET_MAGNETRON_FILAMENT_ON_RESISTANCE:
310:                     if (data_word > 10000) {
003638  9002BE     MOV [W14+6], W5
00363A  227104     MOV #0x2710, W4
00363C  528F84     SUB W5, W4, [W15]
00363E  3600F4     BRA LEU, .L69, .LSM182
311:               	magnetron_filament_on_resistance = data_word;
003640  90023E     MOV [W14+6], W4
003642  884394     MOV W4, magnetron_filament_on_resistance
312:                     }
313:                     break;
003644  370102     BRA .L14, .LSM190
003828  000000     NOP
00382A  37000F     BRA .L14, .LSM190
314:               	
315:                     
316:                     //#if defined(__SET_MAGNET_CURRENT_OVER_SERIAL_INTERFACE)
317:                   case CMD_SET_MAGNETRON_MAGNET_CURRENT:
318:                     if (ram_config_set_magnetron_magnet_current_from_GUI) {
003646  208444     MOV #0x844, W4
003648  784214     MOV.B [W4], W4
00364A  524FE0     SUB.B W4, #0x0, [W15]
00364C  3200EF     BRA Z, .L70, .LSM183
319:               	itemp = data_word;
00364E  90023E     MOV [W14+6], W4
003650  980754     MOV W4, [W14+10]
320:               	vtemp = GenerateMagnetVprog(itemp);
003652  90005E     MOV [W14+10], W0
003654  07042D     RCALL GenerateMagnetVprog
003656  780200     MOV W0, W4
003658  980764     MOV W4, [W14+12]
321:               	SetPowerSupplyTarget(&ps_magnet, vtemp, itemp);
00365A  90015E     MOV [W14+10], W2
00365C  9000EE     MOV [W14+12], W1
00365E  20A9E0     MOV #0xA9E, W0
003660  07F24F     RCALL SetPowerSupplyTarget
322:               	/*
323:               	ps_magnet_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnet.v_command_set_point;
324:               	ps_magnet_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnet.i_command_set_point;
325:               	_wait_eedata();
326:               	_erase_eedata(EE_address_ps_magnet_config_in_EEPROM, _EE_ROW);
327:               	_wait_eedata();
328:               	_write_eedata_row(EE_address_ps_magnet_config_in_EEPROM, ps_magnet_config_ram_copy);
329:               	*/
330:                     }
331:                     break;
003662  3700F3     BRA .L14, .LSM190
00382C  000000     NOP
00382E  37000D     BRA .L14, .LSM190
332:               
333:                     //#endif //#if defined(__SET_MAGNET_CURRENT_OVER_SERIAL_INTERFACE)
334:               
335:                     
336:                   case CMD_READ_RAM_VALUE:
337:                     return_data_word = ReadFromRam(command_string.register_byte);
003664  217A74     MOV #0x17A7, W4
003666  784214     MOV.B [W4], W4
003668  FB8204     ZE W4, W4
00366A  780004     MOV W4, W0
00366C  0700FB     RCALL ReadFromRam
00366E  780200     MOV W0, W4
003670  780F04     MOV W4, [W14]
338:                     break;
003672  3700EB     BRA .L14, .LSM190
339:               
340:                     
341:                   case CMD_DATA_LOGGING:
342:                     if (command_string.register_byte == 1) {
003674  217A74     MOV #0x17A7, W4
003676  784214     MOV.B [W4], W4
003678  524FE1     SUB.B W4, #0x1, [W15]
00367A  3A0005     BRA NZ, .L42, .LSM93
343:               	data_logging_to_uart = 1;
00367C  B3C014     MOV.B #0x1, W4
00367E  FD0200     EXCH W0, W4
003680  B7F7AB     MOV.B WREG, data_logging_to_uart
003682  FD0200     EXCH W0, W4
344:                     } else {
345:                     	data_logging_to_uart = 0;
003686  EB4200     CLR.B W4
003688  FD0200     EXCH W0, W4
00368A  B7F7AB     MOV.B WREG, data_logging_to_uart
00368C  FD0200     EXCH W0, W4
346:                     }
347:                     break;
003684  3700E2     BRA .L14, .LSM190
00368E  3700DD     BRA .L14, .LSM190
348:               
349:                     /*
350:                   case CMD_SET_HIGH_ENERGY_TARGET_CURRENT_SETPOINT:
351:                     linac_high_energy_target_current_set_point = data_word;
352:                     if (linac_high_energy_target_current_set_point < LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR) {
353:               	linac_high_energy_target_current_set_point = LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR;
354:                     }
355:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_HIGH_ENERGY_TARGET] = linac_high_energy_target_current_set_point;
356:                     _wait_eedata();
357:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
358:                     _wait_eedata();
359:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
360:                     break;
361:                     
362:               
363:                   case CMD_SET_LOW_ENERGY_PORTAL_TARGET_CURRENT_SETPOINT:
364:                     linac_low_energy_target_current_set_point_portal_mode = data_word;
365:                     if (linac_low_energy_target_current_set_point_portal_mode < LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR) {
366:               	linac_low_energy_target_current_set_point_portal_mode = LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR;
367:                     }
368:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_PORTAL_TARGET] = linac_low_energy_target_current_set_point_portal_mode;
369:                     _wait_eedata();
370:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
371:                     _wait_eedata();
372:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
373:                     break;
374:               
375:                   case CMD_SET_LOW_ENERGY_GANTRY_TARGET_CURRENT_SETPOINT:
376:                     linac_low_energy_target_current_set_point_gantry_mode = data_word;
377:                     if (linac_low_energy_target_current_set_point_gantry_mode < LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR) {
378:               	linac_low_energy_target_current_set_point_gantry_mode = LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR;
379:                     }
380:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_GANTRY_TARGET] = linac_low_energy_target_current_set_point_gantry_mode;
381:                     _wait_eedata();
382:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
383:                     _wait_eedata();
384:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
385:                     break;
386:               
387:                   case CMD_SET_TARGET_CURRENT_STARTUP_PULSES:
388:                     low_energy_target_current_startup_adjust_decay_time_pulses = data_word;
389:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_STARTUP_PULSES] = low_energy_target_current_startup_adjust_decay_time_pulses;
390:                     _wait_eedata();
391:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
392:                     _wait_eedata();
393:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
394:                     break;
395:               
396:                   case CMD_SET_TARGET_CURRENT_STARTUP_MAGNITUDE:
397:                     max_low_energy_target_current_startup_adjust_initital_value = data_word;
398:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_MAX_MAGNITUDE] = max_low_energy_target_current_startup_adjust_initital_value;
399:                     _wait_eedata();
400:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
401:                     _wait_eedata();
402:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
403:                     break;
404:               
405:                   case CMD_SET_TARGET_CURRENT_STARTUP_DIRECTION:
406:                     low_energy_target_current_startup_max_cooldown = data_word;
407:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_MAX_COOLDOWN] = low_energy_target_current_startup_max_cooldown;
408:                     _wait_eedata();
409:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
410:                     _wait_eedata();
411:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
412:                     break;
413:               
414:                     */
415:               
416:               
417:                   case CMD_SET_CNTRL_CAL_DATA:
418:                     if (command_string.register_byte == EEPROM_CNTRL_MAGNET_FACTOR_LINEAR) {
003690  217A74     MOV #0x17A7, W4
003692  784214     MOV.B [W4], W4
003694  524FE1     SUB.B W4, #0x1, [W15]
003696  3A001C     BRA NZ, .L44, .LSM107
419:               	eeprom_write_complete = 0;
003698  EB0200     CLR W4
00369A  980714     MOV W4, [W14+2]
420:               	eeprom_write_attempt = 0;
00369C  EB0200     CLR W4
00369E  980724     MOV W4, [W14+4]
421:               	while (eeprom_write_complete == 0) {
0036A0  37000F     BRA .L45, .LSM104
0036C0  90021E     MOV [W14+2], W4
0036C2  520FE0     SUB W4, #0x0, [W15]
0036C4  32FFEE     BRA Z, .L47, .LSM99
422:               	  eeprom_write_complete = ETMEEPromWriteWordWithConfirmation(EEPROM_REGISTER_MAGNET_SCALING_LINEAR, data_word);
0036A2  9000BE     MOV [W14+6], W1
0036A4  EB0000     CLR W0
0036A6  070AE4     RCALL ETMEEPromWriteWordWithConfirmation
0036A8  780200     MOV W0, W4
0036AA  980714     MOV W4, [W14+2]
423:               	  eeprom_write_attempt++;
0036AC  90022E     MOV [W14+4], W4
0036AE  E80204     INC W4, W4
0036B0  980724     MOV W4, [W14+4]
424:               	  if (eeprom_write_attempt >= 10) {
0036B2  90022E     MOV [W14+4], W4
0036B4  520FE9     SUB W4, #0x9, [W15]
0036B6  360004     BRA LEU, .L45, .LSM104
425:               	    eeprom_write_failure_count++;
0036B8  804084     MOV eeprom_write_failure_count, W4
0036BA  E80204     INC W4, W4
0036BC  884084     MOV W4, eeprom_write_failure_count
426:               	    break;
0036BE  370003     BRA .L46, .LSM105
427:               	  }
428:               	}
429:               	if (eeprom_write_complete) {
0036C6  90021E     MOV [W14+2], W4
0036C8  520FE0     SUB W4, #0x0, [W15]
0036CA  320002     BRA Z, .L44, .LSM107
430:               	  magnet_scaling_linear_factor = data_word;
0036CC  90023E     MOV [W14+6], W4
0036CE  884064     MOV W4, magnet_scaling_linear_factor
431:               	}
432:                     }
433:               
434:                     if (command_string.register_byte == EEPROM_CNTRL_MAGNET_FACTOR_CONST) {
0036D0  217A74     MOV #0x17A7, W4
0036D2  784214     MOV.B [W4], W4
0036D4  524FE2     SUB.B W4, #0x2, [W15]
0036D6  3A00AC     BRA NZ, .L71, .LSM184
435:               	eeprom_write_complete = 0;
0036D8  EB0200     CLR W4
0036DA  980714     MOV W4, [W14+2]
436:               	eeprom_write_attempt = 0;
0036DC  EB0200     CLR W4
0036DE  980724     MOV W4, [W14+4]
437:               	while (eeprom_write_complete == 0) {
0036E0  37000F     BRA .L49, .LSM116
003700  90021E     MOV [W14+2], W4
003702  520FE0     SUB W4, #0x0, [W15]
003704  32FFEE     BRA Z, .L51, .LSM111
438:               	  eeprom_write_complete = ETMEEPromWriteWordWithConfirmation(EEPROM_REGISTER_MAGNET_SCALING_CONST, data_word);
0036E2  9000BE     MOV [W14+6], W1
0036E4  200010     MOV #0x1, W0
0036E6  070AC4     RCALL ETMEEPromWriteWordWithConfirmation
0036E8  780200     MOV W0, W4
0036EA  980714     MOV W4, [W14+2]
439:               	  eeprom_write_attempt++;
0036EC  90022E     MOV [W14+4], W4
0036EE  E80204     INC W4, W4
0036F0  980724     MOV W4, [W14+4]
440:               	  if (eeprom_write_attempt >= 10) {
0036F2  90022E     MOV [W14+4], W4
0036F4  520FE9     SUB W4, #0x9, [W15]
0036F6  360004     BRA LEU, .L49, .LSM116
441:               	    eeprom_write_failure_count++;
0036F8  804084     MOV eeprom_write_failure_count, W4
0036FA  E80204     INC W4, W4
0036FC  884084     MOV W4, eeprom_write_failure_count
442:               	    break;
0036FE  370003     BRA .L50, .LSM117
443:               	  }
444:               	}
445:               	if (eeprom_write_complete) {
003706  90021E     MOV [W14+2], W4
003708  520FE0     SUB W4, #0x0, [W15]
00370A  320094     BRA Z, .L72
446:               	  magnet_scaling_constant_factor = data_word;
00370C  90023E     MOV [W14+6], W4
00370E  884074     MOV W4, magnet_scaling_constant_factor
447:               	}
448:                     }
449:                     break;
003710  37009C     BRA .L14, .LSM190
003830  000000     NOP
003832  37000B     BRA .L14, .LSM190
003834  000000     NOP
003836  370009     BRA .L14, .LSM190
450:               
451:                   case CMD_READ_CNTRL_CAL_DATA:
452:                     return_data_word = 0;
003712  EB0200     CLR W4
003714  780F04     MOV W4, [W14]
453:               
454:                     if (command_string.register_byte == EEPROM_CNTRL_MAGNET_FACTOR_LINEAR) {
003716  217A74     MOV #0x17A7, W4
003718  784214     MOV.B [W4], W4
00371A  524FE1     SUB.B W4, #0x1, [W15]
00371C  3A0002     BRA NZ, .L52, .LSM123
455:               	return_data_word = magnet_scaling_linear_factor;
00371E  804064     MOV magnet_scaling_linear_factor, W4
003720  780F04     MOV W4, [W14]
456:                     }
457:               
458:                     if (command_string.register_byte == EEPROM_CNTRL_MAGNET_FACTOR_CONST) {
003722  217A74     MOV #0x17A7, W4
003724  784214     MOV.B [W4], W4
003726  524FE2     SUB.B W4, #0x2, [W15]
003728  3A0087     BRA NZ, .L73, .LSM185
459:               	return_data_word = magnet_scaling_constant_factor;
00372A  804074     MOV magnet_scaling_constant_factor, W4
00372C  780F04     MOV W4, [W14]
460:                     }
461:                     break;
00372E  37008D     BRA .L14, .LSM190
003838  000000     NOP
00383A  370007     BRA .L14, .LSM190
462:               
463:                     /*
464:                   case CMD_SAVE_CNTRL_CAL_DATA_TO_EEPROM:
465:                     _wait_eedata();
466:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
467:                     _wait_eedata();
468:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);
469:                     break;
470:                     */
471:               
472:               
473:                     
474:                   case CMD_SET_FILAMENT_OFFSET:
475:                     look_up_offset = (signed int)data_word;
003730  90023E     MOV [W14+6], W4
003732  8840E4     MOV W4, look_up_offset
476:                     break;
003734  37008A     BRA .L14, .LSM190
477:               
478:                   case CMD_SET_SCALE_INTERLEAVED:
479:                     eeprom_write_complete = 0;
003736  EB0200     CLR W4
003738  980714     MOV W4, [W14+2]
480:                     eeprom_write_attempt = 0;
00373A  EB0200     CLR W4
00373C  980724     MOV W4, [W14+4]
481:                     while (eeprom_write_complete == 0) {
00373E  37000F     BRA .L54, .LSM136
00375E  90021E     MOV [W14+2], W4
003760  520FE0     SUB W4, #0x0, [W15]
003762  32FFEE     BRA Z, .L56, .LSM131
482:               	eeprom_write_complete = ETMEEPromWriteWordWithConfirmation(EEPROM_REGISTER_SCALE_INTERLEAVED, data_word);
003740  9000BE     MOV [W14+6], W1
003742  200020     MOV #0x2, W0
003744  070A95     RCALL ETMEEPromWriteWordWithConfirmation
003746  780200     MOV W0, W4
003748  980714     MOV W4, [W14+2]
483:               	eeprom_write_attempt++;
00374A  90022E     MOV [W14+4], W4
00374C  E80204     INC W4, W4
00374E  980724     MOV W4, [W14+4]
484:               	if (eeprom_write_attempt >= 10) {
003750  90022E     MOV [W14+4], W4
003752  520FE9     SUB W4, #0x9, [W15]
003754  360004     BRA LEU, .L54, .LSM136
485:               	  eeprom_write_failure_count++;
003756  804084     MOV eeprom_write_failure_count, W4
003758  E80204     INC W4, W4
00375A  884084     MOV W4, eeprom_write_failure_count
486:               	  break;
00375C  370003     BRA .L55, .LSM137
487:               	}
488:                     }
489:                     if (eeprom_write_complete) {
003764  90021E     MOV [W14+2], W4
003766  520FE0     SUB W4, #0x0, [W15]
003768  320069     BRA Z, .L74, .LSM186
490:               	scale_interleaved = data_word;
00376A  90023E     MOV [W14+6], W4
00376C  88B874     MOV W4, scale_interleaved
491:                     }
492:               
493:                     
494:                     /*
495:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_INTERLEAVED_POWER_SCALE] = data_word;
496:                     _wait_eedata();
497:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
498:                     _wait_eedata();
499:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);
500:                     */ 
501:                     break;
00376E  37006D     BRA .L14, .LSM190
00383C  000000     NOP
00383E  370005     BRA .L14, .LSM190
502:                     
503:                   case CMD_SET_SCALE_LOW_ENERGY:
504:                     eeprom_write_complete = 0;
003770  EB0200     CLR W4
003772  980714     MOV W4, [W14+2]
505:                     eeprom_write_attempt = 0;
003774  EB0200     CLR W4
003776  980724     MOV W4, [W14+4]
506:                     while (eeprom_write_complete == 0) {
003778  37000F     BRA .L58, .LSM148
003798  90021E     MOV [W14+2], W4
00379A  520FE0     SUB W4, #0x0, [W15]
00379C  32FFEE     BRA Z, .L60, .LSM143
507:               	eeprom_write_complete = ETMEEPromWriteWordWithConfirmation(EEPROM_REGISTER_SCALE_LOW_ENERGY, data_word);
00377A  9000BE     MOV [W14+6], W1
00377C  200030     MOV #0x3, W0
00377E  070A78     RCALL ETMEEPromWriteWordWithConfirmation
003780  780200     MOV W0, W4
003782  980714     MOV W4, [W14+2]
508:               	eeprom_write_attempt++;
003784  90022E     MOV [W14+4], W4
003786  E80204     INC W4, W4
003788  980724     MOV W4, [W14+4]
509:               	if (eeprom_write_attempt >= 10) {
00378A  90022E     MOV [W14+4], W4
00378C  520FE9     SUB W4, #0x9, [W15]
00378E  360004     BRA LEU, .L58, .LSM148
510:               	  eeprom_write_failure_count++;
003790  804084     MOV eeprom_write_failure_count, W4
003792  E80204     INC W4, W4
003794  884084     MOV W4, eeprom_write_failure_count
511:               	  break;
003796  370003     BRA .L59, .LSM149
512:               	}
513:                     }
514:                     if (eeprom_write_complete) {
00379E  90021E     MOV [W14+2], W4
0037A0  520FE0     SUB W4, #0x0, [W15]
0037A2  32004E     BRA Z, .L75, .LSM187
515:               	scale_low_energy = data_word;
0037A4  90023E     MOV [W14+6], W4
0037A6  88B884     MOV W4, scale_low_energy
516:                     }
517:               
518:               
519:                     /*
520:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_POWER_SCALE] = data_word;
521:                     _wait_eedata();
522:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
523:                     _wait_eedata();
524:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);
525:                     */   
526:                     break;
0037A8  370050     BRA .L14, .LSM190
003840  000000     NOP
003842  370003     BRA .L14, .LSM190
527:               
528:                   case CMD_FORCE_SOFTWARE_RESTART:
529:                     /*
530:               	We don't want to be forcing software resets on a production system
531:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
532:                     __delay32(100000); // this should be 10ms
533:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 1;
534:                     __delay32(100);
535:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
536:                    __asm__ ("Reset");
537:                     */
538:                     break;
003820  000000     NOP
003822  370013     BRA .L14, .LSM190
539:               
540:                   case CMD_SOFTWARE_SKIP_WARMUP:
541:                     if (control_state == STATE_WARM_UP) {
0037AA  208585     MOV #0x858, W5
0037AC  784295     MOV.B [W5], W5
0037AE  B3C244     MOV.B #0x24, W4
0037B0  52CF84     SUB.B W5, W4, [W15]
0037B2  3A0048     BRA NZ, .L76, .LSM188
542:               	software_skip_warmup = 1;
0037B4  200014     MOV #0x1, W4
0037B6  884214     MOV W4, software_skip_warmup
543:                     }
544:                     break;
0037B8  370048     BRA .L14, .LSM190
003844  000000     NOP
003846  370001     BRA .L14, .LSM190
545:               
546:                   case CMD_SET_MAGNETRON_FILAMENT_CURRENT:
547:                     eeprom_write_complete = 0;
0037BA  EB0200     CLR W4
0037BC  980714     MOV W4, [W14+2]
548:                     eeprom_write_attempt = 0;
0037BE  EB0200     CLR W4
0037C0  980724     MOV W4, [W14+4]
549:                     while (eeprom_write_complete == 0) {
0037C2  37000F     BRA .L63, .LSM163
0037E2  90021E     MOV [W14+2], W4
0037E4  520FE0     SUB W4, #0x0, [W15]
0037E6  32FFEE     BRA Z, .L65, .LSM158
550:               	eeprom_write_complete = ETMEEPromWriteWordWithConfirmation(EEPROM_REGISTER_MAGNETRON_FILAMENT_CURRENT, data_word);
0037C4  9000BE     MOV [W14+6], W1
0037C6  200040     MOV #0x4, W0
0037C8  070A53     RCALL ETMEEPromWriteWordWithConfirmation
0037CA  780200     MOV W0, W4
0037CC  980714     MOV W4, [W14+2]
551:               	eeprom_write_attempt++;
0037CE  90022E     MOV [W14+4], W4
0037D0  E80204     INC W4, W4
0037D2  980724     MOV W4, [W14+4]
552:               	if (eeprom_write_attempt >= 10) {
0037D4  90022E     MOV [W14+4], W4
0037D6  520FE9     SUB W4, #0x9, [W15]
0037D8  360004     BRA LEU, .L63, .LSM163
553:               	  eeprom_write_failure_count++;
0037DA  804084     MOV eeprom_write_failure_count, W4
0037DC  E80204     INC W4, W4
0037DE  884084     MOV W4, eeprom_write_failure_count
554:               	  break;
0037E0  370003     BRA .L64, .LSM164
555:               	}
556:                     }
557:                     if (eeprom_write_complete) {
0037E8  90021E     MOV [W14+2], W4
0037EA  520FE0     SUB W4, #0x0, [W15]
0037EC  32002D     BRA Z, .L77, .LSM189
558:               	itemp = data_word;
0037EE  90023E     MOV [W14+6], W4
0037F0  980754     MOV W4, [W14+10]
559:               	vtemp = GenerateFilamentVprog(itemp);
0037F2  90005E     MOV [W14+10], W0
0037F4  070373     RCALL GenerateFilamentVprog
0037F6  780200     MOV W0, W4
0037F8  980764     MOV W4, [W14+12]
560:               	SetPowerSupplyTarget(&ps_filament, vtemp, itemp);
0037FA  90015E     MOV [W14+10], W2
0037FC  9000EE     MOV [W14+12], W1
0037FE  20AF80     MOV #0xAF8, W0
003800  07F17F     RCALL SetPowerSupplyTarget
561:                     }
562:               
563:                     
564:                     /*
565:                     ps_filament_config_ram_copy[EEPROM_V_SET_POINT] = ps_filament.v_command_set_point;
566:                     ps_filament_config_ram_copy[EEPROM_I_SET_POINT] = ps_filament.i_command_set_point;
567:                     _wait_eedata();
568:                     _erase_eedata(EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
569:                     _wait_eedata();
570:                     _write_eedata_row(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_ram_copy);
571:                     */
572:                     break;
003802  370023     BRA .L14, .LSM190
003848  000000     NOP
573:               
574:                   case CMD_CLEAR_PROCESSOR_RESET_DATA:
575:                     // DPARKER using this command to reset "reset data"
576:                     debug_status_register = 0;
003804  EB0200     CLR W4
003806  88B9F4     MOV W4, debug_status_register
577:                     _POR = 0;
003808  A90740     BCLR RCON, #0
578:                     _EXTR = 0;
00380A  A9E740     BCLR RCON, #7
579:                     _SWR = 0;
00380C  A9C740     BCLR RCON, #6
580:                     _BOR = 0;
00380E  A92740     BCLR RCON, #1
581:                     _TRAPR = 0;
003810  A9E741     BCLR 0x741, #7
582:                     _WDTO = 0;
003812  A98740     BCLR RCON, #4
583:                     _IOPUWR = 0;
003814  A9C741     BCLR 0x741, #6
584:                     last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
003816  EB0200     CLR W4
003818  88BDE4     MOV W4, last_known_action
585:                     processor_crash_count = 0;
00381A  EB0200     CLR W4
00381C  88BE04     MOV W4, processor_crash_count
586:                     break;
00381E  370015     BRA .L14, .LSM190
587:               
588:               
589:                   }
590:                 
591:                 // Echo the command that was recieved back to the controller
592:                 SendCommand(return_command_byte, command_string.register_byte, return_data_word);
00384A  217A75     MOV #0x17A7, W5
00384C  784295     MOV.B [W5], W5
00384E  90024E     MOV [W14+8], W4
003850  784204     MOV.B W4, W4
003852  78011E     MOV [W14], W2
003854  784085     MOV.B W5, W1
003856  784004     MOV.B W4, W0
003858  07FE38     RCALL SendCommand
593:                 
594:                 command_string.data_state = COMMAND_BUFFER_EMPTY;
00385A  EB4200     CLR.B W4
00385C  780004     MOV W4, W0
00385E  B7F7AA     MOV.B WREG, .LSM672
595:               }
003860  FA8000     ULNK
003862  060000     RETURN
596:               
597:               
598:               
599:               unsigned int ReadFromRam(unsigned int ram_location) {
003864  FA0010     LNK #0x10
003866  BE9F88     MOV.D W8, [W15++]
003868  BE9F8A     MOV.D W10, [W15++]
00386A  980770     MOV W0, [W14+14]
600:                 unsigned long temp_long;
601:                 unsigned int data_return;
602:                 unsigned long long int temp_long_long;
603:                 switch (ram_location) 
00386C  90027E     MOV [W14+14], W4
00386E  B82361     MUL.UU W4, #1, W6
003870  EB8200     SETM W4
003872  EB8280     SETM W5
003874  420206     ADD W4, W6, W4
003876  4A8287     ADDC W5, W7, W5
003878  200B66     MOV #0xB6, W6
00387A  200007     MOV #0x0, W7
00387C  520F86     SUB W4, W6, [W15]
00387E  5A8F87     SUBB W5, W7, [W15]
003880  3E0297     BRA GTU, .L79, .LSM394
003882  016004     BRA W4
003884  370232     BRA .L80, .LSM333
003886  370236     BRA .L81, .LSM335
003888  370238     BRA .L82, .LSM337
00388A  37023C     BRA .L83, .LSM339
00388C  37023E     BRA .L84, .LSM341
00388E  370290     BRA .L79, .LSM394
003890  37028F     BRA .L79, .LSM394
003892  37028E     BRA .L79, .LSM394
003894  37028D     BRA .L79, .LSM394
003896  37028C     BRA .L79, .LSM394
003898  37028B     BRA .L79, .LSM394
00389A  37028A     BRA .L79, .LSM394
00389C  370289     BRA .L79, .LSM394
00389E  370288     BRA .L79, .LSM394
0038A0  370287     BRA .L79, .LSM394
0038A2  3700E1     BRA .L85, .LSM223
0038A4  3700DD     BRA .L86, .LSM221
0038A6  3700E9     BRA .L87, .LSM227
0038A8  3700E5     BRA .L88, .LSM225
0038AA  370282     BRA .L79, .LSM394
0038AC  370281     BRA .L79, .LSM394
0038AE  370280     BRA .L79, .LSM394
0038B0  37027F     BRA .L79, .LSM394
0038B2  37027E     BRA .L79, .LSM394
0038B4  37027D     BRA .L79, .LSM394
0038B6  37027C     BRA .L79, .LSM394
0038B8  37027B     BRA .L79, .LSM394
0038BA  37027A     BRA .L79, .LSM394
0038BC  370279     BRA .L79, .LSM394
0038BE  370278     BRA .L79, .LSM394
0038C0  370277     BRA .L79, .LSM394
0038C2  3700A8     BRA .L89, .LSM201
0038C4  3700B5     BRA .L90, .LSM205
0038C6  3700AD     BRA .L91, .LSM203
0038C8  3700B6     BRA .L92, .LSM207
0038CA  3700B8     BRA .L93, .LSM209
0038CC  3700BA     BRA .L94, .LSM211
0038CE  3700BC     BRA .L95, .LSM213
0038D0  3700BE     BRA .L96, .LSM215
0038D2  37026E     BRA .L79, .LSM394
0038D4  37026D     BRA .L79, .LSM394
0038D6  37026C     BRA .L79, .LSM394
0038D8  37026B     BRA .L79, .LSM394
0038DA  37026A     BRA .L79, .LSM394
0038DC  370269     BRA .L79, .LSM394
0038DE  370268     BRA .L79, .LSM394
0038E0  370267     BRA .L79, .LSM394
0038E2  37008E     BRA .L97, .LSM197
0038E4  370094     BRA .L98, .LSM199
0038E6  370085     BRA .L99, .LSM195
0038E8  370263     BRA .L79, .LSM394
0038EA  370262     BRA .L79, .LSM394
0038EC  370261     BRA .L79, .LSM394
0038EE  370260     BRA .L79, .LSM394
0038F0  37025F     BRA .L79, .LSM394
0038F2  37025E     BRA .L79, .LSM394
0038F4  37025D     BRA .L79, .LSM394
0038F6  37025C     BRA .L79, .LSM394
0038F8  37025B     BRA .L79, .LSM394
0038FA  37025A     BRA .L79, .LSM394
0038FC  370259     BRA .L79, .LSM394
0038FE  370258     BRA .L79, .LSM394
003900  370257     BRA .L79, .LSM394
003902  3700A8     BRA .L100, .LSM217
003904  370255     BRA .L79, .LSM394
003906  370254     BRA .L79, .LSM394
003908  370253     BRA .L79, .LSM394
00390A  370252     BRA .L79, .LSM394
00390C  370251     BRA .L79, .LSM394
00390E  370250     BRA .L79, .LSM394
003910  37024F     BRA .L79, .LSM394
003912  3700A3     BRA .L101, .LSM219
003914  37024D     BRA .L79, .LSM394
003916  37024C     BRA .L79, .LSM394
003918  37024B     BRA .L79, .LSM394
00391A  37024A     BRA .L79, .LSM394
00391C  370249     BRA .L79, .LSM394
00391E  370248     BRA .L79, .LSM394
003920  370247     BRA .L79, .LSM394
003922  370106     BRA .L102, .LSM253
003924  37010C     BRA .L103, .LSM255
003926  370244     BRA .L79, .LSM394
003928  370243     BRA .L79, .LSM394
00392A  370242     BRA .L79, .LSM394
00392C  370241     BRA .L79, .LSM394
00392E  37010E     BRA .L104, .LSM257
003930  37011A     BRA .L105, .LSM261
003932  370120     BRA .L106, .LSM264
003934  370122     BRA .L107, .LSM266
003936  370135     BRA .L108, .LSM270
003938  370148     BRA .L109, .LSM274
00393A  37015C     BRA .L110, .LSM278
00393C  370165     BRA .L111, .LSM281
00393E  370171     BRA .L112, .LSM285
003940  370237     BRA .L79, .LSM394
003942  370189     BRA .L113, .LSM289
003944  37018B     BRA .L114, .LSM291
003946  37018D     BRA .L115, .LSM293
003948  37018F     BRA .L116, .LSM295
00394A  370195     BRA .L117, .LSM297
00394C  37019B     BRA .L118, .LSM299
00394E  37019D     BRA .L119, .LSM301
003950  37019F     BRA .L120, .LSM303
003952  3701A1     BRA .L121, .LSM305
003954  37022D     BRA .L79, .LSM394
003956  37022C     BRA .L79, .LSM394
003958  37022B     BRA .L79, .LSM394
00395A  37022A     BRA .L79, .LSM394
00395C  370229     BRA .L79, .LSM394
00395E  370228     BRA .L79, .LSM394
003960  370227     BRA .L79, .LSM394
003962  370092     BRA .L122, .LSM229
003964  370098     BRA .L123, .LSM231
003966  37009E     BRA .L124, .LSM233
003968  3700A4     BRA .L125, .LSM235
00396A  3700AA     BRA .L126, .LSM237
00396C  3700B0     BRA .L127, .LSM239
00396E  370220     BRA .L79, .LSM394
003970  37021F     BRA .L79, .LSM394
003972  3700B4     BRA .L128, .LSM241
003974  3700BA     BRA .L129, .LSM243
003976  3700C0     BRA .L130, .LSM245
003978  3700C6     BRA .L131, .LSM247
00397A  3700CC     BRA .L132, .LSM249
00397C  3700D2     BRA .L133, .LSM251
00397E  370218     BRA .L79, .LSM394
003980  370217     BRA .L79, .LSM394
003982  370216     BRA .L79, .LSM394
003984  370215     BRA .L79, .LSM394
003986  370214     BRA .L79, .LSM394
003988  370213     BRA .L79, .LSM394
00398A  370212     BRA .L79, .LSM394
00398C  370211     BRA .L79, .LSM394
00398E  370210     BRA .L79, .LSM394
003990  37020F     BRA .L79, .LSM394
003992  37020E     BRA .L79, .LSM394
003994  37020D     BRA .L79, .LSM394
003996  37020C     BRA .L79, .LSM394
003998  37020B     BRA .L79, .LSM394
00399A  37020A     BRA .L79, .LSM394
00399C  370209     BRA .L79, .LSM394
00399E  370208     BRA .L79, .LSM394
0039A0  370207     BRA .L79, .LSM394
0039A2  37017C     BRA .L134, .LSM307
0039A4  37017E     BRA .L135, .LSM309
0039A6  370180     BRA .L136, .LSM311
0039A8  370182     BRA .L137, .LSM313
0039AA  370184     BRA .L138, .LSM315
0039AC  370186     BRA .L139, .LSM317
0039AE  370188     BRA .L140, .LSM319
0039B0  37018A     BRA .L141, .LSM321
0039B2  37018C     BRA .L142, .LSM323
0039B4  37018E     BRA .L143, .LSM325
0039B6  370190     BRA .L144, .LSM327
0039B8  370192     BRA .L145, .LSM329
0039BA  370194     BRA .L146, .LSM331
0039BC  3701F9     BRA .L79, .LSM394
0039BE  3701F8     BRA .L79, .LSM394
0039C0  3701F7     BRA .L79, .LSM394
0039C2  3701A6     BRA .L147, .LSM343
0039C4  3701A8     BRA .L148, .LSM345
0039C6  3701AA     BRA .L149, .LSM347
0039C8  3701AC     BRA .L150, .LSM349
0039CA  3701AE     BRA .L151, .LSM351
0039CC  3701B0     BRA .L152, .LSM353
0039CE  3701B2     BRA .L153, .LSM355
0039D0  3701B4     BRA .L154, .LSM357
0039D2  3701B6     BRA .L155, .LSM359
0039D4  3701BE     BRA .L156, .LSM365
0039D6  3701C9     BRA .L157, .LSM373
0039D8  3701C5     BRA .L158, .LSM371
0039DA  3701C1     BRA .L159, .LSM369
0039DC  3701BD     BRA .L160, .LSM367
0039DE  3701B3     BRA .L161, .LSM361
0039E0  3701B5     BRA .L162, .LSM363
0039E2  3701CE     BRA .L163, .LSM378
0039E4  3701D0     BRA .L164, .LSM380
0039E6  3701D2     BRA .L165, .LSM382
0039E8  3701D4     BRA .L166, .LSM384
0039EA  3701D6     BRA .L167, .LSM386
0039EC  3701D8     BRA .L168, .LSM388
0039EE  3701DA     BRA .L169, .LSM390
0039F0  3701DC     BRA .L170, .LSM392
604:                   {
605:               
606:                     // Magnet Supply Data
607:                   case RAM_READ_MAGNETRON_MAGNET_VOLTAGE_ADC:
608:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnet, ps_magnet.v_adc_reading);
0039F2  805574     MOV 0xAAE, W4
0039F4  780084     MOV W4, W1
0039F6  20A9E0     MOV #0xA9E, W0
0039F8  07027C     RCALL ReturnPowerSupplyADCScaledVoltage
0039FA  780200     MOV W0, W4
0039FC  780F04     MOV W4, [W14]
609:                     break;
0039FE  3701DB     BRA .L172, .LSM396
610:                     
611:                   case RAM_READ_MAGNETRON_MAGNET_CURRENT_ADC:
612:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnet, ps_magnet.i_adc_reading);
003A00  8056D4     MOV .LSM109, W4
003A02  780084     MOV W4, W1
003A04  20A9E0     MOV #0xA9E, W0
003A06  0702AB     RCALL ReturnPowerSupplyADCScaledCurrent
003A08  780200     MOV W0, W4
003A0A  780F04     MOV W4, [W14]
613:                     break;
003A0C  3701D4     BRA .L172, .LSM396
614:                     
615:                   case RAM_READ_MAGNETRON_MAGNET_CURRENT_SET_POINT:
616:                     data_return = ps_magnet.i_command_set_point;
003A0E  805661     MOV 0xACC, W1
003A10  780F01     MOV W1, [W14]
617:                     break;
003A12  3701D1     BRA .L172, .LSM396
618:               
619:               
620:                     // Filament Supply Data
621:                   case RAM_READ_MAGNETRON_FILAMENT_VOLTAGE_ADC:
622:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_filament, ps_filament.v_adc_reading);
003A14  805844     MOV 0xB08, W4
003A16  780084     MOV W4, W1
003A18  20AF80     MOV #0xAF8, W0
003A1A  07026B     RCALL ReturnPowerSupplyADCScaledVoltage
003A1C  780200     MOV W0, W4
003A1E  780F04     MOV W4, [W14]
623:                     break;
003A20  3701CA     BRA .L172, .LSM396
624:                     
625:                   case RAM_READ_MAGNETRON_FILAMENT_CURRENT_ADC:
626:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_filament, ps_filament.i_adc_reading);
003A22  8059A4     MOV 0xB34, W4
003A24  780084     MOV W4, W1
003A26  20AF80     MOV #0xAF8, W0
003A28  07029A     RCALL ReturnPowerSupplyADCScaledCurrent
003A2A  780200     MOV W0, W4
003A2C  780F04     MOV W4, [W14]
627:                     break;
003A2E  3701C3     BRA .L172, .LSM396
628:                     
629:                   case RAM_READ_MAGNETRON_FILAMENT_VOLTAGE_SET_POINT:
630:                     data_return = ps_filament.v_command_set_point;
003A30  8057D4     MOV 0xAFA, W4
003A32  780F04     MOV W4, [W14]
631:                     break;
003A34  3701C0     BRA .L172, .LSM396
632:               
633:                   case RAM_READ_MAGNETRON_FILAMENT_CURRENT_SET_POINT:
634:                     data_return = ps_filament.i_command_set_point;
003A36  805935     MOV 0xB26, W5
003A38  780F05     MOV W5, [W14]
635:                     break;
003A3A  3701BD     BRA .L172, .LSM396
636:               
637:                   case RAM_READ_MAGNETRON_FILAMENT_CONTROL_MODE:
638:                     data_return = magnetron_filament_control_mode;
003A3C  804378     MOV magnetron_filament_control_mode, W8
003A3E  780F08     MOV W8, [W14]
639:                     break;
003A40  3701BA     BRA .L172, .LSM396
640:               
641:                   case RAM_READ_MAGNETRON_FILAMENT_OFF_RESISTANCE:
642:                     data_return = magnetron_filament_off_resistance;
003A42  804389     MOV magnetron_filament_off_resistance, W9
003A44  780F09     MOV W9, [W14]
643:                     break;
003A46  3701B7     BRA .L172, .LSM396
644:               
645:                   case RAM_READ_MAGNETRON_FILAMENT_ON_RESISTANCE:
646:                     data_return = magnetron_filament_on_resistance;
003A48  80439A     MOV magnetron_filament_on_resistance, W10
003A4A  780F0A     MOV W10, [W14]
647:                     break;
003A4C  3701B4     BRA .L172, .LSM396
648:               
649:                   case RAM_READ_MAGNETRON_FILAMENT_MEASURED_RESISTANCE:
650:                     data_return = magnetron_filament_resistance_measurement;
003A4E  8043AB     MOV magnetron_filament_resistance_measurement, W11
003A50  780F0B     MOV W11, [W14]
651:                     break;
003A52  3701B1     BRA .L172, .LSM396
652:               
653:                     // Lambda Mode A Data
654:                   case RAM_READ_HV_LAMBDA_SET_POINT_MODE_A:
655:                     data_return = ps_hv_lambda_mode_A.v_command_set_point;
003A54  8049C1     MOV 0x938, W1
003A56  780F01     MOV W1, [W14]
656:                     break;
003A58  3701AE     BRA .L172, .LSM396
657:               
658:               
659:                     // Lambda Mode B Data
660:                   case RAM_READ_HV_LAMBDA_SET_POINT_MODE_B:
661:                     data_return = ps_hv_lambda_mode_B.v_command_set_point;
003A5A  804F64     MOV 0x9EC, W4
003A5C  780F04     MOV W4, [W14]
662:                     break;
003A5E  3701AB     BRA .L172, .LSM396
663:               
664:                     
665:                     // Thyratron Cathode Heater data
666:                   case RAM_READ_THYR_CATH_HTR_VOTAGE_SET_POINT:
667:                     data_return = ps_thyr_cathode_htr.v_command_set_point;
003A60  805AA5     MOV 0xB54, W5
003A62  780F05     MOV W5, [W14]
668:                     break;
003A64  3701A8     BRA .L172, .LSM396
669:                     
670:                   case RAM_READ_THYR_CATH_HTR_VOTAGE_ADC:
671:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_thyr_cathode_htr, ps_thyr_cathode_htr.v_adc_reading);
003A66  805B14     MOV 0xB62, W4
003A68  780084     MOV W4, W1
003A6A  20B520     MOV #0xB52, W0
003A6C  070242     RCALL ReturnPowerSupplyADCScaledVoltage
003A6E  780200     MOV W0, W4
003A70  780F04     MOV W4, [W14]
672:                     break;
003A72  3701A1     BRA .L172, .LSM396
673:               
674:               
675:                     // Thyratron Reservoir Heater data
676:                   case RAM_READ_THYR_RESER_HTR_VOLTAGE_SET_POINT:
677:                     data_return = ps_thyr_reservoir_htr.v_command_set_point;
003A74  805D78     MOV 0xBAE, W8
003A76  780F08     MOV W8, [W14]
678:                     break;
003A78  37019E     BRA .L172, .LSM396
679:                     
680:                   case RAM_READ_THYR_RESER_HTR_VOLTAGE_ADC:
681:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_thyr_reservoir_htr, ps_thyr_reservoir_htr.v_adc_reading);
003A7A  805DE4     MOV 0xBBC, W4
003A7C  780084     MOV W4, W1
003A7E  20BAC0     MOV #0xBAC, W0
003A80  070238     RCALL ReturnPowerSupplyADCScaledVoltage
003A82  780200     MOV W0, W4
003A84  780F04     MOV W4, [W14]
682:                     break;
003A86  370197     BRA .L172, .LSM396
683:                     
684:               
685:                     // PULSE MODE A DATA
686:                   case RAM_READ_PULSE_MODE_A_FILTERED_CURRENT:
687:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_reading);
003A88  804E64     MOV .LSM70, W4
003A8A  780084     MOV W4, W1
003A8C  209900     MOV #0x990, W0
003A8E  070267     RCALL ReturnPowerSupplyADCScaledCurrent
003A90  780200     MOV W0, W4
003A92  780F04     MOV W4, [W14]
688:                     break;
003A94  370190     BRA .L172, .LSM396
689:               
690:                   case RAM_READ_PULSE_MODE_A_FILTERED_VOLTAGE:
691:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_reading);
003A96  804D04     MOV .LSM63, W4
003A98  780084     MOV W4, W1
003A9A  209900     MOV #0x990, W0
003A9C  07022A     RCALL ReturnPowerSupplyADCScaledVoltage
003A9E  780200     MOV W0, W4
003AA0  780F04     MOV W4, [W14]
692:                     break;
003AA2  370189     BRA .L172, .LSM396
693:               
694:                   case RAM_READ_PULSE_MODE_A_MAX_CURRENT:
695:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_max_reading);
003AA4  804F34     MOV 0x9E6, W4
003AA6  780084     MOV W4, W1
003AA8  209900     MOV #0x990, W0
003AAA  070259     RCALL ReturnPowerSupplyADCScaledCurrent
003AAC  780200     MOV W0, W4
003AAE  780F04     MOV W4, [W14]
696:                     break;
003AB0  370182     BRA .L172, .LSM396
697:               
698:                   case RAM_READ_PULSE_MODE_A_MIN_CURRENT:
699:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_min_reading);
003AB2  804F44     MOV .LSM75, W4
003AB4  780084     MOV W4, W1
003AB6  209900     MOV #0x990, W0
003AB8  070252     RCALL ReturnPowerSupplyADCScaledCurrent
003ABA  780200     MOV W0, W4
003ABC  780F04     MOV W4, [W14]
700:                     break;
003ABE  37017B     BRA .L172, .LSM396
701:               
702:                  case RAM_READ_PULSE_MODE_A_MAX_VOLTAGE:
703:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_max_reading);
003AC0  804DD4     MOV 0x9BA, W4
003AC2  780084     MOV W4, W1
003AC4  209900     MOV #0x990, W0
003AC6  070215     RCALL ReturnPowerSupplyADCScaledVoltage
003AC8  780200     MOV W0, W4
003ACA  780F04     MOV W4, [W14]
704:                     break;
003ACC  370174     BRA .L172, .LSM396
705:               
706:                   case RAM_READ_PULSE_MODE_A_MIN_VOLTAGE:
707:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_min_reading);
003ACE  804DE4     MOV 0x9BC, W4
003AD0  780084     MOV W4, W1
003AD2  209900     MOV #0x990, W0
003AD4  07020E     RCALL ReturnPowerSupplyADCScaledVoltage
003AD6  780200     MOV W0, W4
003AD8  780F04     MOV W4, [W14]
708:                     break;
003ADA  37016D     BRA .L172, .LSM396
709:               
710:               
711:                   // PULSE MODE B DATA
712:                   case RAM_READ_PULSE_MODE_B_FILTERED_CURRENT:
713:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_reading);
003ADC  805404     MOV 0xA80, W4
003ADE  780084     MOV W4, W1
003AE0  20A440     MOV #0xA44, W0
003AE2  07023D     RCALL ReturnPowerSupplyADCScaledCurrent
003AE4  780200     MOV W0, W4
003AE6  780F04     MOV W4, [W14]
714:                     break;
003AE8  370166     BRA .L172, .LSM396
715:               
716:                   case RAM_READ_PULSE_MODE_B_FILTERED_VOLTAGE:
717:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_reading);
003AEA  8052A4     MOV 0xA54, W4
003AEC  780084     MOV W4, W1
003AEE  20A440     MOV #0xA44, W0
003AF0  070200     RCALL ReturnPowerSupplyADCScaledVoltage
003AF2  780200     MOV W0, W4
003AF4  780F04     MOV W4, [W14]
718:                     break;
003AF6  37015F     BRA .L172, .LSM396
719:               
720:                   case RAM_READ_PULSE_MODE_B_MAX_CURRENT:
721:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_max_reading);
003AF8  8054D4     MOV 0xA9A, W4
003AFA  780084     MOV W4, W1
003AFC  20A440     MOV #0xA44, W0
003AFE  07022F     RCALL ReturnPowerSupplyADCScaledCurrent
003B00  780200     MOV W0, W4
003B02  780F04     MOV W4, [W14]
722:                     break;
003B04  370158     BRA .L172, .LSM396
723:               
724:                   case RAM_READ_PULSE_MODE_B_MIN_CURRENT:
725:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_min_reading);
003B06  8054E4     MOV 0xA9C, W4
003B08  780084     MOV W4, W1
003B0A  20A440     MOV #0xA44, W0
003B0C  070228     RCALL ReturnPowerSupplyADCScaledCurrent
003B0E  780200     MOV W0, W4
003B10  780F04     MOV W4, [W14]
726:                     break;      
003B12  370151     BRA .L172, .LSM396
727:               
728:                   case RAM_READ_PULSE_MODE_B_MAX_VOLTAGE:
729:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_max_reading);
003B14  805374     MOV 0xA6E, W4
003B16  780084     MOV W4, W1
003B18  20A440     MOV #0xA44, W0
003B1A  0701EB     RCALL ReturnPowerSupplyADCScaledVoltage
003B1C  780200     MOV W0, W4
003B1E  780F04     MOV W4, [W14]
730:                     break;     
003B20  37014A     BRA .L172, .LSM396
731:               
732:                   case RAM_READ_PULSE_MODE_B_MIN_VOLTAGE:
733:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_min_reading);
003B22  805384     MOV 0xA70, W4
003B24  780084     MOV W4, W1
003B26  20A440     MOV #0xA44, W0
003B28  0701E4     RCALL ReturnPowerSupplyADCScaledVoltage
003B2A  780200     MOV W0, W4
003B2C  780F04     MOV W4, [W14]
734:                     break;
003B2E  370143     BRA .L172, .LSM396
735:               
736:               
737:                     // Magnetron Data
738:                   case RAM_READ_PREVIOUS_PULSE_MAGNETRON_VOLTAGE_ADC:
739:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, pulse_magnetron_voltage_adc_reading);
003B30  8043C4     MOV pulse_magnetron_voltage_adc_reading, W4
003B32  780084     MOV W4, W1
003B34  209900     MOV #0x990, W0
003B36  0701DD     RCALL ReturnPowerSupplyADCScaledVoltage
003B38  780200     MOV W0, W4
003B3A  780F04     MOV W4, [W14]
740:                     break;
003B3C  37013C     BRA .L172, .LSM396
741:                     
742:                   case RAM_READ_PREVIOUS_PULSE_MAGNETRON_CURRENT_ADC:
743:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, pulse_magnetron_current_adc_reading);
003B3E  8043B4     MOV pulse_magnetron_current_adc_reading, W4
003B40  780084     MOV W4, W1
003B42  209900     MOV #0x990, W0
003B44  07020C     RCALL ReturnPowerSupplyADCScaledCurrent
003B46  780200     MOV W0, W4
003B48  780F04     MOV W4, [W14]
744:                     break;
003B4A  370135     BRA .L172, .LSM396
745:               
746:               
747:               
748:                     // Counter Data 
749:                   case RAM_READ_ARC_COUNTER_PERSISTENT_HIGH_WORD:
750:                     temp_long = arc_counter_persistent;
003B4C  80BD6A     MOV arc_counter_persistent, W10
003B4E  80BD7B     MOV 0x17AE, W11
003B50  98071A     MOV W10, [W14+2]
003B52  98072B     MOV W11, [W14+4]
751:                     temp_long = temp_long >> 16;
003B54  90021E     MOV [W14+2], W4
003B56  9002AE     MOV [W14+4], W5
003B58  DE2A40     LSR W5, #0, W4
003B5A  200005     MOV #0x0, W5
003B5C  980714     MOV W4, [W14+2]
003B5E  980725     MOV W5, [W14+4]
752:                     data_return = temp_long;
003B60  90059E     MOV [W14+2], W11
003B62  780F0B     MOV W11, [W14]
753:                     break;
003B64  370128     BRA .L172, .LSM396
754:                     
755:                   case RAM_READ_ARC_COUNTER_PERSISTENT_LOW_WORD:
756:                     temp_long = arc_counter_persistent;
003B66  80BD64     MOV arc_counter_persistent, W4
003B68  80BD75     MOV 0x17AE, W5
003B6A  980714     MOV W4, [W14+2]
003B6C  980725     MOV W5, [W14+4]
757:                     data_return = temp_long;
003B6E  90029E     MOV [W14+2], W5
003B70  780F05     MOV W5, [W14]
758:                     break;
003B72  370121     BRA .L172, .LSM396
759:                     
760:                   case RAM_READ_ARC_COUNTER_THIS_HV_ON:
761:                     data_return = arc_counter_this_hv_on;
003B74  80BE18     MOV arc_counter_this_hv_on, W8
003B76  780F08     MOV W8, [W14]
762:                     break;
003B78  37011E     BRA .L172, .LSM396
763:                     
764:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_3_MSB:
765:                     temp_long_long = pulse_counter_persistent;
003B7A  2179E4     MOV #0x179E, W4
003B7C  BE0434     MOV.D [W4++], W8
003B7E  BE0524     MOV.D [W4--], W10
003B80  980738     MOV W8, [W14+6]
003B82  980749     MOV W9, [W14+8]
003B84  98075A     MOV W10, [W14+10]
003B86  98076B     MOV W11, [W14+12]
766:                     temp_long_long = temp_long_long >> 48;
003B88  90023E     MOV [W14+6], W4
003B8A  9002CE     MOV [W14+8], W5
003B8C  90035E     MOV [W14+10], W6
003B8E  9003EE     MOV [W14+12], W7
003B90  B83A61     MUL.UU W7, #1, W4
003B92  B83360     MUL.UU W6, #0, W6
003B94  980734     MOV W4, [W14+6]
003B96  980745     MOV W5, [W14+8]
003B98  980756     MOV W6, [W14+10]
003B9A  980767     MOV W7, [W14+12]
767:                     data_return = temp_long_long;
003B9C  90053E     MOV [W14+6], W10
003B9E  780F0A     MOV W10, [W14]
768:                     break;
003BA0  37010A     BRA .L172, .LSM396
769:                     
770:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_2:
771:                     temp_long_long = pulse_counter_persistent;
003BA2  2179E4     MOV #0x179E, W4
003BA4  BE0434     MOV.D [W4++], W8
003BA6  BE0524     MOV.D [W4--], W10
003BA8  980738     MOV W8, [W14+6]
003BAA  980749     MOV W9, [W14+8]
003BAC  98075A     MOV W10, [W14+10]
003BAE  98076B     MOV W11, [W14+12]
772:                     temp_long_long = temp_long_long >> 32;
003BB0  90023E     MOV [W14+6], W4
003BB2  9002CE     MOV [W14+8], W5
003BB4  90035E     MOV [W14+10], W6
003BB6  9003EE     MOV [W14+12], W7
003BB8  BE0206     MOV.D W6, W4
003BBA  B83360     MUL.UU W6, #0, W6
003BBC  980734     MOV W4, [W14+6]
003BBE  980745     MOV W5, [W14+8]
003BC0  980756     MOV W6, [W14+10]
003BC2  980767     MOV W7, [W14+12]
773:                     data_return = temp_long_long;
003BC4  90053E     MOV [W14+6], W10
003BC6  780F0A     MOV W10, [W14]
774:                     break;
003BC8  3700F6     BRA .L172, .LSM396
775:                     
776:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_1:
777:                     temp_long_long = pulse_counter_persistent;
003BCA  2179E4     MOV #0x179E, W4
003BCC  BE0434     MOV.D [W4++], W8
003BCE  BE0524     MOV.D [W4--], W10
003BD0  980738     MOV W8, [W14+6]
003BD2  980749     MOV W9, [W14+8]
003BD4  98075A     MOV W10, [W14+10]
003BD6  98076B     MOV W11, [W14+12]
778:                     temp_long_long = temp_long_long >> 16;
003BD8  90023E     MOV [W14+6], W4
003BDA  9002CE     MOV [W14+8], W5
003BDC  90035E     MOV [W14+10], W6
003BDE  9003EE     MOV [W14+12], W7
003BE0  780205     MOV W5, W4
003BE2  780286     MOV W6, W5
003BE4  B83B61     MUL.UU W7, #1, W6
003BE6  980734     MOV W4, [W14+6]
003BE8  980745     MOV W5, [W14+8]
003BEA  980756     MOV W6, [W14+10]
003BEC  980767     MOV W7, [W14+12]
779:                     data_return = temp_long_long;
003BEE  90053E     MOV [W14+6], W10
003BF0  780F0A     MOV W10, [W14]
780:                     break;
003BF2  3700E1     BRA .L172, .LSM396
781:                     
782:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_0_LSB:
783:                     temp_long_long = pulse_counter_persistent;
003BF4  2179E4     MOV #0x179E, W4
003BF6  BE0434     MOV.D [W4++], W8
003BF8  BE0524     MOV.D [W4--], W10
003BFA  980738     MOV W8, [W14+6]
003BFC  980749     MOV W9, [W14+8]
003BFE  98075A     MOV W10, [W14+10]
003C00  98076B     MOV W11, [W14+12]
784:                     data_return = temp_long_long;
003C02  9004BE     MOV [W14+6], W9
003C04  780F09     MOV W9, [W14]
785:                     break;
003C06  3700D7     BRA .L172, .LSM396
786:                     
787:                   case RAM_READ_PULSE_COUNTER_THIS_HV_ON_HIGH_WORD:
788:                     temp_long = pulse_counter_this_hv_on;
003C08  80BD8A     MOV pulse_counter_this_hv_on, W10
003C0A  80BD9B     MOV 0x17B2, W11
003C0C  98071A     MOV W10, [W14+2]
003C0E  98072B     MOV W11, [W14+4]
789:                     temp_long = temp_long >> 16;
003C10  90021E     MOV [W14+2], W4
003C12  9002AE     MOV [W14+4], W5
003C14  DE2A40     LSR W5, #0, W4
003C16  200005     MOV #0x0, W5
003C18  980714     MOV W4, [W14+2]
003C1A  980725     MOV W5, [W14+4]
790:                     data_return = temp_long;
003C1C  90059E     MOV [W14+2], W11
003C1E  780F0B     MOV W11, [W14]
791:                     break;
003C20  3700CA     BRA .L172, .LSM396
792:                     
793:                   case RAM_READ_PULSE_COUNTER_THIS_HV_ON_LOW_WORD:
794:                     temp_long = pulse_counter_this_hv_on;
003C22  80BD84     MOV pulse_counter_this_hv_on, W4
003C24  80BD95     MOV 0x17B2, W5
003C26  980714     MOV W4, [W14+2]
003C28  980725     MOV W5, [W14+4]
795:                     temp_long &= 0x0000FFFF;
003C2A  90031E     MOV [W14+2], W6
003C2C  9003AE     MOV [W14+4], W7
003C2E  2FFFF4     MOV #0xFFFF, W4
003C30  200005     MOV #0x0, W5
003C32  780006     MOV W6, W0
003C34  780307     MOV W7, W6
003C36  780384     MOV W4, W7
003C38  780205     MOV W5, W4
003C3A  600007     AND W0, W7, W0
003C3C  630204     AND W6, W4, W4
003C3E  200005     MOV #0x0, W5
003C40  DD22C0     SL W4, #0, W5
003C42  200004     MOV #0x0, W4
003C44  BE0304     MOV.D W4, W6
003C46  B80261     MUL.UU W0, #1, W4
003C48  730304     IOR W6, W4, W6
003C4A  738385     IOR W7, W5, W7
003C4C  980716     MOV W6, [W14+2]
003C4E  980727     MOV W7, [W14+4]
796:                     data_return = temp_long;
003C50  90029E     MOV [W14+2], W5
003C52  780F05     MOV W5, [W14]
797:                     break;
003C54  3700B0     BRA .L172, .LSM396
798:                     
799:               
800:                     // Power information
801:                   case RAM_READ_AVERAGE_PULSE_ENERGY:
802:                     data_return = average_energy_per_pulse_milli_joules;
003C56  804288     MOV average_energy_per_pulse_milli_joules, W8
003C58  780F08     MOV W8, [W14]
803:                     break;
003C5A  3700AD     BRA .L172, .LSM396
804:               
805:                   case RAM_READ_AVERAGE_PULSE_FREQUENCY:
806:                     data_return = prf_deciherz;
003C5C  8041F9     MOV prf_deciherz, W9
003C5E  780F09     MOV W9, [W14]
807:                     break;
003C60  3700AA     BRA .L172, .LSM396
808:               
809:                   case RAM_READ_AVERAGE_MAGNETRON_INPUT_POWER:
810:                     data_return = average_output_power_watts;
003C62  80429A     MOV average_output_power_watts, W10
003C64  780F0A     MOV W10, [W14]
811:                     break;
003C66  3700A7     BRA .L172, .LSM396
812:               
813:                   case RAM_READ_HV_LAMBDA_VPEAK_ADC:
814:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_hv_lambda_mode_A, ps_hv_lambda_mode_A.v_adc_reading);
003C68  804A34     MOV .LSM52, W4
003C6A  780084     MOV W4, W1
003C6C  209360     MOV #0x936, W0
003C6E  070141     RCALL ReturnPowerSupplyADCScaledVoltage
003C70  780200     MOV W0, W4
003C72  780F04     MOV W4, [W14]
815:                     break;
003C74  3700A0     BRA .L172, .LSM396
816:               
817:                   case RAM_READ_HV_LAMBDA_VMON_ADC:
818:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_hv_lambda_mode_B, ps_hv_lambda_mode_B.v_adc_reading);
003C76  804FD4     MOV 0x9FA, W4
003C78  780084     MOV W4, W1
003C7A  209EA0     MOV #0x9EA, W0
003C7C  07013A     RCALL ReturnPowerSupplyADCScaledVoltage
003C7E  780200     MOV W0, W4
003C80  780F04     MOV W4, [W14]
819:                     break;
003C82  370099     BRA .L172, .LSM396
820:                     
821:                   case RAM_READ_FILAMENT_OFFSET:
822:                     data_return = (unsigned int)look_up_offset;
003C84  8040E4     MOV look_up_offset, W4
003C86  780F04     MOV W4, [W14]
823:                     break;
003C88  370096     BRA .L172, .LSM396
824:               
825:                   case RAM_READ_OPERATION_MODE:
826:                     data_return = operation_mode;
003C8A  80B86B     MOV operation_mode, W11
003C8C  780F0B     MOV W11, [W14]
827:                     break;
003C8E  370093     BRA .L172, .LSM396
828:               
829:                   case RAM_READ_SCALE_INTERLEAVED:
830:                     data_return = scale_interleaved;
003C90  80B871     MOV scale_interleaved, W1
003C92  780F01     MOV W1, [W14]
831:                     break;
003C94  370090     BRA .L172, .LSM396
832:               
833:                   case RAM_READ_SCALE_LOW_ENERGY:
834:                     data_return = scale_low_energy;
003C96  80B884     MOV scale_low_energy, W4
003C98  780F04     MOV W4, [W14]
835:               	break;
003C9A  37008D     BRA .L172, .LSM396
836:               
837:                     // Fault information
838:                   case RAM_READ_DEBUG_STATUS_REG:
839:                     data_return = debug_status_register;
003C9C  80B9F5     MOV debug_status_register, W5
003C9E  780F05     MOV W5, [W14]
840:                     break;
003CA0  37008A     BRA .L172, .LSM396
841:               
842:                   case RAM_READ_FAULT_MAGNETRON_FAULT_REG:
843:                     data_return = faults_magnetron_fault_reg;
003CA2  80BA18     MOV faults_magnetron_fault_reg, W8
003CA4  780F08     MOV W8, [W14]
844:                     break;
003CA6  370087     BRA .L172, .LSM396
845:               
846:                   case RAM_READ_FAULT_MAGNETRON_STATUS_REG:
847:                     data_return = faults_magnetron_status_reg;
003CA8  80BA09     MOV faults_magnetron_status_reg, W9
003CAA  780F09     MOV W9, [W14]
848:                     break;
003CAC  370084     BRA .L172, .LSM396
849:               
850:                   case RAM_READ_FAULT_MAGNETRON_WARNING_REG:
851:                     data_return = faults_magnetron_warning_reg;
003CAE  80BA2A     MOV faults_magnetron_warning_reg, W10
003CB0  780F0A     MOV W10, [W14]
852:                     break;
003CB2  370081     BRA .L172, .LSM396
853:               
854:                   case RAM_READ_FAULT_HIGH_VOLTAGE_FAULT_REG:
855:                     data_return = faults_high_voltage_fault_reg;
003CB4  80BA4B     MOV faults_high_voltage_fault_reg, W11
003CB6  780F0B     MOV W11, [W14]
856:                     break;
003CB8  37007E     BRA .L172, .LSM396
857:               
858:                   case RAM_READ_FAULT_HIGH_VOLTAGE_STATUS_REG:
859:                     data_return = faults_high_voltage_status_reg;
003CBA  80BA31     MOV faults_high_voltage_status_reg, W1
003CBC  780F01     MOV W1, [W14]
860:                     break;
003CBE  37007B     BRA .L172, .LSM396
861:               
862:                   case RAM_READ_FAULT_HIGH_VOLTAGE_WARNING_REG:
863:                     data_return = faults_high_voltage_warning_reg;
003CC0  80BA54     MOV faults_high_voltage_warning_reg, W4
003CC2  780F04     MOV W4, [W14]
864:                     break;
003CC4  370078     BRA .L172, .LSM396
865:               
866:                   case RAM_READ_FAULT_THYRATRON_FAULT_REG:
867:                     data_return = faults_thyratron_fault_reg;
003CC6  80BAD5     MOV faults_thyratron_fault_reg, W5
003CC8  780F05     MOV W5, [W14]
868:                     break;
003CCA  370075     BRA .L172, .LSM396
869:               
870:                   case RAM_READ_FAULT_THYRATRON_STATUS_REG:
871:                     data_return = faults_thyratron_status_reg;
003CCC  80BAC8     MOV faults_thyratron_status_reg, W8
003CCE  780F08     MOV W8, [W14]
872:                     break;
003CD0  370072     BRA .L172, .LSM396
873:               
874:                   case RAM_READ_FAULT_THYRATRON_WARNING_REG:
875:                     data_return = faults_thyratron_warning_reg;
003CD2  80BAE9     MOV faults_thyratron_warning_reg, W9
003CD4  780F09     MOV W9, [W14]
876:                     break;
003CD6  37006F     BRA .L172, .LSM396
877:               
878:                   case RAM_READ_FAULT_CONTROL_BOARD_FAULT_REG:
879:                     data_return = faults_control_board_fault_reg;
003CD8  80BB0A     MOV faults_control_board_fault_reg, W10
003CDA  780F0A     MOV W10, [W14]
880:                     break;
003CDC  37006C     BRA .L172, .LSM396
881:               
882:                   case RAM_READ_FAULT_CONTROL_BOARD_STATUS_REG:
883:                     data_return = faults_control_board_status_reg;
003CDE  80BAFB     MOV faults_control_board_status_reg, W11
003CE0  780F0B     MOV W11, [W14]
884:                     break;
003CE2  370069     BRA .L172, .LSM396
885:               
886:                   case RAM_READ_FAULT_CONTROL_BOARD_WARNING_REG:
887:                     data_return = faults_control_board_warning_reg;
003CE4  80BB11     MOV faults_control_board_warning_reg, W1
003CE6  780F01     MOV W1, [W14]
888:                     break;
003CE8  370066     BRA .L172, .LSM396
889:                     
890:                     
891:                     // Read Status
892:                   case RAM_READ_STATE:
893:                     data_return = control_state;
003CEA  208584     MOV #0x858, W4
003CEC  784214     MOV.B [W4], W4
003CEE  FB8204     ZE W4, W4
003CF0  780F04     MOV W4, [W14]
894:                     break;
003CF2  370061     BRA .L172, .LSM396
895:                     
896:                   case RAM_READ_VERSION:
897:                     data_return = VERSION_NUMBER;
003CF4  203784     MOV #0x378, W4
003CF6  780F04     MOV W4, [W14]
898:                     break;
003CF8  37005E     BRA .L172, .LSM396
899:               
900:                   case RAM_READ_LOCAL_REMOTE_MAGNET_CURRENT_CONTROL:
901:                     data_return = ram_config_set_magnetron_magnet_current_from_GUI;
003CFA  208444     MOV #0x844, W4
003CFC  784214     MOV.B [W4], W4
003CFE  FB8204     ZE W4, W4
003D00  780F04     MOV W4, [W14]
902:                     break;
003D02  370059     BRA .L172, .LSM396
903:                     
904:                   case RAM_READ_MAGNETRON_TYPE:
905:               #ifdef __MG7095
906:                     data_return = 7095;
003D04  21BB74     MOV #0x1BB7, W4
003D06  780F04     MOV W4, [W14]
907:               #else
908:                     data_return = 5193;
909:               #endif
910:                     break;
003D08  370056     BRA .L172, .LSM396
911:                  
912:                   case RAM_READ_CONTROL_BOARD_TYPE:
913:               #ifndef __A36760
914:                     data_return = 34760;
915:               #else
916:                     data_return = 36760;
003D0A  28F984     MOV #0x8F98, W4
003D0C  780F04     MOV W4, [W14]
917:               #endif
918:                     break;
003D0E  370053     BRA .L172, .LSM396
919:                     
920:                     
921:                     // Read Bedug Counters
922:                     
923:                   case RAM_READ_COUNT_MAGNETRON_CURRENT_ADC_GLITCH:
924:                     data_return = eeprom_write_failure_count;
003D10  804084     MOV eeprom_write_failure_count, W4
003D12  780F04     MOV W4, [W14]
925:                     break;
003D14  370050     BRA .L172, .LSM396
926:                     
927:                   case RAM_READ_COUNT_MAGNETRON_VOLTAGE_ADC_GLITCH:
928:                     data_return = eeprom_read_failure_count;
003D16  8040A5     MOV eeprom_read_failure_count, W5
003D18  780F05     MOV W5, [W14]
929:                     break;
003D1A  37004D     BRA .L172, .LSM396
930:                     
931:                   case RAM_READ_COUNT_I2C_BUS_ERROR:
932:                     data_return = pac_2_adc_reading;
003D1C  8042E8     MOV pac_2_adc_reading, W8
003D1E  780F08     MOV W8, [W14]
933:                     break;
003D20  37004A     BRA .L172, .LSM396
934:                     
935:                   case RAM_READ_COUNT_SPI1_BUS_ERROR:
936:                     data_return = default_pac_2_adc_reading;
003D22  8040F9     MOV default_pac_2_adc_reading, W9
003D24  780F09     MOV W9, [W14]
937:                     break;
003D26  370047     BRA .L172, .LSM396
938:                     
939:                   case RAM_READ_COUNT_SPI2_BUS_ERROR:
940:                     data_return = pac_1_adc_reading;
003D28  8042DA     MOV pac_1_adc_reading, W10
003D2A  780F0A     MOV W10, [W14]
941:                     break;
003D2C  370044     BRA .L172, .LSM396
942:                     
943:                   case RAM_READ_COUNT_EXTERNAL_ADC_FALSE_TRIGGER:
944:                     data_return = global_debug_counter.external_adc_false_trigger;
003D2E  80B99B     MOV .LSM632, W11
003D30  780F0B     MOV W11, [W14]
945:                     break;
003D32  370041     BRA .L172, .LSM396
946:               
947:                   case RAM_READ_COUNT_LTC2656_WRITE_ERROR:
948:                     data_return = global_debug_counter.LTC2656_write_error;
003D34  80B9A1     MOV .LSM633, W1
003D36  780F01     MOV W1, [W14]
949:                     break;
003D38  37003E     BRA .L172, .LSM396
950:                     
951:                   case RAM_READ_COUNT_SETPOINT_NOT_VALID:
952:                     data_return = global_debug_counter.setpoint_not_valid;
003D3A  80B9B4     MOV .LSM634, W4
003D3C  780F04     MOV W4, [W14]
953:                     break;
003D3E  37003B     BRA .L172, .LSM396
954:                     
955:                   case RAM_READ_COUNT_SCALE16BIT_SATURATION:
956:                     data_return = global_debug_counter.scale16bit_saturation;
003D40  80B9C5     MOV .LSM635, W5
003D42  780F05     MOV W5, [W14]
957:                     break;
003D44  370038     BRA .L172, .LSM396
958:               
959:                   case RAM_READ_LAST_OSCCON_BEFORE_CRASH:
960:                     //data_return = last_osccon;
961:                     data_return = timing_error_int1_count;
003D46  804208     MOV timing_error_int1_count, W8
003D48  780F08     MOV W8, [W14]
962:                     break;
003D4A  370035     BRA .L172, .LSM396
963:               
964:                   case RAM_READ_PULSE_LATCH_RESET_ERROR:
965:                     data_return = global_debug_counter.pulse_latch_reset_error;
003D4C  80B9E9     MOV .LSM637, W9
003D4E  780F09     MOV W9, [W14]
966:                     break;
003D50  370032     BRA .L172, .LSM396
967:               
968:                   case RAM_READ_COUNT_REVERSESCALE16BIT_SATURATION:
969:                     data_return = global_debug_counter.reversescale16bit_saturation;
003D52  80B9DA     MOV .LSM636, W10
003D54  780F0A     MOV W10, [W14]
970:                     break;
003D56  37002F     BRA .L172, .LSM396
971:               
972:                   case RAM_READ_COUNT_LVD_INTERRUPT:
973:                     data_return = eoc_counts_total; // should be lvdinterrupt_counter;
003D58  80BABB     MOV eoc_counts_total, W11
003D5A  780F0B     MOV W11, [W14]
974:                     break;
003D5C  37002C     BRA .L172, .LSM396
975:               
976:                   case RAM_READ_LAST_ACTION_BEFORE_CRASH:
977:                     data_return = previous_last_action;
003D5E  804231     MOV previous_last_action, W1
003D60  780F01     MOV W1, [W14]
978:                     break;
003D62  370029     BRA .L172, .LSM396
979:               
980:                   case RAM_READ_COUNT_PROCESSOR_CRASH:
981:                     data_return = processor_crash_count;
003D64  80BE04     MOV processor_crash_count, W4
003D66  780F04     MOV W4, [W14]
982:                     break;
003D68  370026     BRA .L172, .LSM396
983:                     
984:                   case RAM_READ_COUNT_TIMING_ERROR_INT1:
985:                     //data_return = timing_error_int1_count;
986:                     if (PIN_GANTRY_PORTAL_SELECT == ILL_GANTRY_MODE) {
003D6A  801735     MOV PORTG, W5
003D6C  280004     MOV #0x8000, W4
003D6E  628204     AND W5, W4, W4
003D70  520FE0     SUB W4, #0x0, [W15]
003D72  3A0003     BRA NZ, .L173, .LSM376
987:               	data_return = 1;
003D74  200014     MOV #0x1, W4
003D76  780F04     MOV W4, [W14]
988:                     } else {
989:               	data_return = 0;
003D7A  EB0200     CLR W4
003D7C  780F04     MOV W4, [W14]
990:                     }
991:               
992:                     break;
003D78  37001E     BRA .L172, .LSM396
003D7E  37001B     BRA .L172, .LSM396
993:               
994:               
995:                   case RAM_READ_HIGH_TARGET_CURRENT_SET_POINT:
996:                     data_return = linac_high_energy_target_current_set_point;
003D80  804155     MOV linac_high_energy_target_current_set_point, W5
003D82  780F05     MOV W5, [W14]
997:                     break;
003D84  370018     BRA .L172, .LSM396
998:               
999:                   case RAM_READ_LOW_TARGET_CURRENT_SET_POINT:
1000:                    data_return = linac_low_energy_target_current_set_point;
003D86  804178     MOV linac_low_energy_target_current_set_point, W8
003D88  780F08     MOV W8, [W14]
1001:                    break;
003D8A  370015     BRA .L172, .LSM396
1002:              
1003:                  case RAM_READ_HIGH_TARGET_CURRENT_READING:
1004:                    data_return = linac_high_energy_target_current_adc_reading;
003D8C  804149     MOV linac_high_energy_target_current_adc_reading, W9
003D8E  780F09     MOV W9, [W14]
1005:                    break;
003D90  370012     BRA .L172, .LSM396
1006:              
1007:                  case RAM_READ_LOW_TARGET_CURRENT_READING:
1008:                    data_return = linac_low_energy_target_current_adc_reading;
003D92  80416A     MOV linac_low_energy_target_current_adc_reading, W10
003D94  780F0A     MOV W10, [W14]
1009:                    break;
003D96  37000F     BRA .L172, .LSM396
1010:              
1011:                  case RAM_READ_TARGET_ADJUST_MAX_PULSES:
1012:                    data_return = low_energy_target_current_startup_adjust_decay_time_pulses;
003D98  80BCDB     MOV 0x179A, W11
003D9A  780F0B     MOV W11, [W14]
1013:                    break;
003D9C  37000C     BRA .L172, .LSM396
1014:                    
1015:                  case RAM_READ_TARGET_ADJUST_MAX_MAGNITUDE:
1016:                    data_return = max_low_energy_target_current_startup_adjust_initital_value;
003D9E  80BCB1     MOV 0x1796, W1
003DA0  780F01     MOV W1, [W14]
1017:                    break;
003DA2  370009     BRA .L172, .LSM396
1018:              
1019:                  case RAM_READ_TARGET_ADJUST_MAX_COOLDOWN:
1020:                    data_return = low_energy_target_current_startup_max_cooldown;
003DA4  80BCC4     MOV 0x1798, W4
003DA6  780F04     MOV W4, [W14]
1021:                    break;
003DA8  370006     BRA .L172, .LSM396
1022:              
1023:                  case RAM_READ_TARGET_ADJUST_INITIAL_MAGNITUDE:
1024:                    data_return = low_energy_target_current_startup_adjust_initital_value;
003DAA  804105     MOV low_energy_target_current_startup_adjust_initital_value, W5
003DAC  780F05     MOV W5, [W14]
1025:                    break;
003DAE  370003     BRA .L172, .LSM396
1026:              
1027:                  default:
1028:                    data_return = 0;
003DB0  EB0200     CLR W4
003DB2  780F04     MOV W4, [W14]
1029:                    break;
003DB4  000000     NOP
1030:                    
1031:                  }
1032:                
1033:                return data_return;
003DB6  78021E     MOV [W14], W4
1034:              }
003DB8  780004     MOV W4, W0
003DBA  BE054F     MOV.D [--W15], W10
003DBC  BE044F     MOV.D [--W15], W8
003DBE  FA8000     ULNK
003DC0  060000     RETURN
1035:              
1036:              
1037:              unsigned int MakeCRC(unsigned char command_byte, unsigned char register_byte, unsigned int data_word) {
003DC2  FA0006     LNK #0x6
003DC4  984720     MOV.B W0, [W14+2]
003DC6  984731     MOV.B W1, [W14+3]
003DC8  980722     MOV W2, [W14+4]
1038:                unsigned int crc;
1039:                crc = SYNC_BYTE_1 + SYNC_BYTE_2 + SYNC_BYTE_3_SEND;
003DCA  202D74     MOV #0x2D7, W4
003DCC  780F04     MOV W4, [W14]
1040:                crc += command_byte + register_byte;
003DCE  90422E     MOV.B [W14+2], W4
003DD0  FB8284     ZE W4, W5
003DD2  90423E     MOV.B [W14+3], W4
003DD4  FB8204     ZE W4, W4
003DD6  428204     ADD W5, W4, W4
003DD8  420F1E     ADD W4, [W14], [W14]
1041:                crc += (data_word >> 8);
003DDA  90022E     MOV [W14+4], W4
003DDC  DE2248     LSR W4, #8, W4
003DDE  420F1E     ADD W4, [W14], [W14]
1042:                crc += (data_word & 0x00FF);
003DE0  9002AE     MOV [W14+4], W5
003DE2  200FF4     MOV #0xFF, W4
003DE4  628204     AND W5, W4, W4
003DE6  420F1E     ADD W4, [W14], [W14]
1043:                
1044:                return crc;
003DE8  78021E     MOV [W14], W4
1045:                // DPAKRER Make real CRC
1046:              }
003DEA  780004     MOV W4, W0
003DEC  FA8000     ULNK
003DEE  060000     RETURN
1047:              
1048:              
1049:              unsigned char CheckCRC(unsigned int crc) {
003DF0  FA0004     LNK #0x4
003DF2  980710     MOV W0, [W14+2]
1050:                unsigned int crcCheck;
1051:                // At the moment the CRC is just a checksum
1052:                crcCheck = SYNC_BYTE_1 + SYNC_BYTE_2 + SYNC_BYTE_3_RECEIVE; 
003DF4  202D64     MOV #0x2D6, W4
003DF6  780F04     MOV W4, [W14]
1053:                crcCheck += command_string.command_byte + command_string.register_byte;
003DF8  217A64     MOV #0x17A6, W4
003DFA  784214     MOV.B [W4], W4
003DFC  FB8284     ZE W4, W5
003DFE  217A74     MOV #0x17A7, W4
003E00  784214     MOV.B [W4], W4
003E02  FB8204     ZE W4, W4
003E04  428204     ADD W5, W4, W4
003E06  420F1E     ADD W4, [W14], [W14]
1054:                crcCheck += command_string.data_high_byte + command_string.data_low_byte;
003E08  217A84     MOV #0x17A8, W4
003E0A  784214     MOV.B [W4], W4
003E0C  FB8284     ZE W4, W5
003E0E  217A94     MOV #0x17A9, W4
003E10  784214     MOV.B [W4], W4
003E12  FB8204     ZE W4, W4
003E14  428204     ADD W5, W4, W4
003E16  420F1E     ADD W4, [W14], [W14]
1055:                if (crcCheck == crc) {
003E18  90021E     MOV [W14+2], W4
003E1A  78029E     MOV [W14], W5
003E1C  528F84     SUB W5, W4, [W15]
003E1E  3A0002     BRA NZ, .L177, .LSM411
1056:                  return 1;
003E20  B3C014     MOV.B #0x1, W4
003E22  370001     BRA .L178, .LSM412
1057:                } else {
1058:                  return 0;
003E24  EB4200     CLR.B W4
1059:                }
1060:                // DPARKER make Real CRC
1061:              
1062:              }
003E26  784004     MOV.B W4, W0
003E28  FA8000     ULNK
003E2A  060000     RETURN
1063:              
1064:              
1065:              
1066:              void _ISRNOPSV _U1RXInterrupt(void) {
003E2C  F80036     PUSH RCOUNT
003E2E  BE9F80     MOV.D W0, [W15++]
003E30  BE9F82     MOV.D W2, [W15++]
003E32  BE9F84     MOV.D W4, [W15++]
003E34  BE9F86     MOV.D W6, [W15++]
003E36  FA0000     LNK #0x0
1067:                _U1RXIF = 0;
003E38  A92085     BCLR 0x85, #1
1068:                while (U1STAbits.URXDA) {
003E3A  370005     BRA .L180, .LSM417
003E46  801074     MOV U1STA, W4
003E48  620261     AND W4, #0x1, W4
003E4A  520FE0     SUB W4, #0x0, [W15]
003E4C  3AFFF7     BRA NZ, .L181, .LSM416
1069:                  Buffer64WriteByte(&uart1_input_buffer, U1RXREG);
003E3C  801094     MOV U1RXREG, W4
003E3E  784204     MOV.B W4, W4
003E40  784084     MOV.B W4, W1
003E42  2089A0     MOV #0x89A, W0
003E44  070D12     RCALL Buffer64WriteByte
1070:                }
1071:              }
003E4E  FA8000     ULNK
003E50  BE034F     MOV.D [--W15], W6
003E52  BE024F     MOV.D [--W15], W4
003E54  BE014F     MOV.D [--W15], W2
003E56  BE004F     MOV.D [--W15], W0
003E58  F90036     POP RCOUNT
003E5A  064000     RETFIE
1072:              
1073:              
1074:              
1075:              void _ISRNOPSV _U1TXInterrupt(void) {
003E5C  F80036     PUSH RCOUNT
003E5E  BE9F80     MOV.D W0, [W15++]
003E60  BE9F82     MOV.D W2, [W15++]
003E62  BE9F84     MOV.D W4, [W15++]
003E64  BE9F86     MOV.D W6, [W15++]
003E66  FA0000     LNK #0x0
1076:                _U1TXIF = 0;
003E68  A94085     BCLR 0x85, #2
1077:                while ((!U1STAbits.UTXBF) && (Buffer64BytesInBuffer(&uart1_output_buffer))) {
003E6A  370005     BRA .L183, .LSM423
003E76  801075     MOV U1STA, W5
003E78  202004     MOV #0x200, W4
003E7A  628204     AND W5, W4, W4
003E7C  520FE0     SUB W4, #0x0, [W15]
003E7E  3A0005     BRA NZ, .L182, .LSM424
003E80  208DC0     MOV #0x8DC, W0
003E82  070D36     RCALL Buffer64BytesInBuffer
003E84  784200     MOV.B W0, W4
003E86  524FE0     SUB.B W4, #0x0, [W15]
003E88  3AFFF1     BRA NZ, .L185, .LSM422
1078:                  /*
1079:                    There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
1080:                    Move a byte from the output buffer into the transmit buffer
1081:                  */
1082:                  U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
003E6C  208DC0     MOV #0x8DC, W0
003E6E  070D22     RCALL Buffer64ReadByte
003E70  784200     MOV.B W0, W4
003E72  FB8204     ZE W4, W4
003E74  881084     MOV W4, U1TXREG
1083:                }
1084:              }
003E8A  FA8000     ULNK
003E8C  BE034F     MOV.D [--W15], W6
003E8E  BE024F     MOV.D [--W15], W4
003E90  BE014F     MOV.D [--W15], W2
003E92  BE004F     MOV.D [--W15], W0
003E94  F90036     POP RCOUNT
003E96  064000     RETFIE
1085:              
1086:              
1087:              unsigned int GenerateMagnetronVprog(unsigned int iprog) {
003E98  FA0002     LNK #0x2
003E9A  780F00     MOV W0, [W14]
1088:                return 42000;
003E9C  2A4104     MOV #0xA410, W4
1089:                // DPARKER write this function
1090:              }
003E9E  780004     MOV W4, W0
003EA0  FA8000     ULNK
003EA2  060000     RETURN
1091:              
1092:              
1093:              
1094:              unsigned int GenerateLambdaIprog(unsigned int vprog) {
003EA4  FA0002     LNK #0x2
003EA6  780F00     MOV W0, [W14]
1095:                return 0;
003EA8  EB0200     CLR W4
1096:              }
003EAA  780004     MOV W4, W0
003EAC  FA8000     ULNK
003EAE  060000     RETURN
1097:              
1098:               
1099:              unsigned int GenerateMagnetVprog(unsigned int iprog) {
003EB0  FA0004     LNK #0x4
003EB2  980710     MOV W0, [W14+2]
1100:                unsigned int temp;
1101:                temp = Scale16Bit(iprog,10240); // temp = iprog*1.25
003EB4  228001     MOV #0x2800, W1
003EB6  90001E     MOV [W14+2], W0
003EB8  07F65A     RCALL Scale16Bit
003EBA  780200     MOV W0, W4
003EBC  780F04     MOV W4, [W14]
1102:                return temp;
003EBE  78021E     MOV [W14], W4
1103:              }
003EC0  780004     MOV W4, W0
003EC2  FA8000     ULNK
003EC4  060000     RETURN
1104:              
1105:              
1106:              unsigned int GenerateFilamentIprog(unsigned int vprog) {
003EC6  FA0004     LNK #0x4
003EC8  980710     MOV W0, [W14+2]
1107:                unsigned int temp;
1108:                temp = Scale16Bit(vprog, 5425);
003ECA  215311     MOV #0x1531, W1
003ECC  90001E     MOV [W14+2], W0
003ECE  07F64F     RCALL Scale16Bit
003ED0  780200     MOV W0, W4
003ED2  780F04     MOV W4, [W14]
1109:                return temp;
003ED4  78021E     MOV [W14], W4
1110:              }
003ED6  780004     MOV W4, W0
003ED8  FA8000     ULNK
003EDA  060000     RETURN
1111:              
1112:              unsigned int GenerateFilamentVprog(unsigned int iprog) {
003EDC  FA0004     LNK #0x4
003EDE  980710     MOV W0, [W14+2]
1113:                unsigned int temp;
1114:                temp = Scale16Bit(iprog, 19363);
003EE0  24BA31     MOV #0x4BA3, W1
003EE2  90001E     MOV [W14+2], W0
003EE4  07F644     RCALL Scale16Bit
003EE6  780200     MOV W0, W4
003EE8  780F04     MOV W4, [W14]
1115:                return temp;
003EEA  78021E     MOV [W14], W4
1116:              }
003EEC  780004     MOV W4, W0
003EEE  FA8000     ULNK
003EF0  060000     RETURN
1117:              
1118:              
1119:              unsigned int ReturnPowerSupplyADCScaledVoltage(POWERSUPPLY* ptr, unsigned int value) {
003EF2  FA0004     LNK #0x4
003EF4  780F00     MOV W0, [W14]
003EF6  980711     MOV W1, [W14+2]
1120:                //value = value - ptr->v_adc_cal_offset;
1121:                if (ptr->v_adc_cal_offset > 0) {
003EF8  78021E     MOV [W14], W4
003EFA  900A34     MOV [W4+22], W4
003EFC  520FE0     SUB W4, #0x0, [W15]
003EFE  34000F     BRA LE, .L192, .LSM448
1122:                  // the offset is positive
1123:                  // Check to make sure we do not overflow below 0x0000
1124:                  if (ptr->v_adc_cal_offset >= value) {
003F00  78021E     MOV [W14], W4
003F02  900A34     MOV [W4+22], W4
003F04  780284     MOV W4, W5
003F06  90021E     MOV [W14+2], W4
003F08  528F84     SUB W5, W4, [W15]
003F0A  390003     BRA NC, .L193, .LSM447
1125:                    value = 0;
003F0C  EB0200     CLR W4
003F0E  980714     MOV W4, [W14+2]
003F10  370014     BRA .L194, .LSM451
1126:                  } else {
1127:                    value = value - ptr->v_adc_cal_offset;
003F12  78021E     MOV [W14], W4
003F14  900A34     MOV [W4+22], W4
003F16  90029E     MOV [W14+2], W5
003F18  528204     SUB W5, W4, W4
003F1A  980714     MOV W4, [W14+2]
003F1C  37000E     BRA .L194, .LSM451
1128:                  }
1129:                } else {
1130:                  // The offset is negative
1131:                  // Check to make sure we do not overflow above 0xFFFF
1132:                  if ((0xFFFF + ptr->v_adc_cal_offset) <= value) {
003F1E  78021E     MOV [W14], W4
003F20  900A34     MOV [W4+22], W4
003F22  E90284     DEC W4, W5
003F24  90021E     MOV [W14+2], W4
003F26  528F84     SUB W5, W4, [W15]
003F28  3E0003     BRA GTU, .L195, .LSM450
1133:                    value = 0xFFFF;
003F2A  EB8200     SETM W4
003F2C  980714     MOV W4, [W14+2]
003F2E  370005     BRA .L194, .LSM451
1134:                  } else {
1135:                    value = value - ptr->v_adc_cal_offset;
003F30  78021E     MOV [W14], W4
003F32  900A34     MOV [W4+22], W4
003F34  90029E     MOV [W14+2], W5
003F36  528204     SUB W5, W4, W4
003F38  980714     MOV W4, [W14+2]
1136:                  }
1137:                }
1138:                value = ReverseScale16Bit(value, ptr->v_adc_cal_gain);
003F3A  78021E     MOV [W14], W4
003F3C  900A24     MOV [W4+20], W4
003F3E  780084     MOV W4, W1
003F40  90001E     MOV [W14+2], W0
003F42  070043     RCALL ReverseScale16Bit
003F44  780200     MOV W0, W4
003F46  980714     MOV W4, [W14+2]
1139:                value = ReverseScale16Bit(value, ptr->v_adc_scale);
003F48  78021E     MOV [W14], W4
003F4A  900A14     MOV [W4+18], W4
003F4C  780084     MOV W4, W1
003F4E  90001E     MOV [W14+2], W0
003F50  07003C     RCALL ReverseScale16Bit
003F52  780200     MOV W0, W4
003F54  980714     MOV W4, [W14+2]
1140:                return value;
003F56  90021E     MOV [W14+2], W4
1141:              }
003F58  780004     MOV W4, W0
003F5A  FA8000     ULNK
003F5C  060000     RETURN
1142:              
1143:              unsigned int ReturnPowerSupplyADCScaledCurrent(POWERSUPPLY* ptr, unsigned int value) {
003F5E  FA0004     LNK #0x4
003F60  780F00     MOV W0, [W14]
003F62  980711     MOV W1, [W14+2]
1144:                if (ptr->i_adc_cal_offset > 0) {
003F64  78021E     MOV [W14], W4
003F66  902214     MOV [W4+66], W4
003F68  520FE0     SUB W4, #0x0, [W15]
003F6A  34000F     BRA LE, .L197, .LSM460
1145:                  // Check to make sure we do not overflow below 0x0000
1146:                  // Our offset is 
1147:                  if (ptr->i_adc_cal_offset > value) {
003F6C  78021E     MOV [W14], W4
003F6E  902214     MOV [W4+66], W4
003F70  780284     MOV W4, W5
003F72  90021E     MOV [W14+2], W4
003F74  528F84     SUB W5, W4, [W15]
003F76  360003     BRA LEU, .L198, .LSM459
1148:                    value = 0;
003F78  EB0200     CLR W4
003F7A  980714     MOV W4, [W14+2]
003F7C  370014     BRA .L199, .LSM463
1149:                  } else {
1150:                    value = value - ptr->i_adc_cal_offset;
003F7E  78021E     MOV [W14], W4
003F80  902214     MOV [W4+66], W4
003F82  90029E     MOV [W14+2], W5
003F84  528204     SUB W5, W4, W4
003F86  980714     MOV W4, [W14+2]
003F88  37000E     BRA .L199, .LSM463
1151:                  }
1152:                } else {
1153:                  // Check to make sure we do not overflow above 0xFFFF
1154:                  if ((0xFFFF + ptr->i_adc_cal_offset) < value) {
003F8A  78021E     MOV [W14], W4
003F8C  902214     MOV [W4+66], W4
003F8E  E90284     DEC W4, W5
003F90  90021E     MOV [W14+2], W4
003F92  528F84     SUB W5, W4, [W15]
003F94  310003     BRA C, .L200, .LSM462
1155:                    value = 0xFFFF;
003F96  EB8200     SETM W4
003F98  980714     MOV W4, [W14+2]
003F9A  370005     BRA .L199, .LSM463
1156:                  } else {
1157:                    value = value - ptr->i_adc_cal_offset;
003F9C  78021E     MOV [W14], W4
003F9E  902214     MOV [W4+66], W4
003FA0  90029E     MOV [W14+2], W5
003FA2  528204     SUB W5, W4, W4
003FA4  980714     MOV W4, [W14+2]
1158:                  }
1159:                }
1160:                value = ReverseScale16Bit(value, ptr->i_adc_cal_gain);
003FA6  78021E     MOV [W14], W4
003FA8  902204     MOV [W4+64], W4
003FAA  780084     MOV W4, W1
003FAC  90001E     MOV [W14+2], W0
003FAE  07000D     RCALL ReverseScale16Bit
003FB0  780200     MOV W0, W4
003FB2  980714     MOV W4, [W14+2]
1161:                value = ReverseScale16Bit(value, ptr->i_adc_scale);
003FB4  78021E     MOV [W14], W4
003FB6  901A74     MOV [W4+62], W4
003FB8  780084     MOV W4, W1
003FBA  90001E     MOV [W14+2], W0
003FBC  070006     RCALL ReverseScale16Bit
003FBE  780200     MOV W0, W4
003FC0  980714     MOV W4, [W14+2]
1162:                return value;
003FC2  90021E     MOV [W14+2], W4
1163:              }
003FC4  780004     MOV W4, W0
003FC6  FA8000     ULNK
003FC8  060000     RETURN
1164:               
1165:              
1166:              unsigned int ReverseScale16Bit(unsigned int value, unsigned int scale) {
003FCA  FA0008     LNK #0x8
003FCC  980720     MOV W0, [W14+4]
003FCE  980731     MOV W1, [W14+6]
1167:                unsigned long temp;
1168:                temp = value;
003FD0  90022E     MOV [W14+4], W4
003FD2  200005     MOV #0x0, W5
003FD4  BE8F04     MOV.D W4, [W14]
1169:                temp = temp << 13;
003FD6  BE031E     MOV.D [W14], W6
003FD8  DD3A4D     SL W7, #13, W4
003FDA  DE32C3     LSR W6, #3, W5
003FDC  720285     IOR W4, W5, W5
003FDE  DD324D     SL W6, #13, W4
003FE0  BE8F04     MOV.D W4, [W14]
1170:                temp /= scale;
003FE2  90023E     MOV [W14+6], W4
003FE4  200005     MOV #0x0, W5
003FE6  BE0104     MOV.D W4, W2
003FE8  BE001E     MOV.D [W14], W0
003FEA  07E1A8     RCALL ___udivsi3
003FEC  BE0200     MOV.D W0, W4
003FEE  BE8F04     MOV.D W4, [W14]
1171:                if (temp > 0x0000FFFF) {
003FF0  2FFFF4     MOV #0xFFFF, W4
003FF2  200005     MOV #0x0, W5
003FF4  BE031E     MOV.D [W14], W6
003FF6  530F84     SUB W6, W4, [W15]
003FF8  5B8F85     SUBB W7, W5, [W15]
003FFA  360006     BRA LEU, .L202, .LSM474
1172:                  temp = 0x0000FFFF;
003FFC  2FFFF4     MOV #0xFFFF, W4
003FFE  200005     MOV #0x0, W5
004000  BE8F04     MOV.D W4, [W14]
1173:                  global_debug_counter.reversescale16bit_saturation++;
004002  80B9D4     MOV .LSM636, W4
004004  E80204     INC W4, W4
004006  88B9D4     MOV W4, .LSM636
1174:                }
1175:                temp = temp & 0xFFFF;
004008  2FFFF4     MOV #0xFFFF, W4
00400A  200005     MOV #0x0, W5
00400C  BE031E     MOV.D [W14], W6
00400E  780006     MOV W6, W0
004010  780307     MOV W7, W6
004012  780384     MOV W4, W7
004014  780205     MOV W5, W4
004016  600007     AND W0, W7, W0
004018  630204     AND W6, W4, W4
00401A  200005     MOV #0x0, W5
00401C  DD22C0     SL W4, #0, W5
00401E  200004     MOV #0x0, W4
004020  BE0304     MOV.D W4, W6
004022  B80261     MUL.UU W0, #1, W4
004024  730304     IOR W6, W4, W6
004026  738385     IOR W7, W5, W7
004028  BE8F06     MOV.D W6, [W14]
1176:                return temp;
00402A  78021E     MOV [W14], W4
1177:              }
00402C  780004     MOV W4, W0
00402E  FA8000     ULNK
004030  060000     RETURN
1178:              
1179:              void CalculatePRFDivider(unsigned int requested_prf) {
004032  FA0002     LNK #0x2
004034  780F00     MOV W0, [W14]
1180:                if (requested_prf == 0) {
004036  78021E     MOV [W14], W4
004038  520FE0     SUB W4, #0x0, [W15]
00403A  3A0005     BRA NZ, .L204, .LSM481
1181:                  prf_mult = 1;
00403C  200014     MOV #0x1, W4
00403E  88BDA4     MOV W4, .LSM673
1182:                  prf_divider = 1;
004040  200014     MOV #0x1, W4
004042  88BDB4     MOV W4, .LSM674
004044  3700BA     BRA .L203, .LSM546
1183:                } else if (requested_prf >= 400) {
004046  2018F4     MOV #0x18F, W4
004048  78029E     MOV [W14], W5
00404A  528F84     SUB W5, W4, [W15]
00404C  360005     BRA LEU, .L206, .LSM484
1184:                  prf_mult = 1;
00404E  200014     MOV #0x1, W4
004050  88BDA4     MOV W4, .LSM673
1185:                  prf_divider = 1;
004052  200014     MOV #0x1, W4
004054  88BDB4     MOV W4, .LSM674
004056  3700B1     BRA .L203, .LSM546
1186:                } else if (requested_prf >= 350) {
004058  2015D4     MOV #0x15D, W4
00405A  78029E     MOV [W14], W5
00405C  528F84     SUB W5, W4, [W15]
00405E  360005     BRA LEU, .L207, .LSM487
1187:                  prf_mult = 7;
004060  200074     MOV #0x7, W4
004062  88BDA4     MOV W4, .LSM673
1188:                  prf_divider = 8;
004064  200084     MOV #0x8, W4
004066  88BDB4     MOV W4, .LSM674
004068  3700A8     BRA .L203, .LSM546
1189:                } else if (requested_prf >= 320) {
00406A  2013F4     MOV #0x13F, W4
00406C  78029E     MOV [W14], W5
00406E  528F84     SUB W5, W4, [W15]
004070  360005     BRA LEU, .L208, .LSM490
1190:                  prf_mult = 4;
004072  200044     MOV #0x4, W4
004074  88BDA4     MOV W4, .LSM673
1191:                  prf_divider = 5;
004076  200054     MOV #0x5, W4
004078  88BDB4     MOV W4, .LSM674
00407A  37009F     BRA .L203, .LSM546
1192:                } else if (requested_prf >= 300) {
00407C  2012B4     MOV #0x12B, W4
00407E  78029E     MOV [W14], W5
004080  528F84     SUB W5, W4, [W15]
004082  360005     BRA LEU, .L209, .LSM493
1193:                  prf_mult = 3;
004084  200034     MOV #0x3, W4
004086  88BDA4     MOV W4, .LSM673
1194:                  prf_divider = 4;
004088  200044     MOV #0x4, W4
00408A  88BDB4     MOV W4, .LSM674
00408C  370096     BRA .L203, .LSM546
1195:                } else if (requested_prf >= 266) {
00408E  201094     MOV #0x109, W4
004090  78029E     MOV [W14], W5
004092  528F84     SUB W5, W4, [W15]
004094  360005     BRA LEU, .L210, .LSM496
1196:                  prf_mult = 2;
004096  200024     MOV #0x2, W4
004098  88BDA4     MOV W4, .LSM673
1197:                  prf_divider = 3;
00409A  200034     MOV #0x3, W4
00409C  88BDB4     MOV W4, .LSM674
00409E  37008D     BRA .L203, .LSM546
1198:                } else if (requested_prf >= 200) {
0040A0  200C74     MOV #0xC7, W4
0040A2  78029E     MOV [W14], W5
0040A4  528F84     SUB W5, W4, [W15]
0040A6  360005     BRA LEU, .L211, .LSM499
1199:                  prf_mult = 1;
0040A8  200014     MOV #0x1, W4
0040AA  88BDA4     MOV W4, .LSM673
1200:                  prf_divider = 2;
0040AC  200024     MOV #0x2, W4
0040AE  88BDB4     MOV W4, .LSM674
0040B0  370084     BRA .L203, .LSM546
1201:                } else if (requested_prf >= 160) {
0040B2  2009F4     MOV #0x9F, W4
0040B4  78029E     MOV [W14], W5
0040B6  528F84     SUB W5, W4, [W15]
0040B8  360005     BRA LEU, .L212, .LSM502
1202:                  prf_mult = 2;
0040BA  200024     MOV #0x2, W4
0040BC  88BDA4     MOV W4, .LSM673
1203:                  prf_divider = 5;
0040BE  200054     MOV #0x5, W4
0040C0  88BDB4     MOV W4, .LSM674
0040C2  37007B     BRA .L203, .LSM546
1204:                } else if (requested_prf >= 133) {
0040C4  200844     MOV #0x84, W4
0040C6  78029E     MOV [W14], W5
0040C8  528F84     SUB W5, W4, [W15]
0040CA  360005     BRA LEU, .L213, .LSM505
1205:                  prf_mult = 1;
0040CC  200014     MOV #0x1, W4
0040CE  88BDA4     MOV W4, .LSM673
1206:                  prf_divider = 3;
0040D0  200034     MOV #0x3, W4
0040D2  88BDB4     MOV W4, .LSM674
0040D4  370072     BRA .L203, .LSM546
1207:                } else if (requested_prf >= 100) {
0040D6  200634     MOV #0x63, W4
0040D8  78029E     MOV [W14], W5
0040DA  528F84     SUB W5, W4, [W15]
0040DC  360005     BRA LEU, .L214, .LSM508
1208:                  prf_mult = 1;
0040DE  200014     MOV #0x1, W4
0040E0  88BDA4     MOV W4, .LSM673
1209:                  prf_divider = 4;
0040E2  200044     MOV #0x4, W4
0040E4  88BDB4     MOV W4, .LSM674
0040E6  370069     BRA .L203, .LSM546
1210:                } else if (requested_prf >= 80) {
0040E8  2004F4     MOV #0x4F, W4
0040EA  78029E     MOV [W14], W5
0040EC  528F84     SUB W5, W4, [W15]
0040EE  360005     BRA LEU, .L215, .LSM511
1211:                  prf_mult = 1;
0040F0  200014     MOV #0x1, W4
0040F2  88BDA4     MOV W4, .LSM673
1212:                  prf_divider = 5;
0040F4  200054     MOV #0x5, W4
0040F6  88BDB4     MOV W4, .LSM674
0040F8  370060     BRA .L203, .LSM546
1213:                } else if (requested_prf >= 66) {
0040FA  200414     MOV #0x41, W4
0040FC  78029E     MOV [W14], W5
0040FE  528F84     SUB W5, W4, [W15]
004100  360005     BRA LEU, .L216, .LSM514
1214:                  prf_mult = 1;
004102  200014     MOV #0x1, W4
004104  88BDA4     MOV W4, .LSM673
1215:                  prf_divider = 6;
004106  200064     MOV #0x6, W4
004108  88BDB4     MOV W4, .LSM674
00410A  370057     BRA .L203, .LSM546
1216:                } else if (requested_prf >= 50) {
00410C  200314     MOV #0x31, W4
00410E  78029E     MOV [W14], W5
004110  528F84     SUB W5, W4, [W15]
004112  360005     BRA LEU, .L217, .LSM517
1217:                  prf_mult = 1;
004114  200014     MOV #0x1, W4
004116  88BDA4     MOV W4, .LSM673
1218:                  prf_divider = 8;
004118  200084     MOV #0x8, W4
00411A  88BDB4     MOV W4, .LSM674
00411C  37004E     BRA .L203, .LSM546
1219:                } else if (requested_prf >= 40) {
00411E  200274     MOV #0x27, W4
004120  78029E     MOV [W14], W5
004122  528F84     SUB W5, W4, [W15]
004124  360005     BRA LEU, .L218, .LSM520
1220:                  prf_mult = 1;
004126  200014     MOV #0x1, W4
004128  88BDA4     MOV W4, .LSM673
1221:                  prf_divider = 10;
00412A  2000A4     MOV #0xA, W4
00412C  88BDB4     MOV W4, .LSM674
00412E  370045     BRA .L203, .LSM546
1222:                } else if (requested_prf >= 33) {
004130  200204     MOV #0x20, W4
004132  78029E     MOV [W14], W5
004134  528F84     SUB W5, W4, [W15]
004136  360005     BRA LEU, .L219, .LSM523
1223:                  prf_mult = 1;
004138  200014     MOV #0x1, W4
00413A  88BDA4     MOV W4, .LSM673
1224:                  prf_divider = 12;
00413C  2000C4     MOV #0xC, W4
00413E  88BDB4     MOV W4, .LSM674
004140  37003C     BRA .L203, .LSM546
1225:                } else if (requested_prf >= 25) {
004142  78021E     MOV [W14], W4
004144  520FF8     SUB W4, #0x18, [W15]
004146  360005     BRA LEU, .L220, .LSM526
1226:                  prf_mult = 1;
004148  200014     MOV #0x1, W4
00414A  88BDA4     MOV W4, .LSM673
1227:                  prf_divider = 16;
00414C  200104     MOV #0x10, W4
00414E  88BDB4     MOV W4, .LSM674
004150  370034     BRA .L203, .LSM546
1228:                } else if (requested_prf >= 20) {
004152  78021E     MOV [W14], W4
004154  520FF3     SUB W4, #0x13, [W15]
004156  360005     BRA LEU, .L221, .LSM529
1229:                  prf_mult = 1;
004158  200014     MOV #0x1, W4
00415A  88BDA4     MOV W4, .LSM673
1230:                  prf_divider = 20;
00415C  200144     MOV #0x14, W4
00415E  88BDB4     MOV W4, .LSM674
004160  37002C     BRA .L203, .LSM546
1231:                } else if (requested_prf >= 16) {
004162  78021E     MOV [W14], W4
004164  520FEF     SUB W4, #0xF, [W15]
004166  360005     BRA LEU, .L222, .LSM532
1232:                  prf_mult = 1;
004168  200014     MOV #0x1, W4
00416A  88BDA4     MOV W4, .LSM673
1233:                  prf_divider = 25;
00416C  200194     MOV #0x19, W4
00416E  88BDB4     MOV W4, .LSM674
004170  370024     BRA .L203, .LSM546
1234:                } else if (requested_prf >= 10) {
004172  78021E     MOV [W14], W4
004174  520FE9     SUB W4, #0x9, [W15]
004176  360005     BRA LEU, .L223, .LSM535
1235:                  prf_mult = 1;
004178  200014     MOV #0x1, W4
00417A  88BDA4     MOV W4, .LSM673
1236:                  prf_divider = 40;    
00417C  200284     MOV #0x28, W4
00417E  88BDB4     MOV W4, .LSM674
004180  37001C     BRA .L203, .LSM546
1237:                } else if (requested_prf >= 5) {
004182  78021E     MOV [W14], W4
004184  520FE4     SUB W4, #0x4, [W15]
004186  360005     BRA LEU, .L224, .LSM538
1238:                  prf_mult = 1;
004188  200014     MOV #0x1, W4
00418A  88BDA4     MOV W4, .LSM673
1239:                  prf_divider = 80;    
00418C  200504     MOV #0x50, W4
00418E  88BDB4     MOV W4, .LSM674
004190  370014     BRA .L203, .LSM546
1240:                } else if (requested_prf >= 4) {
004192  78021E     MOV [W14], W4
004194  520FE3     SUB W4, #0x3, [W15]
004196  360005     BRA LEU, .L225, .LSM541
1241:                  prf_mult = 1;
004198  200014     MOV #0x1, W4
00419A  88BDA4     MOV W4, .LSM673
1242:                  prf_divider = 100;    
00419C  200644     MOV #0x64, W4
00419E  88BDB4     MOV W4, .LSM674
0041A0  37000C     BRA .L203, .LSM546
1243:                } else if (requested_prf >= 2) {
0041A2  78021E     MOV [W14], W4
0041A4  520FE1     SUB W4, #0x1, [W15]
0041A6  360005     BRA LEU, .L226, .LSM544
1244:                  prf_mult = 1;
0041A8  200014     MOV #0x1, W4
0041AA  88BDA4     MOV W4, .LSM673
1245:                  prf_divider = 200;    
0041AC  200C84     MOV #0xC8, W4
0041AE  88BDB4     MOV W4, .LSM674
0041B0  370004     BRA .L203, .LSM546
1246:                } else {
1247:                  prf_mult = 1;
0041B2  200014     MOV #0x1, W4
0041B4  88BDA4     MOV W4, .LSM673
1248:                  prf_divider = 400;    
0041B6  201904     MOV #0x190, W4
0041B8  88BDB4     MOV W4, .LSM674
1249:                }
1250:              }
0041BA  FA8000     ULNK
0041BC  060000     RETURN
---  C:/Users/DPARKER/Documents/GitHub/A36760/Main.c  ---------------------------------------------------
1:                 #include <p30F6014a.h>
2:                 #include <libpic30.h>
3:                 #include <adc12.h>
4:                 #include "A34760.h"
5:                 #include "A34760_PINS.h"
6:                 #include "IOPorts.h"
7:                 #include "LTC2656.h"
8:                 #include <i2c.h>
9:                 #include "MCP23017.h"
10:                #include "ETMSPI.h"
11:                #include <spi.h>
12:                #include "ETMdsp.h"
13:                #include "config.h"
14:                #include "eeprom.h"
15:                
16:                
17:                
18:                //_prog_addressT EE_address_ps_magnet_config_in_EEPROM;
19:                //unsigned int _EEDATA(32) ps_magnet_config_in_EEPROM[] = PS_MAGNET_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
20:                //unsigned int ps_magnet_config_ram_copy[16];
21:                
22:                //_prog_addressT EE_address_ps_filament_config_in_EEPROM;
23:                //unsigned int _EEDATA(32) ps_filament_config_in_EEPROM[] = PS_FILAMENT_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
24:                //unsigned int ps_filament_config_ram_copy[16];
25:                
26:                //_prog_addressT EE_address_ps_thyr_cathode_htr_config_in_EEPROM;
27:                //unsigned int _EEDATA(32) ps_thyr_cathode_htr_config_in_EEPROM[] = PS_THYR_CATH_HTR_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
28:                //unsigned int ps_thyr_cathode_htr_config_ram_copy[16];
29:                
30:                //_prog_addressT EE_address_ps_thyr_reservoir_htr_config_in_EEPROM;
31:                //unsigned int _EEDATA(32) ps_thyr_reservoir_htr_config_in_EEPROM[] = PS_THYR_RESER_HTR_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
32:                //unsigned int ps_thyr_reservoir_htr_config_ram_copy[16];
33:                
34:                
35:                //_prog_addressT EE_address_ps_hv_lambda_mode_A_config_in_EEPROM;
36:                //unsigned int _EEDATA(32) ps_hv_lambda_mode_A_config_in_EEPROM[] = PS_HV_LAMBDA_MODE_A_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
37:                //unsigned int ps_hv_lambda_mode_A_config_ram_copy[16];
38:                
39:                //_prog_addressT EE_address_ps_hv_lambda_mode_B_config_in_EEPROM;
40:                //unsigned int _EEDATA(32) ps_hv_lambda_mode_B_config_in_EEPROM[] = PS_HV_LAMBDA_MODE_B_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
41:                //unsigned int ps_hv_lambda_mode_B_config_ram_copy[16];
42:                
43:                
44:                //_prog_addressT EE_address_ps_magnetron_mode_A_config_in_EEPROM;
45:                //unsigned int _EEDATA(32) ps_magnetron_mode_A_config_in_EEPROM[] = PS_MAGNETRON_MODE_A_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
46:                //unsigned int ps_magnetron_mode_A_config_ram_copy[16];
47:                
48:                //_prog_addressT EE_address_ps_magnetron_mode_B_config_in_EEPROM;
49:                //unsigned int _EEDATA(32) ps_magnetron_mode_B_config_in_EEPROM[] = PS_MAGNETRON_MODE_B_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
50:                //unsigned int ps_magnetron_mode_B_config_ram_copy[16];
51:                
52:                //_prog_addressT EE_address_pulse_counter_repository_in_EEPROM;
53:                //unsigned int _EEDATA(32) pulse_counter_repository_in_EEPROM[] = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};  // Create 16 word structure in EEPROM and load zeros
54:                //unsigned int pulse_counter_repository_ram_copy[16];
55:                
56:                
57:                //_prog_addressT EE_address_control_loop_cal_data_in_EEPROM;
58:                //unsigned int _EEDATA(32) control_loop_cal_data_in_EEPROM[] = CONTROL_LOOP_CAL_DATA_DEFAULT_CONFIG; // Create 16 word structure in EEPROM and load default configuration values
59:                //unsigned int control_loop_cal_data_ram_copy[16];
60:                
61:                
62:                /*
63:                  
64:                  
65:                 */
66:                
67:                
68:                
69:                /*
70:                  Pulse Counter Structure
71:                  pulse_counter_repository_ram_copy[0] = pulse_counter MSB
72:                  pulse_counter_repository_ram_copy[1] = pulse_counter 
73:                  pulse_counter_repository_ram_copy[2] = pulse_counter 
74:                  pulse_counter_repository_ram_copy[3] = pulse_counter LSB
75:                
76:                  pulse_counter_repository_ram_copy[4] = arc_counter MSB
77:                  pulse_counter_repository_ram_copy[5] = arc_counter LSB
78:                
79:                
80:                */
81:                
82:                
83:                
84:                /* Configuration Bit Settings */
85:                //_FOSC(LPRC & CSW_FSCM_OFF);
86:                //_FOSC(ECIO & CSW_FSCM_OFF); // Primary Oscillator with PLL and Startup with User Selected Oscillator Source
87:                // DPARKER this is for use with 40MHz ext clock
88:                
89:                _FOSC(FRC_PLL16 & CSW_FSCM_OFF); // Primary Oscillator with PLL and Startup with User Selected Oscillator Source
90:                                                 // External Oscillator is 7.3738MHz with 16x PLL and 4x Clocks per Instruction cycle
91:                                                 // This yields an Instruction Cycle Frequency of 29.4952 MHz
92:                                                 // This yields an Instruction Cycle Time of 33.904nS
93:                
94:                
95:                // Watchdog Timeout is 2 Millisconds with no pre scallers
96:                //_FWDT(WDT_ON & WDTPSA_1 & WDTPSB_2);  // Watchdog Timer is enabled, 4ms TIMEOUT
97:                //_FWDT(WDT_ON & WDTPSA_1 & WDTPSB_16);  // Watchdog Timer is enabled, 32ms TIMEOUT
98:                //_FWDT(WDT_OFF & WDTPSA_1 & WDTPSB_16);  // Watchdog Timer is disnabled, 32ms TIMEOUT
99:                _FWDT(WDT_ON & WDTPSA_512 & WDTPSB_1);  // 1 Second watchdog timer 
100:               
101:               
102:               //_FBORPOR(PWRT_64 & BORV_27 & PBOR_ON & MCLR_EN); // Brown out and Power on Timer settings
103:               _FBORPOR(PWRT_OFF & BORV_45 & PBOR_OFF & MCLR_EN); // Brown out and Power on Timer settings
104:               
105:               // _FBS()  // No Boot Segment
106:               
107:               _FBS(WR_PROTECT_BOOT_OFF & NO_BOOT_CODE & NO_BOOT_EEPROM & NO_BOOT_RAM);
108:               
109:               _FSS(WR_PROT_SEC_OFF & NO_SEC_CODE & NO_SEC_EEPROM & NO_SEC_RAM);
110:               
111:               _FGS(CODE_PROT_OFF);
112:               
113:               _FICD(PGD);
114:               
115:               int main(void) {
0059FC  FA0000     LNK #0x0
116:               
117:                 TRIS_PIN_MAGNETRON_MAGNET_ENABLE = TRIS_OUTPUT_MODE;
0059FE  A922D3     BCLR 0x2D3, #1
118:                 PIN_MAGNETRON_MAGNET_ENABLE = OLL_MAGNETRON_MAGNET_ENABLED;
005A00  A822D7     BSET 0x2D7, #1
119:                 
120:                 PIN_MCU_CLOCK_OUT_TEST_POINT = 1;
005A02  A8E2D1     BSET 0x2D1, #7
121:                 TRIS_PIN_MCU_CLOCK_OUT_TEST_POINT = TRIS_OUTPUT_MODE;
005A04  A9E2CD     BCLR 0x2CD, #7
122:               
123:                 magnetron_filament_control_mode = 0;
005A06  EB0200     CLR W4
005A08  884374     MOV W4, magnetron_filament_control_mode
124:                 magnetron_filament_off_resistance = 22001;
005A0A  255F14     MOV #0x55F1, W4
005A0C  884384     MOV W4, magnetron_filament_off_resistance
125:                 magnetron_filament_on_resistance = 22002;
005A0E  255F24     MOV #0x55F2, W4
005A10  884394     MOV W4, magnetron_filament_on_resistance
126:               
127:               
128:                 control_state = STATE_START_UP;
005A12  B3C044     MOV.B #0x4, W4
005A14  FD0200     EXCH W0, W4
005A16  B7E858     MOV.B WREG, control_state
005A18  FD0200     EXCH W0, W4
129:                 if ((PIN_FP_MODULATOR_ENABLE_INPUT == ILL_MODULATOR_ENABLED) && (PIN_FP_MODULATOR_HV_ON_INPUT == ILL_MODULATOR_HV_ON) && (PIN_FAST_RESTART_STORAGE_CAP_INPUT == ILL_DO_FAST_RESTART)) {
005A1A  801615     MOV PORTA, W5
005A1C  240004     MOV #0x4000, W4
005A1E  628204     AND W5, W4, W4
005A20  520FE0     SUB W4, #0x0, [W15]
005A22  3A000E     BRA NZ, .L2, .LSM11
005A24  801615     MOV PORTA, W5
005A26  280004     MOV #0x8000, W4
005A28  628204     AND W5, W4, W4
005A2A  520FE0     SUB W4, #0x0, [W15]
005A2C  3A0009     BRA NZ, .L2, .LSM11
005A2E  801645     MOV PORTB, W5
005A30  280004     MOV #0x8000, W4
005A32  628204     AND W5, W4, W4
005A34  520FE0     SUB W4, #0x0, [W15]
005A36  3A0004     BRA NZ, .L2, .LSM11
130:                   control_state = STATE_FAST_RECOVERY_START_UP;  // Execute fast startup straight to HV ON
005A38  B3C064     MOV.B #0x6, W4
005A3A  FD0200     EXCH W0, W4
005A3C  B7E858     MOV.B WREG, control_state
005A3E  FD0200     EXCH W0, W4
131:                 }
132:                 
133:               
134:               
135:                 ram_config_set_magnetron_magnet_current_from_GUI = 0;  // On processor rest, Magnet current is set from Mode A Voltage and not from the GUI
005A40  EB4200     CLR.B W4
005A42  FD0200     EXCH W0, W4
005A44  B7E844     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
005A46  FD0200     EXCH W0, W4
136:               
137:               
138:                 while (1) {
139:                   DoStateMachine();
005A48  07D69C     RCALL DoStateMachine
140:                 }
005A4A  37FFFE     BRA .L3, .LSM12
141:               }
142:               
143:               
144:               
---  C:/Users/DPARKER/Documents/GitHub/A36760/MCP23017.c  -----------------------------------------------
1:                 #include "MCP23017.h"
2:                 #include "ETMI2C.h"
3:                 
4:                 unsigned int MCP23017WriteSingleByte(MCP23017* ptr_MCP23017, unsigned char MCP23017_register, unsigned char register_data) {
005786  FA0006     LNK #0x6
005788  980710     MOV W0, [W14+2]
00578A  984741     MOV.B W1, [W14+4]
00578C  984752     MOV.B W2, [W14+5]
5:                   unsigned int error_check;
6:                   
7:                   error_check = WaitForI2CBusIdle(ptr_MCP23017->i2c_port);                                                    // Wait for I2C Bus idle
00578E  90021E     MOV [W14+2], W4
005790  904274     MOV.B [W4+7], W4
005792  784004     MOV.B W4, W0
005794  07FE5D     RCALL WaitForI2CBusIdle
005796  780200     MOV W0, W4
005798  780F04     MOV W4, [W14]
8:                 
9:                   error_check |= GenerateI2CStart(ptr_MCP23017->i2c_port);                                                    // Generate start condition 
00579A  90021E     MOV [W14+2], W4
00579C  904274     MOV.B [W4+7], W4
00579E  784004     MOV.B W4, W0
0057A0  07FE80     RCALL GenerateI2CStart
0057A2  780200     MOV W0, W4
0057A4  720F1E     IOR W4, [W14], [W14]
10:                
11:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_WRITE_CONTROL_BIT), ptr_MCP23017->i2c_port);  // Write the address to the bus in WRITE MODE
0057A6  90021E     MOV [W14+2], W4
0057A8  9042F4     MOV.B [W4+7], W5
0057AA  90021E     MOV [W14+2], W4
0057AC  904264     MOV.B [W4+6], W4
0057AE  784085     MOV.B W5, W1
0057B0  784004     MOV.B W4, W0
0057B2  07FEC7     RCALL WriteByteI2C
0057B4  780200     MOV W0, W4
0057B6  720F1E     IOR W4, [W14], [W14]
12:                  
13:                  error_check |= WriteByteI2C(MCP23017_register, ptr_MCP23017->i2c_port);                                     // Write the register location to the bus
0057B8  90021E     MOV [W14+2], W4
0057BA  904274     MOV.B [W4+7], W4
0057BC  784084     MOV.B W4, W1
0057BE  90404E     MOV.B [W14+4], W0
0057C0  07FEC0     RCALL WriteByteI2C
0057C2  780200     MOV W0, W4
0057C4  720F1E     IOR W4, [W14], [W14]
14:                
15:                  error_check |= WriteByteI2C(register_data, ptr_MCP23017->i2c_port);                                         // Write the data to the bus
0057C6  90021E     MOV [W14+2], W4
0057C8  904274     MOV.B [W4+7], W4
0057CA  784084     MOV.B W4, W1
0057CC  90405E     MOV.B [W14+5], W0
0057CE  07FEB9     RCALL WriteByteI2C
0057D0  780200     MOV W0, W4
0057D2  720F1E     IOR W4, [W14], [W14]
16:                  
17:                  error_check |= GenerateI2CStop(ptr_MCP23017->i2c_port);                                                     // Generate Stop Condition
0057D4  90021E     MOV [W14+2], W4
0057D6  904274     MOV.B [W4+7], W4
0057D8  784004     MOV.B W4, W0
0057DA  07FF21     RCALL GenerateI2CStop
0057DC  780200     MOV W0, W4
0057DE  720F1E     IOR W4, [W14], [W14]
18:                  
19:                  ClrWdt();
0057E0  FE6000     CLRWDT
20:                  return error_check;
0057E2  78021E     MOV [W14], W4
21:                }
0057E4  780004     MOV W4, W0
0057E6  FA8000     ULNK
0057E8  060000     RETURN
22:                
23:                unsigned int MCP23017ReadSingleByte(MCP23017* ptr_MCP23017, unsigned char MCP23017_register) {
0057EA  FA0006     LNK #0x6
0057EC  980710     MOV W0, [W14+2]
0057EE  984741     MOV.B W1, [W14+4]
24:                  unsigned int error_check;
25:                  
26:                  error_check = WaitForI2CBusIdle(ptr_MCP23017->i2c_port);                                                    // Wait for I2C Bus idle
0057F0  90021E     MOV [W14+2], W4
0057F2  904274     MOV.B [W4+7], W4
0057F4  784004     MOV.B W4, W0
0057F6  07FE2C     RCALL WaitForI2CBusIdle
0057F8  780200     MOV W0, W4
0057FA  780F04     MOV W4, [W14]
27:                
28:                  error_check |= GenerateI2CStart(ptr_MCP23017->i2c_port);                                                    // Generate start condition 
0057FC  90021E     MOV [W14+2], W4
0057FE  904274     MOV.B [W4+7], W4
005800  784004     MOV.B W4, W0
005802  07FE4F     RCALL GenerateI2CStart
005804  780200     MOV W0, W4
005806  720F1E     IOR W4, [W14], [W14]
29:                
30:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_WRITE_CONTROL_BIT), ptr_MCP23017->i2c_port);  // Write the address to the bus in WRITE MODE
005808  90021E     MOV [W14+2], W4
00580A  9042F4     MOV.B [W4+7], W5
00580C  90021E     MOV [W14+2], W4
00580E  904264     MOV.B [W4+6], W4
005810  784085     MOV.B W5, W1
005812  784004     MOV.B W4, W0
005814  07FE96     RCALL WriteByteI2C
005816  780200     MOV W0, W4
005818  720F1E     IOR W4, [W14], [W14]
31:                
32:                  error_check |= WriteByteI2C(MCP23017_register, ptr_MCP23017->i2c_port);                                     // Write the register location to the bus
00581A  90021E     MOV [W14+2], W4
00581C  904274     MOV.B [W4+7], W4
00581E  784084     MOV.B W4, W1
005820  90404E     MOV.B [W14+4], W0
005822  07FE8F     RCALL WriteByteI2C
005824  780200     MOV W0, W4
005826  720F1E     IOR W4, [W14], [W14]
33:                
34:                  error_check |= GenerateI2CRestart(ptr_MCP23017->i2c_port);                                                  // Generate re-start condition 
005828  90021E     MOV [W14+2], W4
00582A  904274     MOV.B [W4+7], W4
00582C  784004     MOV.B W4, W0
00582E  07FE61     RCALL GenerateI2CRestart
005830  780200     MOV W0, W4
005832  720F1E     IOR W4, [W14], [W14]
35:                
36:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_READ_CONTROL_BIT), ptr_MCP23017->i2c_port);   // Write the address to the bus in READ MODE
005834  90021E     MOV [W14+2], W4
005836  9042F4     MOV.B [W4+7], W5
005838  90021E     MOV [W14+2], W4
00583A  904264     MOV.B [W4+6], W4
00583C  A00404     BSET.B W4, #0
00583E  784085     MOV.B W5, W1
005840  784004     MOV.B W4, W0
005842  07FE7F     RCALL WriteByteI2C
005844  780200     MOV W0, W4
005846  720F1E     IOR W4, [W14], [W14]
37:                
38:                  error_check |= ReadByteI2C(ptr_MCP23017->i2c_port);                                                         // Read a byte from the bus
005848  90021E     MOV [W14+2], W4
00584A  904274     MOV.B [W4+7], W4
00584C  784004     MOV.B W4, W0
00584E  07FEB1     RCALL ReadByteI2C
005850  780200     MOV W0, W4
005852  720F1E     IOR W4, [W14], [W14]
39:                  
40:                  error_check |= GenerateI2CStop(ptr_MCP23017->i2c_port);                                                     // Generate Stop Condition
005854  90021E     MOV [W14+2], W4
005856  904274     MOV.B [W4+7], W4
005858  784004     MOV.B W4, W0
00585A  07FEE1     RCALL GenerateI2CStop
00585C  780200     MOV W0, W4
00585E  720F1E     IOR W4, [W14], [W14]
41:                  
42:                  ClrWdt();
005860  FE6000     CLRWDT
43:                  return error_check;
005862  78021E     MOV [W14], W4
44:                }
005864  780004     MOV W4, W0
005866  FA8000     ULNK
005868  060000     RETURN
45:                
46:                
47:                
48:                
49:                
---  C:/Users/DPARKER/Documents/GitHub/A36760/LTC2656.c  ------------------------------------------------
1:                 #include "LTC2656.h"
2:                 
3:                 
4:                 void SetupLTC2656(LTC2656* ptr_LTC2656) {
004EB6  FA0002     LNK #0x2
004EB8  780F00     MOV W0, [W14]
5:                   // See h File For Documentation
6:                   
7:                   PinSetValue(ptr_LTC2656->pin_dac_clear, !LTC2656_CLEAR_OUTPUTS);
004EBA  78021E     MOV [W14], W4
004EBC  900214     MOV [W4+2], W4
004EBE  784204     MOV.B W4, W4
004EC0  B3C011     MOV.B #0x1, W1
004EC2  784004     MOV.B W4, W0
004EC4  07021D     RCALL PinSetValue
8:                   PinSetValue(ptr_LTC2656->pin_load_dac, LTC2656_LOAD_DAC);
004EC6  78021E     MOV [W14], W4
004EC8  900224     MOV [W4+4], W4
004ECA  784204     MOV.B W4, W4
004ECC  EB4080     CLR.B W1
004ECE  784004     MOV.B W4, W0
004ED0  070217     RCALL PinSetValue
9:                   PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
004ED2  78021E     MOV [W14], W4
004ED4  780214     MOV [W4], W4
004ED6  784204     MOV.B W4, W4
004ED8  B3C011     MOV.B #0x1, W1
004EDA  784004     MOV.B W4, W0
004EDC  070211     RCALL PinSetValue
10:                  PinSetValue(ptr_LTC2656->pin_por_select, ptr_LTC2656->por_select_value);
004EDE  78021E     MOV [W14], W4
004EE0  900244     MOV [W4+8], W4
004EE2  784284     MOV.B W4, W5
004EE4  78021E     MOV [W14], W4
004EE6  900234     MOV [W4+6], W4
004EE8  784204     MOV.B W4, W4
004EEA  784085     MOV.B W5, W1
004EEC  784004     MOV.B W4, W0
004EEE  070208     RCALL PinSetValue
11:                  
12:                  PinSetTris(ptr_LTC2656->pin_cable_select, TRIS_DIGITAL_OUTPUT);
004EF0  78021E     MOV [W14], W4
004EF2  780214     MOV [W4], W4
004EF4  784204     MOV.B W4, W4
004EF6  EB4080     CLR.B W1
004EF8  784004     MOV.B W4, W0
004EFA  07015A     RCALL PinSetTris
13:                  PinSetTris(ptr_LTC2656->pin_dac_clear, TRIS_DIGITAL_INPUT);
004EFC  78021E     MOV [W14], W4
004EFE  900214     MOV [W4+2], W4
004F00  784204     MOV.B W4, W4
004F02  B3C011     MOV.B #0x1, W1
004F04  784004     MOV.B W4, W0
004F06  070154     RCALL PinSetTris
14:                  PinSetTris(ptr_LTC2656->pin_load_dac, TRIS_DIGITAL_OUTPUT);
004F08  78021E     MOV [W14], W4
004F0A  900224     MOV [W4+4], W4
004F0C  784204     MOV.B W4, W4
004F0E  EB4080     CLR.B W1
004F10  784004     MOV.B W4, W0
004F12  07014E     RCALL PinSetTris
15:                  PinSetTris(ptr_LTC2656->pin_por_select, TRIS_DIGITAL_OUTPUT);  
004F14  78021E     MOV [W14], W4
004F16  900234     MOV [W4+6], W4
004F18  784204     MOV.B W4, W4
004F1A  EB4080     CLR.B W1
004F1C  784004     MOV.B W4, W0
004F1E  070148     RCALL PinSetTris
16:                }
004F20  FA8000     ULNK
004F22  060000     RETURN
17:                
18:                
19:                void ClearOutputsLTC2656(LTC2656* ptr_LTC2656) {
004F24  FA0002     LNK #0x2
004F26  780F00     MOV W0, [W14]
20:                  PinSetValue(ptr_LTC2656->pin_dac_clear, LTC2656_CLEAR_OUTPUTS);
004F28  78021E     MOV [W14], W4
004F2A  900214     MOV [W4+2], W4
004F2C  784204     MOV.B W4, W4
004F2E  EB4080     CLR.B W1
004F30  784004     MOV.B W4, W0
004F32  0701E6     RCALL PinSetValue
21:                  PinSetValue(ptr_LTC2656->pin_dac_clear, !LTC2656_CLEAR_OUTPUTS);
004F34  78021E     MOV [W14], W4
004F36  900214     MOV [W4+2], W4
004F38  784204     MOV.B W4, W4
004F3A  B3C011     MOV.B #0x1, W1
004F3C  784004     MOV.B W4, W0
004F3E  0701E0     RCALL PinSetValue
22:                }
004F40  FA8000     ULNK
004F42  060000     RETURN
23:                
24:                
25:                
26:                unsigned char WriteLTC2656(LTC2656* ptr_LTC2656, unsigned int command_word, unsigned int data_word) {
004F44  FA0010     LNK #0x10
004F46  980750     MOV W0, [W14+10]
004F48  980761     MOV W1, [W14+12]
004F4A  980772     MOV W2, [W14+14]
27:                  // See h File For Documentation
28:                  
29:                  unsigned char spi_error;
30:                  unsigned int command_word_readback;
31:                  unsigned int data_word_readback;
32:                  unsigned long temp;
33:                  
34:                  spi_error = 0;
004F4C  EB4200     CLR.B W4
004F4E  784F04     MOV.B W4, [W14]
35:                
36:                  PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
004F50  90025E     MOV [W14+10], W4
004F52  780214     MOV [W4], W4
004F54  784204     MOV.B W4, W4
004F56  EB4080     CLR.B W1
004F58  784004     MOV.B W4, W0
004F5A  0701D2     RCALL PinSetValue
37:                
38:                
39:                  temp = SendAndReceiveSPI(command_word, ptr_LTC2656->spi_port);
004F5C  90025E     MOV [W14+10], W4
004F5E  904A24     MOV.B [W4+10], W4
004F60  784084     MOV.B W4, W1
004F62  90006E     MOV [W14+12], W0
004F64  070384     RCALL SendAndReceiveSPI
004F66  BE0200     MOV.D W0, W4
004F68  980734     MOV W4, [W14+6]
004F6A  980745     MOV W5, [W14+8]
40:                  if (temp == 0x11110000) {
004F6C  90033E     MOV [W14+6], W6
004F6E  9003CE     MOV [W14+8], W7
004F70  200004     MOV #0x0, W4
004F72  211115     MOV #0x1111, W5
004F74  530F84     SUB W6, W4, [W15]
004F76  5B8F85     SUBB W7, W5, [W15]
004F78  3A0002     BRA NZ, .L4, .LSM20
41:                    spi_error = 0b00000001;
004F7A  B3C014     MOV.B #0x1, W4
004F7C  784F04     MOV.B W4, [W14]
42:                  } 
43:                
44:                  if (spi_error == 0) { 
004F7E  78421E     MOV.B [W14], W4
004F80  524FE0     SUB.B W4, #0x0, [W15]
004F82  3A0010     BRA NZ, .L5, .LSM24
45:                    temp = SendAndReceiveSPI(data_word, ptr_LTC2656->spi_port);
004F84  90025E     MOV [W14+10], W4
004F86  904A24     MOV.B [W4+10], W4
004F88  784084     MOV.B W4, W1
004F8A  90007E     MOV [W14+14], W0
004F8C  070370     RCALL SendAndReceiveSPI
004F8E  BE0200     MOV.D W0, W4
004F90  980734     MOV W4, [W14+6]
004F92  980745     MOV W5, [W14+8]
46:                    if (temp == 0x11110000) {
004F94  90033E     MOV [W14+6], W6
004F96  9003CE     MOV [W14+8], W7
004F98  200004     MOV #0x0, W4
004F9A  211115     MOV #0x1111, W5
004F9C  530F84     SUB W6, W4, [W15]
004F9E  5B8F85     SUBB W7, W5, [W15]
004FA0  3A0001     BRA NZ, .L5, .LSM24
47:                      spi_error |= 0b00000010;
004FA2  A0141E     BSET.B [W14], #1
48:                    } 
49:                  }
50:                 
51:                
52:                  PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
004FA4  90025E     MOV [W14+10], W4
004FA6  780214     MOV [W4], W4
004FA8  784204     MOV.B W4, W4
004FAA  B3C011     MOV.B #0x1, W1
004FAC  784004     MOV.B W4, W0
004FAE  0701A8     RCALL PinSetValue
53:                 
54:                  Nop();
004FB0  000000     NOP
55:                  
56:                  PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
004FB2  90025E     MOV [W14+10], W4
004FB4  780214     MOV [W4], W4
004FB6  784204     MOV.B W4, W4
004FB8  EB4080     CLR.B W1
004FBA  784004     MOV.B W4, W0
004FBC  0701A1     RCALL PinSetValue
57:                
58:                
59:                  if (spi_error == 0) { 
004FBE  78421E     MOV.B [W14], W4
004FC0  524FE0     SUB.B W4, #0x0, [W15]
004FC2  3A0012     BRA NZ, .L6, .LSM32
60:                    temp = SendAndReceiveSPI(LTC2656_CMD_NO_OPERATION, ptr_LTC2656->spi_port);
004FC4  90025E     MOV [W14+10], W4
004FC6  904A24     MOV.B [W4+10], W4
004FC8  784084     MOV.B W4, W1
004FCA  200F00     MOV #0xF0, W0
004FCC  070350     RCALL SendAndReceiveSPI
004FCE  BE0200     MOV.D W0, W4
004FD0  980734     MOV W4, [W14+6]
004FD2  980745     MOV W5, [W14+8]
61:                    command_word_readback = temp & 0xFFFF;
004FD4  90023E     MOV [W14+6], W4
004FD6  980714     MOV W4, [W14+2]
62:                    if (temp == 0x11110000) {
004FD8  90033E     MOV [W14+6], W6
004FDA  9003CE     MOV [W14+8], W7
004FDC  200004     MOV #0x0, W4
004FDE  211115     MOV #0x1111, W5
004FE0  530F84     SUB W6, W4, [W15]
004FE2  5B8F85     SUBB W7, W5, [W15]
004FE4  3A0001     BRA NZ, .L6, .LSM32
63:                      spi_error |= 0b00000100;
004FE6  A0241E     BSET.B [W14], #2
64:                    } 
65:                  }
66:                
67:                  if (spi_error == 0) { 
004FE8  78421E     MOV.B [W14], W4
004FEA  524FE0     SUB.B W4, #0x0, [W15]
004FEC  3A0012     BRA NZ, .L7, .LSM37
68:                    temp = SendAndReceiveSPI(0, ptr_LTC2656->spi_port);
004FEE  90025E     MOV [W14+10], W4
004FF0  904A24     MOV.B [W4+10], W4
004FF2  784084     MOV.B W4, W1
004FF4  EB0000     CLR W0
004FF6  07033B     RCALL SendAndReceiveSPI
004FF8  BE0200     MOV.D W0, W4
004FFA  980734     MOV W4, [W14+6]
004FFC  980745     MOV W5, [W14+8]
69:                    data_word_readback = temp & 0xFFFF;
004FFE  90023E     MOV [W14+6], W4
005000  980724     MOV W4, [W14+4]
70:                    if (temp == 0x11110000) {
005002  90033E     MOV [W14+6], W6
005004  9003CE     MOV [W14+8], W7
005006  200004     MOV #0x0, W4
005008  211115     MOV #0x1111, W5
00500A  530F84     SUB W6, W4, [W15]
00500C  5B8F85     SUBB W7, W5, [W15]
00500E  3A0001     BRA NZ, .L7, .LSM37
71:                      spi_error |= 0b00001000;
005010  A0341E     BSET.B [W14], #3
72:                    } 
73:                  }
74:                
75:                  PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
005012  90025E     MOV [W14+10], W4
005014  780214     MOV [W4], W4
005016  784204     MOV.B W4, W4
005018  B3C011     MOV.B #0x1, W1
00501A  784004     MOV.B W4, W0
00501C  070171     RCALL PinSetValue
76:                
77:                
78:                  if (command_word_readback != command_word) {
00501E  90029E     MOV [W14+2], W5
005020  90026E     MOV [W14+12], W4
005022  528F84     SUB W5, W4, [W15]
005024  320001     BRA Z, .L8, .LSM40
79:                    spi_error |= 0b00010000;
005026  A0441E     BSET.B [W14], #4
80:                  }
81:                  if (data_word_readback != data_word) {
005028  9002AE     MOV [W14+4], W5
00502A  90027E     MOV [W14+14], W4
00502C  528F84     SUB W5, W4, [W15]
00502E  320002     BRA Z, .L9, .LSM42
82:                    spi_error |= 0b00100000;
005030  B3C204     MOV.B #0x20, W4
005032  724F1E     IOR.B W4, [W14], [W14]
83:                  }
84:                  
85:                
86:                  return spi_error;
005034  78421E     MOV.B [W14], W4
87:                }
005036  784004     MOV.B W4, W0
005038  FA8000     ULNK
00503A  060000     RETURN
88:                
89:                
90:                unsigned char WriteLTC2656AllDacChannels(LTC2656* ptr_LTC2656, unsigned int *dac_array) {
00503C  FA0010     LNK #0x10
00503E  980760     MOV W0, [W14+12]
005040  980771     MOV W1, [W14+14]
91:                  // See h File For Documentation
92:                  
93:                  unsigned char spi_error;
94:                  unsigned int command_word_readback;
95:                  unsigned int data_word_readback;
96:                  unsigned long temp;
97:                  unsigned char dac_number;
98:                
99:                  spi_error = 0;
005042  EB4200     CLR.B W4
005044  784F04     MOV.B W4, [W14]
100:                 dac_number = 0;
005046  EB4200     CLR.B W4
005048  984764     MOV.B W4, [W14+6]
101:                 
102:                 while ((spi_error == 0) && (dac_number < 8)) {
00504A  370059     BRA .L11, .LSM65
0050FE  78421E     MOV.B [W14], W4
005100  524FE0     SUB.B W4, #0x0, [W15]
005102  3A0003     BRA NZ, .L16, .LSM66
005104  90426E     MOV.B [W14+6], W4
005106  524FE7     SUB.B W4, #0x7, [W15]
005108  36FFA1     BRA LEU, .L17, .LSM48
103:                   // Send out two 16 bit words on the SPI BUS
104:               
105:                   PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
00504C  90026E     MOV [W14+12], W4
00504E  780214     MOV [W4], W4
005050  784204     MOV.B W4, W4
005052  EB4080     CLR.B W1
005054  784004     MOV.B W4, W0
005056  070154     RCALL PinSetValue
106:                   
107:                   temp = SendAndReceiveSPI(LTC2656_CMD_WRITE_AND_UPDATE_N | dac_number, ptr_LTC2656->spi_port);
005058  90026E     MOV [W14+12], W4
00505A  904A24     MOV.B [W4+10], W4
00505C  90436E     MOV.B [W14+6], W6
00505E  B3C305     MOV.B #0x30, W5
005060  734285     IOR.B W6, W5, W5
005062  FB8285     ZE W5, W5
005064  784084     MOV.B W4, W1
005066  780005     MOV W5, W0
005068  070302     RCALL SendAndReceiveSPI
00506A  BE0200     MOV.D W0, W4
00506C  980744     MOV W4, [W14+8]
00506E  980755     MOV W5, [W14+10]
108:                   command_word_readback = temp & 0xFFFF;
005070  90024E     MOV [W14+8], W4
005072  980714     MOV W4, [W14+2]
109:                   if (temp == 0x11110000) {
005074  90034E     MOV [W14+8], W6
005076  9003DE     MOV [W14+10], W7
005078  200004     MOV #0x0, W4
00507A  211115     MOV #0x1111, W5
00507C  530F84     SUB W6, W4, [W15]
00507E  5B8F85     SUBB W7, W5, [W15]
005080  3A0002     BRA NZ, .L12, .LSM53
110:                     spi_error = 0b00000001;
005082  B3C014     MOV.B #0x1, W4
005084  784F04     MOV.B W4, [W14]
111:                   } 
112:                   
113:                   if (spi_error == 0) { 
005086  78421E     MOV.B [W14], W4
005088  524FE0     SUB.B W4, #0x0, [W15]
00508A  3A0018     BRA NZ, .L13, .LSM58
114:                     temp = SendAndReceiveSPI(dac_array[dac_number], ptr_LTC2656->spi_port);
00508C  90026E     MOV [W14+12], W4
00508E  904A24     MOV.B [W4+10], W4
005090  9042EE     MOV.B [W14+6], W5
005092  FB8285     ZE W5, W5
005094  428285     ADD W5, W5, W5
005096  90037E     MOV [W14+14], W6
005098  430285     ADD W6, W5, W5
00509A  780295     MOV [W5], W5
00509C  784084     MOV.B W4, W1
00509E  780005     MOV W5, W0
0050A0  0702E6     RCALL SendAndReceiveSPI
0050A2  BE0200     MOV.D W0, W4
0050A4  980744     MOV W4, [W14+8]
0050A6  980755     MOV W5, [W14+10]
115:                     data_word_readback = temp & 0xFFFF;
0050A8  90024E     MOV [W14+8], W4
0050AA  980724     MOV W4, [W14+4]
116:                     if (temp == 0x11110000) {
0050AC  90034E     MOV [W14+8], W6
0050AE  9003DE     MOV [W14+10], W7
0050B0  200004     MOV #0x0, W4
0050B2  211115     MOV #0x1111, W5
0050B4  530F84     SUB W6, W4, [W15]
0050B6  5B8F85     SUBB W7, W5, [W15]
0050B8  3A0001     BRA NZ, .L13, .LSM58
117:               	spi_error |= 0b00000010;
0050BA  A0141E     BSET.B [W14], #1
118:                     } 
119:                   }
120:               
121:                   // Check that the command/data returned match the command/data sent out on the previous cycle
122:                   if (dac_number > 0) {
0050BC  90426E     MOV.B [W14+6], W4
0050BE  524FE0     SUB.B W4, #0x0, [W15]
0050C0  320015     BRA Z, .L14, .LSM63
123:                     if (command_word_readback != (LTC2656_CMD_WRITE_AND_UPDATE_N | (dac_number - 1))) {
0050C2  90426E     MOV.B [W14+6], W4
0050C4  FB8204     ZE W4, W4
0050C6  E90284     DEC W4, W5
0050C8  200304     MOV #0x30, W4
0050CA  720205     IOR W4, W5, W4
0050CC  780284     MOV W4, W5
0050CE  90021E     MOV [W14+2], W4
0050D0  528F84     SUB W5, W4, [W15]
0050D2  320001     BRA Z, .L15, .LSM61
124:               	spi_error |= 0b00000100;
0050D4  A0241E     BSET.B [W14], #2
125:                     }
126:                     if (data_word_readback != dac_array[dac_number-1]) {
0050D6  90426E     MOV.B [W14+6], W4
0050D8  FB8204     ZE W4, W4
0050DA  E90204     DEC W4, W4
0050DC  420204     ADD W4, W4, W4
0050DE  9002FE     MOV [W14+14], W5
0050E0  428204     ADD W5, W4, W4
0050E2  780294     MOV [W4], W5
0050E4  90022E     MOV [W14+4], W4
0050E6  528F84     SUB W5, W4, [W15]
0050E8  320001     BRA Z, .L14, .LSM63
127:               	spi_error |= 0b00001000;
0050EA  A0341E     BSET.B [W14], #3
128:                     }   
129:                   }
130:                   
131:                   PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
0050EC  90026E     MOV [W14+12], W4
0050EE  780214     MOV [W4], W4
0050F0  784204     MOV.B W4, W4
0050F2  B3C011     MOV.B #0x1, W1
0050F4  784004     MOV.B W4, W0
0050F6  070104     RCALL PinSetValue
132:                   
133:                   dac_number++;
0050F8  90426E     MOV.B [W14+6], W4
0050FA  E84204     INC.B W4, W4
0050FC  984764     MOV.B W4, [W14+6]
134:                 }
135:               
136:                 // Read back the error check from the last command/data string sent out
137:                 PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
00510A  90026E     MOV [W14+12], W4
00510C  780214     MOV [W4], W4
00510E  784204     MOV.B W4, W4
005110  EB4080     CLR.B W1
005112  784004     MOV.B W4, W0
005114  0700F5     RCALL PinSetValue
138:               
139:                 if (spi_error == 0) { 
005116  78421E     MOV.B [W14], W4
005118  524FE0     SUB.B W4, #0x0, [W15]
00511A  3A0012     BRA NZ, .L18, .LSM72
140:                   temp = SendAndReceiveSPI(LTC2656_CMD_SELECT_INTERNAL_REFERENCE, ptr_LTC2656->spi_port);
00511C  90026E     MOV [W14+12], W4
00511E  904A24     MOV.B [W4+10], W4
005120  784084     MOV.B W4, W1
005122  200600     MOV #0x60, W0
005124  0702A4     RCALL SendAndReceiveSPI
005126  BE0200     MOV.D W0, W4
005128  980744     MOV W4, [W14+8]
00512A  980755     MOV W5, [W14+10]
141:                   command_word_readback = temp & 0xFFFF;
00512C  90024E     MOV [W14+8], W4
00512E  980714     MOV W4, [W14+2]
142:                   if (temp == 0x11110000) {
005130  90034E     MOV [W14+8], W6
005132  9003DE     MOV [W14+10], W7
005134  200004     MOV #0x0, W4
005136  211115     MOV #0x1111, W5
005138  530F84     SUB W6, W4, [W15]
00513A  5B8F85     SUBB W7, W5, [W15]
00513C  3A0001     BRA NZ, .L18, .LSM72
143:                     spi_error |= 0b00000001;
00513E  A0041E     BSET.B [W14], #0
144:                   } 
145:                 }
146:               
147:                 if (spi_error == 0) { 
005140  78421E     MOV.B [W14], W4
005142  524FE0     SUB.B W4, #0x0, [W15]
005144  3A0012     BRA NZ, .L19, .LSM77
148:                   temp = SendAndReceiveSPI(0, ptr_LTC2656->spi_port);
005146  90026E     MOV [W14+12], W4
005148  904A24     MOV.B [W4+10], W4
00514A  784084     MOV.B W4, W1
00514C  EB0000     CLR W0
00514E  07028F     RCALL SendAndReceiveSPI
005150  BE0200     MOV.D W0, W4
005152  980744     MOV W4, [W14+8]
005154  980755     MOV W5, [W14+10]
149:                   data_word_readback = temp & 0xFFFF;
005156  90024E     MOV [W14+8], W4
005158  980724     MOV W4, [W14+4]
150:                   if (temp == 0x11110000) {
00515A  90034E     MOV [W14+8], W6
00515C  9003DE     MOV [W14+10], W7
00515E  200004     MOV #0x0, W4
005160  211115     MOV #0x1111, W5
005162  530F84     SUB W6, W4, [W15]
005164  5B8F85     SUBB W7, W5, [W15]
005166  3A0001     BRA NZ, .L19, .LSM77
151:                     spi_error |= 0b00000010;
005168  A0141E     BSET.B [W14], #1
152:                   } 
153:                 }
154:                 
155:                 PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
00516A  90026E     MOV [W14+12], W4
00516C  780214     MOV [W4], W4
00516E  784204     MOV.B W4, W4
005170  B3C011     MOV.B #0x1, W1
005172  784004     MOV.B W4, W0
005174  0700C5     RCALL PinSetValue
156:                 
157:                 
158:                 if (command_word_readback != (LTC2656_CMD_WRITE_AND_UPDATE_N | (dac_number - 1))) {
005176  90426E     MOV.B [W14+6], W4
005178  FB8204     ZE W4, W4
00517A  E90284     DEC W4, W5
00517C  200304     MOV #0x30, W4
00517E  720205     IOR W4, W5, W4
005180  780284     MOV W4, W5
005182  90021E     MOV [W14+2], W4
005184  528F84     SUB W5, W4, [W15]
005186  320001     BRA Z, .L20, .LSM80
159:                   spi_error |= 0b00010000;
005188  A0441E     BSET.B [W14], #4
160:                 }
161:                 if (data_word_readback != dac_array[dac_number-1]) {
00518A  90426E     MOV.B [W14+6], W4
00518C  FB8204     ZE W4, W4
00518E  E90204     DEC W4, W4
005190  420204     ADD W4, W4, W4
005192  9002FE     MOV [W14+14], W5
005194  428204     ADD W5, W4, W4
005196  780294     MOV [W4], W5
005198  90022E     MOV [W14+4], W4
00519A  528F84     SUB W5, W4, [W15]
00519C  320002     BRA Z, .L21, .LSM82
162:                   spi_error |= 0b00100000;
00519E  B3C204     MOV.B #0x20, W4
0051A0  724F1E     IOR.B W4, [W14], [W14]
163:                 }
164:               
165:               
166:                 Nop();
0051A2  000000     NOP
167:                 Nop();
0051A4  000000     NOP
168:                 Nop();
0051A6  000000     NOP
169:               
170:               
171:                 return spi_error;
0051A8  78421E     MOV.B [W14], W4
172:               }
0051AA  784004     MOV.B W4, W0
0051AC  FA8000     ULNK
0051AE  060000     RETURN
---  C:/Users/DPARKER/Documents/GitHub/A36760/IOPorts.c  ------------------------------------------------
1:                 #include "IOPorts.h"
2:                 
3:                 
4:                 void PinSetTris(unsigned char pin, unsigned char tris_state) {
0051B0  FA0004     LNK #0x4
0051B2  984720     MOV.B W0, [W14+2]
0051B4  984731     MOV.B W1, [W14+3]
5:                   /*
6:                     This is a very ineffecient way of setting the TRIS, but it is usefull because it 
7:                     1) Allows a framework for pins to passed to function
8:                     2) Is easy for others to use as a simple integer for the pin can be passed to functions
9:                   */
10:                  
11:                  unsigned char port;
12:                  unsigned char bit;
13:                  
14:                  port = pin & 0xF0;
0051B6  9042AE     MOV.B [W14+2], W5
0051B8  B3CF04     MOV.B #0xF0, W4
0051BA  62CF04     AND.B W5, W4, [W14]
15:                  bit = pin & 0x0F;
0051BC  90422E     MOV.B [W14+2], W4
0051BE  62426F     AND.B W4, #0xF, W4
0051C0  984714     MOV.B W4, [W14+1]
16:                  
17:                  switch (port) {
0051C2  78429E     MOV.B [W14], W5
0051C4  FB8205     ZE W5, W4
0051C6  200B05     MOV #0xB0, W5
0051C8  520F85     SUB W4, W5, [W15]
0051CA  32002A     BRA Z, .L5, .LSM9
0051CC  200B05     MOV #0xB0, W5
0051CE  520F85     SUB W4, W5, [W15]
0051D0  3C0007     BRA GT, .L9
0051D2  200905     MOV #0x90, W5
0051D4  520F85     SUB W4, W5, [W15]
0051D6  32007C     BRA Z, .L3, .LSM29
0051D8  200A05     MOV #0xA0, W5
0051DA  520F85     SUB W4, W5, [W15]
0051DC  32000B     BRA Z, .L4, .LSM4
0051DE  37008E     BRA .L1, .LSM34
0051E0  200D05     MOV #0xD0, W5
0051E2  520F85     SUB W4, W5, [W15]
0051E4  320049     BRA Z, .L7, .LSM19
0051E6  200F05     MOV #0xF0, W5
0051E8  520F85     SUB W4, W5, [W15]
0051EA  32005C     BRA Z, .L8, .LSM24
0051EC  200C05     MOV #0xC0, W5
0051EE  520F85     SUB W4, W5, [W15]
0051F0  32002D     BRA Z, .L6, .LSM14
0051F2  370084     BRA .L1, .LSM34
18:                    
19:                #if defined(_PORTA)
20:                  case _PORT_PORTA:
21:                    if (tris_state) {
0051F4  90423E     MOV.B [W14+3], W4
0051F6  524FE0     SUB.B W4, #0x0, [W15]
0051F8  320009     BRA Z, .L10, .LSM7
22:                      TRISA = TRISA | (0x01 << bit);
0051FA  90421E     MOV.B [W14+1], W4
0051FC  FB8204     ZE W4, W4
0051FE  200015     MOV #0x1, W5
005200  DD2A04     SL W5, W4, W4
005202  780284     MOV W4, W5
005204  801604     MOV TRISA, W4
005206  720205     IOR W4, W5, W4
005208  881604     MOV W4, TRISA
23:                    } else {
24:                      TRISA = TRISA & (~(0x01 << bit));
00520C  90421E     MOV.B [W14+1], W4
00520E  FB8204     ZE W4, W4
005210  200015     MOV #0x1, W5
005212  DD2A04     SL W5, W4, W4
005214  EA8204     COM W4, W4
005216  780284     MOV W4, W5
005218  801604     MOV TRISA, W4
00521A  628204     AND W5, W4, W4
00521C  881604     MOV W4, TRISA
25:                    }
26:                    break;
00520A  370078     BRA .L1, .LSM34
00521E  37006E     BRA .L1, .LSM34
27:                #endif
28:                
29:                #if defined(_PORTB)
30:                  case _PORT_PORTB:
31:                    if (tris_state) {
005220  90423E     MOV.B [W14+3], W4
005222  524FE0     SUB.B W4, #0x0, [W15]
005224  320009     BRA Z, .L12, .LSM12
32:                      TRISB = TRISB | (0x01 << bit);
005226  90421E     MOV.B [W14+1], W4
005228  FB8204     ZE W4, W4
00522A  200015     MOV #0x1, W5
00522C  DD2A04     SL W5, W4, W4
00522E  780284     MOV W4, W5
005230  801634     MOV TRISB, W4
005232  720205     IOR W4, W5, W4
005234  881634     MOV W4, TRISB
33:                    } else {
34:                      TRISB = TRISB & (~(0x01 << bit));
005238  90421E     MOV.B [W14+1], W4
00523A  FB8204     ZE W4, W4
00523C  200015     MOV #0x1, W5
00523E  DD2A04     SL W5, W4, W4
005240  EA8204     COM W4, W4
005242  780284     MOV W4, W5
005244  801634     MOV TRISB, W4
005246  628204     AND W5, W4, W4
005248  881634     MOV W4, TRISB
35:                    }
36:                    break;
005236  370062     BRA .L1, .LSM34
00524A  370058     BRA .L1, .LSM34
37:                #endif
38:                    
39:                #if defined(_PORTC)
40:                  case _PORT_PORTC:
41:                    if (tris_state) {
00524C  90423E     MOV.B [W14+3], W4
00524E  524FE0     SUB.B W4, #0x0, [W15]
005250  320009     BRA Z, .L14, .LSM17
42:                      TRISC = TRISC | (0x01 << bit);
005252  90421E     MOV.B [W14+1], W4
005254  FB8204     ZE W4, W4
005256  200015     MOV #0x1, W5
005258  DD2A04     SL W5, W4, W4
00525A  780284     MOV W4, W5
00525C  801664     MOV TRISC, W4
00525E  720205     IOR W4, W5, W4
005260  881664     MOV W4, TRISC
43:                    } else {
44:                      TRISC = TRISC & (~(0x01 << bit));
005264  90421E     MOV.B [W14+1], W4
005266  FB8204     ZE W4, W4
005268  200015     MOV #0x1, W5
00526A  DD2A04     SL W5, W4, W4
00526C  EA8204     COM W4, W4
00526E  780284     MOV W4, W5
005270  801664     MOV TRISC, W4
005272  628204     AND W5, W4, W4
005274  881664     MOV W4, TRISC
45:                    }
46:                    break;
005262  37004C     BRA .L1, .LSM34
005276  370042     BRA .L1, .LSM34
47:                #endif
48:                
49:                #if defined(_PORTD)
50:                  case _PORT_PORTD:
51:                    if (tris_state) {
005278  90423E     MOV.B [W14+3], W4
00527A  524FE0     SUB.B W4, #0x0, [W15]
00527C  320009     BRA Z, .L16, .LSM22
52:                      TRISD = TRISD | (0x01 << bit);
00527E  90421E     MOV.B [W14+1], W4
005280  FB8204     ZE W4, W4
005282  200015     MOV #0x1, W5
005284  DD2A04     SL W5, W4, W4
005286  780284     MOV W4, W5
005288  801694     MOV TRISD, W4
00528A  720205     IOR W4, W5, W4
00528C  881694     MOV W4, TRISD
53:                    } else {
54:                      TRISD = TRISD & (~(0x01 << bit));
005290  90421E     MOV.B [W14+1], W4
005292  FB8204     ZE W4, W4
005294  200015     MOV #0x1, W5
005296  DD2A04     SL W5, W4, W4
005298  EA8204     COM W4, W4
00529A  780284     MOV W4, W5
00529C  801694     MOV TRISD, W4
00529E  628204     AND W5, W4, W4
0052A0  881694     MOV W4, TRISD
55:                    }
56:                    break;
00528E  370036     BRA .L1, .LSM34
0052A2  37002C     BRA .L1, .LSM34
57:                #endif
58:                
59:                
60:                #if defined(_PORTE)    
61:                  case _PORT_PORTE:
62:                    if (tris_state) {
63:                      TRISE = TRISE | (0x01 << bit);
64:                    } else {
65:                      TRISE = TRISE & (~(0x01 << bit));
66:                    }
67:                    break;
68:                #endif
69:                
70:                #if defined(_PORTF)    
71:                  case _PORT_PORTF:
72:                    if (tris_state) {
0052A4  90423E     MOV.B [W14+3], W4
0052A6  524FE0     SUB.B W4, #0x0, [W15]
0052A8  320009     BRA Z, .L18, .LSM27
73:                      TRISF = TRISF | (0x01 << bit);
0052AA  90421E     MOV.B [W14+1], W4
0052AC  FB8204     ZE W4, W4
0052AE  200015     MOV #0x1, W5
0052B0  DD2A04     SL W5, W4, W4
0052B2  780284     MOV W4, W5
0052B4  8016F4     MOV TRISF, W4
0052B6  720205     IOR W4, W5, W4
0052B8  8816F4     MOV W4, TRISF
74:                    } else {
75:                      TRISF = TRISF & (~(0x01 << bit));
0052BC  90421E     MOV.B [W14+1], W4
0052BE  FB8204     ZE W4, W4
0052C0  200015     MOV #0x1, W5
0052C2  DD2A04     SL W5, W4, W4
0052C4  EA8204     COM W4, W4
0052C6  780284     MOV W4, W5
0052C8  8016F4     MOV TRISF, W4
0052CA  628204     AND W5, W4, W4
0052CC  8816F4     MOV W4, TRISF
76:                    }
77:                    break;
0052BA  370020     BRA .L1, .LSM34
0052CE  370016     BRA .L1, .LSM34
78:                #endif
79:                    
80:                #if defined(_PORTG)
81:                  case _PORT_PORTG:
82:                    if (tris_state) {
0052D0  90423E     MOV.B [W14+3], W4
0052D2  524FE0     SUB.B W4, #0x0, [W15]
0052D4  320009     BRA Z, .L20, .LSM32
83:                      TRISG = TRISG | (0x01 << bit);
0052D6  90421E     MOV.B [W14+1], W4
0052D8  FB8204     ZE W4, W4
0052DA  200015     MOV #0x1, W5
0052DC  DD2A04     SL W5, W4, W4
0052DE  780284     MOV W4, W5
0052E0  801724     MOV TRISG, W4
0052E2  720205     IOR W4, W5, W4
0052E4  881724     MOV W4, TRISG
84:                    } else {
85:                      TRISG = TRISG & (~(0x01 << bit));
0052E8  90421E     MOV.B [W14+1], W4
0052EA  FB8204     ZE W4, W4
0052EC  200015     MOV #0x1, W5
0052EE  DD2A04     SL W5, W4, W4
0052F0  EA8204     COM W4, W4
0052F2  780284     MOV W4, W5
0052F4  801724     MOV TRISG, W4
0052F6  628204     AND W5, W4, W4
0052F8  881724     MOV W4, TRISG
86:                    }
87:                    break;
0052E6  37000A     BRA .L1, .LSM34
0052FA  000000     NOP
88:                #endif
89:                    
90:                  }
91:                }
0052FC  FA8000     ULNK
0052FE  060000     RETURN
92:                
93:                void PinSetValue(unsigned char pin, unsigned char pin_value) {
005300  FA0004     LNK #0x4
005302  984720     MOV.B W0, [W14+2]
005304  984731     MOV.B W1, [W14+3]
94:                  /*
95:                    This is a very ineffecient way of setting pins, but it is usefull because it 
96:                    1) Allows a framework for pins to passed to function
97:                    2) Is easy for others to use as a simple integer for the pin can be passed to functions
98:                    Note that is changes the LATCH registers not, the output registers.  DO NOT SET the output registers, use the Latches instead
99:                  */
100:                 
101:                 unsigned char port;
102:                 unsigned char bit;
103:                 
104:                 port = pin & 0xF0; 
005306  9042AE     MOV.B [W14+2], W5
005308  B3CF04     MOV.B #0xF0, W4
00530A  62CF04     AND.B W5, W4, [W14]
105:                 bit = pin & 0x0F;
00530C  90422E     MOV.B [W14+2], W4
00530E  62426F     AND.B W4, #0xF, W4
005310  984714     MOV.B W4, [W14+1]
106:                 
107:                 switch (port) {
005312  78429E     MOV.B [W14], W5
005314  FB8205     ZE W5, W4
005316  200B05     MOV #0xB0, W5
005318  520F85     SUB W4, W5, [W15]
00531A  32002A     BRA Z, .L26, .LSM44
00531C  200B05     MOV #0xB0, W5
00531E  520F85     SUB W4, W5, [W15]
005320  3C0007     BRA GT, .L30
005322  200905     MOV #0x90, W5
005324  520F85     SUB W4, W5, [W15]
005326  32007C     BRA Z, .L24, .LSM64
005328  200A05     MOV #0xA0, W5
00532A  520F85     SUB W4, W5, [W15]
00532C  32000B     BRA Z, .L25, .LSM39
00532E  37008E     BRA .L22, .LSM69
005330  200D05     MOV #0xD0, W5
005332  520F85     SUB W4, W5, [W15]
005334  320049     BRA Z, .L28, .LSM54
005336  200F05     MOV #0xF0, W5
005338  520F85     SUB W4, W5, [W15]
00533A  32005C     BRA Z, .L29, .LSM59
00533C  200C05     MOV #0xC0, W5
00533E  520F85     SUB W4, W5, [W15]
005340  32002D     BRA Z, .L27, .LSM49
005342  370084     BRA .L22, .LSM69
108:                
109:               #if defined(_PORTA)
110:                 case _PORT_PORTA:
111:                   if (pin_value) {
005344  90423E     MOV.B [W14+3], W4
005346  524FE0     SUB.B W4, #0x0, [W15]
005348  320009     BRA Z, .L31, .LSM42
112:                     LATA = LATA | (0x01 << bit);
00534A  90421E     MOV.B [W14+1], W4
00534C  FB8204     ZE W4, W4
00534E  200015     MOV #0x1, W5
005350  DD2A04     SL W5, W4, W4
005352  780284     MOV W4, W5
005354  801624     MOV LATA, W4
005356  720205     IOR W4, W5, W4
005358  881624     MOV W4, LATA
113:                   } else {
114:                     LATA = LATA & (~(0x01 << bit));
00535C  90421E     MOV.B [W14+1], W4
00535E  FB8204     ZE W4, W4
005360  200015     MOV #0x1, W5
005362  DD2A04     SL W5, W4, W4
005364  EA8204     COM W4, W4
005366  780284     MOV W4, W5
005368  801624     MOV LATA, W4
00536A  628204     AND W5, W4, W4
00536C  881624     MOV W4, LATA
115:                   }
116:                   break;
00535A  370078     BRA .L22, .LSM69
00536E  37006E     BRA .L22, .LSM69
117:               #endif
118:               
119:               #if defined(_PORTB)
120:                 case _PORT_PORTB:
121:                   if (pin_value) {
005370  90423E     MOV.B [W14+3], W4
005372  524FE0     SUB.B W4, #0x0, [W15]
005374  320009     BRA Z, .L33, .LSM47
122:                     LATB = LATB | (0x01 << bit);
005376  90421E     MOV.B [W14+1], W4
005378  FB8204     ZE W4, W4
00537A  200015     MOV #0x1, W5
00537C  DD2A04     SL W5, W4, W4
00537E  780284     MOV W4, W5
005380  801654     MOV LATB, W4
005382  720205     IOR W4, W5, W4
005384  881654     MOV W4, LATB
123:                   } else {
124:                     LATB = LATB & (~(0x01 << bit));
005388  90421E     MOV.B [W14+1], W4
00538A  FB8204     ZE W4, W4
00538C  200015     MOV #0x1, W5
00538E  DD2A04     SL W5, W4, W4
005390  EA8204     COM W4, W4
005392  780284     MOV W4, W5
005394  801654     MOV LATB, W4
005396  628204     AND W5, W4, W4
005398  881654     MOV W4, LATB
125:                   }
126:                   break;
005386  370062     BRA .L22, .LSM69
00539A  370058     BRA .L22, .LSM69
127:               #endif
128:               
129:               #if defined(_PORTC)
130:                 case _PORT_PORTC:
131:                   if (pin_value) {
00539C  90423E     MOV.B [W14+3], W4
00539E  524FE0     SUB.B W4, #0x0, [W15]
0053A0  320009     BRA Z, .L35, .LSM52
132:                     LATB = LATB | (0x01 << bit);
0053A2  90421E     MOV.B [W14+1], W4
0053A4  FB8204     ZE W4, W4
0053A6  200015     MOV #0x1, W5
0053A8  DD2A04     SL W5, W4, W4
0053AA  780284     MOV W4, W5
0053AC  801654     MOV LATB, W4
0053AE  720205     IOR W4, W5, W4
0053B0  881654     MOV W4, LATB
133:                   } else {
134:                     LATB = LATB & (~(0x01 << bit));
0053B4  90421E     MOV.B [W14+1], W4
0053B6  FB8204     ZE W4, W4
0053B8  200015     MOV #0x1, W5
0053BA  DD2A04     SL W5, W4, W4
0053BC  EA8204     COM W4, W4
0053BE  780284     MOV W4, W5
0053C0  801654     MOV LATB, W4
0053C2  628204     AND W5, W4, W4
0053C4  881654     MOV W4, LATB
135:                   }
136:                   break;
0053B2  37004C     BRA .L22, .LSM69
0053C6  370042     BRA .L22, .LSM69
137:               #endif
138:               
139:               #if defined(_PORTD)
140:                 case _PORT_PORTD:
141:                   if (pin_value) {
0053C8  90423E     MOV.B [W14+3], W4
0053CA  524FE0     SUB.B W4, #0x0, [W15]
0053CC  320009     BRA Z, .L37, .LSM57
142:                     LATD = LATD | (0x01 << bit);
0053CE  90421E     MOV.B [W14+1], W4
0053D0  FB8204     ZE W4, W4
0053D2  200015     MOV #0x1, W5
0053D4  DD2A04     SL W5, W4, W4
0053D6  780284     MOV W4, W5
0053D8  8016B4     MOV LATD, W4
0053DA  720205     IOR W4, W5, W4
0053DC  8816B4     MOV W4, LATD
143:                   } else {
144:                     LATD = LATD & (~(0x01 << bit));
0053E0  90421E     MOV.B [W14+1], W4
0053E2  FB8204     ZE W4, W4
0053E4  200015     MOV #0x1, W5
0053E6  DD2A04     SL W5, W4, W4
0053E8  EA8204     COM W4, W4
0053EA  780284     MOV W4, W5
0053EC  8016B4     MOV LATD, W4
0053EE  628204     AND W5, W4, W4
0053F0  8816B4     MOV W4, LATD
145:                   }
146:                   break;
0053DE  370036     BRA .L22, .LSM69
0053F2  37002C     BRA .L22, .LSM69
147:               #endif
148:               
149:               #if defined(_PORTE)
150:                 case _PORT_PORTE:
151:                   if (pin_value) {
152:                     LATE = LATE | (0x01 << bit);
153:                   } else {
154:                     LATE = LATE & (~(0x01 << bit));
155:                   }
156:                   break;
157:               #endif
158:               
159:               #if defined(_PORTF)
160:                 case _PORT_PORTF:
161:                   if (pin_value) {
0053F4  90423E     MOV.B [W14+3], W4
0053F6  524FE0     SUB.B W4, #0x0, [W15]
0053F8  320009     BRA Z, .L39, .LSM62
162:                     LATF = LATF | (0x01 << bit);
0053FA  90421E     MOV.B [W14+1], W4
0053FC  FB8204     ZE W4, W4
0053FE  200015     MOV #0x1, W5
005400  DD2A04     SL W5, W4, W4
005402  780284     MOV W4, W5
005404  801714     MOV LATF, W4
005406  720205     IOR W4, W5, W4
005408  881714     MOV W4, LATF
163:                   } else {
164:                     LATF = LATF & (~(0x01 << bit));
00540C  90421E     MOV.B [W14+1], W4
00540E  FB8204     ZE W4, W4
005410  200015     MOV #0x1, W5
005412  DD2A04     SL W5, W4, W4
005414  EA8204     COM W4, W4
005416  780284     MOV W4, W5
005418  801714     MOV LATF, W4
00541A  628204     AND W5, W4, W4
00541C  881714     MOV W4, LATF
165:                   }
166:                   break;
00540A  370020     BRA .L22, .LSM69
00541E  370016     BRA .L22, .LSM69
167:               #endif
168:               
169:               #if defined(_PORTG)
170:                 case _PORT_PORTG:
171:                   if (pin_value) {
005420  90423E     MOV.B [W14+3], W4
005422  524FE0     SUB.B W4, #0x0, [W15]
005424  320009     BRA Z, .L41, .LSM67
172:                     LATG = LATG | (0x01 << bit);
005426  90421E     MOV.B [W14+1], W4
005428  FB8204     ZE W4, W4
00542A  200015     MOV #0x1, W5
00542C  DD2A04     SL W5, W4, W4
00542E  780284     MOV W4, W5
005430  801744     MOV LATG, W4
005432  720205     IOR W4, W5, W4
005434  881744     MOV W4, LATG
173:                   } else {
174:                     LATG = LATG & (~(0x01 << bit));
005438  90421E     MOV.B [W14+1], W4
00543A  FB8204     ZE W4, W4
00543C  200015     MOV #0x1, W5
00543E  DD2A04     SL W5, W4, W4
005440  EA8204     COM W4, W4
005442  780284     MOV W4, W5
005444  801744     MOV LATG, W4
005446  628204     AND W5, W4, W4
005448  881744     MOV W4, LATG
175:                   }
176:                   break;
005436  37000A     BRA .L22, .LSM69
00544A  000000     NOP
177:               #endif
178:               
179:                 }
180:               }
00544C  FA8000     ULNK
00544E  060000     RETURN
181:               
182:               
183:               
---  C:/Users/DPARKER/Documents/GitHub/A36760/ETMdsp.s  -------------------------------------------------
                                                  1:     
                                                  2:     .ifdef __dsPIC30F
                                                  3:             .include "p30fxxxx.inc"
                                                  4:     .endif
                                                  5:     .ifdef __dsPIC33F
                                                  6:             .include "p33Fxxxx.inc"
                                                  7:     .endif
                                                  8:     
                                                  9:             .global  _AverageADC128
                                                  10:    
                                                  11:             .text
                                                  12:    _AverageADC128:
005AAA  780200     MOV W0, W4                     13:    		mov		W0, W4		; move source address
005AAC  C30112     CLR A                          14:    		CLR		A		; 0 40 bit Acc
                                                  15:    
005AAE  09007F     REPEAT #0x7F                   16:    ACC_S:	REPEAT	#127			; add em all up
005AB0  C90234     ADD [W4++], #4, A              17:    		ADD		[W4++], #4, A ; signed 16 add to ACCA (right shift 4 bits)
                                                  18:    	                                      ; The data that we want is now stored in the 15 LSB of ACCAH and the 1 MSB of ACCAL
                                                  19:    	                                      ; If we shift the data left one bit and call SAC.R the data will be bashed because
                                                  20:    	                                      ; The accumulator will be signed.  There for we must work around this little problem 
005AB2  CC0000     SAC A, W0                      21:    		SAC		A, W0	      ; Move ACCAH to W0
005AB4  DD0041     SL W0, #1, W0                  22:    		SL		W0, #1, W0    ; Shift W0 left by one bit.  
005AB6  C8007F     SFTAC A, #-1                   23:     		SFTAC           A, #-1        ; Shift Accumulator left by one bit.
005AB8  CD0001     SAC.R A, W1                    24:    	        SAC.R           A, W1         ; Move ACCAH to W1
005ABA  B20011     AND #0x1, W1                   25:    		AND             #0x0001, W1   ; W1 &= 0x0001
005ABC  700001     IOR W0, W1, W0                 26:    	        IOR             W0, W1, W0    ; WO = WO | W1
005ABE  060000     RETURN                         27:    		return
                                                  28:    ;--------End of All Code Sections ---------------------------------------------
                                                  29:            .end                               ;End of program code in this file
                                                  30:    
                                                  31:    
                                                  32:    
---  C:/Users/DPARKER/Documents/GitHub/A36760/ETM_SCALE.s  ----------------------------------------------
                                                  1:     .ifdef __dsPIC30F
                                                  2:             .include "p30fxxxx.inc"
                                                  3:     .endif
                                                  4:     .ifdef __dsPIC33F
                                                  5:             .include "p33Fxxxx.inc"
                                                  6:     .endif
                                                  7:     
                                                  8:     .section .nbss, bss, near    	
                                                  9:     	_etm_scale_saturation_etmscalefactor2_count:	.space 2
                                                  10:    	.global _etm_scale_saturation_etmscalefactor2_count
                                                  11:    	_etm_scale_saturation_etmscalefactor16_count:	.space 2
                                                  12:    	.global _etm_scale_saturation_etmscalefactor16_count
                                                  13:    .text	
                                                  14:    
                                                  15:    
                                                  16:    
                                                  17:    	;; ----------------------------------------------------------
                                                  18:    
                                                  19:    	
                                                  20:    	.global  _ETMScaleFactor2
                                                  21:    	;; uses and does not restore W0->W3
                                                  22:    	.text
                                                  23:    _ETMScaleFactor2:
                                                  24:    	;; Value is stored in w0
                                                  25:    	;; Scale is stored in w1
                                                  26:    	;; Offset is stored in w2 
                                                  27:    
0059A8  E00002     CP0 W2                         28:    	CP0		W2
0059AA  3B0005     BRA NN, 0x59B6                 29:    	BRA		NN,  _ETMScaleFactor2_offset_not_negative
                                                  30:    
                                                  31:    	;; The offset is negative
0059AC  400002     ADD W0, W2, W0                 32:    	ADD             W0,W2,W0                ; Add the offset to the base value
                                                  33:    	;; Look for overflow
0059AE  310008     BRA C, 0x59C0                  34:    	BRA             C, _ETMScaleFactor2_addition_done
                                                  35:    	;; There was overflow with the negative offset
                                                  36:    	;; Increment the overflow counter and set the results to 0x0000
0059B0  200000     MOV #0x0, W0                   37:    	MOV		#0x0000, W0
0059B2  EC37B8     INC 0x17B8                     38:    	INC		_etm_scale_saturation_etmscalefactor2_count
0059B4  370005     BRA 0x59C0                     39:    	BRA             _ETMScaleFactor2_addition_done	
                                                  40:    
                                                  41:    _ETMScaleFactor2_offset_not_negative:		
0059B6  400002     ADD W0, W2, W0                 42:    	ADD             W0,W2,W0                ; Add the offset to the base value
                                                  43:    	;; Look for overflow
                                                  44:    	;; 	CP              W3,W2 ;If W3 is less than W2 then there was an overflow
0059B8  390003     BRA NC, 0x59C0                 45:    	BRA             NC, _ETMScaleFactor2_addition_done
                                                  46:    	;; There was an overflow in the addition
                                                  47:    	;; Increment the overflow counter and set the results to 0xFFFF
0059BA  2FFFF0     MOV #0xFFFF, W0                48:    	MOV		#0xFFFF, W0
0059BC  EC37B8     INC 0x17B8                     49:    	INC		_etm_scale_saturation_etmscalefactor2_count
0059BE  370000     BRA 0x59C0                     50:    	BRA             _ETMScaleFactor2_addition_done	
                                                  51:    
                                                  52:    _ETMScaleFactor2_addition_done:		
0059C0  B80101     MUL.UU W0, W1, W2              53:    	MUL.UU		W0,W1,W2 		; Multiply W0 by W1 and store in W2:W3, MSW is stored in W3
0059C2  B81862     MUL.UU W3, #2, W0              54:    	MUL.UU		W3,#2,W0		; Multiply W3 by 2 and store the results in W0:W1 - W0(LSW) is the result we care about
                                                  55:    						
0059C4  E00001     CP0 W1                         56:    	CP0		W1			; If W1 is Zero, then there was NOT an overflow
0059C6  320002     BRA Z, 0x59CC                  57:    	BRA		Z, _ETMScaleFactor2_multiply_ok
                                                  58:    	;; There was an overflow in the multiply opertion
                                                  59:    	;; Increment the overflow counter and set the result to 0xFFFF
0059C8  2FFFF0     MOV #0xFFFF, W0                60:    	MOV		#0xFFFF, W0
0059CA  EC37B8     INC 0x17B8                     61:    	INC		_etm_scale_saturation_etmscalefactor2_count
                                                  62:    _ETMScaleFactor2_multiply_ok:	
                                                  63:    	;; OR together W0, W1 into W0 to give the final results
0059CC  DE10CF     LSR W2, #15, W1                64:    	LSR		W2, #15, W1		; Take the 1 MSbits of W2 and store then as the 1 LSB of W1
0059CE  700001     IOR W0, W1, W0                 65:    	IOR		W0, W1, W0		; Add W1 to W0 (using bitwise or in this case)
0059D0  060000     RETURN                         66:    	RETURN
                                                  67:    
                                                  68:    
                                                  69:    
                                                  70:    
                                                  71:    	
                                                  72:    	;; ----------------------------------------------------------
                                                  73:    
                                                  74:    	
                                                  75:    	.global  _ETMScaleFactor16
                                                  76:    	;; uses and does not restore W0->W3
                                                  77:    	.text
                                                  78:    _ETMScaleFactor16:
                                                  79:    	;; Value is stored in w0
                                                  80:    	;; Scale is stored in w1
                                                  81:    	;; Offset is stored in w2 	
                                                  82:    
0059D2  E00002     CP0 W2                         83:    	CP0		W2
0059D4  3B0005     BRA NN, 0x59E0                 84:    	BRA		NN,  _ETMScaleFactor16_offset_not_negative
                                                  85:    
                                                  86:    	;; The offset is negative
0059D6  400002     ADD W0, W2, W0                 87:    	ADD             W0,W2,W0                ; Add the offset to the base value
                                                  88:    	;; Look for overflow
0059D8  310008     BRA C, 0x59EA                  89:    	BRA             C, _ETMScaleFactor16_addition_done
                                                  90:    	;; There was overflow with the negative offset
                                                  91:    	;; Increment the overflow counter and set the results to 0x0000
0059DA  200000     MOV #0x0, W0                   92:    	MOV		#0x0000, W0
0059DC  EC37BA     INC 0x17BA                     93:    	INC		_etm_scale_saturation_etmscalefactor16_count
0059DE  370005     BRA 0x59EA                     94:    	BRA             _ETMScaleFactor16_addition_done	
                                                  95:    
                                                  96:    _ETMScaleFactor16_offset_not_negative:		
0059E0  400002     ADD W0, W2, W0                 97:    	ADD             W0,W2,W0                ; Add the offset to the base value
                                                  98:    	;; Look for overflow
                                                  99:    	;; 	CP              W3,W2 ;If W3 is less than W2 then there was an overflow
0059E2  390003     BRA NC, 0x59EA                 100:   	BRA             NC, _ETMScaleFactor16_addition_done
                                                  101:   	;; There was an overflow in the addition
                                                  102:   	;; Increment the overflow counter and set the results to 0xFFFF
0059E4  2FFFF0     MOV #0xFFFF, W0                103:   	MOV		#0xFFFF, W0
0059E6  EC37BA     INC 0x17BA                     104:   	INC		_etm_scale_saturation_etmscalefactor16_count
0059E8  370000     BRA 0x59EA                     105:   	BRA             _ETMScaleFactor16_addition_done	
                                                  106:   
                                                  107:   _ETMScaleFactor16_addition_done:		
                                                  108:   	
0059EA  B80101     MUL.UU W0, W1, W2              109:   	MUL.UU		W0,W1,W2 		; Multiply W0 by W1 and store in W2:W3, MSW is stored in W3
0059EC  B81870     MUL.UU W3, #16, W0             110:   	MUL.UU		W3,#16,W0		; Multiply W3 by 16 and store the results in W0:W1 - W0(LSW) is the result we care about
                                                  111:   						
0059EE  E00001     CP0 W1                         112:   	CP0		W1			; If W1 is Zero, then there was NOT an overflow
0059F0  320002     BRA Z, 0x59F6                  113:   	BRA		Z, _ETMScaleFactor16_no_overflow
                                                  114:   	;; There was an overflow in the multiply opertion
                                                  115:   	;; Increment the overflow counter and set the result to 0xFFFF
0059F2  2FFFF0     MOV #0xFFFF, W0                116:   	MOV		#0xFFFF, W0
0059F4  EC37BA     INC 0x17BA                     117:   	INC		_etm_scale_saturation_etmscalefactor16_count
                                                  118:   _ETMScaleFactor16_no_overflow:	
                                                  119:   	;; OR together W0, W1 into W0 to give the final results
0059F6  DE10CC     LSR W2, #12, W1                120:   	LSR		W2, #12, W1		; Take the 4 MSbits of W2 and store then as the 4 LSB of W1
0059F8  700001     IOR W0, W1, W0                 121:   	IOR		W0, W1, W0		; Add W1 to W0 (using bitwise or in this case)
0059FA  060000     RETURN                         122:   	RETURN
                                                  123:   
                                                  124:   	
---  C:/Users/DPARKER/Documents/GitHub/A36760/ETM_CRC.c  ------------------------------------------------
1:                 #include "ETM_CRC.h"
2:                 
3:                 unsigned int ETMDoCRC(const void *c_ptr, unsigned int len, unsigned int initial_value, const unsigned int *value_ptr);
4:                 /*
5:                   This is a generic CRC handling function
6:                 */
7:                 
8:                 
9:                 #define ETM_CRC_16_SEED                      0x0000
10:                #define ETM_CRC_MODBUS_SEED                  0xFFFF
11:                
12:                const unsigned int crc_lookup_table_A001[256] = {
13:                  0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241,
14:                  0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440,
15:                  0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40,
16:                  0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841,
17:                  0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
18:                  0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
19:                  0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
20:                  0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
21:                  0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
22:                  0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
23:                  0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
24:                  0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
25:                  0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
26:                  0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
27:                  0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
28:                  0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
29:                  0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
30:                  0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
31:                  0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
32:                  0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
33:                  0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
34:                  0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
35:                  0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
36:                  0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
37:                  0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
38:                  0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
39:                  0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
40:                  0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
41:                  0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
42:                  0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
43:                  0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
44:                  0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040
45:                };
46:                
47:                
48:                  
49:                unsigned int ETMCRC16(const void *c_ptr, unsigned int len) {
005922  FA0004     LNK #0x4
005924  780F00     MOV W0, [W14]
005926  980711     MOV W1, [W14+2]
50:                  return ETMDoCRC(c_ptr, len, ETM_CRC_16_SEED, crc_lookup_table_A001);
005928  285023     MOV #0x8502, W3
00592A  EB0100     CLR W2
00592C  90009E     MOV [W14+2], W1
00592E  78001E     MOV [W14], W0
005930  070010     RCALL ETMDoCRC
005932  780200     MOV W0, W4
51:                }
005934  780004     MOV W4, W0
005936  FA8000     ULNK
005938  060000     RETURN
52:                
53:                unsigned int ETMCRCModbus(const void *c_ptr, unsigned int len) {
00593A  FA0004     LNK #0x4
00593C  780F00     MOV W0, [W14]
00593E  980711     MOV W1, [W14+2]
54:                  return ETMDoCRC(c_ptr, len, ETM_CRC_MODBUS_SEED, crc_lookup_table_A001);
005940  285023     MOV #0x8502, W3
005942  EB8100     SETM W2
005944  90009E     MOV [W14+2], W1
005946  78001E     MOV [W14], W0
005948  070004     RCALL ETMDoCRC
00594A  780200     MOV W0, W4
55:                }
00594C  780004     MOV W4, W0
00594E  FA8000     ULNK
005950  060000     RETURN
56:                
57:                unsigned int ETMDoCRC(const void *c_ptr, unsigned int len, unsigned int initial_value, const unsigned int *value_ptr) {
005952  FA000E     LNK #0xE
005954  980730     MOV W0, [W14+6]
005956  980741     MOV W1, [W14+8]
005958  980752     MOV W2, [W14+10]
00595A  980763     MOV W3, [W14+12]
58:                  unsigned int crc = initial_value;
00595C  90025E     MOV [W14+10], W4
00595E  780F04     MOV W4, [W14]
59:                  const unsigned char *data_ptr = c_ptr;
005960  90023E     MOV [W14+6], W4
005962  980714     MOV W4, [W14+2]
60:                  unsigned int crc_comb_val;
61:                
62:                  while (len--) {
005964  370012     BRA .L4, .LSM12
00598A  90024E     MOV [W14+8], W4
00598C  A7F004     BTSC W4, #15
00598E  EA0204     NEG W4, W4
005990  EA0204     NEG W4, W4
005992  DE224F     LSR W4, #15, W4
005994  784204     MOV.B W4, W4
005996  9002CE     MOV [W14+8], W5
005998  E90285     DEC W5, W5
00599A  980745     MOV W5, [W14+8]
00599C  524FE0     SUB.B W4, #0x0, [W15]
00599E  3AFFE3     BRA NZ, .L5, .LSM10
63:                    crc_comb_val = crc ^ *data_ptr++;
005966  90021E     MOV [W14+2], W4
005968  784214     MOV.B [W4], W4
00596A  FB8204     ZE W4, W4
00596C  6A021E     XOR W4, [W14], W4
00596E  980724     MOV W4, [W14+4]
005970  90021E     MOV [W14+2], W4
005972  E80204     INC W4, W4
005974  980714     MOV W4, [W14+2]
64:                    crc = (crc >> 8) ^ value_ptr[crc_comb_val & 0x00ff];
005976  78021E     MOV [W14], W4
005978  DE22C8     LSR W4, #8, W5
00597A  90032E     MOV [W14+4], W6
00597C  200FF4     MOV #0xFF, W4
00597E  630204     AND W6, W4, W4
005980  420204     ADD W4, W4, W4
005982  90036E     MOV [W14+12], W6
005984  430204     ADD W6, W4, W4
005986  780214     MOV [W4], W4
005988  6A8F04     XOR W5, W4, [W14]
65:                  }
66:                  return crc;  
0059A0  78021E     MOV [W14], W4
67:                }
0059A2  780004     MOV W4, W0
0059A4  FA8000     ULNK
0059A6  060000     RETURN
---  C:/Users/DPARKER/Documents/GitHub/A36760/ETMSPI.c  -------------------------------------------------
1:                 #include "ETMSPI.h"
2:                 
3:                 
4:                 unsigned long SendAndReceiveSPI(unsigned int data_word, unsigned char spi_port) {
00566E  FA0008     LNK #0x8
005670  980720     MOV W0, [W14+4]
005672  984761     MOV.B W1, [W14+6]
5:                   unsigned char spi_bus_status;
6:                   unsigned int return_data;
7:                 
8:                   spi_bus_status = SPI_BUS_ACTIVE;
005674  EB4200     CLR.B W4
005676  784F04     MOV.B W4, [W14]
9:                   SPI_TIMER_REGISTER = 0;
005678  EB0200     CLR W4
00567A  8808A4     MOV W4, TMR4
10:                  SPI_TIMER_PERIOD = SPI_TIMEOUT_CYCLES;
00567C  20FA04     MOV #0xFA0, W4
00567E  8808D4     MOV W4, PR4
11:                  SPI_TIMER_INT_FLAG = 0;
005680  A9A086     BCLR IFS1, #5
12:                  SPI_TIMER_CON_BITS.TON = 1;
005682  A8E11F     BSET 0x11F, #7
13:                  SPI_TIMER_CON_BITS.TCKPS = SPI_TIMER_PRESCALE_1_1;
005684  8008F4     MOV T4CON, W4
005686  A14004     BCLR W4, #4
005688  A15004     BCLR W4, #5
00568A  8808F4     MOV W4, T4CON
14:                  
15:                
16:                #if defined(_SPIIF)
17:                  if ((spi_port == 0) || (spi_port == 1)) {
18:                    _SPIIF = 0;
19:                    SPIBUF = data_word;
20:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
21:                      if (SPI_TIMER_INT_FLAG) {
22:                	// There was a timeout of the data read, this is effectivly a fault
23:                	spi_bus_status = SPI_BUS_TIMEOUT;
24:                      }
25:                      if (SPISTATbits.SPIROV) {
26:                	// There was a data overflow in the buffer, this is a fault
27:                	spi_bus_status = SPI_BUS_OVERFLOW;
28:                      }
29:                      if (!SPISTATbits.SPITBF) {
30:                	spi_bus_status = SPI_DATA_SENT;
31:                      }
32:                    }
33:                    
34:                    while(spi_bus_status == SPI_DATA_SENT) {
35:                      if (SPI_TIMER_INT_FLAG) {
36:                	// There was a timeout of the data read, this is effectivly a fault
37:                	spi_bus_status = SPI_BUS_TIMEOUT;
38:                      }
39:                      if (SPISTATbits.SPIROV) {
40:                	// There was a data overflow in the buffer, this is a fault
41:                	spi_bus_status = SPI_BUS_OVERFLOW;
42:                      }
43:                      if (_SPIIF) {
44:                	// Data  been recieved in the buffer, read the data from the return buffer
45:                	spi_bus_status = SPI_DATA_RECEIVED;
46:                      }    
47:                    }
48:                    return_data = SPIBUF;
49:                  }
50:                #endif
51:                
52:                
53:                #if defined(_SPI1IF)
54:                  if (spi_port == 1) {
00568C  90426E     MOV.B [W14+6], W4
00568E  524FE1     SUB.B W4, #0x1, [W15]
005690  3A0036     BRA NZ, .L2, .LSM27
55:                    _SPI1IF = 0;
005692  A90085     BCLR 0x85, #0
56:                    SPI1BUF = data_word;
005694  90022E     MOV [W14+4], W4
005696  881124     MOV W4, SPI1BUF
57:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
005698  370014     BRA .L3, .LSM17
0056C2  78421E     MOV.B [W14], W4
0056C4  524FE0     SUB.B W4, #0x0, [W15]
0056C6  32FFE9     BRA Z, .L6, .LSM11
58:                      if (SPI_TIMER_INT_FLAG) {
00569A  800435     MOV IFS1, W5
00569C  200204     MOV #0x20, W4
00569E  628204     AND W5, W4, W4
0056A0  520FE0     SUB W4, #0x0, [W15]
0056A2  320002     BRA Z, .L4, .LSM13
59:                	// There was a timeout of the data read, this is effectivly a fault
60:                	spi_bus_status = SPI_BUS_TIMEOUT;
0056A4  B3C034     MOV.B #0x3, W4
0056A6  784F04     MOV.B W4, [W14]
61:                      }
62:                      if (SPI1STATbits.SPIROV) {
0056A8  801105     MOV SPI1STAT, W5
0056AA  200404     MOV #0x40, W4
0056AC  628204     AND W5, W4, W4
0056AE  520FE0     SUB W4, #0x0, [W15]
0056B0  320002     BRA Z, .L5, .LSM15
63:                	// There was a data overflow in the buffer, this is a fault
64:                	spi_bus_status = SPI_BUS_OVERFLOW;
0056B2  B3C044     MOV.B #0x4, W4
0056B4  784F04     MOV.B W4, [W14]
65:                      }
66:                      if (!SPI1STATbits.SPITBF) {
0056B6  801104     MOV SPI1STAT, W4
0056B8  620262     AND W4, #0x2, W4
0056BA  520FE0     SUB W4, #0x0, [W15]
0056BC  3A0002     BRA NZ, .L3, .LSM17
67:                	spi_bus_status = SPI_DATA_SENT;
0056BE  B3C014     MOV.B #0x1, W4
0056C0  784F04     MOV.B W4, [W14]
68:                      }
69:                    }
70:                    
71:                    while(spi_bus_status == SPI_DATA_SENT) {
0056C8  370015     BRA .L7, .LSM25
0056F4  78421E     MOV.B [W14], W4
0056F6  524FE1     SUB.B W4, #0x1, [W15]
0056F8  32FFE8     BRA Z, .L10, .LSM19
72:                      if (SPI_TIMER_INT_FLAG) {
0056CA  800435     MOV IFS1, W5
0056CC  200204     MOV #0x20, W4
0056CE  628204     AND W5, W4, W4
0056D0  520FE0     SUB W4, #0x0, [W15]
0056D2  320002     BRA Z, .L8, .LSM21
73:                	// There was a timeout of the data read, this is effectivly a fault
74:                	spi_bus_status = SPI_BUS_TIMEOUT;
0056D4  B3C034     MOV.B #0x3, W4
0056D6  784F04     MOV.B W4, [W14]
75:                      }
76:                      if (SPI1STATbits.SPIROV) {
0056D8  801105     MOV SPI1STAT, W5
0056DA  200404     MOV #0x40, W4
0056DC  628204     AND W5, W4, W4
0056DE  520FE0     SUB W4, #0x0, [W15]
0056E0  320002     BRA Z, .L9, .LSM23
77:                	// There was a data overflow in the buffer, this is a fault
78:                	spi_bus_status = SPI_BUS_OVERFLOW;
0056E2  B3C044     MOV.B #0x4, W4
0056E4  784F04     MOV.B W4, [W14]
79:                      }
80:                      //if (SPI1STATbits.SPIRBF) {
81:                      // A byte has been recieved in the buffer, read the data from the return buffer
82:                      if (_SPI1IF) {
0056E6  800425     MOV IFS0, W5
0056E8  201004     MOV #0x100, W4
0056EA  628204     AND W5, W4, W4
0056EC  520FE0     SUB W4, #0x0, [W15]
0056EE  320002     BRA Z, .L7, .LSM25
83:                	// Data  been recieved in the buffer, read the data from the return buffer
84:                	spi_bus_status = SPI_DATA_RECEIVED;
0056F0  B3C024     MOV.B #0x2, W4
0056F2  784F04     MOV.B W4, [W14]
85:                      }    
86:                    }
87:                    return_data = SPI1BUF;
0056FA  801124     MOV SPI1BUF, W4
0056FC  980714     MOV W4, [W14+2]
88:                  }
89:                #endif
90:                
91:                
92:                
93:                #if defined(_SPI2IF)
94:                  if (spi_port == 2) {
0056FE  90426E     MOV.B [W14+6], W4
005700  524FE2     SUB.B W4, #0x2, [W15]
005702  3A0036     BRA NZ, .L11, .LSM47
95:                
96:                    _SPI2IF = 0;
005704  A94087     BCLR 0x87, #2
97:                    SPI2BUF = data_word;
005706  90022E     MOV [W14+4], W4
005708  881154     MOV W4, SPI2BUF
98:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
00570A  370014     BRA .L12, .LSM37
005734  78421E     MOV.B [W14], W4
005736  524FE0     SUB.B W4, #0x0, [W15]
005738  32FFE9     BRA Z, .L15, .LSM31
99:                      if (SPI_TIMER_INT_FLAG) {
00570C  800435     MOV IFS1, W5
00570E  200204     MOV #0x20, W4
005710  628204     AND W5, W4, W4
005712  520FE0     SUB W4, #0x0, [W15]
005714  320002     BRA Z, .L13, .LSM33
100:               	// There was a timeout of the data read, this is effectivly a fault
101:               	spi_bus_status = SPI_BUS_TIMEOUT;
005716  B3C034     MOV.B #0x3, W4
005718  784F04     MOV.B W4, [W14]
102:                     }
103:                     if (SPI2STATbits.SPIROV) {
00571A  801135     MOV SPI2STAT, W5
00571C  200404     MOV #0x40, W4
00571E  628204     AND W5, W4, W4
005720  520FE0     SUB W4, #0x0, [W15]
005722  320002     BRA Z, .L14, .LSM35
104:               	// There was a data overflow in the buffer, this is a fault
105:               	spi_bus_status = SPI_BUS_OVERFLOW;
005724  B3C044     MOV.B #0x4, W4
005726  784F04     MOV.B W4, [W14]
106:                     }
107:                     if (!SPI2STATbits.SPITBF) {
005728  801134     MOV SPI2STAT, W4
00572A  620262     AND W4, #0x2, W4
00572C  520FE0     SUB W4, #0x0, [W15]
00572E  3A0002     BRA NZ, .L12, .LSM37
108:               	spi_bus_status = SPI_DATA_SENT;  // Data has been moved into the shift register for sending out
005730  B3C014     MOV.B #0x1, W4
005732  784F04     MOV.B W4, [W14]
109:                     }
110:                   }
111:                   
112:                   while(spi_bus_status == SPI_DATA_SENT) {
00573A  370015     BRA .L16, .LSM45
005766  78421E     MOV.B [W14], W4
005768  524FE1     SUB.B W4, #0x1, [W15]
00576A  32FFE8     BRA Z, .L19, .LSM39
113:                     if (SPI_TIMER_INT_FLAG) {
00573C  800435     MOV IFS1, W5
00573E  200204     MOV #0x20, W4
005740  628204     AND W5, W4, W4
005742  520FE0     SUB W4, #0x0, [W15]
005744  320002     BRA Z, .L17, .LSM41
114:               	// There was a timeout of the data read, this is effectivly a fault
115:               	spi_bus_status = SPI_BUS_TIMEOUT;
005746  B3C034     MOV.B #0x3, W4
005748  784F04     MOV.B W4, [W14]
116:                     }
117:                     if (SPI2STATbits.SPIROV) {
00574A  801135     MOV SPI2STAT, W5
00574C  200404     MOV #0x40, W4
00574E  628204     AND W5, W4, W4
005750  520FE0     SUB W4, #0x0, [W15]
005752  320002     BRA Z, .L18, .LSM43
118:               	// There was a data overflow in the buffer, this is a fault
119:               	spi_bus_status = SPI_BUS_OVERFLOW;
005754  B3C044     MOV.B #0x4, W4
005756  784F04     MOV.B W4, [W14]
120:                     }
121:                     if (_SPI2IF) {
005758  800435     MOV IFS1, W5
00575A  204004     MOV #0x400, W4
00575C  628204     AND W5, W4, W4
00575E  520FE0     SUB W4, #0x0, [W15]
005760  320002     BRA Z, .L16, .LSM45
122:               	// Data  been recieved in the buffer, read the data from the return buffer
123:               	spi_bus_status = SPI_DATA_RECEIVED;
005762  B3C024     MOV.B #0x2, W4
005764  784F04     MOV.B W4, [W14]
124:                     }    
125:                   }
126:                   return_data = SPI2BUF;
00576C  801154     MOV SPI2BUF, W4
00576E  980714     MOV W4, [W14+2]
127:                 }
128:               #endif
129:                 
130:                 if (spi_bus_status == SPI_DATA_RECEIVED) {
005770  78421E     MOV.B [W14], W4
005772  524FE2     SUB.B W4, #0x2, [W15]
005774  3A0003     BRA NZ, .L20, .LSM49
131:                   return (0x0000FFFF & return_data);
005776  90021E     MOV [W14+2], W4
005778  200005     MOV #0x0, W5
00577A  370002     BRA .L21, .LSM50
132:                 } else {
133:                   return (0x11110000);
00577C  200004     MOV #0x0, W4
00577E  211115     MOV #0x1111, W5
134:                 }
135:               }
005780  BE0004     MOV.D W4, W0
005782  FA8000     ULNK
005784  060000     RETURN
---  C:/Users/DPARKER/Documents/GitHub/A36760/ETMI2C.c  -------------------------------------------------
1:                 #include "ETMI2C.h"
2:                 
3:                 
4:                 unsigned int WaitForI2CBusIdle(unsigned char i2c_port) {
005450  FA0002     LNK #0x2
005452  784F00     MOV.B W0, [W14]
5:                   
6:                   I2C_TIMER_REGISTER = 0;
005454  EB0200     CLR W4
005456  8808A4     MOV W4, TMR4
7:                   I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
005458  23E804     MOV #0x3E80, W4
00545A  8808D4     MOV W4, PR4
8:                   I2C_TIMER_INT_FLAG = 0;
00545C  A9A086     BCLR IFS1, #5
9:                   I2C_TIMER_CON_BITS.TON = 1;
00545E  A8E11F     BSET 0x11F, #7
10:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
005460  8008F4     MOV T4CON, W4
005462  A14004     BCLR W4, #4
005464  A15004     BCLR W4, #5
005466  8808F4     MOV W4, T4CON
11:                  
12:                #if defined(_I2CMD)
13:                  if ((i2c_port == 0) || (i2c_port == 1)) {
005468  78421E     MOV.B [W14], W4
00546A  524FE0     SUB.B W4, #0x0, [W15]
00546C  320004     BRA Z, .L7
00546E  78421E     MOV.B [W14], W4
005470  524FE1     SUB.B W4, #0x1, [W15]
005472  3A000C     BRA NZ, .L3, .LSM8
14:                    while (I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
005474  370001     BRA .L4
005476  000000     NOP
005478  801045     MOV I2CSTAT, W5
00547A  240004     MOV #0x4000, W4
00547C  628204     AND W5, W4, W4
00547E  520FE0     SUB W4, #0x0, [W15]
005480  320005     BRA Z, .L3, .LSM8
005482  800435     MOV IFS1, W5
005484  200204     MOV #0x20, W4
005486  628204     AND W5, W4, W4
005488  520FE0     SUB W4, #0x0, [W15]
00548A  32FFF6     BRA Z, .L4
15:                  }
16:                #endif
17:                
18:                #if defined(_I2C1MD)
19:                  if (i2c_port == 1) {
20:                    while (I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
21:                  }
22:                #endif
23:                
24:                #if defined(_I2C2MD)
25:                  if (i2c_port == 2) {
26:                    while (I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
27:                  }
28:                #endif
29:                    
30:                  if (I2C_TIMER_INT_FLAG) {
00548C  800435     MOV IFS1, W5
00548E  200204     MOV #0x20, W4
005490  628204     AND W5, W4, W4
005492  520FE0     SUB W4, #0x0, [W15]
005494  320002     BRA Z, .L5, .LSM10
31:                    return 0xFA00;
005496  2FA004     MOV #0xFA00, W4
005498  370001     BRA .L6, .LSM11
32:                  } else {
33:                    return 0x0000;
00549A  EB0200     CLR W4
34:                  }
35:                }
00549C  780004     MOV W4, W0
00549E  FA8000     ULNK
0054A0  060000     RETURN
36:                  
37:                
38:                
39:                
40:                
41:                unsigned int GenerateI2CStart(unsigned char i2c_port) {
0054A2  FA0002     LNK #0x2
0054A4  784F00     MOV.B W0, [W14]
42:                  I2C_TIMER_REGISTER = 0;
0054A6  EB0200     CLR W4
0054A8  8808A4     MOV W4, TMR4
43:                  I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
0054AA  23E804     MOV #0x3E80, W4
0054AC  8808D4     MOV W4, PR4
44:                  I2C_TIMER_INT_FLAG = 0;
0054AE  A9A086     BCLR IFS1, #5
45:                  I2C_TIMER_CON_BITS.TON = 1;
0054B0  A8E11F     BSET 0x11F, #7
46:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
0054B2  8008F4     MOV T4CON, W4
0054B4  A14004     BCLR W4, #4
0054B6  A15004     BCLR W4, #5
0054B8  8808F4     MOV W4, T4CON
47:                  
48:                #if defined(_I2CMD)
49:                  if ((i2c_port == 0) || (i2c_port == 1)) {
0054BA  78421E     MOV.B [W14], W4
0054BC  524FE0     SUB.B W4, #0x0, [W15]
0054BE  320003     BRA Z, .L9, .LSM19
0054C0  78421E     MOV.B [W14], W4
0054C2  524FE1     SUB.B W4, #0x1, [W15]
0054C4  3A000B     BRA NZ, .L10, .LSM21
50:                    I2CCONbits.SEN = 1;		                         //Generate Start COndition
0054C6  A80206     BSET I2CCON, #0
51:                    while (I2CCONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
0054C8  000000     NOP
0054CA  801034     MOV I2CCON, W4
0054CC  620261     AND W4, #0x1, W4
0054CE  520FE0     SUB W4, #0x0, [W15]
0054D0  320005     BRA Z, .L10, .LSM21
0054D2  800435     MOV IFS1, W5
0054D4  200204     MOV #0x20, W4
0054D6  628204     AND W5, W4, W4
0054D8  520FE0     SUB W4, #0x0, [W15]
0054DA  32FFF7     BRA Z, .L11
52:                  }
53:                #endif
54:                
55:                #if defined(_I2C1MD)
56:                  if (i2c_port == 1) {
57:                    I2C1CONbits.SEN = 1;		                         //Generate Start COndition
58:                    while (I2C1CONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
59:                  }
60:                #endif
61:                
62:                #if defined(_I2C2MD)
63:                  if (i2c_port == 2) {
64:                    I2C2CONbits.SEN = 1;		                         //Generate Start COndition
65:                    while (I2C2CONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
66:                  }
67:                #endif
68:                    
69:                  if (I2C_TIMER_INT_FLAG) {
0054DC  800435     MOV IFS1, W5
0054DE  200204     MOV #0x20, W4
0054E0  628204     AND W5, W4, W4
0054E2  520FE0     SUB W4, #0x0, [W15]
0054E4  320002     BRA Z, .L12, .LSM23
70:                    return 0xFA00;
0054E6  2FA004     MOV #0xFA00, W4
0054E8  370001     BRA .L13, .LSM24
71:                  } else {
72:                    return 0x0000;
0054EA  EB0200     CLR W4
73:                  }
74:                }
0054EC  780004     MOV W4, W0
0054EE  FA8000     ULNK
0054F0  060000     RETURN
75:                
76:                
77:                
78:                unsigned int GenerateI2CRestart(unsigned char i2c_port) {
0054F2  FA0002     LNK #0x2
0054F4  784F00     MOV.B W0, [W14]
79:                  I2C_TIMER_REGISTER = 0;
0054F6  EB0200     CLR W4
0054F8  8808A4     MOV W4, TMR4
80:                  I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
0054FA  23E804     MOV #0x3E80, W4
0054FC  8808D4     MOV W4, PR4
81:                  I2C_TIMER_INT_FLAG = 0;
0054FE  A9A086     BCLR IFS1, #5
82:                  I2C_TIMER_CON_BITS.TON = 1;
005500  A8E11F     BSET 0x11F, #7
83:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
005502  8008F4     MOV T4CON, W4
005504  A14004     BCLR W4, #4
005506  A15004     BCLR W4, #5
005508  8808F4     MOV W4, T4CON
84:                  
85:                #if defined(_I2CMD)
86:                  if ((i2c_port == 0) || (i2c_port == 1)) {
00550A  78421E     MOV.B [W14], W4
00550C  524FE0     SUB.B W4, #0x0, [W15]
00550E  320003     BRA Z, .L15, .LSM32
005510  78421E     MOV.B [W14], W4
005512  524FE1     SUB.B W4, #0x1, [W15]
005514  3A000B     BRA NZ, .L16, .LSM34
87:                    I2CCONbits.RSEN = 1;	                         //Generate Re-Start COndition
005516  A82206     BSET I2CCON, #1
88:                    while (I2CCONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
005518  000000     NOP
00551A  801034     MOV I2CCON, W4
00551C  620262     AND W4, #0x2, W4
00551E  520FE0     SUB W4, #0x0, [W15]
005520  320005     BRA Z, .L16, .LSM34
005522  800435     MOV IFS1, W5
005524  200204     MOV #0x20, W4
005526  628204     AND W5, W4, W4
005528  520FE0     SUB W4, #0x0, [W15]
00552A  32FFF7     BRA Z, .L17
89:                  }
90:                #endif
91:                
92:                #if defined(_I2C1MD)
93:                  if (i2c_port == 1) {
94:                    I2C1CONbits.RSEN = 1;		                 //Generate Re-Start COndition
95:                    while (I2C1CONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
96:                  }
97:                #endif
98:                
99:                #if defined(_I2C2MD)
100:                 if (i2c_port == 2) {
101:                   I2C2CONbits.RSEN = 1;		                 //Generate Re-Start COndition
102:                   while (I2C2CONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
103:                 }
104:               #endif
105:                   
106:                 if (I2C_TIMER_INT_FLAG) {
00552C  800435     MOV IFS1, W5
00552E  200204     MOV #0x20, W4
005530  628204     AND W5, W4, W4
005532  520FE0     SUB W4, #0x0, [W15]
005534  320002     BRA Z, .L18, .LSM36
107:                   return 0xFA00;
005536  2FA004     MOV #0xFA00, W4
005538  370001     BRA .L19, .LSM37
108:                 } else {
109:                   return 0x0000;
00553A  EB0200     CLR W4
110:                 }
111:               }
00553C  780004     MOV W4, W0
00553E  FA8000     ULNK
005540  060000     RETURN
112:               
113:               
114:               
115:               unsigned int WriteByteI2C(unsigned char data, unsigned char i2c_port) {
005542  FA0002     LNK #0x2
005544  784F00     MOV.B W0, [W14]
005546  984711     MOV.B W1, [W14+1]
116:                 I2C_TIMER_REGISTER = 0;
005548  EB0200     CLR W4
00554A  8808A4     MOV W4, TMR4
117:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
00554C  23E804     MOV #0x3E80, W4
00554E  8808D4     MOV W4, PR4
118:                 I2C_TIMER_INT_FLAG = 0;
005550  A9A086     BCLR IFS1, #5
119:                 I2C_TIMER_CON_BITS.TON = 1;
005552  A8E11F     BSET 0x11F, #7
120:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
005554  8008F4     MOV T4CON, W4
005556  A14004     BCLR W4, #4
005558  A15004     BCLR W4, #5
00555A  8808F4     MOV W4, T4CON
121:                 
122:               #if defined(_I2CMD)
123:                 if ((i2c_port == 0) || (i2c_port == 1)) {
00555C  90421E     MOV.B [W14+1], W4
00555E  524FE0     SUB.B W4, #0x0, [W15]
005560  320003     BRA Z, .L21, .LSM45
005562  90421E     MOV.B [W14+1], W4
005564  524FE1     SUB.B W4, #0x1, [W15]
005566  3A001A     BRA NZ, .L22, .LSM48
124:                   I2CTRN = (data);                                            //Load data to the transmit buffer
005568  78429E     MOV.B [W14], W5
00556A  FB8205     ZE W5, W4
00556C  881014     MOV W4, I2CTRN
125:                   while (!I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);         //Set when transmit process starts
00556E  000000     NOP
005570  801045     MOV I2CSTAT, W5
005572  240004     MOV #0x4000, W4
005574  628204     AND W5, W4, W4
005576  520FE0     SUB W4, #0x0, [W15]
005578  3A0006     BRA NZ, .L28
00557A  800435     MOV IFS1, W5
00557C  200204     MOV #0x20, W4
00557E  628204     AND W5, W4, W4
005580  520FE0     SUB W4, #0x0, [W15]
005582  32FFF6     BRA Z, .L24
126:                   while (I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);          //Cleared at end of Slave ACK
005584  370001     BRA .L25
005586  000000     NOP
005588  801045     MOV I2CSTAT, W5
00558A  240004     MOV #0x4000, W4
00558C  628204     AND W5, W4, W4
00558E  520FE0     SUB W4, #0x0, [W15]
005590  320005     BRA Z, .L22, .LSM48
005592  800435     MOV IFS1, W5
005594  200204     MOV #0x20, W4
005596  628204     AND W5, W4, W4
005598  520FE0     SUB W4, #0x0, [W15]
00559A  32FFF6     BRA Z, .L25
127:                 }
128:               #endif
129:               
130:               #if defined(_I2C1MD)
131:                 if (i2c_port == 1) {
132:                   I2C1TRN = (data);                                           //Load data to the transmit buffer
133:                   while (!I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);        //Set when transmit process starts
134:                   while (I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);	        //Cleared at end of Slave ACK
135:                 }
136:               #endif
137:               
138:               #if defined(_I2C2MD)
139:                 if (i2c_port == 2) {
140:                   I2C2TRN = (data);                                           //Load data to the transmit buffer
141:                   while (!I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);        //Set when transmit process starts
142:                   while (I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);	        //Cleared at end of Slave ACK
143:                 }
144:               #endif
145:                   
146:                 if (I2C_TIMER_INT_FLAG) {
00559C  800435     MOV IFS1, W5
00559E  200204     MOV #0x20, W4
0055A0  628204     AND W5, W4, W4
0055A2  520FE0     SUB W4, #0x0, [W15]
0055A4  320002     BRA Z, .L26, .LSM50
147:                   return 0xFA00;
0055A6  2FA004     MOV #0xFA00, W4
0055A8  370001     BRA .L27, .LSM51
148:                 } else {
149:                   return 0x0000;
0055AA  EB0200     CLR W4
150:                 }
151:               }
0055AC  780004     MOV W4, W0
0055AE  FA8000     ULNK
0055B0  060000     RETURN
152:               
153:               unsigned int ReadByteI2C(unsigned char i2c_port) {
0055B2  FA0004     LNK #0x4
0055B4  984720     MOV.B W0, [W14+2]
154:                 unsigned char return_data;
155:               
156:                 I2C_TIMER_REGISTER = 0;
0055B6  EB0200     CLR W4
0055B8  8808A4     MOV W4, TMR4
157:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
0055BA  23E804     MOV #0x3E80, W4
0055BC  8808D4     MOV W4, PR4
158:                 I2C_TIMER_INT_FLAG = 0;
0055BE  A9A086     BCLR IFS1, #5
159:                 I2C_TIMER_CON_BITS.TON = 1;
0055C0  A8E11F     BSET 0x11F, #7
160:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
0055C2  8008F4     MOV T4CON, W4
0055C4  A14004     BCLR W4, #4
0055C6  A15004     BCLR W4, #5
0055C8  8808F4     MOV W4, T4CON
161:                 
162:               #if defined(_I2CMD)
163:                 if ((i2c_port == 0) || (i2c_port == 1)) {
0055CA  90422E     MOV.B [W14+2], W4
0055CC  524FE0     SUB.B W4, #0x0, [W15]
0055CE  320003     BRA Z, .L30, .LSM59
0055D0  90422E     MOV.B [W14+2], W4
0055D2  524FE1     SUB.B W4, #0x1, [W15]
0055D4  3A0018     BRA NZ, .L31, .LSM63
164:                   I2CCONbits.RCEN = 1;			                 //Start Master receive
0055D6  A86206     BSET I2CCON, #3
165:                   while(I2CCONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
0055D8  000000     NOP
0055DA  801034     MOV I2CCON, W4
0055DC  620268     AND W4, #0x8, W4
0055DE  520FE0     SUB W4, #0x0, [W15]
0055E0  320006     BRA Z, .L38
0055E2  800435     MOV IFS1, W5
0055E4  200204     MOV #0x20, W4
0055E6  628204     AND W5, W4, W4
0055E8  520FE0     SUB W4, #0x0, [W15]
0055EA  32FFF7     BRA Z, .L33
166:                   while(!I2CSTATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
0055EC  370001     BRA .L35
0055EE  000000     NOP
0055F0  801044     MOV I2CSTAT, W4
0055F2  620262     AND W4, #0x2, W4
0055F4  520FE0     SUB W4, #0x0, [W15]
0055F6  3A0005     BRA NZ, .L34, .LSM62
0055F8  800435     MOV IFS1, W5
0055FA  200204     MOV #0x20, W4
0055FC  628204     AND W5, W4, W4
0055FE  520FE0     SUB W4, #0x0, [W15]
005600  32FFF7     BRA Z, .L35
167:                   return_data = I2CRCV;
005602  801004     MOV I2CRCV, W4
005604  784F04     MOV.B W4, [W14]
168:                 }
169:               #endif
170:               
171:               #if defined(_I2C1MD)
172:                 if (i2c_port == 1) {
173:                   I2C1CONbits.RCEN = 1;			                 //Start Master receive
174:                   while(I2C1CONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
175:                   while(!I2C1STATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
176:                   return_data = I2C1RCV;
177:                 }
178:               #endif
179:               
180:               #if defined(_I2C2MD)
181:                 if (i2c_port == 2) {
182:                   I2C2CONbits.RCEN = 1;			                 //Start Master receive
183:                   while(I2C2CONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
184:                   while(!I2C2STATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
185:                   return_data = I2C2RCV;
186:                 }
187:               #endif
188:                   
189:                 if (I2C_TIMER_INT_FLAG) {
005606  800435     MOV IFS1, W5
005608  200204     MOV #0x20, W4
00560A  628204     AND W5, W4, W4
00560C  520FE0     SUB W4, #0x0, [W15]
00560E  320002     BRA Z, .L36, .LSM65
190:                   return 0xFA00;
005610  2FA004     MOV #0xFA00, W4
005612  370002     BRA .L37, .LSM66
191:                 } else {
192:                   return (return_data & 0x00FF);
005614  78429E     MOV.B [W14], W5
005616  FB8205     ZE W5, W4
193:                 }
194:               }
005618  780004     MOV W4, W0
00561A  FA8000     ULNK
00561C  060000     RETURN
195:               
196:               
197:               
198:               unsigned int GenerateI2CStop(unsigned char i2c_port) {
00561E  FA0002     LNK #0x2
005620  784F00     MOV.B W0, [W14]
199:                 I2C_TIMER_REGISTER = 0;
005622  EB0200     CLR W4
005624  8808A4     MOV W4, TMR4
200:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
005626  23E804     MOV #0x3E80, W4
005628  8808D4     MOV W4, PR4
201:                 I2C_TIMER_INT_FLAG = 0;
00562A  A9A086     BCLR IFS1, #5
202:                 I2C_TIMER_CON_BITS.TON = 1;
00562C  A8E11F     BSET 0x11F, #7
203:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
00562E  8008F4     MOV T4CON, W4
005630  A14004     BCLR W4, #4
005632  A15004     BCLR W4, #5
005634  8808F4     MOV W4, T4CON
204:                 
205:               #if defined(_I2CMD)
206:                 if ((i2c_port == 0) || (i2c_port == 1)) {
005636  78421E     MOV.B [W14], W4
005638  524FE0     SUB.B W4, #0x0, [W15]
00563A  320003     BRA Z, .L40, .LSM74
00563C  78421E     MOV.B [W14], W4
00563E  524FE1     SUB.B W4, #0x1, [W15]
005640  3A000B     BRA NZ, .L41, .LSM76
207:                   I2CCONbits.PEN = 1;	                                 //Generate Stop COndition
005642  A84206     BSET I2CCON, #2
208:                   while (I2CCONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for Stop COndition
005644  000000     NOP
005646  801034     MOV I2CCON, W4
005648  620264     AND W4, #0x4, W4
00564A  520FE0     SUB W4, #0x0, [W15]
00564C  320005     BRA Z, .L41, .LSM76
00564E  800435     MOV IFS1, W5
005650  200204     MOV #0x20, W4
005652  628204     AND W5, W4, W4
005654  520FE0     SUB W4, #0x0, [W15]
005656  32FFF7     BRA Z, .L42
209:                 }
210:               #endif
211:               
212:               #if defined(_I2C1MD)
213:                 if (i2c_port == 1) {
214:                   I2C1CONbits.PEN = 1;		                 //Generate stop COndition
215:                   while (I2C1CONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for stop COndition
216:                 }
217:               #endif
218:               
219:               #if defined(_I2C2MD)
220:                 if (i2c_port == 2) {
221:                   I2C2CONbits.PEN = 1;		                 //Generate stop COndition
222:                   while (I2C2CONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for stop COndition
223:                 }
224:               #endif
225:                   
226:                 if (I2C_TIMER_INT_FLAG) {
005658  800435     MOV IFS1, W5
00565A  200204     MOV #0x20, W4
00565C  628204     AND W5, W4, W4
00565E  520FE0     SUB W4, #0x0, [W15]
005660  320002     BRA Z, .L43, .LSM78
227:                   return 0xFA00;
005662  2FA004     MOV #0xFA00, W4
005664  370001     BRA .L44, .LSM79
228:                 } else {
229:                   return 0x0000;
005666  EB0200     CLR W4
230:                 }
231:               }
005668  780004     MOV W4, W0
00566A  FA8000     ULNK
00566C  060000     RETURN
232:               
233:               
---  C:/Users/DPARKER/Documents/GitHub/A36760/Buffer64.c  -----------------------------------------------
1:                 #include "Buffer64.h"
2:                 
3:                 void Buffer64WriteByte(BUFFER64BYTE* ptr, unsigned char value) {
00586A  FA0004     LNK #0x4
00586C  780F00     MOV W0, [W14]
00586E  984721     MOV.B W1, [W14+2]
4:                   ptr->data[ptr->write_location] = value;
005870  78021E     MOV [W14], W4
005872  90C204     MOV.B [W4+64], W4
005874  FB8204     ZE W4, W4
005876  78029E     MOV [W14], W5
005878  90432E     MOV.B [W14+2], W6
00587A  7A7286     MOV.B W6, [W5+W4]
5:                   ptr->write_location += 1;
00587C  78021E     MOV [W14], W4
00587E  90C204     MOV.B [W4+64], W4
005880  E84204     INC.B W4, W4
005882  78029E     MOV [W14], W5
005884  98C284     MOV.B W4, [W5+64]
6:                   ptr->write_location &= Buffer64Mask;
005886  78021E     MOV [W14], W4
005888  90C204     MOV.B [W4+64], W4
00588A  B243F4     AND.B #0x3F, W4
00588C  78029E     MOV [W14], W5
00588E  98C284     MOV.B W4, [W5+64]
7:                   if (ptr->write_location == ptr->read_location) {
005890  78021E     MOV [W14], W4
005892  90C284     MOV.B [W4+64], W5
005894  78021E     MOV [W14], W4
005896  90C214     MOV.B [W4+65], W4
005898  52CF84     SUB.B W5, W4, [W15]
00589A  3A000A     BRA NZ, .L1, .LSM7
8:                     ptr->read_location += 1;
00589C  78021E     MOV [W14], W4
00589E  90C214     MOV.B [W4+65], W4
0058A0  E84204     INC.B W4, W4
0058A2  78029E     MOV [W14], W5
0058A4  98C294     MOV.B W4, [W5+65]
9:                     ptr->read_location &= Buffer64Mask;
0058A6  78021E     MOV [W14], W4
0058A8  90C214     MOV.B [W4+65], W4
0058AA  B243F4     AND.B #0x3F, W4
0058AC  78029E     MOV [W14], W5
0058AE  98C294     MOV.B W4, [W5+65]
10:                  }
11:                }
0058B0  FA8000     ULNK
0058B2  060000     RETURN
12:                
13:                unsigned char Buffer64ReadByte(BUFFER64BYTE* ptr) {
0058B4  FA0004     LNK #0x4
0058B6  980710     MOV W0, [W14+2]
14:                  unsigned char local_read_location;
15:                  unsigned char return_data;
16:                						
17:                  local_read_location = ptr->read_location;
0058B8  90021E     MOV [W14+2], W4
0058BA  90C294     MOV.B [W4+65], W5
0058BC  984715     MOV.B W5, [W14+1]
18:                  if (local_read_location != ptr->write_location) {
0058BE  90021E     MOV [W14+2], W4
0058C0  90C284     MOV.B [W4+64], W5
0058C2  90421E     MOV.B [W14+1], W4
0058C4  52CF84     SUB.B W5, W4, [W15]
0058C6  32000E     BRA Z, .L4, .LSM15
19:                    // the buffer is not empty
20:                    return_data = ptr->data[local_read_location];
0058C8  90421E     MOV.B [W14+1], W4
0058CA  FB8204     ZE W4, W4
0058CC  90029E     MOV [W14+2], W5
0058CE  7A4F65     MOV.B [W5+W4], [W14]
21:                    local_read_location += 1;
0058D0  90421E     MOV.B [W14+1], W4
0058D2  E84204     INC.B W4, W4
0058D4  984714     MOV.B W4, [W14+1]
22:                    local_read_location &= Buffer64Mask; 
0058D6  90421E     MOV.B [W14+1], W4
0058D8  B243F4     AND.B #0x3F, W4
0058DA  984714     MOV.B W4, [W14+1]
23:                    ptr->read_location = local_read_location;
0058DC  90021E     MOV [W14+2], W4
0058DE  90429E     MOV.B [W14+1], W5
0058E0  98C215     MOV.B W5, [W4+65]
0058E2  370002     BRA .L5, .LSM16
24:                  } else {
25:                    // the buffer was empty
26:                    // return zero and do not increment the read_location
27:                    return_data = 0;
0058E4  EB4200     CLR.B W4
0058E6  784F04     MOV.B W4, [W14]
28:                  }
29:                  return return_data;
0058E8  78421E     MOV.B [W14], W4
30:                }
0058EA  784004     MOV.B W4, W0
0058EC  FA8000     ULNK
0058EE  060000     RETURN
31:                
32:                unsigned char Buffer64BytesInBuffer(BUFFER64BYTE* ptr) {
0058F0  FA0002     LNK #0x2
0058F2  780F00     MOV W0, [W14]
33:                  return ((ptr->write_location - ptr->read_location) & Buffer64Mask);
0058F4  78021E     MOV [W14], W4
0058F6  90C284     MOV.B [W4+64], W5
0058F8  78021E     MOV [W14], W4
0058FA  90C214     MOV.B [W4+65], W4
0058FC  52C204     SUB.B W5, W4, W4
0058FE  B243F4     AND.B #0x3F, W4
34:                }
005900  784004     MOV.B W4, W0
005902  FA8000     ULNK
005904  060000     RETURN
35:                
36:                unsigned char Buffer64IsNotEmpty(BUFFER64BYTE* ptr) {
005906  FA0002     LNK #0x2
005908  780F00     MOV W0, [W14]
37:                  if (ptr->write_location == ptr->read_location) {
00590A  78021E     MOV [W14], W4
00590C  90C284     MOV.B [W4+64], W5
00590E  78021E     MOV [W14], W4
005910  90C214     MOV.B [W4+65], W4
005912  52CF84     SUB.B W5, W4, [W15]
005914  3A0002     BRA NZ, .L8, .LSM24
38:                    return 0;
005916  EB4200     CLR.B W4
005918  370001     BRA .L9, .LSM25
39:                  } else {
40:                    return 1;
00591A  B3C014     MOV.B #0x1, W4
41:                  }
42:                }
00591C  784004     MOV.B W4, W0
00591E  FA8000     ULNK
005920  060000     RETURN
43:                
44:                
45:                
---  C:/Users/DPARKER/Documents/GitHub/A36760/A34760.c  -------------------------------------------------
1:                 #include "A34760.h"
2:                 #include "faults.h"
3:                 #include "Serial.h"
4:                 #include "A34760_PINS.h"
5:                 #include "Buffer64.h"
6:                 #include "LTC2656.h"
7:                 #include "IOPorts.h"
8:                 #include "MCP23017.h"
9:                 #include "faults.h"
10:                #include <libpic30.h>
11:                #include "ETMdsp.h"
12:                #include "Config.h"
13:                #include "ETM_Scale.h"
14:                #include "eeprom.h"
15:                
16:                #define FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG7095_NEW_ROLLOFF 100,100,99,99,99,98,98,97,97,96,96,95,95,94,94,93,93,92,91,91,90,89,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,60,59,58,57,56,54,53,52,51,49,48
17:                
18:                #define FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG7095 100,99,99,98,98,97,96,95,94,94,93,92,91,90,89,88,87,86,84,83,82,81,79,78,77,75,74,72,71,69,67,66,64,62,61,59,57,55,53,51,49,47,45,43,41,39,37,35,32,30,28,25,23,21,18,16,13,10,8,5,3,0,0,0
19:                
20:                #define FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG5193 100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,97,94,91,88,84,81,78,75,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
21:                
22:                #ifdef __MG7095
23:                const unsigned int FilamentLookUpTable[64] = {FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG7095_NEW_ROLLOFF};
24:                #else
25:                const unsigned int FilamentLookUpTable[64] = {FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG5193};
26:                #endif
27:                
28:                
29:                unsigned int magnet_scaling_linear_factor;
30:                unsigned int magnet_scaling_constant_factor;
31:                unsigned int eeprom_write_failure_count;
32:                unsigned int filament_iprog;
33:                unsigned int eeprom_read_failure_count;
34:                
35:                
36:                
37:                unsigned int arc_detected;
38:                
39:                unsigned long low_energy_target_current_set_point_derived; 
40:                
41:                signed int look_up_offset;
42:                
43:                unsigned int default_pac_2_adc_reading;
44:                
45:                unsigned int max_low_energy_target_current_startup_adjust_initital_value = 300;
46:                unsigned int low_energy_target_current_startup_max_cooldown = 12000;
47:                unsigned int low_energy_target_current_startup_adjust_initital_value = 0;
48:                unsigned int low_energy_target_current_startup_adjust_decay_time_pulses = 1200;
49:                unsigned int low_energy_target_current_startup_adjust_direction_positive = 0;
50:                unsigned int low_energy_target_current_startup_adjust;
51:                
52:                unsigned int pulse_off_time_10_ms_units;
53:                
54:                unsigned int linac_high_energy_target_current_adc_reading;
55:                unsigned int linac_high_energy_target_current_set_point;
56:                
57:                unsigned int linac_low_energy_target_current_adc_reading;
58:                unsigned int linac_low_energy_target_current_set_point;
59:                unsigned int linac_low_energy_target_current_set_point_portal_mode;
60:                unsigned int linac_low_energy_target_current_set_point_gantry_mode;
61:                
62:                
63:                
64:                signed int linac_high_energy_program_offset;
65:                signed int linac_low_energy_program_offset;
66:                unsigned char fast_ratio_mode;
67:                
68:                unsigned int pulse_counter_this_run;   // This counts the number of pulses in the current "run".  This will be reset to 0 if there are no triggers for 100mS or more.
69:                
70:                  
71:                
72:                unsigned int false_trigger;
73:                
74:                unsigned int last_period = 62501;
75:                unsigned int prf_deciherz = 0;
76:                
77:                void ReadADCtoPACArray(void);
78:                
79:                volatile unsigned int timing_error_int1_count = 0;
80:                
81:                unsigned int software_skip_warmup = 0;
82:                
83:                unsigned char ram_config_set_magnetron_magnet_current_from_GUI;
84:                
85:                volatile unsigned int _PERSISTENT last_known_action;
86:                volatile unsigned int _PERSISTENT last_osccon;
87:                
88:                unsigned int _PERSISTENT processor_crash_count;
89:                
90:                unsigned int previous_last_action;
91:                
92:                volatile unsigned int lvdinterrupt_counter = 0;
93:                
94:                unsigned int MakeScale(unsigned int num, unsigned int den);
95:                
96:                unsigned int start_reset_process;
97:                
98:                void SavePulseCountersToEEPROM(void);
99:                
100:               void UpdateIOExpanderOutputs(void);
101:               
102:               unsigned int CheckSkipNextPulse(void);
103:               unsigned int this_pulse_skipped;
104:               
105:               unsigned char slow_down_thyratron_pid_counter;
106:               
107:               
108:               unsigned int average_energy_per_pulse_milli_joules;
109:               unsigned int average_output_power_watts;
110:               unsigned int average_pulse_repetition_frequency_deci_herz;
111:               unsigned int prf_pulse_counter;
112:               
113:               
114:               unsigned char control_state;
115:               
116:               unsigned int pac_1_adc_reading;
117:               unsigned int pac_2_adc_reading;
118:               
119:               
120:               unsigned int fast_reset_counter_persistent;
121:               unsigned long _PERSISTENT arc_counter_persistent;
122:               unsigned int arc_counter_consecutive;
123:               unsigned int _PERSISTENT arc_counter_this_hv_on;
124:               unsigned long _PERSISTENT pulse_counter_this_hv_on;
125:               unsigned long long _PERSISTENT pulse_counter_persistent;
126:               unsigned int arc_counter_fast;
127:               unsigned int arc_counter_slow;
128:               unsigned int pulse_counter_fast;
129:               unsigned int pulse_counter_slow;
130:               
131:               unsigned int led_pulse_count;
132:               
133:               
134:               unsigned int time_since_last_trigger;
135:               unsigned int magnetron_filament_control_mode;
136:               unsigned int magnetron_filament_off_resistance;
137:               unsigned int magnetron_filament_on_resistance;
138:               unsigned int magnetron_filament_resistance_measurement;
139:               
140:               
141:               unsigned int pulse_magnetron_current_adc_reading;
142:               unsigned int pulse_magnetron_voltage_adc_reading;
143:               
144:               
145:               // Control structers for the thyratron heater PID loops
146:               tPID thyratron_reservoir_heater_PID;
147:               fractional pid_thyratron_reservoir_heater_controlHistory[3] __attribute__ ((section (".ybss, bss, ymemory")));
148:               fractional pid_thyratron_reservoir_heater_abcCoefficient[3] __attribute__ ((section (".xbss, bss, xmemory")));
149:               fractional pid_thyratron_reservoir_heater_kCoeffs[] = {0,0,0};
150:               
151:               tPID thyratron_cathode_heater_PID;
152:               fractional pid_thyratron_cathode_heater_controlHistory[3] __attribute__ ((section (".ybss, bss, ymemory")));
153:               fractional pid_thyratron_cathode_heater_abcCoefficient[3] __attribute__ ((section (".xbss, bss, xmemory")));
154:               fractional pid_thyratron_cathode_heater_kCoeffs[] = {0,0,0};
155:               
156:               
157:               
158:               
159:               BUFFER64BYTE uart1_input_buffer;
160:               BUFFER64BYTE uart1_output_buffer;
161:               
162:               LTC2656 U44_LTC2656;
163:               MCP23017 U64_MCP23017;
164:               
165:               POWERSUPPLY ps_hv_lambda_mode_A;
166:               POWERSUPPLY ps_magnetron_mode_A;
167:               POWERSUPPLY ps_hv_lambda_mode_B;
168:               POWERSUPPLY ps_magnetron_mode_B;
169:               POWERSUPPLY ps_magnet;
170:               POWERSUPPLY ps_filament;
171:               POWERSUPPLY ps_thyr_cathode_htr;
172:               POWERSUPPLY ps_thyr_reservoir_htr;
173:               
174:               
175:               volatile unsigned char adc_result_index;
176:               
177:               unsigned int pfn_rev_current_array[128];
178:               
179:               unsigned int pac_1_array[128];
180:               unsigned int pac_2_array[128];
181:               
182:               unsigned int thyratron_cathode_heater_voltage_array[128];
183:               unsigned int thyratron_reservoir_heater_voltage_array[128];
184:               
185:               unsigned int magnetron_magnet_current_array[128];
186:               unsigned int magnetron_magnet_voltage_array[128];
187:               
188:               unsigned int magnetron_filament_current_array[128];
189:               unsigned int magnetron_filament_voltage_array[128];
190:               
191:               unsigned int lambda_vpeak_array[128];
192:               unsigned int lambda_vmon_array[128];
193:               
194:               
195:               volatile unsigned char global_run_post_pulse_process;
196:               volatile unsigned char global_adc_ignore_this_sample;
197:               
198:               
199:               
200:               unsigned char a_b_selected_mode;
201:               volatile unsigned char next_pulse_a_b_selected_mode;
202:               
203:               
204:               unsigned int operation_mode;
205:               unsigned int scale_interleaved;
206:               unsigned int scale_low_energy;
207:               
208:               
209:               
210:               void DoA34760StartUpCommon(void);
211:               void DoA34760StartUpNormalProcess(void);
212:               void DoA34760StartUpFastProcess(void);
213:               void DoA34760StartUpCommonPostProcess(void);
214:               
215:               
216:               
217:               void CalcPowerSupplySettings(POWERSUPPLY* ptr_ps);
218:               void UpdateDacAll(void);
219:               void Do10msTicToc(void);
220:               void DoThyratronPIDs(void);
221:               void DoMagnetronFilamentAdjust(void);
222:               void ReadIsolatedAdcToRam(void);
223:               void FilterADCs(void);
224:               void FastReadAndFilterFeedbacks(void);
225:               void FastReadAndFilterPACInputs(void);
226:               void ExitHvOnState(void);
227:               void DoColdShutDown(void);
228:               void DoWarmShutDown(void);
229:               void StartWarmUp(void);
230:               
231:               void ScalePowerSupply(POWERSUPPLY* ptr_ps, unsigned int num, unsigned int den);
232:               
233:               void EnableMagnetronFilamentSupply(void);
234:               void DisableMagnetronFilamentSupply(void);
235:               void EnableMagnetronMagnetSupply(void);
236:               void DisableMagnetronMagnetSupply(void);
237:               void DisableHVLambdaSupply(void);
238:               void HVLambdaStartCharging(void);
239:               
240:               unsigned int CalculatePoly(unsigned int set_point);
241:               
242:               extern unsigned int ReturnPowerSupplyADCScaledVoltage(POWERSUPPLY* ptr, unsigned int value);
243:               extern unsigned int ReturnPowerSupplyADCScaledCurrent(POWERSUPPLY* ptr, unsigned int value);
244:               
245:               
246:               //unsigned int RCFilter256Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
247:               //unsigned int RCFilter64Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
248:               //unsigned int RCFilter16Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
249:               
250:               
251:               unsigned int mode_A_pulse_magnetron_current_adc_reading_filtered;
252:               unsigned int mode_B_pulse_magnetron_current_adc_reading_filtered;
253:               
254:               unsigned int mode_A_pulse_magnetron_voltage_adc_reading_filtered;
255:               unsigned int mode_B_pulse_magnetron_voltage_adc_reading_filtered;
256:               
257:               unsigned int mode_A_pulse_magnetron_current_adc_reading_max;
258:               unsigned int mode_A_pulse_magnetron_current_adc_reading_min;
259:               
260:               unsigned int mode_B_pulse_magnetron_current_adc_reading_max;
261:               unsigned int mode_B_pulse_magnetron_current_adc_reading_min;
262:               
263:               unsigned int mode_A_pulse_magnetron_voltage_adc_reading_filtered;
264:               unsigned int mode_B_pulse_magnetron_voltage_adc_reading_filtered;
265:               
266:               
267:               
268:               
269:               
270:               void DoStateMachine(void) {
000782  FA000A     LNK #0xA
271:                 unsigned int warmup_counter;
272:                 unsigned int lambda_supply_startup_counter;
273:                 unsigned int vtemp;
274:                 
275:                 unsigned long temp_long;
276:               	  
277:               
278:               
279:                 switch(control_state) {
000784  208584     MOV #0x858, W4
000786  784214     MOV.B [W4], W4
000788  FB8204     ZE W4, W4
00078A  200345     MOV #0x34, W5
00078C  520F85     SUB W4, W5, [W15]
00078E  32011F     BRA Z, .L7, .LSM71
000790  200345     MOV #0x34, W5
000792  520F85     SUB W4, W5, [W15]
000794  3C000D     BRA GT, .L13
000796  520FE6     SUB W4, #0x6, [W15]
000798  320030     BRA Z, .L4, .LSM10
00079A  520FE6     SUB W4, #0x6, [W15]
00079C  3C0003     BRA GT, .L14
00079E  520FE4     SUB W4, #0x4, [W15]
0007A0  32001B     BRA Z, .L3, .LSM2
0007A2  370392     BRA .L2, .LSM243
0007A4  520FF4     SUB W4, #0x14, [W15]
0007A6  32007A     BRA Z, .L5, .LSM22
0007A8  200245     MOV #0x24, W5
0007AA  520F85     SUB W4, W5, [W15]
0007AC  320092     BRA Z, .L6, .LSM32
0007AE  37038C     BRA .L2, .LSM243
0007B0  200A05     MOV #0xA0, W5
0007B2  520F85     SUB W4, W5, [W15]
0007B4  320386     BRA Z, .L10, .LSM240
0007B6  200A05     MOV #0xA0, W5
0007B8  520F85     SUB W4, W5, [W15]
0007BA  3C0007     BRA GT, .L15
0007BC  200355     MOV #0x35, W5
0007BE  520F85     SUB W4, W5, [W15]
0007C0  320144     BRA Z, .L8, .LSM89
0007C2  200445     MOV #0x44, W5
0007C4  520F85     SUB W4, W5, [W15]
0007C6  320190     BRA Z, .L9, .LSM112
0007C8  37037F     BRA .L2, .LSM243
0007CA  200A45     MOV #0xA4, W5
0007CC  520F85     SUB W4, W5, [W15]
0007CE  320342     BRA Z, .L11, .LSM220
0007D0  200A85     MOV #0xA8, W5
0007D2  520F85     SUB W4, W5, [W15]
0007D4  320351     BRA Z, .L12, .LSM228
0007D6  370378     BRA .L2, .LSM243
280:                   
281:                 case STATE_START_UP:
282:                   
283:                   DoA34760StartUpCommon();
0007D8  07037D     RCALL DoA34760StartUpCommon
284:                   DoA34760StartUpNormalProcess();
0007DA  070858     RCALL DoA34760StartUpNormalProcess
285:                   DoA34760StartUpCommonPostProcess();
0007DC  070971     RCALL DoA34760StartUpCommonPostProcess
286:                   
287:                   if (CheckStartupFailed()) {
0007DE  072089     RCALL CheckStartupFailed
0007E0  780200     MOV W0, W4
0007E2  520FE0     SUB W4, #0x0, [W15]
0007E4  320005     BRA Z, .L16, .LSM8
288:                     control_state = STATE_FAULT_MCU_CORE_FAULT;
0007E6  B3CA04     MOV.B #0xA0, W4
0007E8  FD0200     EXCH W0, W4
0007EA  B7E858     MOV.B WREG, control_state
0007EC  FD0200     EXCH W0, W4
289:                   } else {
290:                     control_state = STATE_SYSTEM_COLD_READY;
0007F0  B3C144     MOV.B #0x14, W4
0007F2  FD0200     EXCH W0, W4
0007F4  B7E858     MOV.B WREG, control_state
0007F6  FD0200     EXCH W0, W4
291:                   }
292:                   break;
0007EE  370370     BRA .L1, .LSM245
0007F8  37036B     BRA .L1, .LSM245
293:                   
294:                 case STATE_FAST_RECOVERY_START_UP:
295:               
296:                   // It takes a 360uS to get to here (really just to read flash)
297:               
298:                   PIN_UART2_TX = !PIN_UART2_TX;
0007FA  801655     MOV LATB, W5
0007FC  200404     MOV #0x40, W4
0007FE  628204     AND W5, W4, W4
000800  A7F004     BTSC W4, #15
000802  EA0204     NEG W4, W4
000804  E90204     DEC W4, W4
000806  DE224F     LSR W4, #15, W4
000808  784204     MOV.B W4, W4
00080A  FB8204     ZE W4, W4
00080C  620261     AND W4, #0x1, W4
00080E  DD2246     SL W4, #6, W4
000810  801656     MOV LATB, W6
000812  2FFBF5     MOV #0xFFBF, W5
000814  630285     AND W6, W5, W5
000816  720205     IOR W4, W5, W4
000818  881654     MOV W4, LATB
299:                   DoA34760StartUpCommon();  // This Takes 4.6ms (4.55 ms of this is loading and intialization of Power Supply Structures)
00081A  07035C     RCALL DoA34760StartUpCommon
300:                   PIN_UART2_TX = !PIN_UART2_TX;
00081C  801655     MOV LATB, W5
00081E  200404     MOV #0x40, W4
000820  628204     AND W5, W4, W4
000822  A7F004     BTSC W4, #15
000824  EA0204     NEG W4, W4
000826  E90204     DEC W4, W4
000828  DE224F     LSR W4, #15, W4
00082A  784204     MOV.B W4, W4
00082C  FB8204     ZE W4, W4
00082E  620261     AND W4, #0x1, W4
000830  DD2246     SL W4, #6, W4
000832  801656     MOV LATB, W6
000834  2FFBF5     MOV #0xFFBF, W5
000836  630285     AND W6, W5, W5
000838  720205     IOR W4, W5, W4
00083A  881654     MOV W4, LATB
301:                   DoA34760StartUpFastProcess(); // This takes 4.3mS 
00083C  070895     RCALL DoA34760StartUpFastProcess
302:                   PIN_UART2_TX = !PIN_UART2_TX;
00083E  801655     MOV LATB, W5
000840  200404     MOV #0x40, W4
000842  628204     AND W5, W4, W4
000844  A7F004     BTSC W4, #15
000846  EA0204     NEG W4, W4
000848  E90204     DEC W4, W4
00084A  DE224F     LSR W4, #15, W4
00084C  784204     MOV.B W4, W4
00084E  FB8204     ZE W4, W4
000850  620261     AND W4, #0x1, W4
000852  DD2246     SL W4, #6, W4
000854  801656     MOV LATB, W6
000856  2FFBF5     MOV #0xFFBF, W5
000858  630285     AND W6, W5, W5
00085A  720205     IOR W4, W5, W4
00085C  881654     MOV W4, LATB
303:                   DoA34760StartUpCommonPostProcess(); // This takes 60uS
00085E  070930     RCALL DoA34760StartUpCommonPostProcess
304:                   PIN_UART2_TX = !PIN_UART2_TX;
000860  801655     MOV LATB, W5
000862  200404     MOV #0x40, W4
000864  628204     AND W5, W4, W4
000866  A7F004     BTSC W4, #15
000868  EA0204     NEG W4, W4
00086A  E90204     DEC W4, W4
00086C  DE224F     LSR W4, #15, W4
00086E  784204     MOV.B W4, W4
000870  FB8204     ZE W4, W4
000872  620261     AND W4, #0x1, W4
000874  DD2246     SL W4, #6, W4
000876  801656     MOV LATB, W6
000878  2FFBF5     MOV #0xFFBF, W5
00087A  630285     AND W6, W5, W5
00087C  720205     IOR W4, W5, W4
00087E  881654     MOV W4, LATB
305:                   
306:                   if (CheckStartupFailed()) {
000880  072038     RCALL CheckStartupFailed
000882  780200     MOV W0, W4
000884  520FE0     SUB W4, #0x0, [W15]
000886  320005     BRA Z, .L19, .LSM20
307:                     control_state = STATE_FAULT_MCU_CORE_FAULT;
000888  B3CA04     MOV.B #0xA0, W4
00088A  FD0200     EXCH W0, W4
00088C  B7E858     MOV.B WREG, control_state
00088E  FD0200     EXCH W0, W4
308:                   } else {
309:                     control_state = STATE_HV_ON;
000892  B3C444     MOV.B #0x44, W4
000894  FD0200     EXCH W0, W4
000896  B7E858     MOV.B WREG, control_state
000898  FD0200     EXCH W0, W4
310:                   }
311:               
312:                   break;
000890  37031F     BRA .L1, .LSM245
00089A  37031A     BRA .L1, .LSM245
313:               
314:                   
315:               
316:                 case STATE_SYSTEM_COLD_READY:
317:                   DoColdShutDown();
00089C  07100F     RCALL DoColdShutDown
318:                   while (control_state == STATE_SYSTEM_COLD_READY) {
00089E  370014     BRA .L21, .LSM30
0008C8  208584     MOV #0x858, W4
0008CA  784214     MOV.B [W4], W4
0008CC  524FF4     SUB.B W4, #0x14, [W15]
0008CE  32FFE8     BRA Z, .L23, .LSM24
319:                     Do10msTicToc();  // Execute 10mS timed functions if the 10ms Timer has rolled
0008A0  070AE7     RCALL Do10msTicToc
320:                     DoSerialCommand();
0008A2  071545     RCALL DoSerialCommand
321:                     if (CheckFaultActive()) {
0008A4  07202B     RCALL CheckFaultActive
0008A6  780200     MOV W0, W4
0008A8  520FE0     SUB W4, #0x0, [W15]
0008AA  320005     BRA Z, .L22, .LSM28
322:               	control_state = STATE_FAULT_COLD_FAULT;
0008AC  B3CA44     MOV.B #0xA4, W4
0008AE  FD0200     EXCH W0, W4
0008B0  B7E858     MOV.B WREG, control_state
0008B2  FD0200     EXCH W0, W4
0008B4  370009     BRA .L21, .LSM30
323:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == ILL_MODULATOR_ENABLED) {
0008B6  801615     MOV PORTA, W5
0008B8  240004     MOV #0x4000, W4
0008BA  628204     AND W5, W4, W4
0008BC  520FE0     SUB W4, #0x0, [W15]
0008BE  3A0004     BRA NZ, .L21, .LSM30
324:               	control_state = STATE_WARM_UP;
0008C0  B3C244     MOV.B #0x24, W4
0008C2  FD0200     EXCH W0, W4
0008C4  B7E858     MOV.B WREG, control_state
0008C6  FD0200     EXCH W0, W4
325:                     }
326:                   }
327:                   break;
0008D0  3702FF     BRA .L1, .LSM245
328:                   
329:                 case STATE_WARM_UP:
330:                   StartWarmUp();
0008D2  071026     RCALL StartWarmUp
331:                   warmup_counter = 0;
0008D4  EB0200     CLR W4
0008D6  780F04     MOV W4, [W14]
332:                   software_skip_warmup = 0;
0008D8  EB0200     CLR W4
0008DA  884214     MOV W4, software_skip_warmup
333:                   while (control_state == STATE_WARM_UP) {
0008DC  370072     BRA .L24, .LSM69
0009C2  208585     MOV #0x858, W5
0009C4  784295     MOV.B [W5], W5
0009C6  B3C244     MOV.B #0x24, W4
0009C8  52CF84     SUB.B W5, W4, [W15]
0009CA  32FF89     BRA Z, .L32, .LSM36
334:                     Do10msTicToc();
0008DE  070AC8     RCALL Do10msTicToc
335:                     DoSerialCommand();
0008E0  071526     RCALL DoSerialCommand
336:                     Nop();
0008E2  000000     NOP
337:                     Nop();
0008E4  000000     NOP
338:                     Nop();
0008E6  000000     NOP
339:                     if (_T2IF) {
0008E8  800425     MOV IFS0, W5
0008EA  200404     MOV #0x40, W4
0008EC  628204     AND W5, W4, W4
0008EE  520FE0     SUB W4, #0x0, [W15]
0008F0  32002F     BRA Z, .L25, .LSM53
340:               	warmup_counter++;
0008F2  E80F1E     INC [W14], [W14]
341:               	_T2IF = 0;
0008F4  A9C084     BCLR IFS0, #6
342:               	if ((PIN_FP_FAST_RESTART == ILL_FAST_RESTART) || (software_skip_warmup == 1)) {
0008F6  801735     MOV PORTG, W5
0008F8  210004     MOV #0x1000, W4
0008FA  628204     AND W5, W4, W4
0008FC  520FE0     SUB W4, #0x0, [W15]
0008FE  320003     BRA Z, .L26, .LSM45
000900  804214     MOV software_skip_warmup, W4
000902  520FE1     SUB W4, #0x1, [W15]
000904  3A0011     BRA NZ, .L27, .LSM49
343:               	  ScalePowerSupply(&ps_filament, warmup_counter, 10);
000906  2000A2     MOV #0xA, W2
000908  78009E     MOV [W14], W1
00090A  20AF80     MOV #0xAF8, W0
00090C  07092B     RCALL ScalePowerSupply
344:               	  ScalePowerSupply(&ps_magnet, warmup_counter, 10);
00090E  2000A2     MOV #0xA, W2
000910  78009E     MOV [W14], W1
000912  20A9E0     MOV #0xA9E, W0
000914  070927     RCALL ScalePowerSupply
345:               	  ScalePowerSupply(&ps_thyr_cathode_htr, warmup_counter, 10);
000916  2000A2     MOV #0xA, W2
000918  78009E     MOV [W14], W1
00091A  20B520     MOV #0xB52, W0
00091C  070923     RCALL ScalePowerSupply
346:               	  ScalePowerSupply(&ps_thyr_reservoir_htr, warmup_counter, 10);
00091E  2000A2     MOV #0xA, W2
000920  78009E     MOV [W14], W1
000922  20BAC0     MOV #0xBAC, W0
000924  07091F     RCALL ScalePowerSupply
000926  370014     BRA .L25, .LSM53
347:               	} else {
348:               	  ScalePowerSupply(&ps_filament, warmup_counter, ps_filament.warmup_ramp_time);
000928  8057C4     MOV ps_filament, W4
00092A  780104     MOV W4, W2
00092C  78009E     MOV [W14], W1
00092E  20AF80     MOV #0xAF8, W0
000930  070919     RCALL ScalePowerSupply
349:               	  ScalePowerSupply(&ps_magnet, warmup_counter, ps_magnet.warmup_ramp_time);
000932  8054F4     MOV ps_magnet, W4
000934  780104     MOV W4, W2
000936  78009E     MOV [W14], W1
000938  20A9E0     MOV #0xA9E, W0
00093A  070914     RCALL ScalePowerSupply
350:               	  ScalePowerSupply(&ps_thyr_cathode_htr, warmup_counter, ps_thyr_cathode_htr.warmup_ramp_time);
00093C  805A94     MOV ps_thyr_cathode_htr, W4
00093E  780104     MOV W4, W2
000940  78009E     MOV [W14], W1
000942  20B520     MOV #0xB52, W0
000944  07090F     RCALL ScalePowerSupply
351:               	  ScalePowerSupply(&ps_thyr_reservoir_htr, warmup_counter, ps_thyr_reservoir_htr.warmup_ramp_time);
000946  805D64     MOV ps_thyr_reservoir_htr, W4
000948  780104     MOV W4, W2
00094A  78009E     MOV [W14], W1
00094C  20BAC0     MOV #0xBAC, W0
00094E  07090A     RCALL ScalePowerSupply
352:               	}
353:                     }
354:                     if (CheckFaultActive()) {
000950  071FD5     RCALL CheckFaultActive
000952  780200     MOV W0, W4
000954  520FE0     SUB W4, #0x0, [W15]
000956  320005     BRA Z, .L28, .LSM55
355:               	control_state = STATE_FAULT_COLD_FAULT;
000958  B3CA44     MOV.B #0xA4, W4
00095A  FD0200     EXCH W0, W4
00095C  B7E858     MOV.B WREG, control_state
00095E  FD0200     EXCH W0, W4
000960  370030     BRA .L24, .LSM69
356:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000962  801615     MOV PORTA, W5
000964  240004     MOV #0x4000, W4
000966  628204     AND W5, W4, W4
000968  520FE0     SUB W4, #0x0, [W15]
00096A  320005     BRA Z, .L29, .LSM57
357:               	control_state = STATE_SYSTEM_COLD_READY;
00096C  B3C144     MOV.B #0x14, W4
00096E  FD0200     EXCH W0, W4
000970  B7E858     MOV.B WREG, control_state
000972  FD0200     EXCH W0, W4
000974  370026     BRA .L24, .LSM69
358:                     } else if (warmup_counter > SYSTEM_WARM_UP_TIME) {
000976  200644     MOV #0x64, W4
000978  78029E     MOV [W14], W5
00097A  528F84     SUB W5, W4, [W15]
00097C  360008     BRA LEU, .L30, .LSM61
359:               	ResetHWLatches();
00097E  071D45     RCALL ResetHWLatches
360:               	control_state = STATE_SYSTEM_WARM_READY;
000980  B3C344     MOV.B #0x34, W4
000982  FD0200     EXCH W0, W4
000984  B7E858     MOV.B WREG, control_state
000986  FD0200     EXCH W0, W4
361:               	software_skip_warmup = 0;
000988  EB0200     CLR W4
00098A  884214     MOV W4, software_skip_warmup
00098C  37001A     BRA .L24, .LSM69
362:                     } else if ((PIN_FP_FAST_RESTART == ILL_FAST_RESTART) && (warmup_counter > 20)) {
00098E  801735     MOV PORTG, W5
000990  210004     MOV #0x1000, W4
000992  628204     AND W5, W4, W4
000994  520FE0     SUB W4, #0x0, [W15]
000996  3A000B     BRA NZ, .L31, .LSM65
000998  78021E     MOV [W14], W4
00099A  520FF4     SUB W4, #0x14, [W15]
00099C  360008     BRA LEU, .L31, .LSM65
363:               	ResetHWLatches();
00099E  071D35     RCALL ResetHWLatches
364:               	control_state = STATE_SYSTEM_WARM_READY;
0009A0  B3C344     MOV.B #0x34, W4
0009A2  FD0200     EXCH W0, W4
0009A4  B7E858     MOV.B WREG, control_state
0009A6  FD0200     EXCH W0, W4
365:               	software_skip_warmup = 0;
0009A8  EB0200     CLR W4
0009AA  884214     MOV W4, software_skip_warmup
0009AC  37000A     BRA .L24, .LSM69
366:                     } else if (software_skip_warmup == 1) {
0009AE  804214     MOV software_skip_warmup, W4
0009B0  520FE1     SUB W4, #0x1, [W15]
0009B2  3A0007     BRA NZ, .L24, .LSM69
367:               	ResetHWLatches();
0009B4  071D2A     RCALL ResetHWLatches
368:               	control_state = STATE_SYSTEM_WARM_READY;
0009B6  B3C344     MOV.B #0x34, W4
0009B8  FD0200     EXCH W0, W4
0009BA  B7E858     MOV.B WREG, control_state
0009BC  FD0200     EXCH W0, W4
369:               	software_skip_warmup = 0;
0009BE  EB0200     CLR W4
0009C0  884214     MOV W4, software_skip_warmup
370:                     }
371:                   }
372:                   break;
0009CC  370281     BRA .L1, .LSM245
373:                   
374:                 case STATE_SYSTEM_WARM_READY:
375:                   // DPARKER SaveDataToEEPROM(); -- New Commands to deal with EEPROM access and storage
376:                   DoWarmShutDown();
0009CE  070F9E     RCALL DoWarmShutDown
377:                   ScalePowerSupply(&ps_hv_lambda_mode_A,100,100);
0009D0  200642     MOV #0x64, W2
0009D2  200641     MOV #0x64, W1
0009D4  209360     MOV #0x936, W0
0009D6  0708C6     RCALL ScalePowerSupply
378:                   ScalePowerSupply(&ps_hv_lambda_mode_B,100,100);
0009D8  200642     MOV #0x64, W2
0009DA  200641     MOV #0x64, W1
0009DC  209EA0     MOV #0x9EA, W0
0009DE  0708C2     RCALL ScalePowerSupply
379:                   ScalePowerSupply(&ps_filament,100,100);
0009E0  200642     MOV #0x64, W2
0009E2  200641     MOV #0x64, W1
0009E4  20AF80     MOV #0xAF8, W0
0009E6  0708BE     RCALL ScalePowerSupply
380:                   ScalePowerSupply(&ps_magnet,100,100);
0009E8  200642     MOV #0x64, W2
0009EA  200641     MOV #0x64, W1
0009EC  20A9E0     MOV #0xA9E, W0
0009EE  0708BA     RCALL ScalePowerSupply
381:                   ScalePowerSupply(&ps_thyr_reservoir_htr,100,100);
0009F0  200642     MOV #0x64, W2
0009F2  200641     MOV #0x64, W1
0009F4  20BAC0     MOV #0xBAC, W0
0009F6  0708B6     RCALL ScalePowerSupply
382:                   ScalePowerSupply(&ps_thyr_cathode_htr,100,100);
0009F8  200642     MOV #0x64, W2
0009FA  200641     MOV #0x64, W1
0009FC  20B520     MOV #0xB52, W0
0009FE  0708B2     RCALL ScalePowerSupply
383:                   while (control_state == STATE_SYSTEM_WARM_READY) {
000A00  37001E     BRA .L33, .LSM87
000A3E  208585     MOV #0x858, W5
000A40  784295     MOV.B [W5], W5
000A42  B3C344     MOV.B #0x34, W4
000A44  52CF84     SUB.B W5, W4, [W15]
000A46  32FFDD     BRA Z, .L36, .LSM79
384:                     Do10msTicToc();
000A02  070A36     RCALL Do10msTicToc
385:                     DoSerialCommand();
000A04  071494     RCALL DoSerialCommand
386:                     if (CheckFaultActive()) {
000A06  071F7A     RCALL CheckFaultActive
000A08  780200     MOV W0, W4
000A0A  520FE0     SUB W4, #0x0, [W15]
000A0C  320005     BRA Z, .L34, .LSM83
387:               	control_state = STATE_FAULT_WARM_FAULT;
000A0E  B3CA84     MOV.B #0xA8, W4
000A10  FD0200     EXCH W0, W4
000A12  B7E858     MOV.B WREG, control_state
000A14  FD0200     EXCH W0, W4
000A16  370013     BRA .L33, .LSM87
388:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000A18  801615     MOV PORTA, W5
000A1A  240004     MOV #0x4000, W4
000A1C  628204     AND W5, W4, W4
000A1E  520FE0     SUB W4, #0x0, [W15]
000A20  320005     BRA Z, .L35, .LSM85
389:               	control_state = STATE_SYSTEM_COLD_READY;
000A22  B3C144     MOV.B #0x14, W4
000A24  FD0200     EXCH W0, W4
000A26  B7E858     MOV.B WREG, control_state
000A28  FD0200     EXCH W0, W4
000A2A  370009     BRA .L33, .LSM87
390:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == ILL_MODULATOR_HV_ON) {
000A2C  801615     MOV PORTA, W5
000A2E  280004     MOV #0x8000, W4
000A30  628204     AND W5, W4, W4
000A32  520FE0     SUB W4, #0x0, [W15]
000A34  3A0004     BRA NZ, .L33, .LSM87
391:               	control_state = STATE_HV_STARTUP;
000A36  B3C354     MOV.B #0x35, W4
000A38  FD0200     EXCH W0, W4
000A3A  B7E858     MOV.B WREG, control_state
000A3C  FD0200     EXCH W0, W4
392:                     }
393:                   }
394:                   break;
000A48  370243     BRA .L1, .LSM245
395:                   
396:                 case STATE_HV_STARTUP:
397:                   // THIS STATE uses the same faults as STATE_SYSTEM_WARM_READY
398:               
399:               #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
400:                   
401:                   vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
000A4A  8042D4     MOV pac_1_adc_reading, W4
000A4C  20C351     MOV #0xC35, W1
000A4E  780004     MOV W4, W0
000A50  07108E     RCALL Scale16Bit
000A52  780200     MOV W0, W4
000A54  980724     MOV W4, [W14+4]
402:                   SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp , 0);
000A56  EB0100     CLR W2
000A58  9000AE     MOV [W14+4], W1
000A5A  209360     MOV #0x936, W0
000A5C  070851     RCALL SetPowerSupplyTarget
403:                   
404:                   vtemp = Scale16Bit(pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
000A5E  8042E4     MOV pac_2_adc_reading, W4
000A60  20C351     MOV #0xC35, W1
000A62  780004     MOV W4, W0
000A64  071084     RCALL Scale16Bit
000A66  780200     MOV W0, W4
000A68  980724     MOV W4, [W14+4]
405:                   SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
000A6A  EB0100     CLR W2
000A6C  9000AE     MOV [W14+4], W1
000A6E  209EA0     MOV #0x9EA, W0
000A70  070847     RCALL SetPowerSupplyTarget
406:               #endif
407:               
408:               
409:                   lambda_supply_startup_counter = 0;
000A72  EB0200     CLR W4
000A74  980714     MOV W4, [W14+2]
410:                   PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART;
000A76  A9E2CB     BCLR 0x2CB, #7
411:                   while (control_state == STATE_HV_STARTUP) {
000A78  370031     BRA .L37, .LSM110
000ADC  208585     MOV #0x858, W5
000ADE  784295     MOV.B [W5], W5
000AE0  B3C354     MOV.B #0x35, W4
000AE2  52CF84     SUB.B W5, W4, [W15]
000AE4  32FFCA     BRA Z, .L42, .LSM96
412:                     Do10msTicToc();
000A7A  0709FA     RCALL Do10msTicToc
413:                     DoSerialCommand();
000A7C  071458     RCALL DoSerialCommand
414:                     if (_T2IF) {
000A7E  800425     MOV IFS0, W5
000A80  200404     MOV #0x40, W4
000A82  628204     AND W5, W4, W4
000A84  520FE0     SUB W4, #0x0, [W15]
000A86  320004     BRA Z, .L38, .LSM101
415:               	// 100ms Timer over flow 
416:               	_T2IF = 0;
000A88  A9C084     BCLR IFS0, #6
417:               	lambda_supply_startup_counter++;
000A8A  90021E     MOV [W14+2], W4
000A8C  E80204     INC W4, W4
000A8E  980714     MOV W4, [W14+2]
418:                     }
419:                     if (CheckFaultActive()) {
000A90  071F35     RCALL CheckFaultActive
000A92  780200     MOV W0, W4
000A94  520FE0     SUB W4, #0x0, [W15]
000A96  320005     BRA Z, .L39, .LSM103
420:               	control_state = STATE_FAULT_WARM_FAULT;
000A98  B3CA84     MOV.B #0xA8, W4
000A9A  FD0200     EXCH W0, W4
000A9C  B7E858     MOV.B WREG, control_state
000A9E  FD0200     EXCH W0, W4
000AA0  37001D     BRA .L37, .LSM110
421:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000AA2  801615     MOV PORTA, W5
000AA4  240004     MOV #0x4000, W4
000AA6  628204     AND W5, W4, W4
000AA8  520FE0     SUB W4, #0x0, [W15]
000AAA  320005     BRA Z, .L40, .LSM105
422:               	control_state = STATE_SYSTEM_COLD_READY;
000AAC  B3C144     MOV.B #0x14, W4
000AAE  FD0200     EXCH W0, W4
000AB0  B7E858     MOV.B WREG, control_state
000AB2  FD0200     EXCH W0, W4
000AB4  370013     BRA .L37, .LSM110
423:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == !ILL_MODULATOR_HV_ON) {
000AB6  801615     MOV PORTA, W5
000AB8  280004     MOV #0x8000, W4
000ABA  628204     AND W5, W4, W4
000ABC  520FE0     SUB W4, #0x0, [W15]
000ABE  320005     BRA Z, .L41, .LSM107
424:               	control_state = STATE_SYSTEM_WARM_READY;
000AC0  B3C344     MOV.B #0x34, W4
000AC2  FD0200     EXCH W0, W4
000AC4  B7E858     MOV.B WREG, control_state
000AC6  FD0200     EXCH W0, W4
000AC8  370009     BRA .L37, .LSM110
425:                     } else if (lambda_supply_startup_counter >= LAMBDA_SUPPLY_STARTUP_DELAY) {
000ACA  90029E     MOV [W14+2], W5
000ACC  200314     MOV #0x31, W4
000ACE  528F84     SUB W5, W4, [W15]
000AD0  360005     BRA LEU, .L37, .LSM110
426:               	control_state = STATE_HV_ON;
000AD2  B3C444     MOV.B #0x44, W4
000AD4  FD0200     EXCH W0, W4
000AD6  B7E858     MOV.B WREG, control_state
000AD8  FD0200     EXCH W0, W4
427:               	HVLambdaStartCharging();
000ADA  070FEF     RCALL HVLambdaStartCharging
428:                     }
429:                   }
430:                   break;
000AE6  3701F4     BRA .L1, .LSM245
431:               
432:                   
433:                 case STATE_HV_ON:
434:                   arc_counter_consecutive = 0;
000AE8  EB0200     CLR W4
000AEA  884304     MOV W4, arc_counter_consecutive
435:                   arc_counter_slow = 0;
000AEC  EB0200     CLR W4
000AEE  884324     MOV W4, arc_counter_slow
436:                   arc_counter_fast = 0;
000AF0  EB0200     CLR W4
000AF2  884314     MOV W4, arc_counter_fast
437:                   arc_counter_this_hv_on = 0;
000AF4  EB0200     CLR W4
000AF6  88BE14     MOV W4, arc_counter_this_hv_on
438:                   pulse_counter_this_hv_on = 0;
000AF8  B82260     MUL.UU W4, #0, W4
000AFA  88BD84     MOV W4, pulse_counter_this_hv_on
000AFC  88BD95     MOV W5, 0x17B2
439:                   global_run_post_pulse_process = 0;
000AFE  EB4200     CLR.B W4
000B00  FD0200     EXCH W0, W4
000B02  B7F708     MOV.B WREG, global_run_post_pulse_process
000B04  FD0200     EXCH W0, W4
440:                   
441:                   lambda_eoc_fault = 0;
000B06  EB4200     CLR.B W4
000B08  FD0200     EXCH W0, W4
000B0A  B7F74C     MOV.B WREG, lambda_eoc_fault
000B0C  FD0200     EXCH W0, W4
442:                   eoc_counts = 0;
000B0E  EB4200     CLR.B W4
000B10  FD0200     EXCH W0, W4
000B12  B7F74D     MOV.B WREG, eoc_counts
000B14  FD0200     EXCH W0, W4
443:                   eoc_max_reached_timer = 0;
000B16  EB0200     CLR W4
000B18  88BA74     MOV W4, eoc_max_reached_timer
444:                   for (vtemp = 0; vtemp < EOC_MAX_COUNT; vtemp++)
000B1A  EB0200     CLR W4
000B1C  980724     MOV W4, [W14+4]
000B1E  370009     BRA .L43
000B2C  90022E     MOV [W14+4], W4
000B2E  E80204     INC W4, W4
000B30  980724     MOV W4, [W14+4]
000B32  90022E     MOV [W14+4], W4
000B34  520FE2     SUB W4, #0x2, [W15]
000B36  36FFF4     BRA LEU, .L44, .LSM122
445:                   	eoc_10ms_timer[vtemp] = 0;    
000B20  90022E     MOV [W14+4], W4
000B22  420284     ADD W4, W4, W5
000B24  217504     MOV #0x1750, W4
000B26  428204     ADD W5, W4, W4
000B28  EB0280     CLR W5
000B2A  780A05     MOV W5, [W4]
446:                   
447:                   // PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART; // THIS is a redundent command and should be removed 
448:               
449:                   _T1IE = 1; // This is added for the fast restart process.  Normally _T1IE is set in HVLambdaStartCharging(), but the fast restart clears this bit temporarily
000B38  A8608C     BSET IEC0, #3
450:                       
451:                   while (control_state == STATE_HV_ON) {
000B3A  370186     BRA .L45, .LSM218
000E48  208585     MOV #0x858, W5
000E4A  784295     MOV.B [W5], W5
000E4C  B3C444     MOV.B #0x44, W4
000E4E  52CF84     SUB.B W5, W4, [W15]
000E50  32FE75     BRA Z, .L77, .LSM126
452:                     last_known_action = LAST_ACTION_HV_ON_LOOP;
000B3C  2000C4     MOV #0xC, W4
000B3E  88BDE4     MOV W4, last_known_action
453:                     Do10msTicToc();
000B40  070997     RCALL Do10msTicToc
454:                     DoSerialCommand();
000B42  0713F5     RCALL DoSerialCommand
455:               
456:                     // If we are not currently pulsing
457:                     // DPARKER how to check this?
458:                     if (time_since_last_trigger > 100) {
000B44  804365     MOV time_since_last_trigger, W5
000B46  200644     MOV #0x64, W4
000B48  528F84     SUB W5, W4, [W15]
000B4A  36000A     BRA LEU, .L46, .LSM133
459:               	if (PIN_A_B_MODE_SELECT == ILL_A_MODE_SELECTED) {
000B4C  801615     MOV PORTA, W5
000B4E  220004     MOV #0x2000, W4
000B50  628204     AND W5, W4, W4
000B52  520FE0     SUB W4, #0x0, [W15]
000B54  320005     BRA Z, .L46, .LSM133
460:               	  next_pulse_a_b_selected_mode = PULSE_MODE_A;
000B56  EB4200     CLR.B W4
000B58  FD0200     EXCH W0, W4
000B5A  B7F70B     MOV.B WREG, next_pulse_a_b_selected_mode
000B5C  FD0200     EXCH W0, W4
461:               	  PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
000B5E  A9C2CB     BCLR 0x2CB, #6
462:               	}
463:                     }
464:               
465:                     
466:                     if (PIN_GANTRY_PORTAL_SELECT == ILL_GANTRY_MODE) {
000B60  801735     MOV PORTG, W5
000B62  280004     MOV #0x8000, W4
000B64  628204     AND W5, W4, W4
000B66  520FE0     SUB W4, #0x0, [W15]
000B68  3A0003     BRA NZ, .L47, .LSM135
467:               	linac_low_energy_target_current_set_point = linac_low_energy_target_current_set_point_gantry_mode;
000B6A  804194     MOV linac_low_energy_target_current_set_point_gantry_mode, W4
000B6C  884174     MOV W4, linac_low_energy_target_current_set_point
000B6E  370002     BRA .L48, .LSM136
468:                     } else {
469:               	linac_low_energy_target_current_set_point = linac_low_energy_target_current_set_point_portal_mode;
000B70  804184     MOV linac_low_energy_target_current_set_point_portal_mode, W4
000B72  884174     MOV W4, linac_low_energy_target_current_set_point
470:                     }
471:               
472:               
473:                     if (global_run_post_pulse_process) {
000B74  217084     MOV #0x1708, W4
000B76  784214     MOV.B [W4], W4
000B78  524FE0     SUB.B W4, #0x0, [W15]
000B7A  320147     BRA Z, .L49, .LSM209
474:               	time_since_last_trigger = 0;
000B7C  EB0200     CLR W4
000B7E  884364     MOV W4, time_since_last_trigger
475:               	if (false_trigger) {
000B80  8041E4     MOV false_trigger, W4
000B82  520FE0     SUB W4, #0x0, [W15]
000B84  320002     BRA Z, .L50, .LSM140
476:               	  RecordThisThyratronFault(FAULT_THYR_FALSE_TRIGGER);
000B86  204000     MOV #0x400, W0
000B88  071E77     RCALL RecordThisThyratronFault
477:               	}
478:               	last_known_action = LAST_ACTION_POST_PULSE_PROC;
000B8A  2000B4     MOV #0xB, W4
000B8C  88BDE4     MOV W4, last_known_action
479:               	// The Pulse Interrupt sets this Flag - And this sequence runs only once
480:               	// Update all the pulse data
481:               	if (pulse_counter_this_run <= 0xFF00) {
000B8E  8041D5     MOV pulse_counter_this_run, W5
000B90  2FF004     MOV #0xFF00, W4
000B92  528F84     SUB W5, W4, [W15]
000B94  3E0003     BRA GTU, .L51, .LSM143
482:               	  pulse_counter_this_run++;
000B96  8041D4     MOV pulse_counter_this_run, W4
000B98  E80204     INC W4, W4
000B9A  8841D4     MOV W4, pulse_counter_this_run
483:               	}
484:               	pulse_counter_this_hv_on++;
000B9C  80BD84     MOV pulse_counter_this_hv_on, W4
000B9E  80BD95     MOV 0x17B2, W5
000BA0  420261     ADD W4, #0x1, W4
000BA2  4A82E0     ADDC W5, #0x0, W5
000BA4  88BD84     MOV W4, pulse_counter_this_hv_on
000BA6  88BD95     MOV W5, 0x17B2
485:               	pulse_counter_persistent++;
000BA8  2179E4     MOV #0x179E, W4
000BAA  BE0034     MOV.D [W4++], W0
000BAC  BE0124     MOV.D [W4--], W2
000BAE  200014     MOV #0x1, W4
000BB0  200005     MOV #0x0, W5
000BB2  B83360     MUL.UU W6, #0, W6
000BB4  420200     ADD W4, W0, W4
000BB6  4A8281     ADDC W5, W1, W5
000BB8  4B0302     ADDC W6, W2, W6
000BBA  4B8383     ADDC W7, W3, W7
000BBC  2179E0     MOV #0x179E, W0
000BBE  BE9804     MOV.D W4, [W0++]
000BC0  BE9006     MOV.D W6, [W0--]
486:               	prf_pulse_counter++;
000BC2  8042B4     MOV prf_pulse_counter, W4
000BC4  E80204     INC W4, W4
000BC6  8842B4     MOV W4, prf_pulse_counter
487:               
488:               	ReadIsolatedAdcToRam(); // Durring the pulse interrupt, the magnetron voltage and current was sampled.  Read back that data here
000BC8  070C20     RCALL ReadIsolatedAdcToRam
489:               	UpdatePulseData(a_b_selected_mode);      // Run filtering/error detection on pulse data
000BCA  2170A4     MOV #0x170A, W4
000BCC  784214     MOV.B [W4], W4
000BCE  784004     MOV.B W4, W0
000BD0  071C3E     RCALL UpdatePulseData
490:               	if (next_pulse_a_b_selected_mode != a_b_selected_mode) {
000BD2  2170B5     MOV #0x170B, W5
000BD4  784295     MOV.B [W5], W5
000BD6  2170A4     MOV #0x170A, W4
000BD8  784214     MOV.B [W4], W4
000BDA  52CF84     SUB.B W5, W4, [W15]
000BDC  32000A     BRA Z, .L52, .LSM152
491:               	  if (ps_hv_lambda_mode_A.v_command_set_point < 17500) {
000BDE  8049C5     MOV 0x938, W5
000BE0  2445B4     MOV #0x445B, W4
000BE2  528F84     SUB W5, W4, [W15]
000BE4  3E0003     BRA GTU, .L53, .LSM151
492:               	    operation_mode = MODE_ULTRA_LOW_DOSE_INTERLEAVED;
000BE6  210304     MOV #0x1030, W4
000BE8  88B864     MOV W4, operation_mode
000BEA  37001A     BRA .L54, .LSM159
493:               	  } else {
494:               	    operation_mode = MODE_PORTAL_GANTRY_INTERLEAVED;
000BEC  200304     MOV #0x30, W4
000BEE  88B864     MOV W4, operation_mode
000BF0  370017     BRA .L54, .LSM159
495:               	  }
496:               	} else {
497:               	  if (next_pulse_a_b_selected_mode == PULSE_MODE_A) {
000BF2  2170B4     MOV #0x170B, W4
000BF4  784214     MOV.B [W4], W4
000BF6  524FE0     SUB.B W4, #0x0, [W15]
000BF8  3A000A     BRA NZ, .L55, .LSM156
498:               	    if (ps_hv_lambda_mode_A.v_command_set_point < 17500) {
000BFA  8049C5     MOV 0x938, W5
000BFC  2445B4     MOV #0x445B, W4
000BFE  528F84     SUB W5, W4, [W15]
000C00  3E0003     BRA GTU, .L56, .LSM155
499:               	      operation_mode = MODE_ULTRA_LOW_DOSE_HIGH_ENERGY;
000C02  210404     MOV #0x1040, W4
000C04  88B864     MOV W4, operation_mode
000C06  37000C     BRA .L54, .LSM159
500:               	    } else {
501:               	      operation_mode = MODE_PORTAL_GANTRY_HIGH_ENERGY;
000C08  200404     MOV #0x40, W4
000C0A  88B864     MOV W4, operation_mode
000C0C  370009     BRA .L54, .LSM159
502:               	    }
503:               	  } else {
504:               	    if (ps_hv_lambda_mode_A.v_command_set_point < 17500) {
000C0E  8049C5     MOV 0x938, W5
000C10  2445B4     MOV #0x445B, W4
000C12  528F84     SUB W5, W4, [W15]
000C14  3E0003     BRA GTU, .L57, .LSM158
505:               	      operation_mode = MODE_ULTRA_LOW_DOSE_LOW_ENERGY;
000C16  210204     MOV #0x1020, W4
000C18  88B864     MOV W4, operation_mode
000C1A  370002     BRA .L54, .LSM159
506:               	    } else {
507:               	      operation_mode = MODE_PORTAL_GANTRY_LOW_ENERGY;
000C1C  200204     MOV #0x20, W4
000C1E  88B864     MOV W4, operation_mode
508:               	    }
509:               	  }
510:               	}
511:               
512:               
513:               	a_b_selected_mode = next_pulse_a_b_selected_mode;
000C20  2170B4     MOV #0x170B, W4
000C22  784214     MOV.B [W4], W4
000C24  780004     MOV W4, W0
000C26  B7F70A     MOV.B WREG, a_b_selected_mode
514:               	
515:               	// DPARKER impliment and test a current control PID LOOP
516:               	linac_low_energy_target_current_adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
000C28  20F080     MOV #0xF08, W0
000C2A  07273F     RCALL _AverageADC128
000C2C  780200     MOV W0, W4
000C2E  884164     MOV W4, linac_low_energy_target_current_adc_reading
517:               	linac_high_energy_target_current_adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
000C30  210080     MOV #0x1008, W0
000C32  07273B     RCALL _AverageADC128
000C34  780200     MOV W0, W4
000C36  884144     MOV W4, linac_high_energy_target_current_adc_reading
518:               	//linac_low_energy_target_current_adc_reading = RCFilter64Tau(linac_low_energy_target_current_adc_reading, AverageADC128(thyratron_cathode_heater_voltage_array));
519:               	//linac_high_energy_target_current_adc_reading = RCFilter64Tau(linac_high_energy_target_current_adc_reading, AverageADC128(thyratron_reservoir_heater_voltage_array));
520:               
521:               	if (pulse_counter_this_run < 30) {
000C38  8041D4     MOV pulse_counter_this_run, W4
000C3A  520FFD     SUB W4, #0x1D, [W15]
000C3C  3E0009     BRA GTU, .L58, .LSM166
522:               	  linac_low_energy_program_offset = 0;
000C3E  EB0200     CLR W4
000C40  8841B4     MOV W4, linac_low_energy_program_offset
523:               	  linac_high_energy_program_offset = 0;
000C42  EB0200     CLR W4
000C44  8841A4     MOV W4, linac_high_energy_program_offset
524:               	  fast_ratio_mode = 1;
000C46  B3C014     MOV.B #0x1, W4
000C48  FD0200     EXCH W0, W4
000C4A  B7E838     MOV.B WREG, fast_ratio_mode
000C4C  FD0200     EXCH W0, W4
000C4E  3700B1     BRA .L59, .LSM197
525:               	} else {
526:               	  // There have been enough pulses for the sample and hold to return valid readins.  Start to close the loop around the measured target current
527:               	  // DPARKER - write the algorythim to take linac_target_current_high_energy_mode and linac_high_energy_target_current_set_point
528:               	
529:               
530:               	  low_energy_target_current_startup_adjust = 0;
000C50  EB0200     CLR W4
000C52  884124     MOV W4, low_energy_target_current_startup_adjust
531:               #ifdef __STARTUP_TARGET_CURRENT_ADJUST
532:               	  if (pulse_counter_this_run < low_energy_target_current_startup_adjust_decay_time_pulses) {
000C54  8041D5     MOV pulse_counter_this_run, W5
000C56  80BCD4     MOV 0x179A, W4
000C58  528F84     SUB W5, W4, [W15]
000C5A  310023     BRA C, .L60, .LSM172
533:               	    temp_long = low_energy_target_current_startup_adjust_initital_value;
000C5C  804104     MOV low_energy_target_current_startup_adjust_initital_value, W4
000C5E  200005     MOV #0x0, W5
000C60  980734     MOV W4, [W14+6]
000C62  980745     MOV W5, [W14+8]
534:               	    temp_long *= (low_energy_target_current_startup_adjust_decay_time_pulses - pulse_counter_this_run);
000C64  80BCD5     MOV 0x179A, W5
000C66  8041D4     MOV pulse_counter_this_run, W4
000C68  528204     SUB W5, W4, W4
000C6A  200005     MOV #0x0, W5
000C6C  90034E     MOV [W14+8], W6
000C6E  B9B304     MUL.SS W6, W4, W6
000C70  780306     MOV W6, W6
000C72  9003BE     MOV [W14+6], W7
000C74  B9B805     MUL.SS W7, W5, W0
000C76  780380     MOV W0, W7
000C78  430307     ADD W6, W7, W6
000C7A  9003BE     MOV [W14+6], W7
000C7C  780204     MOV W4, W4
000C7E  B82207     MUL.UU W4, W7, W4
000C80  430305     ADD W6, W5, W6
000C82  780286     MOV W6, W5
000C84  980734     MOV W4, [W14+6]
000C86  980745     MOV W5, [W14+8]
000C88  980734     MOV W4, [W14+6]
000C8A  980745     MOV W5, [W14+8]
535:               	    temp_long /= low_energy_target_current_startup_adjust_decay_time_pulses;
000C8C  80BCD4     MOV 0x179A, W4
000C8E  200005     MOV #0x0, W5
000C90  BE0104     MOV.D W4, W2
000C92  90003E     MOV [W14+6], W0
000C94  9000CE     MOV [W14+8], W1
000C96  07FB52     RCALL ___udivsi3
000C98  BE0200     MOV.D W0, W4
000C9A  980734     MOV W4, [W14+6]
000C9C  980745     MOV W5, [W14+8]
536:               	    low_energy_target_current_startup_adjust = temp_long;
000C9E  90023E     MOV [W14+6], W4
000CA0  884124     MOV W4, low_energy_target_current_startup_adjust
537:               	  }
538:               #endif
539:               	  
540:               
541:                 
542:               #ifdef __RATIO_CONTROL_MODE    
543:               	  
544:               	  low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point;
545:               	  low_energy_target_current_set_point_derived *= linac_high_energy_target_current_adc_reading;
546:               	  low_energy_target_current_set_point_derived /= linac_high_energy_target_current_set_point;
547:               	  
548:               
549:               	  if (fast_ratio_mode) {
550:               	    if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
551:               	      linac_low_energy_program_offset -= 9*LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
552:               	    } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
553:               	      linac_low_energy_program_offset += 9*LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
554:               	    } else {
555:               	      fast_ratio_mode = 0;
556:               	    }
557:               	  } else {
558:               	    if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
559:               	      linac_low_energy_program_offset -= LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
560:               	    } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
561:               	      linac_low_energy_program_offset += LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
562:               	    }
563:               	  }
564:               #else
565:               		  
566:               	  if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
000CA2  801735     MOV PORTG, W5
000CA4  240004     MOV #0x4000, W4
000CA6  628204     AND W5, W4, W4
000CA8  520FE0     SUB W4, #0x0, [W15]
000CAA  3A0011     BRA NZ, .L61, .LSM176
567:               	    if (low_energy_target_current_startup_adjust_direction_positive) {
000CAC  804114     MOV low_energy_target_current_startup_adjust_direction_positive, W4
000CAE  520FE0     SUB W4, #0x0, [W15]
000CB0  320007     BRA Z, .L62, .LSM175
568:               	      low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point + low_energy_target_current_startup_adjust;
000CB2  804175     MOV linac_low_energy_target_current_set_point, W5
000CB4  804124     MOV low_energy_target_current_startup_adjust, W4
000CB6  428204     ADD W5, W4, W4
000CB8  200005     MOV #0x0, W5
000CBA  8840C4     MOV W4, low_energy_target_current_set_point_derived
000CBC  8840D5     MOV W5, .LSM11
000CBE  370031     BRA .L63, .LSM181
569:               	    } else {
570:               	      low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point - low_energy_target_current_startup_adjust;
000CC0  804175     MOV linac_low_energy_target_current_set_point, W5
000CC2  804124     MOV low_energy_target_current_startup_adjust, W4
000CC4  528204     SUB W5, W4, W4
000CC6  200005     MOV #0x0, W5
000CC8  8840C4     MOV W4, low_energy_target_current_set_point_derived
000CCA  8840D5     MOV W5, .LSM11
000CCC  37002A     BRA .L63, .LSM181
571:               	    }
572:               	  } else {
573:               	    if (low_energy_target_current_startup_adjust_direction_positive) {
000CCE  804114     MOV low_energy_target_current_startup_adjust_direction_positive, W4
000CD0  520FE0     SUB W4, #0x0, [W15]
000CD2  320007     BRA Z, .L64, .LSM178
574:               	      low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point + low_energy_target_current_startup_adjust;
000CD4  804175     MOV linac_low_energy_target_current_set_point, W5
000CD6  804124     MOV low_energy_target_current_startup_adjust, W4
000CD8  428204     ADD W5, W4, W4
000CDA  200005     MOV #0x0, W5
000CDC  8840C4     MOV W4, low_energy_target_current_set_point_derived
000CDE  8840D5     MOV W5, .LSM11
000CE0  370006     BRA .L65, .LSM179
575:               	    } else {
576:               	      low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point - low_energy_target_current_startup_adjust;
000CE2  804175     MOV linac_low_energy_target_current_set_point, W5
000CE4  804124     MOV low_energy_target_current_startup_adjust, W4
000CE6  528204     SUB W5, W4, W4
000CE8  200005     MOV #0x0, W5
000CEA  8840C4     MOV W4, low_energy_target_current_set_point_derived
000CEC  8840D5     MOV W5, .LSM11
577:               	    }	    
578:               	    low_energy_target_current_set_point_derived *= pac_2_adc_reading;
000CEE  8042E4     MOV pac_2_adc_reading, W4
000CF0  B82361     MUL.UU W4, #1, W6
000CF2  8040C4     MOV low_energy_target_current_set_point_derived, W4
000CF4  8040D5     MOV .LSM11, W5
000CF6  B9B804     MUL.SS W7, W4, W0
000CF8  780000     MOV W0, W0
000CFA  B9A906     MUL.SS W5, W6, W2
000CFC  780082     MOV W2, W1
000CFE  400001     ADD W0, W1, W0
000D00  780306     MOV W6, W6
000D02  780204     MOV W4, W4
000D04  B83204     MUL.UU W6, W4, W4
000D06  400005     ADD W0, W5, W0
000D08  780280     MOV W0, W5
000D0A  8840C4     MOV W4, low_energy_target_current_set_point_derived
000D0C  8840D5     MOV W5, .LSM11
579:               	    low_energy_target_current_set_point_derived /= default_pac_2_adc_reading;
000D0E  8040C6     MOV low_energy_target_current_set_point_derived, W6
000D10  8040D7     MOV .LSM11, W7
000D12  8040F4     MOV default_pac_2_adc_reading, W4
000D14  200005     MOV #0x0, W5
000D16  BE0104     MOV.D W4, W2
000D18  BE0006     MOV.D W6, W0
000D1A  07FB10     RCALL ___udivsi3
000D1C  BE0200     MOV.D W0, W4
000D1E  8840C4     MOV W4, low_energy_target_current_set_point_derived
000D20  8840D5     MOV W5, .LSM11
580:               	  }
581:               	  
582:               	  if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
000D22  804164     MOV linac_low_energy_target_current_adc_reading, W4
000D24  B82361     MUL.UU W4, #1, W6
000D26  8040C4     MOV low_energy_target_current_set_point_derived, W4
000D28  8040D5     MOV .LSM11, W5
000D2A  B00324     ADD #0x32, W4
000D2C  B08005     ADDC #0x0, W5
000D2E  530F84     SUB W6, W4, [W15]
000D30  5B8F85     SUBB W7, W5, [W15]
000D32  390004     BRA NC, .L66, .LSM183
583:               	    linac_low_energy_program_offset -= LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
000D34  8041B4     MOV linac_low_energy_program_offset, W4
000D36  E90204     DEC W4, W4
000D38  8841B4     MOV W4, linac_low_energy_program_offset
000D3A  37000E     BRA .L67, .LSM185
584:               	  } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
000D3C  804164     MOV linac_low_energy_target_current_adc_reading, W4
000D3E  B82361     MUL.UU W4, #1, W6
000D40  8040C0     MOV low_energy_target_current_set_point_derived, W0
000D42  8040D1     MOV .LSM11, W1
000D44  2FFCE4     MOV #0xFFCE, W4
000D46  2FFFF5     MOV #0xFFFF, W5
000D48  420200     ADD W4, W0, W4
000D4A  4A8281     ADDC W5, W1, W5
000D4C  530F84     SUB W6, W4, [W15]
000D4E  5B8F85     SUBB W7, W5, [W15]
000D50  3E0003     BRA GTU, .L67, .LSM185
585:               	    linac_low_energy_program_offset += LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
000D52  8041B4     MOV linac_low_energy_program_offset, W4
000D54  E80204     INC W4, W4
000D56  8841B4     MOV W4, linac_low_energy_program_offset
586:               	  }
587:               
588:               	  if (linac_high_energy_target_current_adc_reading > (linac_high_energy_target_current_set_point + LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR)) {
000D58  804154     MOV linac_high_energy_target_current_set_point, W4
000D5A  200325     MOV #0x32, W5
000D5C  428284     ADD W5, W4, W5
000D5E  804144     MOV linac_high_energy_target_current_adc_reading, W4
000D60  528F84     SUB W5, W4, [W15]
000D62  310004     BRA C, .L68, .LSM187
589:               	    linac_high_energy_program_offset -= LINAC_TARGET_CURRENT_HIGH_ENERGY_STEP_SIZE;
000D64  8041A4     MOV linac_high_energy_program_offset, W4
000D66  520263     SUB W4, #0x3, W4
000D68  8841A4     MOV W4, linac_high_energy_program_offset
000D6A  370009     BRA .L69, .LSM189
590:               	  } else if (linac_high_energy_target_current_adc_reading < (linac_high_energy_target_current_set_point - LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR)) {
000D6C  804154     MOV linac_high_energy_target_current_set_point, W4
000D6E  2FFCE5     MOV #0xFFCE, W5
000D70  428284     ADD W5, W4, W5
000D72  804144     MOV linac_high_energy_target_current_adc_reading, W4
000D74  528F84     SUB W5, W4, [W15]
000D76  360003     BRA LEU, .L69, .LSM189
591:               	    linac_high_energy_program_offset += LINAC_TARGET_CURRENT_HIGH_ENERGY_STEP_SIZE;
000D78  8041A4     MOV linac_high_energy_program_offset, W4
000D7A  420263     ADD W4, #0x3, W4
000D7C  8841A4     MOV W4, linac_high_energy_program_offset
592:               	  }
593:               	  
594:               #endif
595:               	  
596:               	  if (linac_low_energy_program_offset > LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET) {
000D7E  8041B5     MOV linac_low_energy_program_offset, W5
000D80  206404     MOV #0x640, W4
000D82  528F84     SUB W5, W4, [W15]
000D84  340003     BRA LE, .L70, .LSM191
597:               	    linac_low_energy_program_offset = LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET;
000D86  206404     MOV #0x640, W4
000D88  8841B4     MOV W4, linac_low_energy_program_offset
000D8A  370006     BRA .L71, .LSM193
598:               	  } else if (linac_low_energy_program_offset < -LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET) {
000D8C  8041B5     MOV linac_low_energy_program_offset, W5
000D8E  2F9C04     MOV #0xF9C0, W4
000D90  528F84     SUB W5, W4, [W15]
000D92  3D0002     BRA GE, .L71, .LSM193
599:               	    linac_low_energy_program_offset = -LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET;
000D94  2F9C04     MOV #0xF9C0, W4
000D96  8841B4     MOV W4, linac_low_energy_program_offset
600:               	  }
601:               
602:               	  if (linac_high_energy_program_offset > LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET) {
000D98  8041A5     MOV linac_high_energy_program_offset, W5
000D9A  202584     MOV #0x258, W4
000D9C  528F84     SUB W5, W4, [W15]
000D9E  340003     BRA LE, .L72, .LSM195
603:               	    linac_high_energy_program_offset = LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET;
000DA0  202584     MOV #0x258, W4
000DA2  8841A4     MOV W4, linac_high_energy_program_offset
000DA4  370006     BRA .L59, .LSM197
604:               	  } else if (linac_high_energy_program_offset < -LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET) {
000DA6  8041A5     MOV linac_high_energy_program_offset, W5
000DA8  2FDA84     MOV #0xFDA8, W4
000DAA  528F84     SUB W5, W4, [W15]
000DAC  3D0002     BRA GE, .L59, .LSM197
605:               	    linac_high_energy_program_offset = -LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET;
000DAE  2FDA84     MOV #0xFDA8, W4
000DB0  8841A4     MOV W4, linac_high_energy_program_offset
606:               	  }
607:               	  	  
608:               	} 
609:               	
610:               #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
611:               	
612:               	vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
000DB2  8042D4     MOV pac_1_adc_reading, W4
000DB4  20C351     MOV #0xC35, W1
000DB6  780004     MOV W4, W0
000DB8  070EDA     RCALL Scale16Bit
000DBA  780200     MOV W0, W4
000DBC  980724     MOV W4, [W14+4]
613:               	if (linac_high_energy_target_current_set_point >= 1000) {
000DBE  804155     MOV linac_high_energy_target_current_set_point, W5
000DC0  203E74     MOV #0x3E7, W4
000DC2  528F84     SUB W5, W4, [W15]
000DC4  360004     BRA LEU, .L73, .LSM200
614:               	  vtemp += linac_high_energy_program_offset;
000DC6  8041A4     MOV linac_high_energy_program_offset, W4
000DC8  9002AE     MOV [W14+4], W5
000DCA  428204     ADD W5, W4, W4
000DCC  980724     MOV W4, [W14+4]
615:               	}
616:               	SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp , 0);
000DCE  EB0100     CLR W2
000DD0  9000AE     MOV [W14+4], W1
000DD2  209360     MOV #0x936, W0
000DD4  070695     RCALL SetPowerSupplyTarget
617:               	
618:               	vtemp = Scale16Bit(default_pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
000DD6  8040F4     MOV default_pac_2_adc_reading, W4
000DD8  20C351     MOV #0xC35, W1
000DDA  780004     MOV W4, W0
000DDC  070EC8     RCALL Scale16Bit
000DDE  780200     MOV W0, W4
000DE0  980724     MOV W4, [W14+4]
619:               	if (linac_low_energy_target_current_set_point >= 1000) {
000DE2  804175     MOV linac_low_energy_target_current_set_point, W5
000DE4  203E74     MOV #0x3E7, W4
000DE6  528F84     SUB W5, W4, [W15]
000DE8  360004     BRA LEU, .L74, .LSM204
620:               	  vtemp += linac_low_energy_program_offset;
000DEA  8041B4     MOV linac_low_energy_program_offset, W4
000DEC  9002AE     MOV [W14+4], W5
000DEE  428204     ADD W5, W4, W4
000DF0  980724     MOV W4, [W14+4]
621:               	}
622:               	SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
000DF2  EB0100     CLR W2
000DF4  9000AE     MOV [W14+4], W1
000DF6  209EA0     MOV #0x9EA, W0
000DF8  070683     RCALL SetPowerSupplyTarget
623:               	
624:               #endif
625:               
626:               
627:               
628:               	
629:               	
630:               	UpdateDacAll();                          // We want to Execute DAC update after a pulse so that a pulse does not corrupt the SPI data
000DFA  0707FE     RCALL UpdateDacAll
631:               	//UpdateIOExpanderOutputs();               // DPAKRER is this needed here?  The io expander outputs should never change in state HV on!!!!
632:               	
633:               	// Set up the 100ms Timer that will roll if there is not another pulse in the next 100mS
634:               	TMR2 = 0;
000DFC  EB0200     CLR W4
000DFE  880834     MOV W4, TMR2
635:               	_T2IF = 0;          
000E00  A9C084     BCLR IFS0, #6
636:               	global_run_post_pulse_process = 0;	
000E02  EB4200     CLR.B W4
000E04  FD0200     EXCH W0, W4
000E06  B7F708     MOV.B WREG, global_run_post_pulse_process
000E08  FD0200     EXCH W0, W4
637:               	//SendLoggingDataToUart();
638:                     }
639:                     
640:                     // DPARKER need to write new timing diagram - should be simplier
641:                     
642:                     if (CheckFaultActive()) {
000E0A  071D78     RCALL CheckFaultActive
000E0C  780200     MOV W0, W4
000E0E  520FE0     SUB W4, #0x0, [W15]
000E10  320006     BRA Z, .L75, .LSM212
643:               	ExitHvOnState();
000E12  070D12     RCALL ExitHvOnState
644:               	control_state = STATE_FAULT_WARM_FAULT;
000E14  B3CA84     MOV.B #0xA8, W4
000E16  FD0200     EXCH W0, W4
000E18  B7E858     MOV.B WREG, control_state
000E1A  FD0200     EXCH W0, W4
000E1C  370015     BRA .L45, .LSM218
645:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000E1E  801615     MOV PORTA, W5
000E20  240004     MOV #0x4000, W4
000E22  628204     AND W5, W4, W4
000E24  520FE0     SUB W4, #0x0, [W15]
000E26  320006     BRA Z, .L76, .LSM215
646:               	ExitHvOnState();
000E28  070D07     RCALL ExitHvOnState
647:               	control_state = STATE_SYSTEM_COLD_READY;
000E2A  B3C144     MOV.B #0x14, W4
000E2C  FD0200     EXCH W0, W4
000E2E  B7E858     MOV.B WREG, control_state
000E30  FD0200     EXCH W0, W4
000E32  37000A     BRA .L45, .LSM218
648:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == !ILL_MODULATOR_HV_ON) {
000E34  801615     MOV PORTA, W5
000E36  280004     MOV #0x8000, W4
000E38  628204     AND W5, W4, W4
000E3A  520FE0     SUB W4, #0x0, [W15]
000E3C  320005     BRA Z, .L45, .LSM218
649:               	ExitHvOnState();
000E3E  070CFC     RCALL ExitHvOnState
650:               	control_state = STATE_SYSTEM_WARM_READY;
000E40  B3C344     MOV.B #0x34, W4
000E42  FD0200     EXCH W0, W4
000E44  B7E858     MOV.B WREG, control_state
000E46  FD0200     EXCH W0, W4
651:                     }
652:                   }
653:                   break;
000E52  37003E     BRA .L1, .LSM245
654:                   
655:                 case STATE_FAULT_COLD_FAULT:
656:                   DoColdShutDown();
000E54  070D33     RCALL DoColdShutDown
657:                   // SaveDataToEEPROM(); DPARKER use better functions
658:                   while (control_state == STATE_FAULT_COLD_FAULT) {
000E56  37000A     BRA .L78, .LSM226
000E6C  208585     MOV #0x858, W5
000E6E  784295     MOV.B [W5], W5
000E70  B3CA44     MOV.B #0xA4, W4
000E72  52CF84     SUB.B W5, W4, [W15]
000E74  32FFF1     BRA Z, .L79, .LSM222
659:                     Do10msTicToc();
000E58  07080B     RCALL Do10msTicToc
660:                     DoSerialCommand();
000E5A  071269     RCALL DoSerialCommand
661:                     if (CheckFaultActive() == 0) {
000E5C  071D4F     RCALL CheckFaultActive
000E5E  780200     MOV W0, W4
000E60  520FE0     SUB W4, #0x0, [W15]
000E62  3A0004     BRA NZ, .L78, .LSM226
662:               	control_state = STATE_SYSTEM_COLD_READY;
000E64  B3C144     MOV.B #0x14, W4
000E66  FD0200     EXCH W0, W4
000E68  B7E858     MOV.B WREG, control_state
000E6A  FD0200     EXCH W0, W4
663:                     }
664:                   }
665:                   break;
000E76  37002C     BRA .L1, .LSM245
666:                   
667:                 case STATE_FAULT_WARM_FAULT:
668:                   DoWarmShutDown();
000E78  070D49     RCALL DoWarmShutDown
669:                   // DPARKER SaveDataToEEPROM();
670:                   while (control_state == STATE_FAULT_WARM_FAULT) {
000E7A  37001D     BRA .L80, .LSM238
000EB6  208585     MOV #0x858, W5
000EB8  784295     MOV.B [W5], W5
000EBA  B3CA84     MOV.B #0xA8, W4
000EBC  52CF84     SUB.B W5, W4, [W15]
000EBE  32FFDE     BRA Z, .L83, .LSM230
671:                     Do10msTicToc();
000E7C  0707F9     RCALL Do10msTicToc
672:                     DoSerialCommand();
000E7E  071257     RCALL DoSerialCommand
673:                     if (CheckColdFaultActive()) {
000E80  071D51     RCALL CheckColdFaultActive
000E82  780200     MOV W0, W4
000E84  520FE0     SUB W4, #0x0, [W15]
000E86  320005     BRA Z, .L81, .LSM234
674:               	control_state = STATE_FAULT_COLD_FAULT;
000E88  B3CA44     MOV.B #0xA4, W4
000E8A  FD0200     EXCH W0, W4
000E8C  B7E858     MOV.B WREG, control_state
000E8E  FD0200     EXCH W0, W4
000E90  370012     BRA .L80, .LSM238
675:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000E92  801615     MOV PORTA, W5
000E94  240004     MOV #0x4000, W4
000E96  628204     AND W5, W4, W4
000E98  520FE0     SUB W4, #0x0, [W15]
000E9A  320005     BRA Z, .L82, .LSM236
676:               	control_state = STATE_FAULT_COLD_FAULT;
000E9C  B3CA44     MOV.B #0xA4, W4
000E9E  FD0200     EXCH W0, W4
000EA0  B7E858     MOV.B WREG, control_state
000EA2  FD0200     EXCH W0, W4
000EA4  370008     BRA .L80, .LSM238
677:                     } else if (CheckFaultActive() == 0) {
000EA6  071D2A     RCALL CheckFaultActive
000EA8  780200     MOV W0, W4
000EAA  520FE0     SUB W4, #0x0, [W15]
000EAC  3A0004     BRA NZ, .L80, .LSM238
678:               	control_state = STATE_SYSTEM_WARM_READY;
000EAE  B3C344     MOV.B #0x34, W4
000EB0  FD0200     EXCH W0, W4
000EB2  B7E858     MOV.B WREG, control_state
000EB4  FD0200     EXCH W0, W4
679:                     }
680:                   }
681:                   break;
000EC0  370007     BRA .L1, .LSM245
682:                   
683:                 case STATE_FAULT_MCU_CORE_FAULT:
684:                   // DPARKER DO SOMETHING!!!!!!
685:                   // Maybe flash some LEDs, go home
686:                   // your're fracked.  Just hang out here till you get reset
687:                   while (1) {
688:                     Do10msTicToc();
000EC2  0707D6     RCALL Do10msTicToc
689:                     DoSerialCommand();
000EC4  071234     RCALL DoSerialCommand
690:                   }
000EC6  37FFFD     BRA .L10, .LSM240
691:                   break;
692:               
693:                 default:
694:                   // DPARKER throw an ERROR
695:                   control_state = STATE_FAULT_MCU_CORE_FAULT;
000EC8  B3CA04     MOV.B #0xA0, W4
000ECA  780004     MOV W4, W0
000ECC  B7E858     MOV.B WREG, control_state
696:                   break;
000ECE  000000     NOP
697:                 }
698:               }
000ED0  FA8000     ULNK
000ED2  060000     RETURN
699:               
700:               void DoA34760StartUpCommon(void) {
000ED4  FA0044     LNK #0x44
000ED6  781F88     MOV W8, [W15++]
701:                 unsigned int *unsigned_int_ptr;  
702:                 unsigned int eeprom_data[16];
703:                 unsigned int eeprom_write[16];
704:                 unsigned int read_attempt;
705:                 prf_mult = 1;
000ED8  200014     MOV #0x1, W4
000EDA  88BDA4     MOV W4, .LSM673
706:                 prf_divider = 1;
000EDC  200014     MOV #0x1, W4
000EDE  88BDB4     MOV W4, .LSM674
707:                 
708:                 // This is debugging info info  If the processor reset, a code that indicates the last major point that the processor entered should be held in RAM at last_known_action
709:                 previous_last_action = last_known_action;
000EE0  80BDE4     MOV last_known_action, W4
000EE2  884234     MOV W4, previous_last_action
710:                 last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
000EE4  EB0200     CLR W4
000EE6  88BDE4     MOV W4, last_known_action
711:               
712:                 eeprom_write_failure_count = 0;
000EE8  EB0200     CLR W4
000EEA  884084     MOV W4, eeprom_write_failure_count
713:                 eeprom_read_failure_count = 0;
000EEC  EB0200     CLR W4
000EEE  8840A4     MOV W4, eeprom_read_failure_count
714:                 
715:                 // Figure out why the processor restarted and save to the debug status register
716:                 debug_status_register = 0;
000EF0  EB0200     CLR W4
000EF2  88B9F4     MOV W4, debug_status_register
717:                 if (_POR) {
000EF4  803A04     MOV RCON, W4
000EF6  620261     AND W4, #0x1, W4
000EF8  520FE0     SUB W4, #0x0, [W15]
000EFA  320003     BRA Z, .L85, .LSM256
718:                   debug_status_register |= STATUS_POR_RESET;
000EFC  80B9F4     MOV debug_status_register, W4
000EFE  A04004     BSET W4, #4
000F00  88B9F4     MOV W4, debug_status_register
719:                   // _POR = 0;
720:                 }
721:                 if (_EXTR) {
000F02  803A05     MOV RCON, W5
000F04  200804     MOV #0x80, W4
000F06  628204     AND W5, W4, W4
000F08  520FE0     SUB W4, #0x0, [W15]
000F0A  320004     BRA Z, .L86, .LSM258
722:                   debug_status_register |= STATUS_EXTERNAL_RESET;
000F0C  80B9F5     MOV debug_status_register, W5
000F0E  200204     MOV #0x20, W4
000F10  720205     IOR W4, W5, W4
000F12  88B9F4     MOV W4, debug_status_register
723:                   //_EXTR = 0;
724:                 }
725:                 if (_SWR) {
000F14  803A05     MOV RCON, W5
000F16  200404     MOV #0x40, W4
000F18  628204     AND W5, W4, W4
000F1A  520FE0     SUB W4, #0x0, [W15]
000F1C  320004     BRA Z, .L87, .LSM260
726:                   debug_status_register |= STATUS_SOFTARE_RESET;
000F1E  80B9F5     MOV debug_status_register, W5
000F20  200404     MOV #0x40, W4
000F22  720205     IOR W4, W5, W4
000F24  88B9F4     MOV W4, debug_status_register
727:                   //_SWR = 0;
728:                 }
729:                 if (_BOR) {
000F26  803A04     MOV RCON, W4
000F28  620262     AND W4, #0x2, W4
000F2A  520FE0     SUB W4, #0x0, [W15]
000F2C  320003     BRA Z, .L88, .LSM262
730:                   debug_status_register |= STATUS_BOR_RESET;
000F2E  80B9F4     MOV debug_status_register, W4
000F30  A00004     BSET W4, #0
000F32  88B9F4     MOV W4, debug_status_register
731:                   //_BOR = 0;
732:                 }
733:                 if (_TRAPR) {
000F34  803A05     MOV RCON, W5
000F36  280004     MOV #0x8000, W4
000F38  628204     AND W5, W4, W4
000F3A  520FE0     SUB W4, #0x0, [W15]
000F3C  320003     BRA Z, .L89, .LSM264
734:                   debug_status_register |= STATUS_TRAPR_RESET;
000F3E  80B9F4     MOV debug_status_register, W4
000F40  A01004     BSET W4, #1
000F42  88B9F4     MOV W4, debug_status_register
735:                   //_TRAPR = 0;
736:                 }
737:                 if (_WDTO) {
000F44  803A04     MOV RCON, W4
000F46  620270     AND W4, #0x10, W4
000F48  520FE0     SUB W4, #0x0, [W15]
000F4A  320003     BRA Z, .L90, .LSM266
738:                   debug_status_register |= STATUS_WDT_RESET;
000F4C  80B9F4     MOV debug_status_register, W4
000F4E  A02004     BSET W4, #2
000F50  88B9F4     MOV W4, debug_status_register
739:                   // _WDTO = 0;
740:                 }
741:                 if (_IOPUWR) {
000F52  803A05     MOV RCON, W5
000F54  240004     MOV #0x4000, W4
000F56  628204     AND W5, W4, W4
000F58  520FE0     SUB W4, #0x0, [W15]
000F5A  320003     BRA Z, .L91, .LSM268
742:                   debug_status_register |= STATUS_IOPUWR_RESET;
000F5C  80B9F4     MOV debug_status_register, W4
000F5E  A03004     BSET W4, #3
000F60  88B9F4     MOV W4, debug_status_register
743:                   //_IOPUWR = 0;
744:                 }
745:               
746:                 
747:                 // Debug Counter Initializations
748:                 global_debug_counter.magnetron_current_adc_glitch = 0;
000F62  EB0200     CLR W4
000F64  88B944     MOV W4, global_debug_counter
749:                 global_debug_counter.magnetron_voltage_adc_glitch = 0;
000F66  EB0200     CLR W4
000F68  88B954     MOV W4, .LSM628
750:                 global_debug_counter.i2c_bus_error = 0;
000F6A  EB0200     CLR W4
000F6C  88B964     MOV W4, .LSM629
751:                 global_debug_counter.spi1_bus_error = 0;
000F6E  EB0200     CLR W4
000F70  88B974     MOV W4, .LSM630
752:                 global_debug_counter.spi2_bus_error = 0;
000F72  EB0200     CLR W4
000F74  88B984     MOV W4, .LSM631
753:                 global_debug_counter.external_adc_false_trigger = 0;
000F76  EB0200     CLR W4
000F78  88B994     MOV W4, .LSM632
754:                 global_debug_counter.LTC2656_write_error = 0;
000F7A  EB0200     CLR W4
000F7C  88B9A4     MOV W4, .LSM633
755:                 global_debug_counter.setpoint_not_valid = 0;
000F7E  EB0200     CLR W4
000F80  88B9B4     MOV W4, .LSM634
756:                 global_debug_counter.scale16bit_saturation = 0;
000F82  EB0200     CLR W4
000F84  88B9C4     MOV W4, .LSM635
757:                 global_debug_counter.reversescale16bit_saturation = 0;
000F86  EB0200     CLR W4
000F88  88B9D4     MOV W4, .LSM636
758:               
759:               
760:                 linac_high_energy_target_current_set_point = 0;//control_loop_cal_data_ram_copy[EEPROM_CNTRL_HIGH_ENERGY_TARGET];
000F8A  EB0200     CLR W4
000F8C  884154     MOV W4, linac_high_energy_target_current_set_point
761:               
762:                 
763:                 linac_low_energy_target_current_set_point_gantry_mode = 0;//control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_GANTRY_TARGET];
000F8E  EB0200     CLR W4
000F90  884194     MOV W4, linac_low_energy_target_current_set_point_gantry_mode
764:                 linac_low_energy_target_current_set_point_portal_mode = 0;//control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_PORTAL_TARGET];
000F92  EB0200     CLR W4
000F94  884184     MOV W4, linac_low_energy_target_current_set_point_portal_mode
765:                 low_energy_target_current_startup_adjust_decay_time_pulses =  0;//control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_STARTUP_PULSES];
000F96  EB0200     CLR W4
000F98  88BCD4     MOV W4, 0x179A
766:                 max_low_energy_target_current_startup_adjust_initital_value = 0;//control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_MAX_MAGNITUDE];
000F9A  EB0200     CLR W4
000F9C  88BCB4     MOV W4, 0x1796
767:                 low_energy_target_current_startup_max_cooldown = 0;//control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_MAX_COOLDOWN];
000F9E  EB0200     CLR W4
000FA0  88BCC4     MOV W4, 0x1798
768:               
769:               
770:                 read_attempt = 0;
000FA2  EB0200     CLR W4
000FA4  780F04     MOV W4, [W14]
771:                 while (ETMEEPromReadPage(PAGE_0_SETTINGS, eeprom_data) == 0) {
000FA6  370025     BRA .L92, .LSM303
000FF2  470264     ADD W14, #0x4, W4
000FF4  780084     MOV W4, W1
000FF6  EB0000     CLR W0
000FF8  071D4A     RCALL ETMEEPromReadPage
000FFA  780200     MOV W0, W4
000FFC  520FE0     SUB W4, #0x0, [W15]
000FFE  32FFD4     BRA Z, .L95, .LSM286
772:                   read_attempt++;
000FA8  E80F1E     INC [W14], [W14]
773:                   ClrWdt();
000FAA  FE6000     CLRWDT
774:                   eeprom_read_failure_count++;
000FAC  8040A4     MOV eeprom_read_failure_count, W4
000FAE  E80204     INC W4, W4
000FB0  8840A4     MOV W4, eeprom_read_failure_count
775:                   if (read_attempt > 10) {
000FB2  78021E     MOV [W14], W4
000FB4  520FEA     SUB W4, #0xA, [W15]
000FB6  36000F     BRA LEU, .L93, .LSM296
776:                     // There was a problem reading from the EEPROM
777:                     // Write the default calibration data
778:                     eeprom_write[0] = 850;
000FB8  203524     MOV #0x352, W4
000FBA  981724     MOV W4, [W14+36]
779:                     eeprom_write[1] = 750;
000FBC  202EE4     MOV #0x2EE, W4
000FBE  981734     MOV W4, [W14+38]
780:                     eeprom_write[2] = 0x7FFF;
000FC0  27FFF4     MOV #0x7FFF, W4
000FC2  981744     MOV W4, [W14+40]
781:                     eeprom_write[3] = 0x7FFF;
000FC4  27FFF4     MOV #0x7FFF, W4
000FC6  981754     MOV W4, [W14+42]
782:                     eeprom_write[4] = 10600;
000FC8  229684     MOV #0x2968, W4
000FCA  981764     MOV W4, [W14+44]
783:                     ETMEEPromWritePage(PAGE_0_SETTINGS,eeprom_write);
000FCC  200244     MOV #0x24, W4
000FCE  42020E     ADD W4, W14, W4
000FD0  780084     MOV W4, W1
000FD2  EB0000     CLR W0
000FD4  071D77     RCALL ETMEEPromWritePage
784:                   }
785:                   if (read_attempt > 15) {
000FD6  78021E     MOV [W14], W4
000FD8  520FEF     SUB W4, #0xF, [W15]
000FDA  36000B     BRA LEU, .L92, .LSM303
786:                     // The EEPROM is not working, signal a massive fault
787:                     // DPARKER HOW TO SIGNAL THIS FAULT???
788:                     eeprom_data[0] = 950;
000FDC  203B64     MOV #0x3B6, W4
000FDE  980724     MOV W4, [W14+4]
789:                     eeprom_data[1] = 750;
000FE0  202EE4     MOV #0x2EE, W4
000FE2  980734     MOV W4, [W14+6]
790:                     eeprom_data[2] = 0x7FFF;
000FE4  27FFF4     MOV #0x7FFF, W4
000FE6  980744     MOV W4, [W14+8]
791:                     eeprom_data[3] = 0x7FFF;
000FE8  27FFF4     MOV #0x7FFF, W4
000FEA  980754     MOV W4, [W14+10]
792:                     eeprom_data[4] = 10600;
000FEC  229684     MOV #0x2968, W4
000FEE  980764     MOV W4, [W14+12]
793:                     break;
000FF0  370007     BRA .L94, .LSM304
794:                   }
795:                 }
796:               
797:                 read_attempt = 0;
001000  EB0200     CLR W4
001002  780F04     MOV W4, [W14]
798:                 while (ETMEEPromWritePageWithConfirmation(PAGE_0_SETTINGS, eeprom_data) == 0) {
001004  370007     BRA .L96, .LSM309
001014  470264     ADD W14, #0x4, W4
001016  780084     MOV W4, W1
001018  EB0000     CLR W0
00101A  071DD2     RCALL ETMEEPromWritePageWithConfirmation
00101C  780200     MOV W0, W4
00101E  520FE0     SUB W4, #0x0, [W15]
001020  32FFF2     BRA Z, .L98, .LSM306
001022  370001     BRA .L97, .LSM311
799:                   read_attempt++;
001006  E80F1E     INC [W14], [W14]
800:                   eeprom_read_failure_count++;
001008  8040A4     MOV eeprom_read_failure_count, W4
00100A  E80204     INC W4, W4
00100C  8840A4     MOV W4, eeprom_read_failure_count
801:                   if (read_attempt >= 10) {
00100E  78021E     MOV [W14], W4
001010  520FE9     SUB W4, #0x9, [W15]
001012  3E0008     BRA GTU, .L103, .LSM310
802:                     break;
001024  000000     NOP
803:                   }
804:                 }
805:               
806:                 
807:                 magnet_scaling_linear_factor   = eeprom_data[0];
001026  90022E     MOV [W14+4], W4
001028  884064     MOV W4, magnet_scaling_linear_factor
808:                 magnet_scaling_constant_factor = eeprom_data[1];
00102A  90023E     MOV [W14+6], W4
00102C  884074     MOV W4, magnet_scaling_constant_factor
809:                 scale_interleaved              = eeprom_data[2];
00102E  90024E     MOV [W14+8], W4
001030  88B874     MOV W4, scale_interleaved
810:                 scale_low_energy               = eeprom_data[3];
001032  90025E     MOV [W14+10], W4
001034  88B884     MOV W4, scale_low_energy
811:                 filament_iprog                 = eeprom_data[4];
001036  90026E     MOV [W14+12], W4
001038  884094     MOV W4, filament_iprog
812:               
813:               
814:               
815:               
816:                 read_attempt = 0;
00103A  EB0200     CLR W4
00103C  780F04     MOV W4, [W14]
817:                 while (ETMEEPromReadPage(PAGE_1_PULSE_COUNTERS, eeprom_data) == 0) {
00103E  370045     BRA .L99, .LSM353
0010CA  470264     ADD W14, #0x4, W4
0010CC  780084     MOV W4, W1
0010CE  200010     MOV #0x1, W0
0010D0  071CDE     RCALL ETMEEPromReadPage
0010D2  780200     MOV W0, W4
0010D4  520FE0     SUB W4, #0x0, [W15]
0010D6  32FFB4     BRA Z, .L102, .LSM318
818:                   ClrWdt();
001040  FE6000     CLRWDT
819:                   read_attempt++;
001042  E80F1E     INC [W14], [W14]
820:                   if (read_attempt > 10) {
001044  78021E     MOV [W14], W4
001046  520FEA     SUB W4, #0xA, [W15]
001048  36001E     BRA LEU, .L100, .LSM336
821:                     // There was a problem reading from the EEPROM
822:                     // Write the default calibration data
823:                     eeprom_write[0] = 0;
00104A  EB0200     CLR W4
00104C  981724     MOV W4, [W14+36]
824:                     eeprom_write[1] = 0;
00104E  EB0200     CLR W4
001050  981734     MOV W4, [W14+38]
825:                     eeprom_write[2] = 0;
001052  EB0200     CLR W4
001054  981744     MOV W4, [W14+40]
826:                     eeprom_write[3] = 0;
001056  EB0200     CLR W4
001058  981754     MOV W4, [W14+42]
827:                     eeprom_write[4] = 0;
00105A  EB0200     CLR W4
00105C  981764     MOV W4, [W14+44]
828:                     eeprom_write[5] = 0;
00105E  EB0200     CLR W4
001060  981774     MOV W4, [W14+46]
829:                     eeprom_write[6] = 0;
001062  EB0200     CLR W4
001064  981F04     MOV W4, [W14+48]
830:                     eeprom_write[7] = 0;
001066  EB0200     CLR W4
001068  981F14     MOV W4, [W14+50]
831:                     eeprom_write[8] = 0;
00106A  EB0200     CLR W4
00106C  981F24     MOV W4, [W14+52]
832:                     eeprom_write[9] = 0;
00106E  EB0200     CLR W4
001070  981F34     MOV W4, [W14+54]
833:                     eeprom_write[10] = 0;
001072  EB0200     CLR W4
001074  981F44     MOV W4, [W14+56]
834:                     eeprom_write[11] = 0;
001076  EB0200     CLR W4
001078  981F54     MOV W4, [W14+58]
835:                     eeprom_write[12] = 0;
00107A  EB0200     CLR W4
00107C  981F64     MOV W4, [W14+60]
836:                     eeprom_write[13] = 0;
00107E  EB0200     CLR W4
001080  981F74     MOV W4, [W14+62]
837:                     eeprom_write[14] = 0;
001082  EB0200     CLR W4
001084  982704     MOV W4, [W14+64]
838:                   }
839:                   if (read_attempt > 15) {
001086  78021E     MOV [W14], W4
001088  520FEF     SUB W4, #0xF, [W15]
00108A  36001F     BRA LEU, .L99, .LSM353
840:                     // If we can't read this register, set everything to zero and keep going.  We don't NEED pulse count
841:                     eeprom_data[0] = 0;
00108C  EB0200     CLR W4
00108E  980724     MOV W4, [W14+4]
842:                     eeprom_data[1] = 0;
001090  EB0200     CLR W4
001092  980734     MOV W4, [W14+6]
843:                     eeprom_data[2] = 0;
001094  EB0200     CLR W4
001096  980744     MOV W4, [W14+8]
844:                     eeprom_data[3] = 0;
001098  EB0200     CLR W4
00109A  980754     MOV W4, [W14+10]
845:                     eeprom_data[4] = 0;
00109C  EB0200     CLR W4
00109E  980764     MOV W4, [W14+12]
846:                     eeprom_data[5] = 0;
0010A0  EB0200     CLR W4
0010A2  980774     MOV W4, [W14+14]
847:                     eeprom_data[6] = 0;
0010A4  EB0200     CLR W4
0010A6  980F04     MOV W4, [W14+16]
848:                     eeprom_data[7] = 0;
0010A8  EB0200     CLR W4
0010AA  980F14     MOV W4, [W14+18]
849:                     eeprom_data[8] = 0;
0010AC  EB0200     CLR W4
0010AE  980F24     MOV W4, [W14+20]
850:                     eeprom_data[9] = 0;
0010B0  EB0200     CLR W4
0010B2  980F34     MOV W4, [W14+22]
851:                     eeprom_data[10] = 0;
0010B4  EB0200     CLR W4
0010B6  980F44     MOV W4, [W14+24]
852:                     eeprom_data[11] = 0;
0010B8  EB0200     CLR W4
0010BA  980F54     MOV W4, [W14+26]
853:                     eeprom_data[12] = 0;
0010BC  EB0200     CLR W4
0010BE  980F64     MOV W4, [W14+28]
854:                     eeprom_data[13] = 0;
0010C0  EB0200     CLR W4
0010C2  980F74     MOV W4, [W14+30]
855:                     eeprom_data[14] = 0;
0010C4  EB0200     CLR W4
0010C6  981704     MOV W4, [W14+32]
856:                     break;
0010C8  370007     BRA .L101, .LSM354
857:                   }
858:                 }
859:                 
860:                 // DPARKER - At some point want to recover the pulse and arc counter from RAM
861:                 // ------------ Load the pulse and arc counters ---------------- //
862:                 unsigned_int_ptr = (unsigned int*)&pulse_counter_persistent;              //unsigned_int_ptr now points to the Least Significant word of pulse_counter_persistent
0010D8  2179E4     MOV #0x179E, W4
0010DA  980714     MOV W4, [W14+2]
863:                 *unsigned_int_ptr = eeprom_data[3];
0010DC  9002DE     MOV [W14+10], W5
0010DE  90021E     MOV [W14+2], W4
0010E0  780A05     MOV W5, [W4]
864:                 unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
0010E2  90021E     MOV [W14+2], W4
0010E4  E88204     INC2 W4, W4
0010E6  980714     MOV W4, [W14+2]
865:                 *unsigned_int_ptr = eeprom_data[2];
0010E8  9002CE     MOV [W14+8], W5
0010EA  90021E     MOV [W14+2], W4
0010EC  780A05     MOV W5, [W4]
866:                 unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
0010EE  90021E     MOV [W14+2], W4
0010F0  E88204     INC2 W4, W4
0010F2  980714     MOV W4, [W14+2]
867:                 *unsigned_int_ptr = eeprom_data[1];
0010F4  9002BE     MOV [W14+6], W5
0010F6  90021E     MOV [W14+2], W4
0010F8  780A05     MOV W5, [W4]
868:                 unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of pulse_counter_persistent
0010FA  90021E     MOV [W14+2], W4
0010FC  E88204     INC2 W4, W4
0010FE  980714     MOV W4, [W14+2]
869:                 *unsigned_int_ptr = eeprom_data[0];
001100  9002AE     MOV [W14+4], W5
001102  90021E     MOV [W14+2], W4
001104  780A05     MOV W5, [W4]
870:               
871:               
872:                 unsigned_int_ptr = (unsigned int*)&arc_counter_persistent;                //unsigned_int_ptr now points to the Least Significant word of arc_counter_persistent
001106  217AC4     MOV #0x17AC, W4
001108  980714     MOV W4, [W14+2]
873:                 *unsigned_int_ptr = eeprom_data[5];
00110A  9002FE     MOV [W14+14], W5
00110C  90021E     MOV [W14+2], W4
00110E  780A05     MOV W5, [W4]
874:                 unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of arc_counter_persistent
001110  90021E     MOV [W14+2], W4
001112  E88204     INC2 W4, W4
001114  980714     MOV W4, [W14+2]
875:                 *unsigned_int_ptr = eeprom_data[4];
001116  9002EE     MOV [W14+12], W5
001118  90021E     MOV [W14+2], W4
00111A  780A05     MOV W5, [W4]
876:                 
877:                 arc_counter_this_hv_on = 0;
00111C  EB0200     CLR W4
00111E  88BE14     MOV W4, arc_counter_this_hv_on
878:                 pulse_counter_this_hv_on = 0;
001120  B82260     MUL.UU W4, #0, W4
001122  88BD84     MOV W4, pulse_counter_this_hv_on
001124  88BD95     MOV W5, 0x17B2
879:                
880:                 fast_reset_counter_persistent = eeprom_data[6];
001126  900A0E     MOV [W14+16], W4
001128  8842F4     MOV W4, fast_reset_counter_persistent
881:               
882:               
883:               
884:                 /*
885:                   Initialize the thyratron heater PID structure
886:                   DPARKER add these values to H file
887:                 */
888:                 thyratron_cathode_heater_PID.abcCoefficients = &pid_thyratron_cathode_heater_abcCoefficient[0];    /*Set up pointer to derived coefficients */
00112A  208064     MOV #0x806, W4
00112C  884454     MOV W4, thyratron_cathode_heater_PID
889:                 
890:                 thyratron_cathode_heater_PID.controlHistory = &pid_thyratron_cathode_heater_controlHistory[0];     /*Set up pointer to controller history samples */
00112E  21FFA4     MOV #0x1FFA, W4
001130  884464     MOV W4, 0x88C
891:                 PIDInit(&thyratron_cathode_heater_PID);                                                    /*Clear the controler history and the controller output */
001132  2088A0     MOV #0x88A, W0
001134  07F84E     RCALL _PIDInit
892:                 pid_thyratron_cathode_heater_kCoeffs[0] = Q15(0.02);
001136  2028F4     MOV #0x28F, W4
001138  8844A4     MOV W4, pid_thyratron_cathode_heater_kCoeffs
893:                 pid_thyratron_cathode_heater_kCoeffs[1] = Q15(0.08);
00113A  20A3D4     MOV #0xA3D, W4
00113C  8844B4     MOV W4, 0x896
894:                 pid_thyratron_cathode_heater_kCoeffs[2] = Q15(0.08);
00113E  20A3D4     MOV #0xA3D, W4
001140  8844C4     MOV W4, 0x898
895:                 PIDCoeffCalc(&pid_thyratron_cathode_heater_kCoeffs[0], &thyratron_cathode_heater_PID);             /*Derive the a,b, & c coefficients from the Kp, Ki & Kd */
001142  2088A1     MOV #0x88A, W1
001144  208940     MOV #0x894, W0
001146  07F850     RCALL _PIDCoeffCalc
896:                 
897:                 thyratron_reservoir_heater_PID.abcCoefficients = &pid_thyratron_reservoir_heater_abcCoefficient[0];    /*Set up pointer to derived coefficients */
001148  208004     MOV #0x800, W4
00114A  8843D4     MOV W4, thyratron_reservoir_heater_PID
898:                 thyratron_reservoir_heater_PID.controlHistory = &pid_thyratron_reservoir_heater_controlHistory[0];     /*Set up pointer to controller history samples */
00114C  21FF44     MOV #0x1FF4, W4
00114E  8843E4     MOV W4, 0x87C
899:                 PIDInit(&thyratron_reservoir_heater_PID);                                          /*Clear the controler history and the controller output */
001150  2087A0     MOV #0x87A, W0
001152  07F83F     RCALL _PIDInit
900:                 pid_thyratron_reservoir_heater_kCoeffs[0] = Q15(0.02);
001154  2028F4     MOV #0x28F, W4
001156  884424     MOV W4, pid_thyratron_reservoir_heater_kCoeffs
901:                 pid_thyratron_reservoir_heater_kCoeffs[1] = Q15(0.08);
001158  20A3D4     MOV #0xA3D, W4
00115A  884434     MOV W4, 0x886
902:                 pid_thyratron_reservoir_heater_kCoeffs[2] = Q15(0.08);
00115C  20A3D4     MOV #0xA3D, W4
00115E  884444     MOV W4, .LSM18
903:                 PIDCoeffCalc(&pid_thyratron_reservoir_heater_kCoeffs[0], &thyratron_reservoir_heater_PID); /*Derive the a,b, & c coefficients from the Kp, Ki & Kd */
001160  2087A1     MOV #0x87A, W1
001162  208840     MOV #0x884, W0
001164  07F841     RCALL _PIDCoeffCalc
904:                 ClrWdt();
001166  FE6000     CLRWDT
905:               
906:                 
907:                   
908:                 // --- ps_magnet initialization ---
909:               
910:                 ps_magnet.warmup_ramp_time     = MAGNET_SUPPLY_WARMUP_RAMP_TIME;
001168  200644     MOV #0x64, W4
00116A  8854F4     MOV W4, ps_magnet
911:                 
912:                 ps_magnet.v_max_set_point      = MAX_MAGNET_SUPPLY_VOLTAGE_SET_POINT;
00116C  27D004     MOV #0x7D00, W4
00116E  885524     MOV W4, 0xAA4
913:                 
914:                 ps_magnet.v_dac_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
001170  EB8080     SETM W1
001172  EB8000     SETM W0
001174  070CC1     RCALL MakeScale
001176  780200     MOV W0, W4
001178  885544     MOV W4, 0xAA8
915:                 ps_magnet.v_dac_cal_gain       = EEPROM_CAL_GAIN_1;
00117A  220004     MOV #0x2000, W4
00117C  885554     MOV W4, 0xAAA
916:                 ps_magnet.v_dac_cal_offset     = EEPROM_CAL_OFFSET_0; 
00117E  EB0200     CLR W4
001180  885564     MOV W4, .LSM104
917:                 
918:                 ps_magnet.v_adc_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_VADC_INPUT_AT_0xFFFF);
001182  292AA1     MOV #0x92AA, W1
001184  EB8000     SETM W0
001186  070CB8     RCALL MakeScale
001188  780200     MOV W0, W4
00118A  885584     MOV W4, 0xAB0
919:                 ps_magnet.v_adc_cal_gain       = EEPROM_CAL_GAIN_1;
00118C  220004     MOV #0x2000, W4
00118E  885594     MOV W4, 0xAB2
920:                 ps_magnet.v_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
001190  EB0200     CLR W4
001192  8855A4     MOV W4, 0xAB4
921:                 ps_magnet.v_adc_over_abs       = Scale16Bit(MAGNET_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_magnet.v_adc_scale);
001194  805584     MOV 0xAB0, W4
001196  780084     MOV W4, W1
001198  275300     MOV #0x7530, W0
00119A  070CE9     RCALL Scale16Bit
00119C  780200     MOV W0, W4
00119E  8855B4     MOV W4, .L40, .LSM105
922:                 ps_magnet.v_adc_over_scale     = MakeScale(MAGNET_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
0011A0  220001     MOV #0x2000, W1
0011A2  228000     MOV #0x2800, W0
0011A4  070CA9     RCALL MakeScale
0011A6  780200     MOV W0, W4
0011A8  8855E4     MOV W4, 0xABC
923:                 ps_magnet.v_adc_under_scale    = MakeScale(MAGNET_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
0011AA  220001     MOV #0x2000, W1
0011AC  210000     MOV #0x1000, W0
0011AE  070CA4     RCALL MakeScale
0011B0  780200     MOV W0, W4
0011B2  8855F4     MOV W4, 0xABE
924:                 ps_magnet.v_adc_over_min_value = MAGNET_SUPPLY_VADC_MIN_OVER_VOLTAGE;
0011B4  203E84     MOV #0x3E8, W4
0011B6  885604     MOV W4, .LSM106
925:                 ps_magnet.v_adc_max_oor        = MAGNET_SUPPLY_VADC_MAX_OUT_OT_RANGE;
0011B8  200324     MOV #0x32, W4
0011BA  885614     MOV W4, 0xAC2
926:                 
927:                 ps_magnet.i_max_set_point      = MAX_MAGNET_SUPPLY_CURRENT_SET_POINT;
0011BC  261A84     MOV #0x61A8, W4
0011BE  885684     MOV W4, 0xAD0
928:                 
929:                 ps_magnet.i_dac_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
0011C0  291E31     MOV #0x91E3, W1
0011C2  EB8000     SETM W0
0011C4  070C99     RCALL MakeScale
0011C6  780200     MOV W0, W4
0011C8  8856A4     MOV W4, 0xAD4
930:                 ps_magnet.i_dac_cal_gain       = EEPROM_CAL_GAIN_1;
0011CA  220004     MOV #0x2000, W4
0011CC  8856B4     MOV W4, 0xAD6
931:                 ps_magnet.i_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
0011CE  EB0200     CLR W4
0011D0  8856C4     MOV W4, 0xAD8
932:                 
933:                 ps_magnet.i_adc_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_IADC_INPUT_AT_0xFFFF);
0011D2  2AB511     MOV #0xAB51, W1
0011D4  EB8000     SETM W0
0011D6  070C90     RCALL MakeScale
0011D8  780200     MOV W0, W4
0011DA  8856E4     MOV W4, .L37, .LSM110
934:                 ps_magnet.i_adc_cal_gain       = EEPROM_CAL_GAIN_1;
0011DC  220004     MOV #0x2000, W4
0011DE  8856F4     MOV W4, 0xADE
935:                 ps_magnet.i_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
0011E0  EB0200     CLR W4
0011E2  885704     MOV W4, 0xAE0
936:                 ps_magnet.i_adc_over_abs       = Scale16Bit(MAGNET_SUPPLY_IADC_OVER_CURRENT_HARD, ps_magnet.i_adc_scale);
0011E4  8056E4     MOV .L37, .LSM110, W4
0011E6  780084     MOV W4, W1
0011E8  265900     MOV #0x6590, W0
0011EA  070CC1     RCALL Scale16Bit
0011EC  780200     MOV W0, W4
0011EE  885714     MOV W4, 0xAE2
937:                 ps_magnet.i_adc_over_scale     = MakeScale(MAGNET_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
0011F0  220001     MOV #0x2000, W1
0011F2  223330     MOV #0x2333, W0
0011F4  070C81     RCALL MakeScale
0011F6  780200     MOV W0, W4
0011F8  885744     MOV W4, .L9, .LSM112
938:                 ps_magnet.i_adc_under_scale    = MakeScale(MAGNET_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
0011FA  220001     MOV #0x2000, W1
0011FC  21CCC0     MOV #0x1CCC, W0
0011FE  070C7C     RCALL MakeScale
001200  780200     MOV W0, W4
001202  885754     MOV W4, 0xAEA
939:                 ps_magnet.i_adc_over_min_value = MAGNET_SUPPLY_IADC_MIN_OVER_CURRENT;
001204  20FA04     MOV #0xFA0, W4
001206  885764     MOV W4, .LSM113
940:                 ps_magnet.i_adc_max_oor        = MAGNET_SUPPLY_IADC_MAX_OUT_OT_RANGE;
001208  200324     MOV #0x32, W4
00120A  885774     MOV W4, 0xAEE
941:               
942:                 //SetPowerSupplyTarget(&ps_magnet, ps_magnet_config_ram_copy[EEPROM_V_SET_POINT], ps_magnet_config_ram_copy[EEPROM_I_SET_POINT]);
943:                 
944:               
945:               
946:                 // --- ps_filament initialization ---
947:               
948:                 ps_filament.warmup_ramp_time     = FILAMENT_SUPPLY_WARMUP_RAMP_TIME;
00120C  200324     MOV #0x32, W4
00120E  8857C4     MOV W4, ps_filament
949:                 
950:                 ps_filament.v_max_set_point      = MAX_FILAMENT_SUPPLY_VOLTAGE_SET_POINT;
001210  25DC04     MOV #0x5DC0, W4
001212  8857F4     MOV W4, .LSM117
951:                 
952:                 ps_filament.v_dac_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
001214  EB8080     SETM W1
001216  EB8000     SETM W0
001218  070C6F     RCALL MakeScale
00121A  780200     MOV W0, W4
00121C  885814     MOV W4, 0xB02
953:                 ps_filament.v_dac_cal_gain       = EEPROM_CAL_GAIN_1;
00121E  220004     MOV #0x2000, W4
001220  885824     MOV W4, 0xB04
954:                 ps_filament.v_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
001222  EB0200     CLR W4
001224  885834     MOV W4, .LSM118
955:                 
956:                 ps_filament.v_adc_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_VADC_INPUT_AT_0xFFFF);
001226  292AA1     MOV #0x92AA, W1
001228  EB8000     SETM W0
00122A  070C66     RCALL MakeScale
00122C  780200     MOV W0, W4
00122E  885854     MOV W4, 0xB0A
957:                 ps_filament.v_adc_cal_gain       = EEPROM_CAL_GAIN_1;
001230  220004     MOV #0x2000, W4
001232  885864     MOV W4, 0xB0C
958:                 ps_filament.v_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
001234  EB0200     CLR W4
001236  885874     MOV W4, .LSM119
959:                 ps_filament.v_adc_over_abs       = Scale16Bit(FILAMENT_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_filament.v_adc_scale);
001238  805854     MOV 0xB0A, W4
00123A  780084     MOV W4, W1
00123C  261A80     MOV #0x61A8, W0
00123E  070C97     RCALL Scale16Bit
001240  780200     MOV W0, W4
001242  885884     MOV W4, 0xB10
960:                 ps_filament.v_adc_over_scale     = MakeScale(FILAMENT_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
001244  220001     MOV #0x2000, W1
001246  240000     MOV #0x4000, W0
001248  070C57     RCALL MakeScale
00124A  780200     MOV W0, W4
00124C  8858B4     MOV W4, .LSM120
961:                 ps_filament.v_adc_under_scale    = MakeScale(FILAMENT_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
00124E  220001     MOV #0x2000, W1
001250  210000     MOV #0x1000, W0
001252  070C52     RCALL MakeScale
001254  780200     MOV W0, W4
001256  8858C4     MOV W4, 0xB18
962:                 ps_filament.v_adc_over_min_value = FILAMENT_SUPPLY_VADC_MIN_OVER_VOLTAGE;
001258  20FA04     MOV #0xFA0, W4
00125A  8858D4     MOV W4, .LSM121
963:                 ps_filament.v_adc_max_oor        = FILAMENT_SUPPLY_VADC_MAX_OUT_OT_RANGE;
00125C  200C84     MOV #0xC8, W4
00125E  8858E4     MOV W4, 0xB1C
964:                 
965:                 ps_filament.i_max_set_point      = MAX_FILAMENT_SUPPLY_CURRENT_SET_POINT;
001260  25DC04     MOV #0x5DC0, W4
001262  885954     MOV W4, 0xB2A
966:                 
967:                 ps_filament.i_dac_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
001264  291E21     MOV #0x91E2, W1
001266  EB8000     SETM W0
001268  070C47     RCALL MakeScale
00126A  780200     MOV W0, W4
00126C  885974     MOV W4, 0xB2E
968:                 ps_filament.i_dac_cal_gain       = EEPROM_CAL_GAIN_1;
00126E  220004     MOV #0x2000, W4
001270  885984     MOV W4, 0xB30
969:                 ps_filament.i_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
001272  EB0200     CLR W4
001274  885994     MOV W4, .L43
970:                 
971:                 ps_filament.i_adc_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_IADC_INPUT_AT_0xFFFF);
001276  2AB511     MOV #0xAB51, W1
001278  EB8000     SETM W0
00127A  070C3E     RCALL MakeScale
00127C  780200     MOV W0, W4
00127E  8859B4     MOV W4, 0xB36
972:                 ps_filament.i_adc_cal_gain       = EEPROM_CAL_GAIN_1;
001280  220004     MOV #0x2000, W4
001282  8859C4     MOV W4, .LSM124
973:                 ps_filament.i_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
001284  EB0200     CLR W4
001286  8859D4     MOV W4, .LSM125
974:                 ps_filament.i_adc_over_abs       = Scale16Bit(FILAMENT_SUPPLY_IADC_OVER_CURRENT_HARD, ps_filament.i_adc_scale);
001288  8059B4     MOV 0xB36, W4
00128A  780084     MOV W4, W1
00128C  232C80     MOV #0x32C8, W0
00128E  070C6F     RCALL Scale16Bit
001290  780200     MOV W0, W4
001292  8859E4     MOV W4, .L77, .LSM126
975:                 ps_filament.i_adc_over_scale     = MakeScale(FILAMENT_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
001294  220001     MOV #0x2000, W1
001296  228000     MOV #0x2800, W0
001298  070C2F     RCALL MakeScale
00129A  780200     MOV W0, W4
00129C  885A14     MOV W4, .LSM128
976:                 ps_filament.i_adc_under_scale    = MakeScale(FILAMENT_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
00129E  220001     MOV #0x2000, W1
0012A0  218000     MOV #0x1800, W0
0012A2  070C2A     RCALL MakeScale
0012A4  780200     MOV W0, W4
0012A6  885A24     MOV W4, .LSM129
977:                 ps_filament.i_adc_over_min_value = FILAMENT_SUPPLY_IADC_MIN_OVER_CURRENT;
0012A8  20FA04     MOV #0xFA0, W4
0012AA  885A34     MOV W4, 0xB46
978:                 ps_filament.i_adc_max_oor        = FILAMENT_SUPPLY_IADC_MAX_OUT_OT_RANGE;
0012AC  200C84     MOV #0xC8, W4
0012AE  885A44     MOV W4, 0xB48
979:               
980:                 SetPowerSupplyTarget(&ps_filament, GenerateFilamentVprog(filament_iprog), filament_iprog);
0012B0  804098     MOV filament_iprog, W8
0012B2  804094     MOV filament_iprog, W4
0012B4  780004     MOV W4, W0
0012B6  071612     RCALL GenerateFilamentVprog
0012B8  780200     MOV W0, W4
0012BA  780108     MOV W8, W2
0012BC  780084     MOV W4, W1
0012BE  20AF80     MOV #0xAF8, W0
0012C0  07041F     RCALL SetPowerSupplyTarget
981:                 
982:               
983:               
984:                 // --- ps_thyr_cathode_htr initialization ---
985:               
986:                 ps_thyr_cathode_htr.warmup_ramp_time     = THYR_CATH_HTR_SUPPLY_WARMUP_RAMP_TIME;
0012C2  207084     MOV #0x708, W4
0012C4  885A94     MOV W4, ps_thyr_cathode_htr
987:                 
988:                 ps_thyr_cathode_htr.v_max_set_point      = MAX_THYR_CATH_HTR_SUPPLY_VOLTAGE_SET_POINT;
0012C6  21A2C4     MOV #0x1A2C, W4
0012C8  885AC4     MOV W4, 0xB58
989:                 
990:                 ps_thyr_cathode_htr.v_dac_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
0012CA  EB0080     CLR W1
0012CC  EB8000     SETM W0
0012CE  070C14     RCALL MakeScale
0012D0  780200     MOV W0, W4
0012D2  885AE4     MOV W4, 0xB5C
991:                 ps_thyr_cathode_htr.v_dac_cal_gain       = EEPROM_CAL_GAIN_1;
0012D4  220004     MOV #0x2000, W4
0012D6  885AF4     MOV W4, .LSM132
992:                 ps_thyr_cathode_htr.v_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
0012D8  EB0200     CLR W4
0012DA  885B04     MOV W4, .L46, .LSM133
993:                 
994:                 ps_thyr_cathode_htr.v_adc_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_VADC_INPUT_AT_0xFFFF);
0012DC  295E21     MOV #0x95E2, W1
0012DE  EB8000     SETM W0
0012E0  070C0B     RCALL MakeScale
0012E2  780200     MOV W0, W4
0012E4  885B24     MOV W4, 0xB64
995:                 ps_thyr_cathode_htr.v_adc_cal_gain       = EEPROM_CAL_GAIN_1;
0012E6  220004     MOV #0x2000, W4
0012E8  885B34     MOV W4, 0xB66
996:                 ps_thyr_cathode_htr.v_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
0012EA  EB0200     CLR W4
0012EC  885B44     MOV W4, 0xB68
997:                 ps_thyr_cathode_htr.v_adc_over_abs       = Scale16Bit(THYR_CATH_HTR_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_thyr_cathode_htr.v_adc_scale);
0012EE  805B24     MOV 0xB64, W4
0012F0  780084     MOV W4, W1
0012F2  21C200     MOV #0x1C20, W0
0012F4  070C3C     RCALL Scale16Bit
0012F6  780200     MOV W0, W4
0012F8  885B54     MOV W4, .LSM134
998:                 ps_thyr_cathode_htr.v_adc_over_scale     = MakeScale(THYR_CATH_HTR_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
0012FA  220001     MOV #0x2000, W1
0012FC  221990     MOV #0x2199, W0
0012FE  070BFC     RCALL MakeScale
001300  780200     MOV W0, W4
001302  885B84     MOV W4, .L47, .LSM135
999:                 ps_thyr_cathode_htr.v_adc_under_scale    = MakeScale(THYR_CATH_HTR_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
001304  220001     MOV #0x2000, W1
001306  21E660     MOV #0x1E66, W0
001308  070BF7     RCALL MakeScale
00130A  780200     MOV W0, W4
00130C  885B94     MOV W4, 0xB72
1000:                ps_thyr_cathode_htr.v_adc_over_min_value = THYR_CATH_HTR_SUPPLY_VADC_MIN_OVER_VOLTAGE;
00130E  203E84     MOV #0x3E8, W4
001310  885BA4     MOV W4, .L48, .LSM136
1001:                ps_thyr_cathode_htr.v_adc_max_oor        = THYR_CATH_HTR_SUPPLY_VADC_MAX_OUT_OT_RANGE;
001312  201F44     MOV #0x1F4, W4
001314  885BB4     MOV W4, 0xB76
1002:                
1003:                ps_thyr_cathode_htr.i_max_set_point      = MAX_THYR_CATH_HTR_SUPPLY_CURRENT_SET_POINT;
001316  EB0200     CLR W4
001318  885C24     MOV W4, 0xB84
1004:                
1005:                ps_thyr_cathode_htr.i_dac_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
00131A  EB0080     CLR W1
00131C  EB8000     SETM W0
00131E  070BEC     RCALL MakeScale
001320  780200     MOV W0, W4
001322  885C44     MOV W4, 0xB88
1006:                ps_thyr_cathode_htr.i_dac_cal_gain       = EEPROM_CAL_GAIN_1;
001324  220004     MOV #0x2000, W4
001326  885C54     MOV W4, .L50, .LSM140
1007:                ps_thyr_cathode_htr.i_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
001328  EB0200     CLR W4
00132A  885C64     MOV W4, 0xB8C
1008:                
1009:                ps_thyr_cathode_htr.i_adc_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_IADC_INPUT_AT_0xFFFF);
00132C  EB0080     CLR W1
00132E  EB8000     SETM W0
001330  070BE3     RCALL MakeScale
001332  780200     MOV W0, W4
001334  885C84     MOV W4, 0xB90
1010:                ps_thyr_cathode_htr.i_adc_cal_gain       = EEPROM_CAL_GAIN_1;
001336  220004     MOV #0x2000, W4
001338  885C94     MOV W4, 0xB92
1011:                ps_thyr_cathode_htr.i_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
00133A  EB0200     CLR W4
00133C  885CA4     MOV W4, 0xB94
1012:                ps_thyr_cathode_htr.i_adc_over_abs       = Scale16Bit(THYR_CATH_HTR_SUPPLY_IADC_OVER_CURRENT_HARD, ps_thyr_cathode_htr.i_adc_scale);
00133E  805C84     MOV 0xB90, W4
001340  780084     MOV W4, W1
001342  EB0000     CLR W0
001344  070C14     RCALL Scale16Bit
001346  780200     MOV W0, W4
001348  885CB4     MOV W4, .LSM142
1013:                ps_thyr_cathode_htr.i_adc_over_scale     = MakeScale(THYR_CATH_HTR_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
00134A  220001     MOV #0x2000, W1
00134C  EB0000     CLR W0
00134E  070BD4     RCALL MakeScale
001350  780200     MOV W0, W4
001352  885CE4     MOV W4, .L51, .LSM143
1014:                ps_thyr_cathode_htr.i_adc_under_scale    = MakeScale(THYR_CATH_HTR_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
001354  220001     MOV #0x2000, W1
001356  EB0000     CLR W0
001358  070BCF     RCALL MakeScale
00135A  780200     MOV W0, W4
00135C  885CF4     MOV W4, 0xB9E
1015:                ps_thyr_cathode_htr.i_adc_over_min_value = THYR_CATH_HTR_SUPPLY_IADC_MIN_OVER_CURRENT;
00135E  EB0200     CLR W4
001360  885D04     MOV W4, 0xBA0
1016:                ps_thyr_cathode_htr.i_adc_max_oor        = THYR_CATH_HTR_SUPPLY_IADC_MAX_OUT_OT_RANGE;
001362  EB0200     CLR W4
001364  885D14     MOV W4, 0xBA2
1017:              
1018:                //SetPowerSupplyTarget(&ps_thyr_cathode_htr, ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_SET_POINT], ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_SET_POINT]);
1019:                
1020:              
1021:              
1022:                // --- ps_thyr_reservoir_htr initialization ---
1023:              
1024:                ps_thyr_reservoir_htr.warmup_ramp_time     = THYR_RESER_HTR_SUPPLY_WARMUP_RAMP_TIME;
001366  207084     MOV #0x708, W4
001368  885D64     MOV W4, ps_thyr_reservoir_htr
1025:                
1026:                ps_thyr_reservoir_htr.v_max_set_point      = MAX_THYR_RESER_HTR_SUPPLY_VOLTAGE_SET_POINT;
00136A  217704     MOV #0x1770, W4
00136C  885D94     MOV W4, 0xBB2
1027:                
1028:                ps_thyr_reservoir_htr.v_dac_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
00136E  EB0080     CLR W1
001370  EB8000     SETM W0
001372  070BC2     RCALL MakeScale
001374  780200     MOV W0, W4
001376  885DB4     MOV W4, 0xBB6
1029:                ps_thyr_reservoir_htr.v_dac_cal_gain       = EEPROM_CAL_GAIN_1;
001378  220004     MOV #0x2000, W4
00137A  885DC4     MOV W4, 0xBB8
1030:                ps_thyr_reservoir_htr.v_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
00137C  EB0200     CLR W4
00137E  885DD4     MOV W4, 0xBBA
1031:                
1032:                ps_thyr_reservoir_htr.v_adc_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_VADC_INPUT_AT_0xFFFF);
001380  295E21     MOV #0x95E2, W1
001382  EB8000     SETM W0
001384  070BB9     RCALL MakeScale
001386  780200     MOV W0, W4
001388  885DF4     MOV W4, 0xBBE
1033:                ps_thyr_reservoir_htr.v_adc_cal_gain       = EEPROM_CAL_GAIN_1;
00138A  220004     MOV #0x2000, W4
00138C  885E04     MOV W4, 0xBC0
1034:                ps_thyr_reservoir_htr.v_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
00138E  EB0200     CLR W4
001390  885E14     MOV W4, .LSM145
1035:                ps_thyr_reservoir_htr.v_adc_over_abs       = Scale16Bit(THYR_RESER_HTR_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_thyr_reservoir_htr.v_adc_scale);
001392  805DF4     MOV 0xBBE, W4
001394  780084     MOV W4, W1
001396  2186A0     MOV #0x186A, W0
001398  070BEA     RCALL Scale16Bit
00139A  780200     MOV W0, W4
00139C  885E24     MOV W4, 0xBC4
1036:                ps_thyr_reservoir_htr.v_adc_over_scale     = MakeScale(THYR_RESER_HTR_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
00139E  220001     MOV #0x2000, W1
0013A0  221990     MOV #0x2199, W0
0013A2  070BAA     RCALL MakeScale
0013A4  780200     MOV W0, W4
0013A6  885E54     MOV W4, .LSM147
1037:                ps_thyr_reservoir_htr.v_adc_under_scale    = MakeScale(THYR_RESER_HTR_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
0013A8  220001     MOV #0x2000, W1
0013AA  21E660     MOV #0x1E66, W0
0013AC  070BA5     RCALL MakeScale
0013AE  780200     MOV W0, W4
0013B0  885E64     MOV W4, 0xBCC
1038:                ps_thyr_reservoir_htr.v_adc_over_min_value = THYR_RESER_HTR_SUPPLY_VADC_MIN_OVER_VOLTAGE;
0013B2  203E84     MOV #0x3E8, W4
0013B4  885E74     MOV W4, 0xBCE
1039:                ps_thyr_reservoir_htr.v_adc_max_oor        = THYR_RESER_HTR_SUPPLY_VADC_MAX_OUT_OT_RANGE;
0013B6  201F44     MOV #0x1F4, W4
0013B8  885E84     MOV W4, 0xBD0
1040:                
1041:                ps_thyr_reservoir_htr.i_max_set_point      = MAX_THYR_RESER_HTR_SUPPLY_CURRENT_SET_POINT;
0013BA  EB0200     CLR W4
0013BC  885EF4     MOV W4, .LSM149
1042:                
1043:                ps_thyr_reservoir_htr.i_dac_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
0013BE  EB0080     CLR W1
0013C0  EB8000     SETM W0
0013C2  070B9A     RCALL MakeScale
0013C4  780200     MOV W0, W4
0013C6  885F14     MOV W4, 0xBE2
1044:                ps_thyr_reservoir_htr.i_dac_cal_gain       = EEPROM_CAL_GAIN_1;
0013C8  220004     MOV #0x2000, W4
0013CA  885F24     MOV W4, 0xBE4
1045:                ps_thyr_reservoir_htr.i_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
0013CC  EB0200     CLR W4
0013CE  885F34     MOV W4, .LSM150
1046:                
1047:                ps_thyr_reservoir_htr.i_adc_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_IADC_INPUT_AT_0xFFFF);
0013D0  EB0080     CLR W1
0013D2  EB8000     SETM W0
0013D4  070B91     RCALL MakeScale
0013D6  780200     MOV W0, W4
0013D8  885F54     MOV W4, 0xBEA
1048:                ps_thyr_reservoir_htr.i_adc_cal_gain       = EEPROM_CAL_GAIN_1;
0013DA  220004     MOV #0x2000, W4
0013DC  885F64     MOV W4, .L53, .LSM151
1049:                ps_thyr_reservoir_htr.i_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
0013DE  EB0200     CLR W4
0013E0  885F74     MOV W4, 0xBEE
1050:                ps_thyr_reservoir_htr.i_adc_over_abs       = Scale16Bit(THYR_RESER_HTR_SUPPLY_IADC_OVER_CURRENT_HARD, ps_thyr_reservoir_htr.i_adc_scale);
0013E2  805F54     MOV 0xBEA, W4
0013E4  780084     MOV W4, W1
0013E6  EB0000     CLR W0
0013E8  070BC2     RCALL Scale16Bit
0013EA  780200     MOV W0, W4
0013EC  885F84     MOV W4, 0xBF0
1051:                ps_thyr_reservoir_htr.i_adc_over_scale     = MakeScale(THYR_RESER_HTR_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
0013EE  220001     MOV #0x2000, W1
0013F0  EB0000     CLR W0
0013F2  070B82     RCALL MakeScale
0013F4  780200     MOV W0, W4
0013F6  885FB4     MOV W4, 0xBF6
1052:                ps_thyr_reservoir_htr.i_adc_under_scale    = MakeScale(THYR_RESER_HTR_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
0013F8  220001     MOV #0x2000, W1
0013FA  EB0000     CLR W0
0013FC  070B7D     RCALL MakeScale
0013FE  780200     MOV W0, W4
001400  885FC4     MOV W4, 0xBF8
1053:                ps_thyr_reservoir_htr.i_adc_over_min_value = THYR_RESER_HTR_SUPPLY_IADC_MIN_OVER_CURRENT;
001402  EB0200     CLR W4
001404  885FD4     MOV W4, .LSM153
1054:                ps_thyr_reservoir_htr.i_adc_max_oor        = THYR_RESER_HTR_SUPPLY_IADC_MAX_OUT_OT_RANGE;
001406  EB0200     CLR W4
001408  885FE4     MOV W4, 0xBFC
1055:              
1056:                //SetPowerSupplyTarget(&ps_thyr_reservoir_htr, ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_SET_POINT], ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_SET_POINT]);
1057:                
1058:              
1059:              
1060:                // --- ps_hv_lambda_mode_A initialization ---
1061:              
1062:                ps_hv_lambda_mode_A.warmup_ramp_time     = HV_LAMBDA_MODE_A_WARMUP_RAMP_TIME;
00140A  EB0200     CLR W4
00140C  8849B4     MOV W4, ps_hv_lambda_mode_A
1063:                
1064:                ps_hv_lambda_mode_A.v_max_set_point      = MAX_HV_LAMBDA_MODE_A_VOLTAGE_SET_POINT;
00140E  24A384     MOV #0x4A38, W4
001410  8849E4     MOV W4, .LSM51
1065:                
1066:                ps_hv_lambda_mode_A.v_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_VDAC_OUTPUT_AT_0xFFFF);
001412  257151     MOV #0x5715, W1
001414  EB8000     SETM W0
001416  070B70     RCALL MakeScale
001418  780200     MOV W0, W4
00141A  884A04     MOV W4, 0x940
1067:                ps_hv_lambda_mode_A.v_dac_cal_gain       = EEPROM_CAL_GAIN_1;
00141C  220004     MOV #0x2000, W4
00141E  884A14     MOV W4, 0x942
1068:                ps_hv_lambda_mode_A.v_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
001420  EB0200     CLR W4
001422  884A24     MOV W4, 0x944
1069:                
1070:                ps_hv_lambda_mode_A.v_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_VADC_INPUT_AT_0xFFFF);
001424  261A81     MOV #0x61A8, W1
001426  EB8000     SETM W0
001428  070B67     RCALL MakeScale
00142A  780200     MOV W0, W4
00142C  884A44     MOV W4, 0x948
1071:                ps_hv_lambda_mode_A.v_adc_cal_gain       = EEPROM_CAL_GAIN_1;
00142E  220004     MOV #0x2000, W4
001430  884A54     MOV W4, 0x94A
1072:                ps_hv_lambda_mode_A.v_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
001432  EB0200     CLR W4
001434  884A64     MOV W4, 0x94C
1073:                ps_hv_lambda_mode_A.v_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_A_VADC_OVER_VOLTAGE_HARD, ps_hv_lambda_mode_A.v_adc_scale);
001436  804A44     MOV 0x948, W4
001438  780084     MOV W4, W1
00143A  24C2C0     MOV #0x4C2C, W0
00143C  070B98     RCALL Scale16Bit
00143E  780200     MOV W0, W4
001440  884A74     MOV W4, 0x94E
1074:                ps_hv_lambda_mode_A.v_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_A_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
001442  220001     MOV #0x2000, W1
001444  EB0000     CLR W0
001446  070B58     RCALL MakeScale
001448  780200     MOV W0, W4
00144A  884AA4     MOV W4, 0x954
1075:                ps_hv_lambda_mode_A.v_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_A_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
00144C  220001     MOV #0x2000, W1
00144E  EB0000     CLR W0
001450  070B53     RCALL MakeScale
001452  780200     MOV W0, W4
001454  884AB4     MOV W4, 0x956
1076:                ps_hv_lambda_mode_A.v_adc_over_min_value = HV_LAMBDA_MODE_A_VADC_MIN_OVER_VOLTAGE;
001456  EB0200     CLR W4
001458  884AC4     MOV W4, .LSM54
1077:                ps_hv_lambda_mode_A.v_adc_max_oor        = HV_LAMBDA_MODE_A_VADC_MAX_OUT_OT_RANGE;
00145A  EB0200     CLR W4
00145C  884AD4     MOV W4, 0x95A
1078:                
1079:                ps_hv_lambda_mode_A.i_max_set_point      = MAX_HV_LAMBDA_MODE_A_CURRENT_SET_POINT;
00145E  EB0200     CLR W4
001460  884B44     MOV W4, 0x968
1080:                
1081:                ps_hv_lambda_mode_A.i_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_IDAC_OUTPUT_AT_0xFFFF);
001462  EB0080     CLR W1
001464  EB8000     SETM W0
001466  070B48     RCALL MakeScale
001468  780200     MOV W0, W4
00146A  884B64     MOV W4, .LSM56
1082:                ps_hv_lambda_mode_A.i_dac_cal_gain       = EEPROM_CAL_GAIN_1;
00146C  220004     MOV #0x2000, W4
00146E  884B74     MOV W4, 0x96E
1083:                ps_hv_lambda_mode_A.i_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
001470  EB0200     CLR W4
001472  884B84     MOV W4, 0x970
1084:                
1085:                ps_hv_lambda_mode_A.i_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_IADC_INPUT_AT_0xFFFF);
001474  EB0080     CLR W1
001476  EB8000     SETM W0
001478  070B3F     RCALL MakeScale
00147A  780200     MOV W0, W4
00147C  884BA4     MOV W4, 0x974
1086:                ps_hv_lambda_mode_A.i_adc_cal_gain       = EEPROM_CAL_GAIN_1;
00147E  220004     MOV #0x2000, W4
001480  884BB4     MOV W4, .L29, .LSM57
1087:                ps_hv_lambda_mode_A.i_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
001482  EB0200     CLR W4
001484  884BC4     MOV W4, 0x978
1088:                ps_hv_lambda_mode_A.i_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_A_IADC_OVER_CURRENT_HARD, ps_hv_lambda_mode_A.i_adc_scale);
001486  804BA4     MOV 0x974, W4
001488  780084     MOV W4, W1
00148A  EB0000     CLR W0
00148C  070B70     RCALL Scale16Bit
00148E  780200     MOV W0, W4
001490  884BD4     MOV W4, 0x97A
1089:                ps_hv_lambda_mode_A.i_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_A_IADC_OVER_CURRENT_SCALE*8192, 8192);
001492  220001     MOV #0x2000, W1
001494  EB0000     CLR W0
001496  070B30     RCALL MakeScale
001498  780200     MOV W0, W4
00149A  884C04     MOV W4, .LSM59
1090:                ps_hv_lambda_mode_A.i_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_A_IADC_UNDER_CURRENT_SCALE*8192, 8192);
00149C  220001     MOV #0x2000, W1
00149E  EB0000     CLR W0
0014A0  070B2B     RCALL MakeScale
0014A2  780200     MOV W0, W4
0014A4  884C14     MOV W4, 0x982
1091:                ps_hv_lambda_mode_A.i_adc_over_min_value = HV_LAMBDA_MODE_A_IADC_MIN_OVER_CURRENT;
0014A6  EB0200     CLR W4
0014A8  884C24     MOV W4, 0x984
1092:                ps_hv_lambda_mode_A.i_adc_max_oor        = HV_LAMBDA_MODE_A_IADC_MAX_OUT_OT_RANGE;
0014AA  EB0200     CLR W4
0014AC  884C34     MOV W4, 0x986
1093:              
1094:                SetPowerSupplyTarget(&ps_hv_lambda_mode_A, 18000, 10000);
0014AE  227102     MOV #0x2710, W2
0014B0  246501     MOV #0x4650, W1
0014B2  209360     MOV #0x936, W0
0014B4  070325     RCALL SetPowerSupplyTarget
1095:                
1096:              
1097:              
1098:                // --- ps_hv_lambda_mode_B initialization ---
1099:              
1100:                ps_hv_lambda_mode_B.warmup_ramp_time     = HV_LAMBDA_MODE_B_WARMUP_RAMP_TIME;
0014B6  EB0200     CLR W4
0014B8  884F54     MOV W4, ps_hv_lambda_mode_B
1101:                
1102:                ps_hv_lambda_mode_B.v_max_set_point      = MAX_HV_LAMBDA_MODE_B_VOLTAGE_SET_POINT;
0014BA  24A384     MOV #0x4A38, W4
0014BC  884F84     MOV W4, .LSM76
1103:                
1104:                ps_hv_lambda_mode_B.v_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_VDAC_OUTPUT_AT_0xFFFF);
0014BE  257151     MOV #0x5715, W1
0014C0  EB8000     SETM W0
0014C2  070B1A     RCALL MakeScale
0014C4  780200     MOV W0, W4
0014C6  884FA4     MOV W4, 0x9F4
1105:                ps_hv_lambda_mode_B.v_dac_cal_gain       = EEPROM_CAL_GAIN_1;
0014C8  220004     MOV #0x2000, W4
0014CA  884FB4     MOV W4, 0x9F6
1106:                ps_hv_lambda_mode_B.v_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
0014CC  EB0200     CLR W4
0014CE  884FC4     MOV W4, .LSM77
1107:                
1108:                ps_hv_lambda_mode_B.v_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_VADC_INPUT_AT_0xFFFF);
0014D0  261A81     MOV #0x61A8, W1
0014D2  EB8000     SETM W0
0014D4  070B11     RCALL MakeScale
0014D6  780200     MOV W0, W4
0014D8  884FE4     MOV W4, 0x9FC
1109:                ps_hv_lambda_mode_B.v_adc_cal_gain       = EEPROM_CAL_GAIN_1;
0014DA  220004     MOV #0x2000, W4
0014DC  884FF4     MOV W4, 0x9FE
1110:                ps_hv_lambda_mode_B.v_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
0014DE  EB0200     CLR W4
0014E0  885004     MOV W4, .LSM78
1111:                ps_hv_lambda_mode_B.v_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_B_VADC_OVER_VOLTAGE_HARD, ps_hv_lambda_mode_B.v_adc_scale);
0014E2  804FE4     MOV 0x9FC, W4
0014E4  780084     MOV W4, W1
0014E6  24C2C0     MOV #0x4C2C, W0
0014E8  070B42     RCALL Scale16Bit
0014EA  780200     MOV W0, W4
0014EC  885014     MOV W4, .L36, .LSM79
1112:                ps_hv_lambda_mode_B.v_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_B_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
0014EE  220001     MOV #0x2000, W1
0014F0  EB0000     CLR W0
0014F2  070B02     RCALL MakeScale
0014F4  780200     MOV W0, W4
0014F6  885044     MOV W4, 0xA08
1113:                ps_hv_lambda_mode_B.v_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_B_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
0014F8  220001     MOV #0x2000, W1
0014FA  EB0000     CLR W0
0014FC  070AFD     RCALL MakeScale
0014FE  780200     MOV W0, W4
001500  885054     MOV W4, 0xA0A
1114:                ps_hv_lambda_mode_B.v_adc_over_min_value = HV_LAMBDA_MODE_B_VADC_MIN_OVER_VOLTAGE;
001502  EB0200     CLR W4
001504  885064     MOV W4, 0xA0C
1115:                ps_hv_lambda_mode_B.v_adc_max_oor        = HV_LAMBDA_MODE_B_VADC_MAX_OUT_OT_RANGE;
001506  EB0200     CLR W4
001508  885074     MOV W4, .LSM82
1116:                
1117:                ps_hv_lambda_mode_B.i_max_set_point      = MAX_HV_LAMBDA_MODE_B_CURRENT_SET_POINT;
00150A  EB0200     CLR W4
00150C  8850E4     MOV W4, 0xA1C
1118:                
1119:                ps_hv_lambda_mode_B.i_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_IDAC_OUTPUT_AT_0xFFFF);
00150E  EB0080     CLR W1
001510  EB8000     SETM W0
001512  070AF2     RCALL MakeScale
001514  780200     MOV W0, W4
001516  885104     MOV W4, 0xA20
1120:                ps_hv_lambda_mode_B.i_dac_cal_gain       = EEPROM_CAL_GAIN_1;
001518  220004     MOV #0x2000, W4
00151A  885114     MOV W4, .LSM84
1121:                ps_hv_lambda_mode_B.i_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
00151C  EB0200     CLR W4
00151E  885124     MOV W4, 0xA24
1122:                
1123:                ps_hv_lambda_mode_B.i_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_IADC_INPUT_AT_0xFFFF);
001520  EB0080     CLR W1
001522  EB8000     SETM W0
001524  070AE9     RCALL MakeScale
001526  780200     MOV W0, W4
001528  885144     MOV W4, 0xA28
1124:                ps_hv_lambda_mode_B.i_adc_cal_gain       = EEPROM_CAL_GAIN_1;
00152A  220004     MOV #0x2000, W4
00152C  885154     MOV W4, 0xA2A
1125:                ps_hv_lambda_mode_B.i_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
00152E  EB0200     CLR W4
001530  885164     MOV W4, .L35, .LSM85
1126:                ps_hv_lambda_mode_B.i_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_B_IADC_OVER_CURRENT_HARD, ps_hv_lambda_mode_B.i_adc_scale);
001532  805144     MOV 0xA28, W4
001534  780084     MOV W4, W1
001536  EB0000     CLR W0
001538  070B1A     RCALL Scale16Bit
00153A  780200     MOV W0, W4
00153C  885174     MOV W4, 0xA2E
1127:                ps_hv_lambda_mode_B.i_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_B_IADC_OVER_CURRENT_SCALE*8192, 8192);
00153E  220001     MOV #0x2000, W1
001540  EB0000     CLR W0
001542  070ADA     RCALL MakeScale
001544  780200     MOV W0, W4
001546  8851A4     MOV W4, 0xA34
1128:                ps_hv_lambda_mode_B.i_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_B_IADC_UNDER_CURRENT_SCALE*8192, 8192);
001548  220001     MOV #0x2000, W1
00154A  EB0000     CLR W0
00154C  070AD5     RCALL MakeScale
00154E  780200     MOV W0, W4
001550  8851B4     MOV W4, .LSM86
1129:                ps_hv_lambda_mode_B.i_adc_over_min_value = HV_LAMBDA_MODE_B_IADC_MIN_OVER_CURRENT;
001552  EB0200     CLR W4
001554  8851C4     MOV W4, 0xA38
1130:                ps_hv_lambda_mode_B.i_adc_max_oor        = HV_LAMBDA_MODE_B_IADC_MAX_OUT_OT_RANGE;
001556  EB0200     CLR W4
001558  8851D4     MOV W4, 0xA3A
1131:              
1132:              
1133:                SetPowerSupplyTarget(&ps_hv_lambda_mode_B, 16000, 10000);
00155A  227102     MOV #0x2710, W2
00155C  23E801     MOV #0x3E80, W1
00155E  209EA0     MOV #0x9EA, W0
001560  0702CF     RCALL SetPowerSupplyTarget
1134:                
1135:              
1136:              
1137:                // --- ps_magnetron_mode_A initialization ---
1138:              
1139:                ps_magnetron_mode_A.warmup_ramp_time     = MAGNETRON_MODE_A_WARMUP_RAMP_TIME;
001562  EB0200     CLR W4
001564  884C84     MOV W4, ps_magnetron_mode_A
1140:                
1141:                ps_magnetron_mode_A.v_max_set_point      = MAX_MAGNETRON_MODE_A_VOLTAGE_SET_POINT;
001566  2D6D84     MOV #0xD6D8, W4
001568  884CB4     MOV W4, 0x996
1142:                
1143:                ps_magnetron_mode_A.v_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_VDAC_OUTPUT_AT_0xFFFF);
00156A  EB0080     CLR W1
00156C  EB8000     SETM W0
00156E  070AC4     RCALL MakeScale
001570  780200     MOV W0, W4
001572  884CD4     MOV W4, 0x99A
1144:                ps_magnetron_mode_A.v_dac_cal_gain       = EEPROM_CAL_GAIN_1;
001574  220004     MOV #0x2000, W4
001576  884CE4     MOV W4, 0x99C
1145:                ps_magnetron_mode_A.v_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
001578  EB0200     CLR W4
00157A  884CF4     MOV W4, .LSM62
1146:                
1147:                ps_magnetron_mode_A.v_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_VADC_INPUT_AT_0xFFFF);
00157C  2D8A11     MOV #0xD8A1, W1
00157E  EB8000     SETM W0
001580  070ABB     RCALL MakeScale
001582  780200     MOV W0, W4
001584  884D14     MOV W4, 0x9A2
1148:                ps_magnetron_mode_A.v_adc_cal_gain       = EEPROM_CAL_GAIN_1;
001586  220004     MOV #0x2000, W4
001588  884D24     MOV W4, 0x9A4
1149:                ps_magnetron_mode_A.v_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
00158A  EB0200     CLR W4
00158C  884D34     MOV W4, 0x9A6
1150:                ps_magnetron_mode_A.v_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_A_VADC_OVER_VOLTAGE_HARD, ps_magnetron_mode_A.v_adc_scale);
00158E  804D14     MOV 0x9A2, W4
001590  780084     MOV W4, W1
001592  2CB200     MOV #0xCB20, W0
001594  070AEC     RCALL Scale16Bit
001596  780200     MOV W0, W4
001598  884D44     MOV W4, .LSM64
1151:                ps_magnetron_mode_A.v_adc_over_scale     = MakeScale(MAGNETRON_MODE_A_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
00159A  220001     MOV #0x2000, W1
00159C  228000     MOV #0x2800, W0
00159E  070AAC     RCALL MakeScale
0015A0  780200     MOV W0, W4
0015A2  884D74     MOV W4, .L31, .LSM65
1152:                ps_magnetron_mode_A.v_adc_under_scale    = MakeScale(MAGNETRON_MODE_A_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
0015A4  220001     MOV #0x2000, W1
0015A6  219990     MOV #0x1999, W0
0015A8  070AA7     RCALL MakeScale
0015AA  780200     MOV W0, W4
0015AC  884D84     MOV W4, 0x9B0
1153:                ps_magnetron_mode_A.v_adc_over_min_value = MAGNETRON_MODE_A_VADC_MIN_OVER_VOLTAGE;
0015AE  203E84     MOV #0x3E8, W4
0015B0  884D94     MOV W4, 0x9B2
1154:                ps_magnetron_mode_A.v_adc_max_oor        = MAGNETRON_MODE_A_VADC_MAX_OUT_OT_RANGE;
0015B2  200144     MOV #0x14, W4
0015B4  884DA4     MOV W4, .LSM66
1155:                
1156:                ps_magnetron_mode_A.i_max_set_point      = MAX_MAGNETRON_MODE_A_CURRENT_SET_POINT;
0015B6  22CEC4     MOV #0x2CEC, W4
0015B8  884E14     MOV W4, .L24, .LSM69
1157:                
1158:                ps_magnetron_mode_A.i_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_IDAC_OUTPUT_AT_0xFFFF);
0015BA  EB0080     CLR W1
0015BC  EB8000     SETM W0
0015BE  070A9C     RCALL MakeScale
0015C0  780200     MOV W0, W4
0015C2  884E34     MOV W4, 0x9C6
1159:                ps_magnetron_mode_A.i_dac_cal_gain       = EEPROM_CAL_GAIN_1;
0015C4  220004     MOV #0x2000, W4
0015C6  884E44     MOV W4, 0x9C8
1160:                ps_magnetron_mode_A.i_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
0015C8  EB0200     CLR W4
0015CA  884E54     MOV W4, 0x9CA
1161:                
1162:                ps_magnetron_mode_A.i_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_IADC_INPUT_AT_0xFFFF);
0015CC  2411B1     MOV #0x411B, W1
0015CE  EB8000     SETM W0
0015D0  070A93     RCALL MakeScale
0015D2  780200     MOV W0, W4
0015D4  884E74     MOV W4, .L7, .LSM71
1163:                ps_magnetron_mode_A.i_adc_cal_gain       = EEPROM_CAL_GAIN_1;
0015D6  220004     MOV #0x2000, W4
0015D8  884E84     MOV W4, .LSM72
1164:                ps_magnetron_mode_A.i_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
0015DA  EB0200     CLR W4
0015DC  884E94     MOV W4, 0x9D2
1165:                ps_magnetron_mode_A.i_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_A_IADC_OVER_CURRENT_HARD, ps_magnetron_mode_A.i_adc_scale);
0015DE  804E74     MOV .L7, .LSM71, W4
0015E0  780084     MOV W4, W1
0015E2  230D40     MOV #0x30D4, W0
0015E4  070AC4     RCALL Scale16Bit
0015E6  780200     MOV W0, W4
0015E8  884EA4     MOV W4, 0x9D4
1166:                ps_magnetron_mode_A.i_adc_over_scale     = MakeScale(MAGNETRON_MODE_A_IADC_OVER_CURRENT_SCALE*8192, 8192);
0015EA  220001     MOV #0x2000, W1
0015EC  221990     MOV #0x2199, W0
0015EE  070A84     RCALL MakeScale
0015F0  780200     MOV W0, W4
0015F2  884ED4     MOV W4, 0x9DA
1167:                ps_magnetron_mode_A.i_adc_under_scale    = MakeScale(MAGNETRON_MODE_A_IADC_UNDER_CURRENT_SCALE*8192, 8192);
0015F4  220001     MOV #0x2000, W1
0015F6  21E660     MOV #0x1E66, W0
0015F8  070A7F     RCALL MakeScale
0015FA  780200     MOV W0, W4
0015FC  884EE4     MOV W4, 0x9DC
1168:                ps_magnetron_mode_A.i_adc_over_min_value = MAGNETRON_MODE_A_IADC_MIN_OVER_CURRENT;
0015FE  203E84     MOV #0x3E8, W4
001600  884EF4     MOV W4, 0x9DE
1169:                ps_magnetron_mode_A.i_adc_max_oor        = MAGNETRON_MODE_A_IADC_MAX_OUT_OT_RANGE;
001602  200144     MOV #0x14, W4
001604  884F04     MOV W4, .LSM74
1170:              
1171:                ps_magnetron_mode_A.i_adc_max_reading    = 0;
001606  EB0200     CLR W4
001608  884F34     MOV W4, 0x9E6
1172:                ps_magnetron_mode_A.i_adc_min_reading    = 0xFFFF;
00160A  EB8200     SETM W4
00160C  884F44     MOV W4, .LSM75
1173:                ps_magnetron_mode_A.v_adc_max_reading    = 0;
00160E  EB0200     CLR W4
001610  884DD4     MOV W4, 0x9BA
1174:                ps_magnetron_mode_A.v_adc_min_reading    = 0xFFFF;
001612  EB8200     SETM W4
001614  884DE4     MOV W4, 0x9BC
1175:              
1176:                //SetPowerSupplyTarget(&ps_magnetron_mode_A, ps_magnetron_mode_A_config_ram_copy[EEPROM_V_SET_POINT], ps_magnetron_mode_A_config_ram_copy[EEPROM_I_SET_POINT]);
1177:                
1178:              
1179:              
1180:                // --- ps_magnetron_mode_B initialization ---
1181:              
1182:                ps_magnetron_mode_B.warmup_ramp_time     = MAGNETRON_MODE_B_WARMUP_RAMP_TIME;
001616  EB0200     CLR W4
001618  885224     MOV W4, ps_magnetron_mode_B
1183:                
1184:                ps_magnetron_mode_B.v_max_set_point      = MAX_MAGNETRON_MODE_B_VOLTAGE_SET_POINT;
00161A  2D6D84     MOV #0xD6D8, W4
00161C  885254     MOV W4, .L8, .LSM89
1185:                
1186:                ps_magnetron_mode_B.v_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_VDAC_OUTPUT_AT_0xFFFF);
00161E  EB0080     CLR W1
001620  EB8000     SETM W0
001622  070A6A     RCALL MakeScale
001624  780200     MOV W0, W4
001626  885274     MOV W4, 0xA4E
1187:                ps_magnetron_mode_B.v_dac_cal_gain       = EEPROM_CAL_GAIN_1;
001628  220004     MOV #0x2000, W4
00162A  885284     MOV W4, 0xA50
1188:                ps_magnetron_mode_B.v_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
00162C  EB0200     CLR W4
00162E  885294     MOV W4, 0xA52
1189:                
1190:                ps_magnetron_mode_B.v_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_VADC_INPUT_AT_0xFFFF);
001630  2D8A11     MOV #0xD8A1, W1
001632  EB8000     SETM W0
001634  070A61     RCALL MakeScale
001636  780200     MOV W0, W4
001638  8852B4     MOV W4, .LSM90
1191:                ps_magnetron_mode_B.v_adc_cal_gain       = EEPROM_CAL_GAIN_1;
00163A  220004     MOV #0x2000, W4
00163C  8852C4     MOV W4, 0xA58
1192:                ps_magnetron_mode_B.v_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
00163E  EB0200     CLR W4
001640  8852D4     MOV W4, 0xA5A
1193:                ps_magnetron_mode_B.v_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_B_VADC_OVER_VOLTAGE_HARD, ps_magnetron_mode_B.v_adc_scale);
001642  8052B4     MOV .LSM90, W4
001644  780084     MOV W4, W1
001646  2CB200     MOV #0xCB20, W0
001648  070A92     RCALL Scale16Bit
00164A  780200     MOV W0, W4
00164C  8852E4     MOV W4, 0xA5C
1194:                ps_magnetron_mode_B.v_adc_over_scale     = MakeScale(MAGNETRON_MODE_B_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
00164E  220001     MOV #0x2000, W1
001650  228000     MOV #0x2800, W0
001652  070A52     RCALL MakeScale
001654  780200     MOV W0, W4
001656  885314     MOV W4, 0xA62
1195:                ps_magnetron_mode_B.v_adc_under_scale    = MakeScale(MAGNETRON_MODE_B_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
001658  220001     MOV #0x2000, W1
00165A  219990     MOV #0x1999, W0
00165C  070A4D     RCALL MakeScale
00165E  780200     MOV W0, W4
001660  885324     MOV W4, 0xA64
1196:                ps_magnetron_mode_B.v_adc_over_min_value = MAGNETRON_MODE_B_VADC_MIN_OVER_VOLTAGE;
001662  203E84     MOV #0x3E8, W4
001664  885334     MOV W4, 0xA66
1197:                ps_magnetron_mode_B.v_adc_max_oor        = MAGNETRON_MODE_B_VADC_MAX_OUT_OT_RANGE;
001666  200144     MOV #0x14, W4
001668  885344     MOV W4, 0xA68
1198:                
1199:                ps_magnetron_mode_B.i_max_set_point      = MAX_MAGNETRON_MODE_B_CURRENT_SET_POINT;
00166A  22CEC4     MOV #0x2CEC, W4
00166C  8853B4     MOV W4, .LSM94
1200:                
1201:                ps_magnetron_mode_B.i_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_IDAC_OUTPUT_AT_0xFFFF);
00166E  EB0080     CLR W1
001670  EB8000     SETM W0
001672  070A42     RCALL MakeScale
001674  780200     MOV W0, W4
001676  8853D4     MOV W4, .L42, .LSM96
1202:                ps_magnetron_mode_B.i_dac_cal_gain       = EEPROM_CAL_GAIN_1;
001678  220004     MOV #0x2000, W4
00167A  8853E4     MOV W4, .LSM97
1203:                ps_magnetron_mode_B.i_dac_cal_offset     = EEPROM_CAL_OFFSET_0;
00167C  EB0200     CLR W4
00167E  8853F4     MOV W4, .LSM98
1204:                
1205:                ps_magnetron_mode_B.i_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_IADC_INPUT_AT_0xFFFF);
001680  2411B1     MOV #0x411B, W1
001682  EB8000     SETM W0
001684  070A39     RCALL MakeScale
001686  780200     MOV W0, W4
001688  885414     MOV W4, 0xA82
1206:                ps_magnetron_mode_B.i_adc_cal_gain       = EEPROM_CAL_GAIN_1;
00168A  220004     MOV #0x2000, W4
00168C  885424     MOV W4, 0xA84
1207:                ps_magnetron_mode_B.i_adc_cal_offset     = EEPROM_CAL_OFFSET_0;
00168E  EB0200     CLR W4
001690  885434     MOV W4, 0xA86
1208:                ps_magnetron_mode_B.i_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_B_IADC_OVER_CURRENT_HARD, ps_magnetron_mode_B.i_adc_scale);
001692  805414     MOV 0xA82, W4
001694  780084     MOV W4, W1
001696  230D40     MOV #0x30D4, W0
001698  070A6A     RCALL Scale16Bit
00169A  780200     MOV W0, W4
00169C  885444     MOV W4, .LSM99
1209:                ps_magnetron_mode_B.i_adc_over_scale     = MakeScale(MAGNETRON_MODE_B_IADC_OVER_CURRENT_SCALE*8192, 8192);
00169E  220001     MOV #0x2000, W1
0016A0  221990     MOV #0x2199, W0
0016A2  070A2A     RCALL MakeScale
0016A4  780200     MOV W0, W4
0016A6  885474     MOV W4, 0xA8E
1210:                ps_magnetron_mode_B.i_adc_under_scale    = MakeScale(MAGNETRON_MODE_B_IADC_UNDER_CURRENT_SCALE*8192, 8192);
0016A8  220001     MOV #0x2000, W1
0016AA  21E660     MOV #0x1E66, W0
0016AC  070A25     RCALL MakeScale
0016AE  780200     MOV W0, W4
0016B0  885484     MOV W4, .L38, .LSM101
1211:                ps_magnetron_mode_B.i_adc_over_min_value = MAGNETRON_MODE_B_IADC_MIN_OVER_CURRENT;
0016B2  203E84     MOV #0x3E8, W4
0016B4  885494     MOV W4, 0xA92
1212:                ps_magnetron_mode_B.i_adc_max_oor        = MAGNETRON_MODE_B_IADC_MAX_OUT_OT_RANGE;
0016B6  200144     MOV #0x14, W4
0016B8  8854A4     MOV W4, 0xA94
1213:              
1214:                ps_magnetron_mode_B.i_adc_max_reading    = 0;
0016BA  EB0200     CLR W4
0016BC  8854D4     MOV W4, 0xA9A
1215:                ps_magnetron_mode_B.i_adc_min_reading    = 0xFFFF;
0016BE  EB8200     SETM W4
0016C0  8854E4     MOV W4, 0xA9C
1216:                ps_magnetron_mode_B.v_adc_max_reading    = 0;
0016C2  EB0200     CLR W4
0016C4  885374     MOV W4, 0xA6E
1217:                ps_magnetron_mode_B.v_adc_min_reading    = 0xFFFF;
0016C6  EB8200     SETM W4
0016C8  885384     MOV W4, 0xA70
1218:              
1219:                //SetPowerSupplyTarget(&ps_magnetron_mode_B, ps_magnetron_mode_B_config_ram_copy[EEPROM_V_SET_POINT], ps_magnetron_mode_B_config_ram_copy[EEPROM_I_SET_POINT]);
1220:                
1221:              
1222:              
1223:                PIN_UART2_TX = !PIN_UART2_TX;
0016CA  801655     MOV LATB, W5
0016CC  200404     MOV #0x40, W4
0016CE  628204     AND W5, W4, W4
0016D0  A7F004     BTSC W4, #15
0016D2  EA0204     NEG W4, W4
0016D4  E90204     DEC W4, W4
0016D6  DE224F     LSR W4, #15, W4
0016D8  784204     MOV.B W4, W4
0016DA  FB8204     ZE W4, W4
0016DC  620261     AND W4, #0x1, W4
0016DE  DD2246     SL W4, #6, W4
0016E0  801656     MOV LATB, W6
0016E2  2FFBF5     MOV #0xFFBF, W5
0016E4  630285     AND W6, W5, W5
0016E6  720205     IOR W4, W5, W4
0016E8  881654     MOV W4, LATB
1224:              
1225:                // --------- BEGIN IO PIN CONFIGURATION ------------------
1226:                
1227:                
1228:                // Initialize Ouput Pin Latches BEFORE setting the pins to Output
1229:                PIN_HV_LAMBDA_ENABLE = !OLL_HV_LAMBDA_ENABLED;
0016EA  A962D7     BCLR 0x2D7, #3
1230:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;
0016EC  A802D6     BSET LATD, #0
1231:              
1232:                //PIN_MAGNETRON_MAGNET_ENABLE = !OLL_MAGNETRON_MAGNET_ENABLED;
1233:                PIN_MAGNETRON_MAGNET_SO = OLL_MAGNETRON_MAGNET_OUTPUT_SHUT_OFF;
0016EE  A942D7     BCLR 0x2D7, #2
1234:                PIN_MAGNETRON_FILAMENT_ENABLE = !OLL_MAGNETRON_FILAMENT_ENABLED;
0016F0  A902D7     BCLR 0x2D7, #0
1235:                
1236:                PIN_SUM_FAULT_FIBER = !OLL_SUM_FAULT_FIBER_FAULT;
0016F2  A8E2C4     BSET LATA, #7
1237:                //DPARKER PIN REPURPOSED PIN_UART2_TX = !OLL_SPARE_OPTICAL_OUT_LIGHT_ON;
1238:                PIN_UART2_TX = !OLL_PIN_UART2_TX_LIGHT_ON;
0016F4  A9C2CA     BCLR LATB, #6
1239:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;
0016F6  A8E2CB     BSET 0x2CB, #7
1240:              
1241:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
0016F8  A9C2C4     BCLR LATA, #6
1242:                PIN_SUM_FAULT_COPPER = !OLL_SUM_FAULT_COPPER_FAULT;
0016FA  A842D0     BSET LATC, #2
1243:                PIN_LATCH_RESET = !OLL_RESET_LATCH;
0016FC  A862D6     BSET LATD, #3
1244:                PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
0016FE  A8A2E2     BSET LATF, #5
1245:                PIN_MAIN_CONTACTOR_CLOSE = !OLL_MAIN_CONTACTOR_CLOSED;
001700  A9E2CA     BCLR LATB, #7
1246:                PIN_SAMPLE_PFN_IREV = !OLL_SAMPLE_PFN_IREV_TRIGGER;
001702  A942CA     BCLR LATB, #2
1247:                PIN_RS422_DE = OLL_RS422_DE_ENABLE_RS422_DRIVER;
001704  A882E2     BSET LATF, #4
1248:                // DPARKER PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
1249:                PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
001706  A9C2CB     BCLR 0x2CB, #6
1250:              
1251:              
1252:                // External 16 bit ADC control pins
1253:                PIN_PULSE_IMON_CS = !OLL_SELECT_PULSE_IMON_ADC;
001708  A8C2D6     BSET LATD, #6
1254:                PIN_PULSE_VMON_CS = !OLL_SELECT_PULSE_VMON_ADC;
00170A  A8A2D6     BSET LATD, #5
1255:                PIN_PULSE_ADC_TRIGGER = !OLL_TRIGGER_PULSE_ADCS;
00170C  A922C5     BCLR 0x2C5, #1
1256:              
1257:                
1258:                // HV Lambda IO Pins
1259:                TRIS_PIN_HV_LAMBDA_ENABLE = TRIS_OUTPUT_MODE;
00170E  A962D3     BCLR 0x2D3, #3
1260:                TRIS_PIN_HV_LAMBDA_INHIBIT = TRIS_OUTPUT_MODE;
001710  A902D2     BCLR TRISD, #0
1261:              
1262:                TRIS_PIN_HV_LAMBDA_EOC_INPUT = TRIS_INPUT_MODE;
001712  A842D2     BSET TRISD, #2
1263:                TRIS_PIN_HV_LAMBDA_SUM_FAULT = TRIS_INPUT_MODE;
001714  A8C2CD     BSET 0x2CD, #6
1264:                TRIS_PIN_HV_LAMBDA_HV_ON_READBACK = TRIS_INPUT_MODE;
001716  A8A2CD     BSET 0x2CD, #5
1265:                TRIS_PIN_HV_LAMBDA_POWER_UP = TRIS_INPUT_MODE;
001718  A822D2     BSET TRISD, #1
1266:                
1267:              
1268:                // Magnetron Filament/Magnet Supply
1269:                TRIS_PIN_MAGNETRON_MAGNET_ENABLE = TRIS_OUTPUT_MODE;
00171A  A922D3     BCLR 0x2D3, #1
1270:                TRIS_PIN_MAGNETRON_MAGNET_SO = TRIS_OUTPUT_MODE;
00171C  A942D3     BCLR 0x2D3, #2
1271:                TRIS_PIN_MAGNETRON_FILAMENT_ENABLE = TRIS_OUTPUT_MODE;
00171E  A902D3     BCLR 0x2D3, #0
1272:              
1273:              
1274:                // Optical Input Pins
1275:                TRIS_PIN_MODULATOR_DRIVE_INPUT = TRIS_INPUT_MODE;
001720  A882C1     BSET 0x2C1, #4
1276:                TRIS_PIN_A_B_MODE_SELECT = TRIS_INPUT_MODE;
001722  A8A2C1     BSET 0x2C1, #5
1277:              
1278:                // Optical Output PIns
1279:                TRIS_PIN_SUM_FAULT_FIBER = TRIS_OUTPUT_MODE;
001724  A9E2C0     BCLR TRISA, #7
1280:                //DPARKER PIN REPURPOSED TRIS_PIN_SPARE_OPTICAL_OUT = TRIS_OUTPUT_MODE;
1281:                TRIS_PIN_UART2_TX = TRIS_OUTPUT_MODE;
001726  A9C2C6     BCLR TRISB, #6
1282:                TRIS_PIN_FAST_RESTART_STORAGE_CAP = TRIS_OUTPUT_MODE;
001728  A9E2C7     BCLR 0x2C7, #7
1283:              
1284:              
1285:                // Digital Control Input Pins
1286:                TRIS_FP_PIN_MODULATOR_ENABLE_INPUT = TRIS_INPUT_MODE;
00172A  A8C2C1     BSET 0x2C1, #6
1287:                TRIS_FP_PIN_MODULATOR_HV_ON_INPUT = TRIS_INPUT_MODE;
00172C  A8E2C1     BSET 0x2C1, #7
1288:                TRIS_FP_PIN_MODULATOR_RESET = TRIS_INPUT_MODE;
00172E  A8A2E5     BSET 0x2E5, #5
1289:                TRIS_FP_PIN_FAST_RESTART = TRIS_INPUT_MODE;
001730  A882E5     BSET 0x2E5, #4
1290:                TRIS_FP_PIN_SPARE_2_SAMPLE_VPROG_INPUT = TRIS_INPUT_MODE;
001732  A8C2E5     BSET 0x2E5, #6
1291:                TRIS_PIN_GANTRY_PORTAL_SELECT = TRIS_INPUT_MODE;
001734  A8E2E5     BSET 0x2E5, #7
1292:              
1293:              
1294:                // Analog Compartor/Latch Input Pins
1295:                TRIS_PIN_PULSE_OVER_CUR_LATCH = TRIS_INPUT_MODE;
001736  A882D2     BSET TRISD, #4
1296:                TRIS_PIN_PULSE_MIN_CUR_LATCH = TRIS_INPUT_MODE;
001738  A8E2D2     BSET TRISD, #7
1297:                TRIS_PIN_MAGNET_CURRENT_OOR_LATCH = TRIS_INPUT_MODE;
00173A  A882D3     BSET 0x2D3, #4
1298:                TRIS_PIN_FILAMENT_OV_LATCH = TRIS_INPUT_MODE;
00173C  A8A2D3     BSET 0x2D3, #5
1299:                
1300:                // Interlock Inputs
1301:                TRIS_PIN_INTERLOCK_1 = TRIS_INPUT_MODE;
00173E  A862CC     BSET TRISC, #3
1302:                TRIS_PIN_INTERLOCK_2 = TRIS_INPUT_MODE;
001740  A882CC     BSET TRISC, #4
1303:                TRIS_PIN_INTERLOCK_3 = TRIS_INPUT_MODE;
001742  A802E5     BSET 0x2E5, #0
1304:                TRIS_PIN_INTERLOCK_4 = TRIS_INPUT_MODE;
001744  A822E5     BSET 0x2E5, #1
1305:                TRIS_PIN_4_20_DRVR_FLT = TRIS_INPUT_MODE;
001746  A842C1     BSET 0x2C1, #2
1306:              
1307:                // Digital Output Pins
1308:                TRIS_PIN_THYRATRON_TRIGGER_ENABLE = TRIS_OUTPUT_MODE;
001748  A9C2C0     BCLR TRISA, #6
1309:                TRIS_PIN_SUM_FAULT_COPPER = TRIS_OUTPUT_MODE;
00174A  A942CC     BCLR TRISC, #2
1310:                TRIS_PIN_LATCH_RESET = TRIS_OUTPUT_MODE;
00174C  A962D2     BCLR TRISD, #3
1311:                TRIS_PIN_PULSE_LATCH_RESET = TRIS_OUTPUT_MODE;
00174E  A9A2DE     BCLR TRISF, #5
1312:                TRIS_PIN_MAIN_CONTACTOR_CLOSE = TRIS_OUTPUT_MODE;
001750  A9E2C6     BCLR TRISB, #7
1313:                TRIS_PIN_SAMPLE_PFN_IREV = TRIS_OUTPUT_MODE;
001752  A942C6     BCLR TRISB, #2
1314:                TRIS_PIN_RS422_DE = TRIS_OUTPUT_MODE;
001754  A982DE     BCLR TRISF, #4
1315:                TRIS_PIN_MCU_CLOCK_OUT_TEST_POINT = TRIS_OUTPUT_MODE;
001756  A9E2CD     BCLR 0x2CD, #7
1316:                TRIS_PIN_LAMBDA_VOLTAGE_SELECT = TRIS_OUTPUT_MODE;
001758  A9C2C7     BCLR 0x2C7, #6
1317:                TRIS_PIN_PULSE_IMON_CS = TRIS_OUTPUT_MODE;
00175A  A9C2D2     BCLR TRISD, #6
1318:                TRIS_PIN_PULSE_VMON_CS = TRIS_OUTPUT_MODE;
00175C  A9A2D2     BCLR TRISD, #5
1319:                TRIS_PIN_PULSE_ADC_TRIGGER = TRIS_OUTPUT_MODE;
00175E  A922C1     BCLR 0x2C1, #1
1320:              
1321:              
1322:              
1323:                // ----------- Configure Interupts -------------- //
1324:              
1325:              
1326:                // Configure INT1 Interrupt
1327:                _INT1IE = 0; // Disable Interrupt
001760  A9008E     BCLR IEC1, #0
1328:                _INT1IF = 0; // Clear Interrupt Flag  
001762  A90086     BCLR IFS1, #0
1329:                _INT1IP = 6; // Highest Priority
001764  8004E4     MOV IPC4, W4
001766  A10004     BCLR W4, #0
001768  A01004     BSET W4, #1
00176A  A02004     BSET W4, #2
00176C  8804E4     MOV W4, IPC4
1330:                _INT1EP = 0; // Positive Transition Trigger
00176E  A92082     BCLR INTCON2, #1
1331:              
1332:                // Configure T1 Interrupt
1333:                _T1IE = 0;  // Disable Interrupt
001770  A9608C     BCLR IEC0, #3
1334:                _T1IF = 0;  // Clear Interrupt Flag  
001772  A96084     BCLR IFS0, #3
1335:                _T1IP = 5;  // Lower Priority than INT1, Higher than everything else  
001774  8004A4     MOV IPC0, W4
001776  A0C004     BSET W4, #12
001778  A1D004     BCLR W4, #13
00177A  A0E004     BSET W4, #14
00177C  8804A4     MOV W4, IPC0
1336:              
1337:                // Configure ADC Interrupt
1338:                _ADIE = 0;
00177E  A9608D     BCLR 0x8D, #3
1339:                _ADIF = 0;
001780  A96085     BCLR 0x85, #3
1340:                _ADIP = 3;
001782  8004C4     MOV IPC2, W4
001784  A0C004     BSET W4, #12
001786  A0D004     BSET W4, #13
001788  A1E004     BCLR W4, #14
00178A  8804C4     MOV W4, IPC2
1341:              
1342:              
1343:                // Configure Change Notification Interrupt
1344:                _CNIF = 0;
00178C  A9E085     BCLR 0x85, #7
1345:                _CN16IE = 1;  // Allow Change notification on CN16 (PULSE MINIMUM CURRENT LATCH)
00178E  A800C2     BSET CNEN2, #0
1346:                _CNIE = 1;
001790  A8E08D     BSET 0x8D, #7
1347:                _CNIP = 4;
001792  8004D4     MOV IPC3, W4
001794  A1C004     BCLR W4, #12
001796  A1D004     BCLR W4, #13
001798  A0E004     BSET W4, #14
00179A  8804D4     MOV W4, IPC3
1348:                
1349:              
1350:              
1351:                // Configure UART Interrupts
1352:                _U1RXIE = 0;
00179C  A9208D     BCLR 0x8D, #1
1353:                _U1RXIP = 5;
00179E  8004C4     MOV IPC2, W4
0017A0  A04004     BSET W4, #4
0017A2  A15004     BCLR W4, #5
0017A4  A06004     BSET W4, #6
0017A6  8804C4     MOV W4, IPC2
1354:                
1355:                _U1TXIE = 0;
0017A8  A9408D     BCLR 0x8D, #2
1356:                _U1RXIP = 5;
0017AA  8004C4     MOV IPC2, W4
0017AC  A04004     BSET W4, #4
0017AE  A15004     BCLR W4, #5
0017B0  A06004     BSET W4, #6
0017B2  8804C4     MOV W4, IPC2
1357:              
1358:              
1359:                // Configure LVD Interrupt
1360:                _LVDIF = 0;
0017B4  A94089     BCLR 0x89, #2
1361:                _LVDIE = 0;
0017B6  A94091     BCLR 0x91, #2
1362:                _LVDIP = 7;
0017B8  800544     MOV IPC10, W4
0017BA  A08004     BSET W4, #8
0017BC  A09004     BSET W4, #9
0017BE  A0A004     BSET W4, #10
0017C0  880544     MOV W4, IPC10
1363:                _LVDL = 0b1100;  //DPARKER LVDL should trigger at 4.1 Volts
0017C2  803A04     MOV RCON, W4
0017C4  A18004     BCLR W4, #8
0017C6  A19004     BCLR W4, #9
0017C8  A0A004     BSET W4, #10
0017CA  A0B004     BSET W4, #11
0017CC  883A04     MOV W4, RCON
1364:              
1365:                
1366:              
1367:                // --------- CONFIGURATION FOR THE I2C BUS ---------------- //
1368:                I2CCON = I2CCON_SETUP;
0017CE  2F00F4     MOV #0xF00F, W4
0017D0  881034     MOV W4, I2CCON
1369:                I2CBRG = I2C_BAUD_RATE_GENERATOR;  // Configure I2C bus based on H file parameters
0017D2  2011E4     MOV #0x11E, W4
0017D4  881024     MOV W4, I2CBRG
1370:              
1371:              
1372:              
1373:                // --------- CONFIGURATION FOR THE SPI BUSSES ---------------- //
1374:                OpenSPI1((A34760_SPI1CON_VALUE & A34760_SPI1CON_CLOCK), A34760_SPI1STAT_VALUE);  // Configure SPI bus 1 based on H file parameters
0017D6  2DFBF1     MOV #0xDFBF, W1
0017D8  2B53E0     MOV #0xB53E, W0
0017DA  07F518     RCALL _OpenSPI1
1375:                OpenSPI2((A34760_SPI2CON_VALUE & A34760_SPI2CON_CLOCK), A34760_SPI2STAT_VALUE);  // Configure SPI bus 2 based on H file parameters
0017DC  2DFBF1     MOV #0xDFBF, W1
0017DE  2BF3D0     MOV #0xBF3D, W0
0017E0  07F518     RCALL _OpenSPI2
1376:                
1377:              
1378:                // ------ CONFIGURE the CAN Modules to be OFF -------------- //
1379:                C1CTRL = 0b0000000100000000;
0017E2  201004     MOV #0x100, W4
0017E4  881C84     MOV W4, C1CTRL
1380:                C2CTRL = 0b0000000100000000;
0017E6  201004     MOV #0x100, W4
0017E8  882284     MOV W4, C2CTRL
1381:                
1382:              
1383:                // ----------------- UART #1 Setup and Data Buffer -------------------------//
1384:                // Setup the UART input and output buffers
1385:                uart1_input_buffer.write_location = 0;  
0017EA  EB4200     CLR.B W4
0017EC  780004     MOV W4, W0
0017EE  B7E8DA     MOV.B WREG, 0x8DA
1386:                uart1_input_buffer.read_location = 0;
0017F0  EB4200     CLR.B W4
0017F2  780004     MOV W4, W0
0017F4  B7E8DB     MOV.B WREG, 0x8DB
1387:                uart1_output_buffer.write_location = 0;
0017F6  EB4200     CLR.B W4
0017F8  780004     MOV W4, W0
0017FA  B7E91C     MOV.B WREG, 0x91C
1388:                uart1_output_buffer.read_location = 0;
0017FC  EB4200     CLR.B W4
0017FE  780004     MOV W4, W0
001800  B7E91D     MOV.B WREG, 0x91D
1389:              
1390:                U1MODE = A34760_U1MODE_VALUE;
001802  2FF004     MOV #0xFF00, W4
001804  881064     MOV W4, U1MODE
1391:                U1BRG = A34760_U1BRG_VALUE;
001806  200BF4     MOV #0xBF, W4
001808  8810A4     MOV W4, U1BRG
1392:                U1STA = A34760_U1STA_VALUE;
00180A  2775F4     MOV #0x775F, W4
00180C  881074     MOV W4, U1STA
1393:                
1394:              
1395:              
1396:               // ---------- Configure Timers ----------------- //
1397:              
1398:              
1399:                // Configure TMR1
1400:                T1CON = A34760_T1CON_VALUE;
00180E  25FAD4     MOV #0x5FAD, W4
001810  880824     MOV W4, T1CON
1401:              
1402:              
1403:                // Configure TMR2
1404:                T2CON = A34760_T2CON_VALUE;
001812  25FA54     MOV #0x5FA5, W4
001814  880884     MOV W4, T2CON
1405:                PR2 = A34760_PR2_VALUE;  
001816  2B4054     MOV #0xB405, W4
001818  880864     MOV W4, PR2
1406:                TMR2 = 0;
00181A  EB0200     CLR W4
00181C  880834     MOV W4, TMR2
1407:                _T2IF = 0;
00181E  A9C084     BCLR IFS0, #6
1408:              
1409:              
1410:                
1411:                /*  This was for a 10MHZ clock
1412:                // Configure TMR3
1413:                // Setup Timer 3 to measure interpulse period.
1414:                T3CON = (T3_ON & T3_IDLE_CON & T3_GATE_OFF & T3_PS_1_64 & T3_SOURCE_INT);
1415:                PR3 = 62500;  // 400mS
1416:                */
1417:              
1418:                // For 29.495 MHz Clock
1419:                T3CON = (T3_ON & T3_IDLE_CON & T3_GATE_OFF & T3_PS_1_64 & T3_SOURCE_INT);
001820  2DFAD4     MOV #0xDFAD, W4
001822  880894     MOV W4, T3CON
1420:                PR3 = 46085;  // 100mS
001824  2B4054     MOV #0xB405, W4
001826  880874     MOV W4, PR3
1421:              
1422:                
1423:                // Configure TMR4
1424:                T4CON = A34760_T4CON_VALUE;
001828  25F854     MOV #0x5F85, W4
00182A  8808F4     MOV W4, T4CON
1425:              
1426:              
1427:                // Configure TMR5
1428:                T5CON = A34760_T5CON_VALUE;
00182C  25F9D4     MOV #0x5F9D, W4
00182E  880904     MOV W4, T5CON
1429:                TMR5 = 0;
001830  EB0200     CLR W4
001832  8808C4     MOV W4, TMR5
1430:                _T5IF = 0;
001834  A9C086     BCLR IFS1, #6
1431:                PR5 = A34760_PR5_VALUE; 
001836  290044     MOV #0x9004, W4
001838  8808E4     MOV W4, PR5
1432:              
1433:              
1434:              
1435:              
1436:              
1437:                // --------------- Initialize U44 - LTC2656 ------------------------- //
1438:                U44_LTC2656.pin_cable_select = _PIN_RD15;
00183A  200DF4     MOV #0xDF, W4
00183C  8848F4     MOV W4, U44_LTC2656
1439:                U44_LTC2656.pin_load_dac = _PIN_RD14;
00183E  200DE4     MOV #0xDE, W4
001840  884914     MOV W4, 0x922
1440:                U44_LTC2656.pin_por_select = _PIN_NOT_CONNECTED;
001842  200204     MOV #0x20, W4
001844  884924     MOV W4, 0x924
1441:                U44_LTC2656.por_select_value = 0;
001846  EB0200     CLR W4
001848  884934     MOV W4, 0x926
1442:                U44_LTC2656.spi_port = SPI_PORT_1;
00184A  B3C014     MOV.B #0x1, W4
00184C  780004     MOV W4, W0
00184E  B7E928     MOV.B WREG, .L27, .LSM49
1443:              #ifndef __A36760
1444:                U44_LTC2656.pin_dac_clear = _PIN_RB15;
1445:              #else
1446:                U44_LTC2656.pin_dac_clear = _PIN_NOT_CONNECTED;
001850  200204     MOV #0x20, W4
001852  884904     MOV W4, 0x920
1447:              #endif
1448:              
1449:              
1450:                SetupLTC2656(&U44_LTC2656);
001854  2091E0     MOV #0x91E, W0
001856  071B2F     RCALL SetupLTC2656
1451:                
1452:              
1453:                // ---------------- Initialize U64 - MCP23017 ----------------//
1454:              
1455:                U64_MCP23017.address = MCP23017_ADDRESS_0;
001858  B3C404     MOV.B #0x40, W4
00185A  FD0200     EXCH W0, W4
00185C  B7E930     MOV.B WREG, 0x930
00185E  FD0200     EXCH W0, W4
1456:                U64_MCP23017.i2c_port = I2C_PORT;
001860  EB4200     CLR.B W4
001862  FD0200     EXCH W0, W4
001864  B7E931     MOV.B WREG, 0x931
001866  FD0200     EXCH W0, W4
1457:                U64_MCP23017.pin_reset = _PIN_NOT_CONNECTED;
001868  200204     MOV #0x20, W4
00186A  884954     MOV W4, U64_MCP23017
1458:                U64_MCP23017.pin_int_a = _PIN_NOT_CONNECTED;
00186C  200204     MOV #0x20, W4
00186E  884964     MOV W4, 0x92C
1459:                U64_MCP23017.pin_int_b = _PIN_NOT_CONNECTED;
001870  200204     MOV #0x20, W4
001872  884974     MOV W4, 0x92E
1460:                U64_MCP23017.output_latch_a_in_ram = MCP23017_U64_LATA_INITIAL;
001874  EBC200     SETM.B W4
001876  FD0200     EXCH W0, W4
001878  B7E932     MOV.B WREG, .LSM50
00187A  FD0200     EXCH W0, W4
1461:                U64_MCP23017.output_latch_b_in_ram = MCP23017_U64_LATB_INITIAL;
00187C  EBC200     SETM.B W4
00187E  FD0200     EXCH W0, W4
001880  B7E933     MOV.B WREG, 0x933
001882  FD0200     EXCH W0, W4
1462:              
1463:              
1464:                ResetAllFaults();
001884  0715CA     RCALL ResetAllFaults
1465:              
1466:                
1467:                /*
1468:                  Check to See if this was a faulty processor Reset.
1469:                  If it was a faulty processor Reset, the following must occur
1470:                  * Durring warmup, if the Fast Restart Pin is set, the warmup will be truncated to 2 seconds
1471:                  
1472:                  * Read persistent RAM values and save to EEPROM as nessesary
1473:                  1) When the processor restarts, copy the persistent counters to a new RAM locations
1474:                  2) Load values from EEPROM
1475:                  3) The following statement *should* be true
1476:                  4) pulse_counter_persistent(from_before_arc) = pulse_counter_persistent(stored_in_EEPROM) + pulse_counter_this_hv_on(from_before_arc)
1477:                  4a) If that math works out, save the pulse information.  If that math does not work out, throw away pre-arc data and just reload from EEPROM
1478:                */
1479:                /*
1480:                pulse_counter_persistent_store = pulse_counter_persistent;
1481:                pulse_counter_this_hv_on_store = pulse_counter_this_hv_on;
1482:                arc_counter_persistent_store = arc_counter_persistent;
1483:                arc_counter_this_hv_on_store = arc_counter_this_hv_on;
1484:              
1485:              
1486:                if (PIN_FP_FAST_RESTART == ILL_FAST_RESTART) {
1487:                  if (pulse_counter_persistent_store > 5) {
1488:                    pulse_counter_persistent_store -= 5;
1489:                  }
1490:                  if ((pulse_counter_persistent + pulse_counter_this_hv_on_store) > pulse_counter_persistent_store) {
1491:                    if ((pulse_counter_persistent + pulse_counter_this_hv_on_store) < (pulse_counter_persistent_store + 10)) {
1492:              	pulse_counter_persistent = pulse_counter_persistent_store + 5;
1493:                    }
1494:                  }
1495:                  
1496:                  if (arc_counter_persistent_store > 5) {
1497:                    arc_counter_persistent_store -= 5;
1498:                  }
1499:                  if ((arc_counter_persistent + arc_counter_this_hv_on_store) > arc_counter_persistent_store) {
1500:                    if ((arc_counter_persistent + arc_counter_this_hv_on_store) < (arc_counter_persistent_store + 10)) {
1501:              	arc_counter_persistent = arc_counter_persistent_store + 5;
1502:                    }
1503:                  }
1504:                  
1505:                  SavePulseCountersToEEPROM();
1506:                  }
1507:                */   
1508:              
1509:              
1510:               
1511:              }
001886  78044F     MOV [--W15], W8
001888  FA8000     ULNK
00188A  060000     RETURN
1512:              
1513:              
1514:              
1515:              void DoA34760StartUpNormalProcess(void) {
00188C  FA0002     LNK #0x2
1516:                unsigned int i2c_test = 0;
00188E  EB0200     CLR W4
001890  780F04     MOV W4, [W14]
1517:              
1518:                // This was a not a reset from a fast crash so clear the reset data
1519:                debug_status_register = 0;
001892  EB0200     CLR W4
001894  88B9F4     MOV W4, debug_status_register
1520:                _POR = 0;
001896  A90740     BCLR RCON, #0
1521:                _EXTR = 0;
001898  A9E740     BCLR RCON, #7
1522:                _SWR = 0;
00189A  A9C740     BCLR RCON, #6
1523:                _BOR = 0;
00189C  A92740     BCLR RCON, #1
1524:                _TRAPR = 0;
00189E  A9E741     BCLR 0x741, #7
1525:                _WDTO = 0;
0018A0  A98740     BCLR RCON, #4
1526:                _IOPUWR = 0;
0018A2  A9C741     BCLR 0x741, #6
1527:                last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
0018A4  EB0200     CLR W4
0018A6  88BDE4     MOV W4, last_known_action
1528:                processor_crash_count = 0;
0018A8  EB0200     CLR W4
0018AA  88BE04     MOV W4, processor_crash_count
1529:                
1530:                ClearOutputsLTC2656(&U44_LTC2656);
0018AC  2091E0     MOV #0x91E, W0
0018AE  071B3A     RCALL ClearOutputsLTC2656
1531:                
1532:                // Test U64 - MCP23017
1533:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
0018B0  EB4100     CLR.B W2
0018B2  B3C0A1     MOV.B #0xA, W1
0018B4  2092A0     MOV #0x92A, W0
0018B6  071F67     RCALL MCP23017WriteSingleByte
0018B8  780200     MOV W0, W4
0018BA  720F1E     IOR W4, [W14], [W14]
1534:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
0018BC  EB4100     CLR.B W2
0018BE  B3C0A1     MOV.B #0xA, W1
0018C0  2092A0     MOV #0x92A, W0
0018C2  071F61     RCALL MCP23017WriteSingleByte
0018C4  780200     MOV W0, W4
0018C6  720F1E     IOR W4, [W14], [W14]
1535:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
0018C8  EB4100     CLR.B W2
0018CA  B3C0A1     MOV.B #0xA, W1
0018CC  2092A0     MOV #0x92A, W0
0018CE  071F5B     RCALL MCP23017WriteSingleByte
0018D0  780200     MOV W0, W4
0018D2  720F1E     IOR W4, [W14], [W14]
1536:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATA, U64_MCP23017.output_latch_a_in_ram);
0018D4  209324     MOV #0x932, W4
0018D6  784214     MOV.B [W4], W4
0018D8  784104     MOV.B W4, W2
0018DA  B3C141     MOV.B #0x14, W1
0018DC  2092A0     MOV #0x92A, W0
0018DE  071F53     RCALL MCP23017WriteSingleByte
0018E0  780200     MOV W0, W4
0018E2  720F1E     IOR W4, [W14], [W14]
1537:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATB, U64_MCP23017.output_latch_b_in_ram);
0018E4  209334     MOV #0x933, W4
0018E6  784214     MOV.B [W4], W4
0018E8  784104     MOV.B W4, W2
0018EA  B3C151     MOV.B #0x15, W1
0018EC  2092A0     MOV #0x92A, W0
0018EE  071F4B     RCALL MCP23017WriteSingleByte
0018F0  780200     MOV W0, W4
0018F2  720F1E     IOR W4, [W14], [W14]
1538:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRA, MCP23017_U64_IODIRA_VALUE);
0018F4  B3CF82     MOV.B #0xF8, W2
0018F6  EB4080     CLR.B W1
0018F8  2092A0     MOV #0x92A, W0
0018FA  071F45     RCALL MCP23017WriteSingleByte
0018FC  780200     MOV W0, W4
0018FE  720F1E     IOR W4, [W14], [W14]
1539:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRB, MCP23017_U64_IODIRB_VALUE);
001900  EB4100     CLR.B W2
001902  B3C011     MOV.B #0x1, W1
001904  2092A0     MOV #0x92A, W0
001906  071F3F     RCALL MCP23017WriteSingleByte
001908  780200     MOV W0, W4
00190A  720F1E     IOR W4, [W14], [W14]
1540:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IPOLA, MCP23017_U64_IPOLA_VALUE);
00190C  EB4100     CLR.B W2
00190E  B3C021     MOV.B #0x2, W1
001910  2092A0     MOV #0x92A, W0
001912  071F39     RCALL MCP23017WriteSingleByte
001914  780200     MOV W0, W4
001916  720F1E     IOR W4, [W14], [W14]
1541:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IPOLB, MCP23017_U64_IPOLB_VALUE);
001918  EB4100     CLR.B W2
00191A  B3C031     MOV.B #0x3, W1
00191C  2092A0     MOV #0x92A, W0
00191E  071F33     RCALL MCP23017WriteSingleByte
001920  780200     MOV W0, W4
001922  720F1E     IOR W4, [W14], [W14]
1542:                  
1543:                if ((i2c_test & 0xFF00) == 0xFA00) {
001924  2FF004     MOV #0xFF00, W4
001926  62029E     AND W4, [W14], W5
001928  2FA004     MOV #0xFA00, W4
00192A  528F84     SUB W5, W4, [W15]
00192C  3A0007     BRA NZ, .L105, .LSM743
1544:                  // There was a fault on the i2c bus, the MCP23017 did not initialize properly
1545:                  debug_status_register |= STATUS_DIGITAL_IO_EXP_ERROR;
00192E  80B9F5     MOV debug_status_register, W5
001930  200804     MOV #0x80, W4
001932  720205     IOR W4, W5, W4
001934  88B9F4     MOV W4, debug_status_register
1546:                  global_debug_counter.i2c_bus_error++;
001936  80B964     MOV .LSM629, W4
001938  E80204     INC W4, W4
00193A  88B964     MOV W4, .LSM629
1547:                }
1548:                
1549:                i2c_test = MCP23017ReadSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRA);
00193C  EB4080     CLR.B W1
00193E  2092A0     MOV #0x92A, W0
001940  071F54     RCALL MCP23017ReadSingleByte
001942  780200     MOV W0, W4
001944  780F04     MOV W4, [W14]
1550:                if ((i2c_test & 0x00FF) != MCP23017_U64_IODIRA_VALUE) {
001946  200FF4     MOV #0xFF, W4
001948  62029E     AND W4, [W14], W5
00194A  200F84     MOV #0xF8, W4
00194C  528F84     SUB W5, W4, [W15]
00194E  320007     BRA Z, .L106, .LSM747
1551:                  // The MCP Write/Read operation failed
1552:                  debug_status_register |= STATUS_DIGITAL_IO_EXP_ERROR;
001950  80B9F5     MOV debug_status_register, W5
001952  200804     MOV #0x80, W4
001954  720205     IOR W4, W5, W4
001956  88B9F4     MOV W4, debug_status_register
1553:                  global_debug_counter.i2c_bus_error++;
001958  80B964     MOV .LSM629, W4
00195A  E80204     INC W4, W4
00195C  88B964     MOV W4, .LSM629
1554:                }
1555:               
1556:                DisableMagnetronFilamentSupply();
00195E  070800     RCALL DisableMagnetronFilamentSupply
1557:                DisableMagnetronMagnetSupply();
001960  070807     RCALL DisableMagnetronMagnetSupply
1558:                DisableHVLambdaSupply();
001962  07080A     RCALL DisableHVLambdaSupply
1559:              }
001964  FA8000     ULNK
001966  060000     RETURN
1560:              
1561:              
1562:              
1563:              
1564:              
1565:              
1566:              void DoA34760StartUpFastProcess(void) {
001968  FA0006     LNK #0x6
1567:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
1568:                unsigned int vtemp;
1569:              #endif
1570:                
1571:                unsigned int vtemp_2;
1572:                unsigned int itemp_2;
1573:              
1574:                processor_crash_count++;
00196A  80BE04     MOV processor_crash_count, W4
00196C  E80204     INC W4, W4
00196E  88BE04     MOV W4, processor_crash_count
1575:              
1576:                // DPARKER - WHAT IS THE FAST RESET COUNTER PERSISTENT AND DO WE STILL NEED IT
1577:                //fast_reset_counter_persistent++;
1578:                //pulse_counter_repository_ram_copy[6] = fast_reset_counter_persistent;
1579:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART;
001970  A9E2CB     BCLR 0x2CB, #7
1580:              
1581:                // Taken from StartWarmUp(); & the start of State Warm Ready
1582:                PIDInit(&thyratron_reservoir_heater_PID);
001972  2087A0     MOV #0x87A, W0
001974  07F42E     RCALL _PIDInit
1583:                PIDInit(&thyratron_cathode_heater_PID);
001976  2088A0     MOV #0x88A, W0
001978  07F42C     RCALL _PIDInit
1584:              
1585:                // DPARKER, there are a lot more power supply configuration calls going on here than are needed, that is a lot of wasted CPU cycles as these are complex math operations
1586:                ScalePowerSupply(&ps_hv_lambda_mode_A,100,100);   // DPARKER this may be re-adjusted below
00197A  200642     MOV #0x64, W2
00197C  200641     MOV #0x64, W1
00197E  209360     MOV #0x936, W0
001980  0700F1     RCALL ScalePowerSupply
1587:                ScalePowerSupply(&ps_hv_lambda_mode_B,100,100);   // DPARKER this may be re-adjusted below
001982  200642     MOV #0x64, W2
001984  200641     MOV #0x64, W1
001986  209EA0     MOV #0x9EA, W0
001988  0700ED     RCALL ScalePowerSupply
1588:                ScalePowerSupply(&ps_filament,100,100);           // DPARKER this may be re-adjusted below
00198A  200642     MOV #0x64, W2
00198C  200641     MOV #0x64, W1
00198E  20AF80     MOV #0xAF8, W0
001990  0700E9     RCALL ScalePowerSupply
1589:                ScalePowerSupply(&ps_magnet,100,100);             // DPARKER this may be re-adjusted below
001992  200642     MOV #0x64, W2
001994  200641     MOV #0x64, W1
001996  20A9E0     MOV #0xA9E, W0
001998  0700E5     RCALL ScalePowerSupply
1590:                ScalePowerSupply(&ps_thyr_reservoir_htr,100,100); // DPARKER this is not actually being used
00199A  200642     MOV #0x64, W2
00199C  200641     MOV #0x64, W1
00199E  20BAC0     MOV #0xBAC, W0
0019A0  0700E1     RCALL ScalePowerSupply
1591:                ScalePowerSupply(&ps_thyr_cathode_htr,100,100);   // DPARKER this is not actually being used
0019A2  200642     MOV #0x64, W2
0019A4  200641     MOV #0x64, W1
0019A6  20B520     MOV #0xB52, W0
0019A8  0700DD     RCALL ScalePowerSupply
1592:              
1593:                EnableMagnetronMagnetSupply();
0019AA  0707DE     RCALL EnableMagnetronMagnetSupply
1594:                EnableMagnetronFilamentSupply();
0019AC  0707D5     RCALL EnableMagnetronFilamentSupply
1595:                HVLambdaStartCharging();  // DPARKER TMR1 and TMR2 must be initialized and ready to go before this call. DPARKER T1 Interrupt must also be ready to go
0019AE  070885     RCALL HVLambdaStartCharging
1596:                _T1IE = 0;  // We don't want to enter the interrupt until we get to STATE_HV_ON
0019B0  A9608C     BCLR IEC0, #3
1597:              
1598:                PIN_UART2_TX = !PIN_UART2_TX;
0019B2  801655     MOV LATB, W5
0019B4  200404     MOV #0x40, W4
0019B6  628204     AND W5, W4, W4
0019B8  A7F004     BTSC W4, #15
0019BA  EA0204     NEG W4, W4
0019BC  E90204     DEC W4, W4
0019BE  DE224F     LSR W4, #15, W4
0019C0  784204     MOV.B W4, W4
0019C2  FB8204     ZE W4, W4
0019C4  620261     AND W4, #0x1, W4
0019C6  DD2246     SL W4, #6, W4
0019C8  801656     MOV LATB, W6
0019CA  2FFBF5     MOV #0xFFBF, W5
0019CC  630285     AND W6, W5, W5
0019CE  720205     IOR W4, W5, W4
0019D0  881654     MOV W4, LATB
1599:                // Setup the ADC to read PAC and save to RAM as appropriate
1600:                FastReadAndFilterPACInputs();
0019D2  070688     RCALL FastReadAndFilterPACInputs
1601:                PIN_UART2_TX = !PIN_UART2_TX;
0019D4  801655     MOV LATB, W5
0019D6  200404     MOV #0x40, W4
0019D8  628204     AND W5, W4, W4
0019DA  A7F004     BTSC W4, #15
0019DC  EA0204     NEG W4, W4
0019DE  E90204     DEC W4, W4
0019E0  DE224F     LSR W4, #15, W4
0019E2  784204     MOV.B W4, W4
0019E4  FB8204     ZE W4, W4
0019E6  620261     AND W4, #0x1, W4
0019E8  DD2246     SL W4, #6, W4
0019EA  801656     MOV LATB, W6
0019EC  2FFBF5     MOV #0xFFBF, W5
0019EE  630285     AND W6, W5, W5
0019F0  720205     IOR W4, W5, W4
0019F2  881654     MOV W4, LATB
1602:              
1603:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
1604:                if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
0019F4  801735     MOV PORTG, W5
0019F6  240004     MOV #0x4000, W4
0019F8  628204     AND W5, W4, W4
0019FA  520FE0     SUB W4, #0x0, [W15]
0019FC  3A0014     BRA NZ, .L108, .LSM774
1605:                  vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
0019FE  8042D4     MOV pac_1_adc_reading, W4
001A00  20C351     MOV #0xC35, W1
001A02  780004     MOV W4, W0
001A04  0708B4     RCALL Scale16Bit
001A06  780200     MOV W0, W4
001A08  780F04     MOV W4, [W14]
1606:                  SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp, 0);
001A0A  EB0100     CLR W2
001A0C  78009E     MOV [W14], W1
001A0E  209360     MOV #0x936, W0
001A10  070077     RCALL SetPowerSupplyTarget
1607:                  
1608:                  vtemp = Scale16Bit(pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
001A12  8042E4     MOV pac_2_adc_reading, W4
001A14  20C351     MOV #0xC35, W1
001A16  780004     MOV W4, W0
001A18  0708AA     RCALL Scale16Bit
001A1A  780200     MOV W0, W4
001A1C  780F04     MOV W4, [W14]
1609:                  SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
001A1E  EB0100     CLR W2
001A20  78009E     MOV [W14], W1
001A22  209EA0     MOV #0x9EA, W0
001A24  07006D     RCALL SetPowerSupplyTarget
1610:                }
1611:              #endif
1612:                
1613:                if (!ram_config_set_magnetron_magnet_current_from_GUI) {
001A26  208444     MOV #0x844, W4
001A28  784214     MOV.B [W4], W4
001A2A  524FE0     SUB.B W4, #0x0, [W15]
001A2C  3A000D     BRA NZ, .L109, .LSM778
1614:                  // The Magnet Current is calculated from Mode A program voltage
1615:                  itemp_2 = CalculatePoly(ps_hv_lambda_mode_A.v_command_set_point);
001A2E  8049C4     MOV 0x938, W4
001A30  780004     MOV W4, W0
001A32  070C21     RCALL CalculatePoly
001A34  780200     MOV W0, W4
001A36  980714     MOV W4, [W14+2]
1616:                  vtemp_2 = GenerateMagnetVprog(itemp_2);
001A38  90001E     MOV [W14+2], W0
001A3A  07123A     RCALL GenerateMagnetVprog
001A3C  780200     MOV W0, W4
001A3E  980724     MOV W4, [W14+4]
1617:                  SetPowerSupplyTarget(&ps_magnet, vtemp_2, itemp_2);
001A40  90011E     MOV [W14+2], W2
001A42  9000AE     MOV [W14+4], W1
001A44  20A9E0     MOV #0xA9E, W0
001A46  07005C     RCALL SetPowerSupplyTarget
1618:                }
1619:                  
1620:                // DPARKER Calculate and Setup Magnetron Filament Power
1621:                // DoMagnetronFilamentAdjust();  
1622:                PIN_UART2_TX = !PIN_UART2_TX;
001A48  801655     MOV LATB, W5
001A4A  200404     MOV #0x40, W4
001A4C  628204     AND W5, W4, W4
001A4E  A7F004     BTSC W4, #15
001A50  EA0204     NEG W4, W4
001A52  E90204     DEC W4, W4
001A54  DE224F     LSR W4, #15, W4
001A56  784204     MOV.B W4, W4
001A58  FB8204     ZE W4, W4
001A5A  620261     AND W4, #0x1, W4
001A5C  DD2246     SL W4, #6, W4
001A5E  801656     MOV LATB, W6
001A60  2FFBF5     MOV #0xFFBF, W5
001A62  630285     AND W6, W5, W5
001A64  720205     IOR W4, W5, W4
001A66  881654     MOV W4, LATB
1623:                UpdateDacAll();
001A68  0701C7     RCALL UpdateDacAll
1624:              
1625:              
1626:                PIN_UART2_TX = !PIN_UART2_TX;
001A6A  801655     MOV LATB, W5
001A6C  200404     MOV #0x40, W4
001A6E  628204     AND W5, W4, W4
001A70  A7F004     BTSC W4, #15
001A72  EA0204     NEG W4, W4
001A74  E90204     DEC W4, W4
001A76  DE224F     LSR W4, #15, W4
001A78  784204     MOV.B W4, W4
001A7A  FB8204     ZE W4, W4
001A7C  620261     AND W4, #0x1, W4
001A7E  DD2246     SL W4, #6, W4
001A80  801656     MOV LATB, W6
001A82  2FFBF5     MOV #0xFFBF, W5
001A84  630285     AND W6, W5, W5
001A86  720205     IOR W4, W5, W4
001A88  881654     MOV W4, LATB
1627:                FastReadAndFilterFeedbacks(); // DPARKER - Move this to as late as possible (want time to feedbacks to get as stable as possible before reading)
001A8A  070564     RCALL FastReadAndFilterFeedbacks
1628:                PIN_UART2_TX = !PIN_UART2_TX;
001A8C  801655     MOV LATB, W5
001A8E  200404     MOV #0x40, W4
001A90  628204     AND W5, W4, W4
001A92  A7F004     BTSC W4, #15
001A94  EA0204     NEG W4, W4
001A96  E90204     DEC W4, W4
001A98  DE224F     LSR W4, #15, W4
001A9A  784204     MOV.B W4, W4
001A9C  FB8204     ZE W4, W4
001A9E  620261     AND W4, #0x1, W4
001AA0  DD2246     SL W4, #6, W4
001AA2  801656     MOV LATB, W6
001AA4  2FFBF5     MOV #0xFFBF, W5
001AA6  630285     AND W6, W5, W5
001AA8  720205     IOR W4, W5, W4
001AAA  881654     MOV W4, LATB
1629:              
1630:                // DPARKER - convert filament voltage readback to the program that will the exact same value.  Scale the filament to that value.  Do all this before you program the DAC
1631:              
1632:                control_state = STATE_HV_ON;  //  Want to check the faults based on STATE_HV_ON
001AAC  B3C444     MOV.B #0x44, W4
001AAE  FD0200     EXCH W0, W4
001AB0  B7E858     MOV.B WREG, control_state
001AB2  FD0200     EXCH W0, W4
1633:                UpdateFaults();
001AB4  071384     RCALL UpdateFaults
1634:                control_state = STATE_FAST_RECOVERY_START_UP;
001AB6  B3C064     MOV.B #0x6, W4
001AB8  780004     MOV W4, W0
001ABA  B7E858     MOV.B WREG, control_state
1635:                
1636:                // DPARKER - NO CONFIG/CHANGES to the I/O Expander for NOW
1637:              }
001ABC  FA8000     ULNK
001ABE  060000     RETURN
1638:              
1639:              
1640:              
1641:              
1642:              void DoA34760StartUpCommonPostProcess(void) {
001AC0  FA0000     LNK #0x0
1643:                
1644:                T2CONbits.TON = 1;
001AC2  A8E111     BSET 0x111, #7
1645:                T5CONbits.TON = 1;
001AC4  A8E121     BSET 0x121, #7
1646:                
1647:                // ---- Configure the dsPIC ADC Module ------------ //
1648:                ADCON1 = A34760_ADCON1_VALUE;             // Configure the high speed ADC module based on H file parameters
001AC6  27CFF4     MOV #0x7CFF, W4
001AC8  881504     MOV W4, ADCON1
1649:                ADCON2 = A34760_ADCON2_VALUE;             // Configure the high speed ADC module based on H file parameters
001ACA  20FE84     MOV #0xFE8, W4
001ACC  881514     MOV W4, ADCON2
1650:                ADCON3 = A34760_ADCON3_VALUE;             // Configure the high speed ADC module based on H file parameters
001ACE  2E3534     MOV #0xE353, W4
001AD0  881524     MOV W4, ADCON3
1651:                ADCHS  = A34760_ADCHS_VALUE;              // Configure the high speed ADC module based on H file parameters
001AD2  2EFE34     MOV #0xEFE3, W4
001AD4  881534     MOV W4, ADCHS
1652:              
1653:                ADPCFG = A34760_ADPCFG_VALUE;             // Set which pins are analog and which are digital I/O
001AD6  2C0074     MOV #0xC007, W4
001AD8  881544     MOV W4, ADPCFG
1654:                ADCSSL = A34760_ADCSSL_VALUE;             // Set which analog pins are scanned
001ADA  23FF84     MOV #0x3FF8, W4
001ADC  881554     MOV W4, ADCSSL
1655:                ADCON1bits.ADON = 1;
001ADE  A8E2A1     BSET 0x2A1, #7
1656:                _ADIF = 0;
001AE0  A96085     BCLR 0x85, #3
1657:                _ADIE = 1;
001AE2  A8608D     BSET 0x8D, #3
1658:               
1659:                
1660:                // Begin UART operation
1661:                _U1TXIF = 0;	// Clear the Transmit Interrupt Flag
001AE4  A94085     BCLR 0x85, #2
1662:                _U1TXIE = 1;	// Enable Transmit Interrupts
001AE6  A8408D     BSET 0x8D, #2
1663:                _U1RXIF = 0;	// Clear the Recieve Interrupt Flag
001AE8  A92085     BCLR 0x85, #1
1664:                _U1RXIE = 1;	// Enable Recieve Interrupts
001AEA  A8208D     BSET 0x8D, #1
1665:                
1666:                U1MODEbits.UARTEN = 1;	// And turn the peripheral on
001AEC  A8E20D     BSET 0x20D, #7
1667:                PIN_RS422_DE = OLL_RS422_DE_ENABLE_RS422_DRIVER;  // Enable the U69-RS422 Driver output (The reciever is always enabled)
001AEE  A882E2     BSET LATF, #4
1668:                command_string.data_state = COMMAND_BUFFER_EMPTY;  // The command buffer is empty
001AF0  EB4200     CLR.B W4
001AF2  FD0200     EXCH W0, W4
001AF4  B7F7AA     MOV.B WREG, .LSM672
001AF6  FD0200     EXCH W0, W4
1669:               
1670:                ResetHWLatches();
001AF8  071488     RCALL ResetHWLatches
1671:                ClrWdt();
001AFA  FE6000     CLRWDT
1672:                // PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;  DPARKER THIS DOES NOT BELONG HERE
1673:              
1674:              }
001AFC  FA8000     ULNK
001AFE  060000     RETURN
1675:              
1676:              
1677:              
1678:              
1679:              
1680:              void SetPowerSupplyTarget(POWERSUPPLY* ptr_ps, unsigned int v_command, unsigned int i_command) {
001B00  FA0006     LNK #0x6
001B02  780F00     MOV W0, [W14]
001B04  980711     MOV W1, [W14+2]
001B06  980722     MOV W2, [W14+4]
1681:                /*
1682:                  ptr_ps - Pointer to the power supply that is having it's set point updated
1683:                  v_command - the new voltage command Set point
1684:                  i_command - the new current command set point
1685:                */
1686:              
1687:                
1688:                if (v_command > ptr_ps->v_max_set_point) {
001B08  78021E     MOV [W14], W4
001B0A  9002B4     MOV [W4+6], W5
001B0C  90021E     MOV [W14+2], W4
001B0E  528F84     SUB W5, W4, [W15]
001B10  310008     BRA C, .L112, .LSM813
1689:                  ptr_ps->v_command_set_point = ptr_ps->v_max_set_point;
001B12  78021E     MOV [W14], W4
001B14  9002B4     MOV [W4+6], W5
001B16  78021E     MOV [W14], W4
001B18  980215     MOV W5, [W4+2]
1690:                  global_debug_counter.setpoint_not_valid++;
001B1A  80B9B4     MOV .LSM634, W4
001B1C  E80204     INC W4, W4
001B1E  88B9B4     MOV W4, .LSM634
001B20  370003     BRA .L113, .LSM814
1691:                } else {
1692:                  ptr_ps->v_command_set_point = v_command;
001B22  78021E     MOV [W14], W4
001B24  90029E     MOV [W14+2], W5
001B26  980215     MOV W5, [W4+2]
1693:                }
1694:                
1695:                if (i_command > ptr_ps->i_max_set_point) {
001B28  78021E     MOV [W14], W4
001B2A  901A94     MOV [W4+50], W5
001B2C  90022E     MOV [W14+4], W4
001B2E  528F84     SUB W5, W4, [W15]
001B30  310008     BRA C, .L114, .LSM817
1696:                  ptr_ps->i_command_set_point = ptr_ps->i_max_set_point;
001B32  78021E     MOV [W14], W4
001B34  901A94     MOV [W4+50], W5
001B36  78021E     MOV [W14], W4
001B38  981275     MOV W5, [W4+46]
1697:                  global_debug_counter.setpoint_not_valid++;
001B3A  80B9B4     MOV .LSM634, W4
001B3C  E80204     INC W4, W4
001B3E  88B9B4     MOV W4, .LSM634
001B40  370003     BRA .L115, .LSM818
1698:                } else {
1699:                  ptr_ps->i_command_set_point = i_command;
001B42  78021E     MOV [W14], W4
001B44  9002AE     MOV [W14+4], W5
001B46  981275     MOV W5, [W4+46]
1700:                }
1701:                
1702:                if (control_state != STATE_WARM_UP) {
001B48  208585     MOV #0x858, W5
001B4A  784295     MOV.B [W5], W5
001B4C  B3C244     MOV.B #0x24, W4
001B4E  52CF84     SUB.B W5, W4, [W15]
001B50  320004     BRA Z, .L116, .LSM820
1703:                  ScalePowerSupply(ptr_ps,100,100);
001B52  200642     MOV #0x64, W2
001B54  200641     MOV #0x64, W1
001B56  78001E     MOV [W14], W0
001B58  070005     RCALL ScalePowerSupply
1704:                }
1705:                CalcPowerSupplySettings(ptr_ps);  // DPARKER is this call redundant since ScalePowerSupply also calls ScalePowerSupply
001B5A  78001E     MOV [W14], W0
001B5C  070054     RCALL CalcPowerSupplySettings
1706:              
1707:                ClrWdt();
001B5E  FE6000     CLRWDT
1708:              
1709:                // DPARKER need to figure out how to combine ScalePowerSupply & SetPowerSupplyTarget & CalcPowerSupplySettings
1710:                
1711:                
1712:                // DPARKER Record Saturation Errors for each supply???
1713:              }
001B60  FA8000     ULNK
001B62  060000     RETURN
1714:              
1715:              
1716:              
1717:              void ScalePowerSupply(POWERSUPPLY* ptr_ps, unsigned int num, unsigned int den) {
001B64  FA000A     LNK #0xA
001B66  980720     MOV W0, [W14+4]
001B68  980731     MOV W1, [W14+6]
001B6A  980742     MOV W2, [W14+8]
1718:              
1719:                unsigned long temp_32_bit;
1720:              
1721:                if (num >= den) {
001B6C  9002BE     MOV [W14+6], W5
001B6E  90024E     MOV [W14+8], W4
001B70  528F84     SUB W5, W4, [W15]
001B72  390009     BRA NC, .L118, .LSM827
1722:                  // Power supply can not be scalled above the set point.
1723:                  // Set the scaled_set_point to the command_set_point
1724:                  ptr_ps->v_scaled_set_point = ptr_ps->v_command_set_point;
001B74  90022E     MOV [W14+4], W4
001B76  900294     MOV [W4+2], W5
001B78  90022E     MOV [W14+4], W4
001B7A  980225     MOV W5, [W4+4]
1725:                  ptr_ps->i_scaled_set_point = ptr_ps->i_command_set_point;
001B7C  90022E     MOV [W14+4], W4
001B7E  9012F4     MOV [W4+46], W5
001B80  90022E     MOV [W14+4], W4
001B82  981A05     MOV W5, [W4+48]
001B84  37003C     BRA .L119, .LSM835
1726:                } else {
1727:                  // Scale v_set_point by num/den
1728:                  temp_32_bit = ptr_ps->v_command_set_point;
001B86  90022E     MOV [W14+4], W4
001B88  900214     MOV [W4+2], W4
001B8A  200005     MOV #0x0, W5
001B8C  BE8F04     MOV.D W4, [W14]
1729:                  temp_32_bit *= num;
001B8E  90023E     MOV [W14+6], W4
001B90  200005     MOV #0x0, W5
001B92  90031E     MOV [W14+2], W6
001B94  B9B304     MUL.SS W6, W4, W6
001B96  780306     MOV W6, W6
001B98  78039E     MOV [W14], W7
001B9A  B9B805     MUL.SS W7, W5, W0
001B9C  780380     MOV W0, W7
001B9E  430307     ADD W6, W7, W6
001BA0  78039E     MOV [W14], W7
001BA2  780204     MOV W4, W4
001BA4  B82207     MUL.UU W4, W7, W4
001BA6  430305     ADD W6, W5, W6
001BA8  780286     MOV W6, W5
001BAA  BE8F04     MOV.D W4, [W14]
001BAC  BE8F04     MOV.D W4, [W14]
1730:                  temp_32_bit /= den;
001BAE  90024E     MOV [W14+8], W4
001BB0  200005     MOV #0x0, W5
001BB2  BE0104     MOV.D W4, W2
001BB4  BE001E     MOV.D [W14], W0
001BB6  07F3C2     RCALL ___udivsi3
001BB8  BE0200     MOV.D W0, W4
001BBA  BE8F04     MOV.D W4, [W14]
1731:                  ptr_ps->v_scaled_set_point = temp_32_bit & 0x0000FFFF;
001BBC  78029E     MOV [W14], W5
001BBE  90022E     MOV [W14+4], W4
001BC0  980225     MOV W5, [W4+4]
1732:                  
1733:                  // Scale i_set_point by num/den
1734:                  temp_32_bit = ptr_ps->i_command_set_point;
001BC2  90022E     MOV [W14+4], W4
001BC4  901274     MOV [W4+46], W4
001BC6  200005     MOV #0x0, W5
001BC8  BE8F04     MOV.D W4, [W14]
1735:                  temp_32_bit *= num;
001BCA  90023E     MOV [W14+6], W4
001BCC  200005     MOV #0x0, W5
001BCE  90031E     MOV [W14+2], W6
001BD0  B9B304     MUL.SS W6, W4, W6
001BD2  780306     MOV W6, W6
001BD4  78039E     MOV [W14], W7
001BD6  B9B805     MUL.SS W7, W5, W0
001BD8  780380     MOV W0, W7
001BDA  430307     ADD W6, W7, W6
001BDC  78039E     MOV [W14], W7
001BDE  780204     MOV W4, W4
001BE0  B82207     MUL.UU W4, W7, W4
001BE2  430305     ADD W6, W5, W6
001BE4  780286     MOV W6, W5
001BE6  BE8F04     MOV.D W4, [W14]
001BE8  BE8F04     MOV.D W4, [W14]
1736:                  temp_32_bit /= den;
001BEA  90024E     MOV [W14+8], W4
001BEC  200005     MOV #0x0, W5
001BEE  BE0104     MOV.D W4, W2
001BF0  BE001E     MOV.D [W14], W0
001BF2  07F3A4     RCALL ___udivsi3
001BF4  BE0200     MOV.D W0, W4
001BF6  BE8F04     MOV.D W4, [W14]
1737:                  ptr_ps->i_scaled_set_point = temp_32_bit & 0x0000FFFF;
001BF8  78029E     MOV [W14], W5
001BFA  90022E     MOV [W14+4], W4
001BFC  981A05     MOV W5, [W4+48]
1738:              
1739:                }
1740:                // Send these scaled values to the DAC and Under/Over setting registers
1741:                CalcPowerSupplySettings(ptr_ps);
001BFE  90002E     MOV [W14+4], W0
001C00  070002     RCALL CalcPowerSupplySettings
1742:              }
001C02  FA8000     ULNK
001C04  060000     RETURN
1743:              
1744:              
1745:              
1746:              void CalcPowerSupplySettings(POWERSUPPLY* ptr_ps) {
001C06  FA0006     LNK #0x6
001C08  980720     MOV W0, [W14+4]
1747:                unsigned int v_temp;
1748:                unsigned int i_temp;
1749:                // This function generates DAC settings and ADC trip points based on the passed voltage and current set point
1750:                
1751:                // Generate the DAC Values associated with the set points
1752:                v_temp = Scale16Bit(ptr_ps->v_scaled_set_point, ptr_ps->v_dac_scale);
001C0A  90022E     MOV [W14+4], W4
001C0C  9002D4     MOV [W4+10], W5
001C0E  90022E     MOV [W14+4], W4
001C10  900224     MOV [W4+4], W4
001C12  780085     MOV W5, W1
001C14  780004     MOV W4, W0
001C16  0707AB     RCALL Scale16Bit
001C18  780200     MOV W0, W4
001C1A  780F04     MOV W4, [W14]
1753:                v_temp = Scale16Bit(v_temp, ptr_ps->v_dac_cal_gain);
001C1C  90022E     MOV [W14+4], W4
001C1E  900264     MOV [W4+12], W4
001C20  780084     MOV W4, W1
001C22  78001E     MOV [W14], W0
001C24  0707A4     RCALL Scale16Bit
001C26  780200     MOV W0, W4
001C28  780F04     MOV W4, [W14]
1754:                if (ptr_ps->v_dac_cal_offset > 0) {
001C2A  90022E     MOV [W14+4], W4
001C2C  900274     MOV [W4+14], W4
001C2E  520FE0     SUB W4, #0x0, [W15]
001C30  34000C     BRA LE, .L121, .LSM844
1755:                  // the offset is positive check for overflow above 0xFFFF
1756:                  if ((0xFFFF-ptr_ps->v_dac_cal_offset) < v_temp) {
001C32  90022E     MOV [W14+4], W4
001C34  900274     MOV [W4+14], W4
001C36  EA8204     COM W4, W4
001C38  520F9E     SUB W4, [W14], [W15]
001C3A  310003     BRA C, .L122, .LSM843
1757:                    v_temp = 0xFFFF;
001C3C  EB8200     SETM W4
001C3E  780F04     MOV W4, [W14]
001C40  37000F     BRA .L123, .LSM847
1758:                  } else {
1759:                    v_temp = v_temp + ptr_ps->v_dac_cal_offset;
001C42  90022E     MOV [W14+4], W4
001C44  900274     MOV [W4+14], W4
001C46  420F1E     ADD W4, [W14], [W14]
001C48  37000B     BRA .L123, .LSM847
1760:                  }
1761:                } else {
1762:                  // the offset is negative check for overflow below 0x0000
1763:                  if ((0-ptr_ps->v_dac_cal_offset) > v_temp) {
001C4A  90022E     MOV [W14+4], W4
001C4C  900274     MOV [W4+14], W4
001C4E  EA0204     NEG W4, W4
001C50  520F9E     SUB W4, [W14], [W15]
001C52  360003     BRA LEU, .L124, .LSM846
1764:                    v_temp = 0x0000;
001C54  EB0200     CLR W4
001C56  780F04     MOV W4, [W14]
001C58  370003     BRA .L123, .LSM847
1765:                  } else {
1766:                    v_temp = v_temp + ptr_ps->v_dac_cal_offset;
001C5A  90022E     MOV [W14+4], W4
001C5C  900274     MOV [W4+14], W4
001C5E  420F1E     ADD W4, [W14], [W14]
1767:                  }
1768:                }
1769:                ptr_ps->v_dac_set_point = v_temp;
001C60  90022E     MOV [W14+4], W4
001C62  78029E     MOV [W14], W5
001C64  980245     MOV W5, [W4+8]
1770:                
1771:                i_temp = Scale16Bit(ptr_ps->i_scaled_set_point, ptr_ps->i_dac_scale);
001C66  90022E     MOV [W14+4], W4
001C68  901AB4     MOV [W4+54], W5
001C6A  90022E     MOV [W14+4], W4
001C6C  901A04     MOV [W4+48], W4
001C6E  780085     MOV W5, W1
001C70  780004     MOV W4, W0
001C72  07077D     RCALL Scale16Bit
001C74  780200     MOV W0, W4
001C76  980714     MOV W4, [W14+2]
1772:                i_temp = Scale16Bit(i_temp, ptr_ps->i_dac_cal_gain);
001C78  90022E     MOV [W14+4], W4
001C7A  901A44     MOV [W4+56], W4
001C7C  780084     MOV W4, W1
001C7E  90001E     MOV [W14+2], W0
001C80  070776     RCALL Scale16Bit
001C82  780200     MOV W0, W4
001C84  980714     MOV W4, [W14+2]
1773:                if (ptr_ps->i_dac_cal_offset > 0) {
001C86  90022E     MOV [W14+4], W4
001C88  901A54     MOV [W4+58], W4
001C8A  520FE0     SUB W4, #0x0, [W15]
001C8C  34000F     BRA LE, .L125, .LSM854
1774:                  // the offset is positive check for overflow above 0xFFFF
1775:                  if ((0xFFFF-ptr_ps->i_dac_cal_offset) < i_temp) {
001C8E  90022E     MOV [W14+4], W4
001C90  901A54     MOV [W4+58], W4
001C92  EA8284     COM W4, W5
001C94  90021E     MOV [W14+2], W4
001C96  528F84     SUB W5, W4, [W15]
001C98  310003     BRA C, .L126, .LSM853
1776:                    i_temp = 0xFFFF;
001C9A  EB8200     SETM W4
001C9C  980714     MOV W4, [W14+2]
001C9E  370015     BRA .L127, .LSM857
1777:                  } else {
1778:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
001CA0  90022E     MOV [W14+4], W4
001CA2  901A54     MOV [W4+58], W4
001CA4  90029E     MOV [W14+2], W5
001CA6  428204     ADD W5, W4, W4
001CA8  980714     MOV W4, [W14+2]
001CAA  37000F     BRA .L127, .LSM857
1779:                  }
1780:                } else {
1781:                  // the offset is negative check for overflow below 0x0000
1782:                  if ((0-ptr_ps->i_dac_cal_offset) > i_temp) {
001CAC  90022E     MOV [W14+4], W4
001CAE  901A54     MOV [W4+58], W4
001CB0  EA0204     NEG W4, W4
001CB2  780284     MOV W4, W5
001CB4  90021E     MOV [W14+2], W4
001CB6  528F84     SUB W5, W4, [W15]
001CB8  360003     BRA LEU, .L128, .LSM856
1783:                    i_temp = 0x0000;
001CBA  EB0200     CLR W4
001CBC  980714     MOV W4, [W14+2]
001CBE  370005     BRA .L127, .LSM857
1784:                  } else {
1785:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
001CC0  90022E     MOV [W14+4], W4
001CC2  901A54     MOV [W4+58], W4
001CC4  90029E     MOV [W14+2], W5
001CC6  428204     ADD W5, W4, W4
001CC8  980714     MOV W4, [W14+2]
1786:                  }
1787:                }
1788:                ptr_ps->i_dac_set_point = i_temp;
001CCA  90022E     MOV [W14+4], W4
001CCC  90029E     MOV [W14+2], W5
001CCE  981A25     MOV W5, [W4+52]
1789:                
1790:                
1791:                // Set all of the over/under trip points based on the set point
1792:                v_temp = Scale16Bit(ptr_ps->v_scaled_set_point, ptr_ps->v_adc_scale);
001CD0  90022E     MOV [W14+4], W4
001CD2  900A94     MOV [W4+18], W5
001CD4  90022E     MOV [W14+4], W4
001CD6  900224     MOV [W4+4], W4
001CD8  780085     MOV W5, W1
001CDA  780004     MOV W4, W0
001CDC  070748     RCALL Scale16Bit
001CDE  780200     MOV W0, W4
001CE0  780F04     MOV W4, [W14]
1793:                v_temp = Scale16Bit(v_temp, ptr_ps->v_adc_cal_gain);
001CE2  90022E     MOV [W14+4], W4
001CE4  900A24     MOV [W4+20], W4
001CE6  780084     MOV W4, W1
001CE8  78001E     MOV [W14], W0
001CEA  070741     RCALL Scale16Bit
001CEC  780200     MOV W0, W4
001CEE  780F04     MOV W4, [W14]
1794:                if (ptr_ps->v_adc_cal_offset > 0) {
001CF0  90022E     MOV [W14+4], W4
001CF2  900A34     MOV [W4+22], W4
001CF4  520FE0     SUB W4, #0x0, [W15]
001CF6  34000C     BRA LE, .L129, .LSM864
1795:                  // the offset is positive check for overflow above 0xFFFF
1796:                  if ((0xFFFF-ptr_ps->v_adc_cal_offset) < v_temp) {
001CF8  90022E     MOV [W14+4], W4
001CFA  900A34     MOV [W4+22], W4
001CFC  EA8204     COM W4, W4
001CFE  520F9E     SUB W4, [W14], [W15]
001D00  310003     BRA C, .L130, .LSM863
1797:                    v_temp = 0xFFFF;
001D02  EB8200     SETM W4
001D04  780F04     MOV W4, [W14]
001D06  37000F     BRA .L131, .LSM867
1798:                  } else {
1799:                    v_temp = v_temp + ptr_ps->v_adc_cal_offset;
001D08  90022E     MOV [W14+4], W4
001D0A  900A34     MOV [W4+22], W4
001D0C  420F1E     ADD W4, [W14], [W14]
001D0E  37000B     BRA .L131, .LSM867
1800:                  }
1801:                } else {
1802:                  // the offset is negative check for overflow below 0x0000
1803:                  if ((0-ptr_ps->v_adc_cal_offset) > v_temp) {
001D10  90022E     MOV [W14+4], W4
001D12  900A34     MOV [W4+22], W4
001D14  EA0204     NEG W4, W4
001D16  520F9E     SUB W4, [W14], [W15]
001D18  360003     BRA LEU, .L132, .LSM866
1804:                    v_temp = 0x0000;
001D1A  EB0200     CLR W4
001D1C  780F04     MOV W4, [W14]
001D1E  370003     BRA .L131, .LSM867
1805:                  } else {
1806:                    v_temp = v_temp + ptr_ps->v_adc_cal_offset;
001D20  90022E     MOV [W14+4], W4
001D22  900A34     MOV [W4+22], W4
001D24  420F1E     ADD W4, [W14], [W14]
1807:                  }
1808:                }
1809:              
1810:                ptr_ps->v_adc_over_rel = Scale16Bit(v_temp, ptr_ps->v_adc_over_scale);
001D26  90022E     MOV [W14+4], W4
001D28  900A74     MOV [W4+30], W4
001D2A  780084     MOV W4, W1
001D2C  78001E     MOV [W14], W0
001D2E  07071F     RCALL Scale16Bit
001D30  780200     MOV W0, W4
001D32  9002AE     MOV [W14+4], W5
001D34  980AD4     MOV W4, [W5+26]
1811:                ptr_ps->v_adc_under_rel = Scale16Bit(v_temp,ptr_ps-> v_adc_under_scale);
001D36  90022E     MOV [W14+4], W4
001D38  901204     MOV [W4+32], W4
001D3A  780084     MOV W4, W1
001D3C  78001E     MOV [W14], W0
001D3E  070717     RCALL Scale16Bit
001D40  780200     MOV W0, W4
001D42  9002AE     MOV [W14+4], W5
001D44  980AE4     MOV W4, [W5+28]
1812:                if (ptr_ps->v_adc_over_rel < ptr_ps->v_adc_over_min_value) {
001D46  90022E     MOV [W14+4], W4
001D48  900AD4     MOV [W4+26], W5
001D4A  90022E     MOV [W14+4], W4
001D4C  901214     MOV [W4+34], W4
001D4E  528F84     SUB W5, W4, [W15]
001D50  310004     BRA C, .L133, .LSM871
1813:                  ptr_ps->v_adc_over_rel = ptr_ps->v_adc_over_min_value;
001D52  90022E     MOV [W14+4], W4
001D54  901294     MOV [W4+34], W5
001D56  90022E     MOV [W14+4], W4
001D58  980A55     MOV W5, [W4+26]
1814:                }
1815:                
1816:                i_temp = Scale16Bit(ptr_ps->i_scaled_set_point, ptr_ps->i_adc_scale);
001D5A  90022E     MOV [W14+4], W4
001D5C  901AF4     MOV [W4+62], W5
001D5E  90022E     MOV [W14+4], W4
001D60  901A04     MOV [W4+48], W4
001D62  780085     MOV W5, W1
001D64  780004     MOV W4, W0
001D66  070703     RCALL Scale16Bit
001D68  780200     MOV W0, W4
001D6A  980714     MOV W4, [W14+2]
1817:                i_temp = Scale16Bit(i_temp, ptr_ps->i_adc_cal_gain);
001D6C  90022E     MOV [W14+4], W4
001D6E  902204     MOV [W4+64], W4
001D70  780084     MOV W4, W1
001D72  90001E     MOV [W14+2], W0
001D74  0706FC     RCALL Scale16Bit
001D76  780200     MOV W0, W4
001D78  980714     MOV W4, [W14+2]
1818:                if (ptr_ps->i_adc_cal_offset > 0) {
001D7A  90022E     MOV [W14+4], W4
001D7C  902214     MOV [W4+66], W4
001D7E  520FE0     SUB W4, #0x0, [W15]
001D80  34000F     BRA LE, .L134, .LSM877
1819:                  // the offset is positive check for overflow above 0xFFFF
1820:                  if ((0xFFFF-ptr_ps->i_adc_cal_offset) < i_temp) {
001D82  90022E     MOV [W14+4], W4
001D84  902214     MOV [W4+66], W4
001D86  EA8284     COM W4, W5
001D88  90021E     MOV [W14+2], W4
001D8A  528F84     SUB W5, W4, [W15]
001D8C  310003     BRA C, .L135, .LSM876
1821:                    i_temp = 0xFFFF;
001D8E  EB8200     SETM W4
001D90  980714     MOV W4, [W14+2]
001D92  370015     BRA .L136, .LSM880
1822:                  } else {
1823:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
001D94  90022E     MOV [W14+4], W4
001D96  901A54     MOV [W4+58], W4
001D98  90029E     MOV [W14+2], W5
001D9A  428204     ADD W5, W4, W4
001D9C  980714     MOV W4, [W14+2]
001D9E  37000F     BRA .L136, .LSM880
1824:                  }
1825:                } else {
1826:                  // the offset is negative check for overflow below 0x0000
1827:                  if ((0-ptr_ps->i_adc_cal_offset) > i_temp) {
001DA0  90022E     MOV [W14+4], W4
001DA2  902214     MOV [W4+66], W4
001DA4  EA0204     NEG W4, W4
001DA6  780284     MOV W4, W5
001DA8  90021E     MOV [W14+2], W4
001DAA  528F84     SUB W5, W4, [W15]
001DAC  360003     BRA LEU, .L137, .LSM879
1828:                    i_temp = 0x0000;
001DAE  EB0200     CLR W4
001DB0  980714     MOV W4, [W14+2]
001DB2  370005     BRA .L136, .LSM880
1829:                  } else {
1830:                    i_temp = i_temp + ptr_ps->i_adc_cal_offset;
001DB4  90022E     MOV [W14+4], W4
001DB6  902214     MOV [W4+66], W4
001DB8  90029E     MOV [W14+2], W5
001DBA  428204     ADD W5, W4, W4
001DBC  980714     MOV W4, [W14+2]
1831:                  }
1832:                }
1833:              
1834:                /*
1835:                //  DPARKER NEED TO ADJUST THE OVER/UNDER SCALE SUCH THAT IT IS SET TO X Percent of MAX VALUE.  NOT PROGRAMED VALUE
1836:                //  This will overwrite the values calculated above
1837:                
1838:                
1839:                #define DPARKER_SCALE_5_PERCENT (410)  // This will be 5%
1840:                dan_temp = Scale16Bit(ptr_ps->v_max_set_point, DPARKER_SCALE_5_PERCENT);
1841:                
1842:                ptr_ps->v_adc_over_rel = v_temp + dan_temp;
1843:              
1844:                if (v_temp > dan_temp) {
1845:                  ptr_ps->v_adc_under_rel = v_temp - dan_temp;
1846:                } else {
1847:                  ptr_ps->v_adc_under_rel = 0;
1848:                }
1849:                
1850:              					       
1851:                // End New code to adjust the over scaling
1852:              
1853:                */
1854:              
1855:              
1856:              
1857:              
1858:                
1859:                ptr_ps->i_adc_over_rel = Scale16Bit(i_temp, ptr_ps->i_adc_over_scale);
001DBE  90022E     MOV [W14+4], W4
001DC0  902254     MOV [W4+74], W4
001DC2  780084     MOV W4, W1
001DC4  90001E     MOV [W14+2], W0
001DC6  0706D3     RCALL Scale16Bit
001DC8  780200     MOV W0, W4
001DCA  9002AE     MOV [W14+4], W5
001DCC  9822B4     MOV W4, [W5+70]
1860:                ptr_ps->i_adc_under_rel = Scale16Bit(i_temp, ptr_ps->i_adc_under_scale);
001DCE  90022E     MOV [W14+4], W4
001DD0  902264     MOV [W4+76], W4
001DD2  780084     MOV W4, W1
001DD4  90001E     MOV [W14+2], W0
001DD6  0706CB     RCALL Scale16Bit
001DD8  780200     MOV W0, W4
001DDA  9002AE     MOV [W14+4], W5
001DDC  9822C4     MOV W4, [W5+72]
1861:                if (ptr_ps->i_adc_over_rel < ptr_ps->i_adc_over_min_value) {
001DDE  90022E     MOV [W14+4], W4
001DE0  9022B4     MOV [W4+70], W5
001DE2  90022E     MOV [W14+4], W4
001DE4  902274     MOV [W4+78], W4
001DE6  528F84     SUB W5, W4, [W15]
001DE8  310004     BRA C, .L138, .LSM884
1862:                  ptr_ps->i_adc_over_rel = ptr_ps->i_adc_over_min_value;
001DEA  90022E     MOV [W14+4], W4
001DEC  9022F4     MOV [W4+78], W5
001DEE  90022E     MOV [W14+4], W4
001DF0  982235     MOV W5, [W4+70]
1863:                }
1864:                ClrWdt();
001DF2  FE6000     CLRWDT
1865:              }
001DF4  FA8000     ULNK
001DF6  060000     RETURN
1866:              
1867:              
1868:              
1869:              
1870:              void UpdateDacAll(void) {
001DF8  FA0012     LNK #0x12
1871:                unsigned int dac_value_array[8];
1872:                unsigned char dac_write_failed;
1873:                unsigned char number_tries;
1874:              
1875:                last_known_action = LAST_ACTION_UPDATE_DAC_ALL;
001DFA  2000A4     MOV #0xA, W4
001DFC  88BDE4     MOV W4, last_known_action
1876:              
1877:                dac_value_array[0] = ps_thyr_reservoir_htr.v_dac_set_point;
001DFE  805DA4     MOV 0xBB4, W4
001E00  980714     MOV W4, [W14+2]
1878:                dac_value_array[1] = ps_thyr_cathode_htr.v_dac_set_point;
001E02  805AD4     MOV 0xB5A, W4
001E04  980724     MOV W4, [W14+4]
1879:                dac_value_array[2] = ps_magnet.v_dac_set_point;
001E06  805534     MOV 0xAA6, W4
001E08  980734     MOV W4, [W14+6]
1880:                dac_value_array[3] = ps_magnet.i_dac_set_point;
001E0A  805694     MOV .LSM108, W4
001E0C  980744     MOV W4, [W14+8]
1881:                dac_value_array[4] = ps_filament.v_dac_set_point;
001E0E  805804     MOV 0xB00, W4
001E10  980754     MOV W4, [W14+10]
1882:                dac_value_array[5] = ps_filament.i_dac_set_point;
001E12  805964     MOV .LSM123, W4
001E14  980764     MOV W4, [W14+12]
1883:                dac_value_array[6] = ps_hv_lambda_mode_A.v_dac_set_point;
001E16  8049F4     MOV 0x93E, W4
001E18  980774     MOV W4, [W14+14]
1884:                dac_value_array[7] = ps_hv_lambda_mode_B.v_dac_set_point;
001E1A  804F94     MOV 0x9F2, W4
001E1C  980F04     MOV W4, [W14+16]
1885:              
1886:                dac_write_failed = 1;
001E1E  B3C014     MOV.B #0x1, W4
001E20  784F04     MOV.B W4, [W14]
1887:                number_tries = 0;
001E22  EB4200     CLR.B W4
001E24  984714     MOV.B W4, [W14+1]
1888:                while ((dac_write_failed != 0) & (number_tries < 20)) {
001E26  370010     BRA .L140, .LSM904
001E48  78429E     MOV.B [W14], W5
001E4A  FB8205     ZE W5, W4
001E4C  EA0204     NEG W4, W4
001E4E  DE224F     LSR W4, #15, W4
001E50  784284     MOV.B W4, W5
001E52  B3C014     MOV.B #0x1, W4
001E54  90431E     MOV.B [W14+1], W6
001E56  534FF3     SUB.B W6, #0x13, [W15]
001E58  360001     BRA LEU, .L142
001E5A  EB4200     CLR.B W4
001E5C  62C204     AND.B W5, W4, W4
001E5E  524FE0     SUB.B W4, #0x0, [W15]
001E60  3AFFE3     BRA NZ, .L143, .LSM899
1889:                  dac_write_failed = WriteLTC2656AllDacChannels(&U44_LTC2656, dac_value_array);
001E28  E8820E     INC2 W14, W4
001E2A  780084     MOV W4, W1
001E2C  2091E0     MOV #0x91E, W0
001E2E  071906     RCALL WriteLTC2656AllDacChannels
001E30  784200     MOV.B W0, W4
001E32  784F04     MOV.B W4, [W14]
1890:                  number_tries++;
001E34  90421E     MOV.B [W14+1], W4
001E36  E84204     INC.B W4, W4
001E38  984714     MOV.B W4, [W14+1]
1891:                  if (dac_write_failed) {
001E3A  78421E     MOV.B [W14], W4
001E3C  524FE0     SUB.B W4, #0x0, [W15]
001E3E  320003     BRA Z, .L141, .LSM903
1892:                    global_debug_counter.LTC2656_write_error++;
001E40  80B9A4     MOV .LSM633, W4
001E42  E80204     INC W4, W4
001E44  88B9A4     MOV W4, .LSM633
1893:                  }
1894:                  ClrWdt();
001E46  FE6000     CLRWDT
1895:                }
1896:                if (number_tries >= 20) {
001E62  90421E     MOV.B [W14+1], W4
001E64  524FF3     SUB.B W4, #0x13, [W15]
001E66  360002     BRA LEU, .L139, .LSM907
1897:                  RecordThisControlBoardFault(FAULT_CB_SPI_UNRECOVERABLE_ERROR);
001E68  200200     MOV #0x20, W0
001E6A  071522     RCALL RecordThisControlBoardFault
1898:                }
1899:              }
001E6C  FA8000     ULNK
001E6E  060000     RETURN
1900:              
1901:              
1902:              
1903:              
1904:              void Do10msTicToc(void) {
001E70  FA000C     LNK #0xC
1905:                /*
1906:                  Certain functions need to happen at regular interval for the system to work
1907:              
1908:                  Thyratron PIDs - The gain and phase of the PID control loop is a function of it's execution frequency therefor it must be updated at a regular interval
1909:                  Analog Filters - The filter response is function of the execution frequency so they must be executed at a regular interval
1910:              
1911:                  DAC updates - The DAC must be regularly.  Durring HV ON this should happen AFTER a pulse so that the SPI bus is not corrupted by EMI
1912:                  If the state is not in HV_ON or the system is pulsing at a very low freqeuncy, DAC updates must be handeled by this function.
1913:                  
1914:                  Calculating the PRF
1915:              
1916:                  Other timing functions like flashing LEDs
1917:                */
1918:              
1919:                unsigned int vtemp;
1920:                unsigned int itemp;
1921:                unsigned long long_math_value;
1922:                unsigned long temp32;
1923:              
1924:                last_known_action = LAST_ACTION_DO_10MS;
001E72  200094     MOV #0x9, W4
001E74  88BDE4     MOV W4, last_known_action
1925:                
1926:                if (_POR) {
001E76  803A04     MOV RCON, W4
001E78  620261     AND W4, #0x1, W4
001E7A  520FE0     SUB W4, #0x0, [W15]
001E7C  320003     BRA Z, .L146, .LSM912
1927:                  debug_status_register |= STATUS_POR_RESET;
001E7E  80B9F4     MOV debug_status_register, W4
001E80  A04004     BSET W4, #4
001E82  88B9F4     MOV W4, debug_status_register
1928:                  // _POR = 0;
1929:                }
1930:                if (_EXTR) {
001E84  803A05     MOV RCON, W5
001E86  200804     MOV #0x80, W4
001E88  628204     AND W5, W4, W4
001E8A  520FE0     SUB W4, #0x0, [W15]
001E8C  320004     BRA Z, .L147, .LSM914
1931:                  debug_status_register |= STATUS_EXTERNAL_RESET;
001E8E  80B9F5     MOV debug_status_register, W5
001E90  200204     MOV #0x20, W4
001E92  720205     IOR W4, W5, W4
001E94  88B9F4     MOV W4, debug_status_register
1932:                  //_EXTR = 0;
1933:                }
1934:                if (_SWR) {
001E96  803A05     MOV RCON, W5
001E98  200404     MOV #0x40, W4
001E9A  628204     AND W5, W4, W4
001E9C  520FE0     SUB W4, #0x0, [W15]
001E9E  320004     BRA Z, .L148, .LSM916
1935:                  debug_status_register |= STATUS_SOFTARE_RESET;
001EA0  80B9F5     MOV debug_status_register, W5
001EA2  200404     MOV #0x40, W4
001EA4  720205     IOR W4, W5, W4
001EA6  88B9F4     MOV W4, debug_status_register
1936:                  //_SWR = 0;
1937:                }
1938:                if (_BOR) {
001EA8  803A04     MOV RCON, W4
001EAA  620262     AND W4, #0x2, W4
001EAC  520FE0     SUB W4, #0x0, [W15]
001EAE  320003     BRA Z, .L149, .LSM918
1939:                  debug_status_register |= STATUS_BOR_RESET;
001EB0  80B9F4     MOV debug_status_register, W4
001EB2  A00004     BSET W4, #0
001EB4  88B9F4     MOV W4, debug_status_register
1940:                  //_BOR = 0;
1941:                }
1942:                if (_TRAPR) {
001EB6  803A05     MOV RCON, W5
001EB8  280004     MOV #0x8000, W4
001EBA  628204     AND W5, W4, W4
001EBC  520FE0     SUB W4, #0x0, [W15]
001EBE  320003     BRA Z, .L150, .LSM920
1943:                  debug_status_register |= STATUS_TRAPR_RESET;
001EC0  80B9F4     MOV debug_status_register, W4
001EC2  A01004     BSET W4, #1
001EC4  88B9F4     MOV W4, debug_status_register
1944:                  //_TRAPR = 0;
1945:                }
1946:                if (_WDTO) {
001EC6  803A04     MOV RCON, W4
001EC8  620270     AND W4, #0x10, W4
001ECA  520FE0     SUB W4, #0x0, [W15]
001ECC  320003     BRA Z, .L151, .LSM922
1947:                  debug_status_register |= STATUS_WDT_RESET;
001ECE  80B9F4     MOV debug_status_register, W4
001ED0  A02004     BSET W4, #2
001ED2  88B9F4     MOV W4, debug_status_register
1948:                  // _WDTO = 0;
1949:                }
1950:                if (_IOPUWR) {
001ED4  803A05     MOV RCON, W5
001ED6  240004     MOV #0x4000, W4
001ED8  628204     AND W5, W4, W4
001EDA  520FE0     SUB W4, #0x0, [W15]
001EDC  320003     BRA Z, .L152, .LSM924
1951:                  debug_status_register |= STATUS_IOPUWR_RESET;
001EDE  80B9F4     MOV debug_status_register, W4
001EE0  A03004     BSET W4, #3
001EE2  88B9F4     MOV W4, debug_status_register
1952:                  //_IOPUWR = 0;
1953:                }
1954:              
1955:              
1956:                ClrWdt();
001EE4  FE6000     CLRWDT
1957:                if (_T5IF) {
001EE6  800435     MOV IFS1, W5
001EE8  200404     MOV #0x40, W4
001EEA  628204     AND W5, W4, W4
001EEC  520FE0     SUB W4, #0x0, [W15]
001EEE  320112     BRA Z, .L145, .LSM991
1958:                  _T5IF = 0;
001EF0  A9C086     BCLR IFS1, #6
1959:                  //10ms roll has occured
1960:              
1961:                  time_since_last_trigger++;
001EF2  804364     MOV time_since_last_trigger, W4
001EF4  E80204     INC W4, W4
001EF6  884364     MOV W4, time_since_last_trigger
1962:                  
1963:                  if (eoc_counts)	{
001EF8  2174D4     MOV #0x174D, W4
001EFA  784214     MOV.B [W4], W4
001EFC  524FE0     SUB.B W4, #0x0, [W15]
001EFE  320024     BRA Z, .L154, .LSM934
1964:                  	if (eoc_counts < EOC_MAX_COUNT) { 
001F00  2174D4     MOV #0x174D, W4
001F02  784214     MOV.B [W4], W4
001F04  524FE2     SUB.B W4, #0x2, [W15]
001F06  3E001A     BRA GTU, .L155, .LSM933
1965:              	    	for (vtemp = 0; vtemp < EOC_MAX_COUNT; vtemp++)	{
001F08  EB0200     CLR W4
001F0A  780F04     MOV W4, [W14]
001F0C  370013     BRA .L156
001F32  E80F1E     INC [W14], [W14]
001F34  78021E     MOV [W14], W4
001F36  520FE2     SUB W4, #0x2, [W15]
001F38  36FFEA     BRA LEU, .L158, .LSM931
001F3A  370006     BRA .L154, .LSM934
1966:              	        	if (eoc_10ms_timer[vtemp] > 0) eoc_10ms_timer[vtemp]--;
001F0E  78021E     MOV [W14], W4
001F10  420284     ADD W4, W4, W5
001F12  217504     MOV #0x1750, W4
001F14  428204     ADD W5, W4, W4
001F16  780214     MOV [W4], W4
001F18  520FE0     SUB W4, #0x0, [W15]
001F1A  34000B     BRA LE, .L157, .LSM932
001F1C  78021E     MOV [W14], W4
001F1E  420284     ADD W4, W4, W5
001F20  217504     MOV #0x1750, W4
001F22  428204     ADD W5, W4, W4
001F24  780214     MOV [W4], W4
001F26  E90284     DEC W4, W5
001F28  78021E     MOV [W14], W4
001F2A  420304     ADD W4, W4, W6
001F2C  217504     MOV #0x1750, W4
001F2E  430204     ADD W6, W4, W4
001F30  780A05     MOV W5, [W4]
1967:              	        }
1968:                      }
1969:                      else {
1970:                      	if (eoc_max_reached_timer > 0) eoc_max_reached_timer--;
001F3C  80BA74     MOV eoc_max_reached_timer, W4
001F3E  520FE0     SUB W4, #0x0, [W15]
001F40  340003     BRA LE, .L154, .LSM934
001F42  80BA74     MOV eoc_max_reached_timer, W4
001F44  E90204     DEC W4, W4
001F46  88BA74     MOV W4, eoc_max_reached_timer
1971:                      }
1972:                  }
1973:                  
1974:                  led_pulse_count = ((led_pulse_count + 1) & 0b00001111);
001F48  804354     MOV led_pulse_count, W4
001F4A  E80204     INC W4, W4
001F4C  62026F     AND W4, #0xF, W4
001F4E  884354     MOV W4, led_pulse_count
1975:                  if (led_pulse_count == 0) {
001F50  804354     MOV led_pulse_count, W4
001F52  520FE0     SUB W4, #0x0, [W15]
001F54  3A0015     BRA NZ, .L159, .LSM941
1976:                    // 10ms * 16 counter has ocurred
1977:                    // Flash the LED - NOTE "PIN_MAIN_CONTACTOR_CLOSE = !PIN_MAIN_CONTACTOR_CLOSE" was causing any changes made in Port F durring interrupt to be overwritten
1978:                    if (PIN_MAIN_CONTACTOR_CLOSE) {
001F56  801655     MOV LATB, W5
001F58  200804     MOV #0x80, W4
001F5A  628204     AND W5, W4, W4
001F5C  520FE0     SUB W4, #0x0, [W15]
001F5E  320002     BRA Z, .L160, .LSM938
1979:              	PIN_MAIN_CONTACTOR_CLOSE = 0;
001F60  A9E2CA     BCLR LATB, #7
001F62  370001     BRA .L161, .LSM939
1980:                    } else {
1981:              	PIN_MAIN_CONTACTOR_CLOSE = 1;
001F64  A8E2CA     BSET LATB, #7
1982:                    }  
1983:                    
1984:                    average_pulse_repetition_frequency_deci_herz = RCFilter16Tau(average_pulse_repetition_frequency_deci_herz, ((prf_pulse_counter*125)>>1));
001F66  8042B5     MOV prf_pulse_counter, W5
001F68  2007D4     MOV #0x7D, W4
001F6A  B9AA04     MUL.SS W5, W4, W4
001F6C  780204     MOV W4, W4
001F6E  D10284     LSR W4, W5
001F70  8042A4     MOV average_pulse_repetition_frequency_deci_herz, W4
001F72  780085     MOV W5, W1
001F74  780004     MOV W4, W0
001F76  0706A1     RCALL RCFilter16Tau
001F78  780200     MOV W0, W4
001F7A  8842A4     MOV W4, average_pulse_repetition_frequency_deci_herz
1985:                    prf_pulse_counter = 0;  
001F7C  EB0200     CLR W4
001F7E  8842B4     MOV W4, prf_pulse_counter
1986:                  }
1987:              
1988:                  temp32 = 156250;
001F80  2625A4     MOV #0x625A, W4
001F82  200025     MOV #0x2, W5
001F84  980714     MOV W4, [W14+2]
001F86  980725     MOV W5, [W14+4]
1989:                  temp32 *= FCY_CLK_MHZ;
001F88  90001E     MOV [W14+2], W0
001F8A  9000AE     MOV [W14+4], W1
001F8C  07F18C     RCALL ___floatunsisf
001F8E  BE0200     MOV.D W0, W4
001F90  2F5C32     MOV #0xF5C3, W2
001F92  241EB3     MOV #0x41EB, W3
001F94  BE0004     MOV.D W4, W0
001F96  07F19E     RCALL ___mulsf3
001F98  BE0200     MOV.D W0, W4
001F9A  BE0004     MOV.D W4, W0
001F9C  07F169     RCALL ___fixunssfsi
001F9E  BE0200     MOV.D W0, W4
001FA0  980714     MOV W4, [W14+2]
001FA2  980725     MOV W5, [W14+4]
1990:              
1991:              
1992:                  // DPARKER DO THESE NEED TO BE BASED ON FCY_MHZ???
1993:              #ifdef __PFN_800_HZ
1994:                  if (last_period < 100) {
001FA4  80BCE5     MOV .LSM669, W5
001FA6  200634     MOV #0x63, W4
001FA8  528F84     SUB W5, W4, [W15]
001FAA  3E0002     BRA GTU, .L162, .LSM945
1995:                    last_period = 100;
001FAC  200644     MOV #0x64, W4
001FAE  88BCE4     MOV W4, .LSM669
1996:                  }
1997:              #else
1998:                  if (last_period < 345) {
1999:                    last_period = 345;
2000:                  }
2001:              #endif
2002:                  
2003:                  temp32 /= last_period;
001FB0  80BCE4     MOV .LSM669, W4
001FB2  200005     MOV #0x0, W5
001FB4  BE0104     MOV.D W4, W2
001FB6  90001E     MOV [W14+2], W0
001FB8  9000AE     MOV [W14+4], W1
001FBA  07F1C0     RCALL ___udivsi3
001FBC  BE0200     MOV.D W0, W4
001FBE  980714     MOV W4, [W14+2]
001FC0  980725     MOV W5, [W14+4]
2004:                  prf_deciherz = temp32;
001FC2  90021E     MOV [W14+2], W4
001FC4  8841F4     MOV W4, prf_deciherz
2005:                  if (_T3IF) {
001FC6  800425     MOV IFS0, W5
001FC8  200804     MOV #0x80, W4
001FCA  628204     AND W5, W4, W4
001FCC  520FE0     SUB W4, #0x0, [W15]
001FCE  320002     BRA Z, .L163, .LSM949
2006:                    // We are pulsing at less than 2.5Hz or 10Hz at 29.495 Mhz Clock
2007:                    // Set the rep rate to zero
2008:                    prf_deciherz = 0;
001FD0  EB0200     CLR W4
001FD2  8841F4     MOV W4, prf_deciherz
2009:                  }
2010:                  
2011:                  
2012:                  if ((PIN_FP_MODULATOR_RESET == !ILL_MODULATOR_RESET) && (start_reset_process)) {
001FD4  801735     MOV PORTG, W5
001FD6  220004     MOV #0x2000, W4
001FD8  628204     AND W5, W4, W4
001FDA  520FE0     SUB W4, #0x0, [W15]
001FDC  320006     BRA Z, .L164, .LSM953
001FDE  804254     MOV start_reset_process, W4
001FE0  520FE0     SUB W4, #0x0, [W15]
001FE2  320003     BRA Z, .L164, .LSM953
2013:                    ResetAllFaults();
001FE4  07121A     RCALL ResetAllFaults
2014:                    ResetHWLatches(); // Clear the hardware Latches
001FE6  071211     RCALL ResetHWLatches
2015:                    ResetPulseLatches();
001FE8  071208     RCALL ResetPulseLatches
2016:                  }
2017:                  
2018:                  if (PIN_FP_MODULATOR_RESET == ILL_MODULATOR_RESET) {
001FEA  801735     MOV PORTG, W5
001FEC  220004     MOV #0x2000, W4
001FEE  628204     AND W5, W4, W4
001FF0  520FE0     SUB W4, #0x0, [W15]
001FF2  3A0003     BRA NZ, .L165, .LSM955
2019:                    // Start the Reset Process
2020:                    start_reset_process = 1;
001FF4  200014     MOV #0x1, W4
001FF6  884254     MOV W4, start_reset_process
001FF8  370002     BRA .L166, .LSM956
2021:                  } else {
2022:                    start_reset_process = 0;
001FFA  EB0200     CLR W4
001FFC  884254     MOV W4, start_reset_process
2023:                  }
2024:                      
2025:                  // ResetSPI1(); // ResetSPI(2) // DPARKER - This may be requried to fix bit errors in the SPI bus
2026:                  
2027:                  
2028:                  FilterADCs();  // Read Data from the DAC arrays, average, and filter
001FFE  07024E     RCALL FilterADCs
2029:                  
2030:                  // If the magnet current is based on mode A program voltage (instead of from GUI), set the magnet current based on mode A program voltage
2031:                  if (!ram_config_set_magnetron_magnet_current_from_GUI) {
002000  208444     MOV #0x844, W4
002002  784214     MOV.B [W4], W4
002004  524FE0     SUB.B W4, #0x0, [W15]
002006  3A000D     BRA NZ, .L167, .LSM961
2032:                    // The Magnet Current is calculated from Mode A program voltage
2033:                    itemp = CalculatePoly(ps_hv_lambda_mode_A.v_command_set_point);
002008  8049C4     MOV 0x938, W4
00200A  780004     MOV W4, W0
00200C  070934     RCALL CalculatePoly
00200E  780200     MOV W0, W4
002010  980734     MOV W4, [W14+6]
2034:                    vtemp = GenerateMagnetVprog(itemp);
002012  90003E     MOV [W14+6], W0
002014  070F4D     RCALL GenerateMagnetVprog
002016  780200     MOV W0, W4
002018  780F04     MOV W4, [W14]
2035:                    SetPowerSupplyTarget(&ps_magnet, vtemp, itemp);
00201A  90013E     MOV [W14+6], W2
00201C  78009E     MOV [W14], W1
00201E  20A9E0     MOV #0xA9E, W0
002020  07FD6F     RCALL SetPowerSupplyTarget
2036:                  }
2037:                
2038:                  if ((control_state == STATE_SYSTEM_COLD_READY) || (control_state == STATE_FAULT_COLD_FAULT)) {
002022  208584     MOV #0x858, W4
002024  784214     MOV.B [W4], W4
002026  524FF4     SUB.B W4, #0x14, [W15]
002028  320005     BRA Z, .L168, .LSM962
00202A  208585     MOV #0x858, W5
00202C  784295     MOV.B [W5], W5
00202E  B3CA44     MOV.B #0xA4, W4
002030  52CF84     SUB.B W5, W4, [W15]
002032  3A0018     BRA NZ, .L169, .LSM968
2039:                    ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
002034  200642     MOV #0x64, W2
002036  EB0080     CLR W1
002038  209360     MOV #0x936, W0
00203A  07FD94     RCALL ScalePowerSupply
2040:                    ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
00203C  200642     MOV #0x64, W2
00203E  EB0080     CLR W1
002040  209360     MOV #0x936, W0
002042  07FD90     RCALL ScalePowerSupply
2041:                    ScalePowerSupply(&ps_filament,0,100);
002044  200642     MOV #0x64, W2
002046  EB0080     CLR W1
002048  20AF80     MOV #0xAF8, W0
00204A  07FD8C     RCALL ScalePowerSupply
2042:                    ScalePowerSupply(&ps_magnet,0,100);
00204C  200642     MOV #0x64, W2
00204E  EB0080     CLR W1
002050  20A9E0     MOV #0xA9E, W0
002052  07FD88     RCALL ScalePowerSupply
2043:                    ScalePowerSupply(&ps_thyr_reservoir_htr,0,100);
002054  200642     MOV #0x64, W2
002056  EB0080     CLR W1
002058  20BAC0     MOV #0xBAC, W0
00205A  07FD84     RCALL ScalePowerSupply
2044:                    ScalePowerSupply(&ps_thyr_cathode_htr,0,100);
00205C  200642     MOV #0x64, W2
00205E  EB0080     CLR W1
002060  20B520     MOV #0xB52, W0
002062  07FD80     RCALL ScalePowerSupply
2045:                  }
2046:              
2047:              
2048:              
2049:              
2050:                  UpdateFaults();  // Update all the fault registers.  Note this must only happen once every 10ms because some faults are timed
002064  0710AC     RCALL UpdateFaults
2051:                  //  DPARKER figure out some better way to timer certain faults
2052:                
2053:                  // Update the sum fault outputs (copper and fiber)
2054:                  if (CheckFaultActive()) {
002066  07144A     RCALL CheckFaultActive
002068  780200     MOV W0, W4
00206A  520FE0     SUB W4, #0x0, [W15]
00206C  320003     BRA Z, .L170, .LSM972
2055:                    PIN_SUM_FAULT_FIBER = OLL_SUM_FAULT_FIBER_FAULT;
00206E  A9E2C4     BCLR LATA, #7
2056:                    PIN_SUM_FAULT_COPPER = OLL_SUM_FAULT_COPPER_FAULT;
002070  A942D0     BCLR LATC, #2
002072  370002     BRA .L171, .LSM974
2057:                  } else {
2058:                    PIN_SUM_FAULT_FIBER = !OLL_SUM_FAULT_FIBER_FAULT;
002074  A8E2C4     BSET LATA, #7
2059:                    PIN_SUM_FAULT_COPPER = !OLL_SUM_FAULT_COPPER_FAULT;
002076  A842D0     BSET LATC, #2
2060:                  }
2061:                  
2062:                  slow_down_thyratron_pid_counter++;
002078  2084E4     MOV #0x84E, W4
00207A  784214     MOV.B [W4], W4
00207C  E84204     INC.B W4, W4
00207E  FD0200     EXCH W0, W4
002080  B7E84E     MOV.B WREG, slow_down_thyratron_pid_counter
002082  FD0200     EXCH W0, W4
2063:                  slow_down_thyratron_pid_counter &= 0b00001111;
002084  2084E4     MOV #0x84E, W4
002086  784214     MOV.B [W4], W4
002088  62426F     AND.B W4, #0xF, W4
00208A  FD0200     EXCH W0, W4
00208C  B7E84E     MOV.B WREG, slow_down_thyratron_pid_counter
00208E  FD0200     EXCH W0, W4
2064:                  if (slow_down_thyratron_pid_counter == 0) {
002090  2084E4     MOV #0x84E, W4
002092  784214     MOV.B [W4], W4
002094  524FE0     SUB.B W4, #0x0, [W15]
002096  3A0001     BRA NZ, .L172, .LSM978
2065:                    //execute PID loop once every 160ms
2066:                    DoThyratronPIDs();
002098  07003F     RCALL DoThyratronPIDs
2067:                  }
2068:                  
2069:              
2070:                  // The system is configured to adjust the filament power based on magnetron power.  Otherwise the filament power will be maxed at all times
2071:                  DoMagnetronFilamentAdjust();
00209A  0700A1     RCALL DoMagnetronFilamentAdjust
2072:              
2073:              
2074:              
2075:                  if ((control_state != STATE_HV_ON) || (_T2IF)) {
00209C  208585     MOV #0x858, W5
00209E  784295     MOV.B [W5], W5
0020A0  B3C444     MOV.B #0x44, W4
0020A2  52CF84     SUB.B W5, W4, [W15]
0020A4  3A0005     BRA NZ, .L173, .LSM980
0020A6  800425     MOV IFS0, W5
0020A8  200404     MOV #0x40, W4
0020AA  628204     AND W5, W4, W4
0020AC  520FE0     SUB W4, #0x0, [W15]
0020AE  320004     BRA Z, .L174, .LSM983
2076:                    // Do10msTicToc needs to be responsible for updating the DAC
2077:                    UpdateDacAll();
0020B0  07FEA3     RCALL UpdateDacAll
2078:                    UpdateIOExpanderOutputs();
0020B2  070467     RCALL UpdateIOExpanderOutputs
2079:                    pulse_counter_this_run = 0;
0020B4  EB0200     CLR W4
0020B6  8841D4     MOV W4, pulse_counter_this_run
2080:                  } 
2081:                  if (pulse_counter_this_run == 0) {
0020B8  8041D4     MOV pulse_counter_this_run, W4
0020BA  520FE0     SUB W4, #0x0, [W15]
0020BC  3A0029     BRA NZ, .L175, .LSM990
2082:                    if (pulse_off_time_10_ms_units < low_energy_target_current_startup_max_cooldown) {
0020BE  804135     MOV pulse_off_time_10_ms_units, W5
0020C0  80BCC4     MOV 0x1798, W4
0020C2  528F84     SUB W5, W4, [W15]
0020C4  310003     BRA C, .L176, .LSM986
2083:              	pulse_off_time_10_ms_units++;
0020C6  804134     MOV pulse_off_time_10_ms_units, W4
0020C8  E80204     INC W4, W4
0020CA  884134     MOV W4, pulse_off_time_10_ms_units
2084:                    }
2085:                    long_math_value = max_low_energy_target_current_startup_adjust_initital_value;
0020CC  80BCB4     MOV 0x1796, W4
0020CE  200005     MOV #0x0, W5
0020D0  980744     MOV W4, [W14+8]
0020D2  980755     MOV W5, [W14+10]
2086:                    long_math_value *= pulse_off_time_10_ms_units;
0020D4  804134     MOV pulse_off_time_10_ms_units, W4
0020D6  200005     MOV #0x0, W5
0020D8  90035E     MOV [W14+10], W6
0020DA  B9B304     MUL.SS W6, W4, W6
0020DC  780306     MOV W6, W6
0020DE  9003CE     MOV [W14+8], W7
0020E0  B9B805     MUL.SS W7, W5, W0
0020E2  780380     MOV W0, W7
0020E4  430307     ADD W6, W7, W6
0020E6  9003CE     MOV [W14+8], W7
0020E8  780204     MOV W4, W4
0020EA  B82207     MUL.UU W4, W7, W4
0020EC  430305     ADD W6, W5, W6
0020EE  780286     MOV W6, W5
0020F0  980744     MOV W4, [W14+8]
0020F2  980755     MOV W5, [W14+10]
0020F4  980744     MOV W4, [W14+8]
0020F6  980755     MOV W5, [W14+10]
2087:                    long_math_value /= low_energy_target_current_startup_max_cooldown;
0020F8  80BCC4     MOV 0x1798, W4
0020FA  200005     MOV #0x0, W5
0020FC  BE0104     MOV.D W4, W2
0020FE  90004E     MOV [W14+8], W0
002100  9000DE     MOV [W14+10], W1
002102  07F11C     RCALL ___udivsi3
002104  BE0200     MOV.D W0, W4
002106  980744     MOV W4, [W14+8]
002108  980755     MOV W5, [W14+10]
2088:                    low_energy_target_current_startup_adjust_initital_value = long_math_value;
00210A  90024E     MOV [W14+8], W4
00210C  884104     MOV W4, low_energy_target_current_startup_adjust_initital_value
00210E  370002     BRA .L145, .LSM991
2089:                  } else {
2090:                    pulse_off_time_10_ms_units = 0;
002110  EB0200     CLR W4
002112  884134     MOV W4, pulse_off_time_10_ms_units
2091:                  }
2092:                } 
2093:              }
002114  FA8000     ULNK
002116  060000     RETURN
2094:              
2095:              
2096:              
2097:              
2098:              
2099:              void DoThyratronPIDs(void) {
002118  FA0002     LNK #0x2
2100:                /*
2101:                  The pid functions provided by dsp.h use Q15 fractional data.
2102:                  This represents fractional inputs/outputs from -1 to 1.
2103:                  Our inputs to the PID come from an unipolar ADC.
2104:                  The control output of the PID goes directly to a DAC.
2105:                  In order for the PID control to work with our unsigned 16 bit data two changed must be made.
2106:                  (1) Measured output must be converted from 16 bit data to Q(15).  This is easily done by shifting one bit to the right.
2107:                      From to PIDs point of view we are just decreasing our resolution by 1 bit, not a problem here.
2108:                  (2) Control output must be convereted so that it can iterface to our DAC.
2109:                      The control output ranges from -1 to 1.  so perform the following logic.
2110:              	If (control_output < 0) then (control_output = 0).
2111:              	Multiply control_output by 2 (shift left 1 bit) to use the full range of the DAC.
2112:              	NOTE: You must perform the math like this we because the PID will set the output to Zero at start.
2113:              	If you shift the entire 16 bits to unsinged interger, 0 will become 0x7FFF and your control_output will start at 50%, not zero!!!!
2114:                  (3) In order to set the DAC the control output "is moved" to v_dac_set_point register by setting v_dac_scale to zero, v_dac_cal_gain to zero
2115:                      and setting v_dac_cal_offset to 0x1000 "zero level" + the output of the PID loop (which ranges from zero to 0xFFFF)
2116:                  (4) If the DAC setting exceeds an output program of 2V (32000 or 0x7D00) , then we have saturated the output.  Throw some faults
2117:                */
2118:              
2119:                unsigned int temp;
2120:              
2121:                last_known_action = LAST_ACTION_DO_THYRATRON_PID;
00211A  200084     MOV #0x8, W4
00211C  88BDE4     MOV W4, last_known_action
2122:              
2123:                // Run the Thyratron Heaters PID loops on the latest data
2124:                // bit shift the data 1 bit to the right because the PID loop is expecting Q15
2125:                temp = Scale16Bit(ps_thyr_reservoir_htr.v_scaled_set_point, ps_thyr_reservoir_htr.v_adc_scale);
00211E  805DF5     MOV 0xBBE, W5
002120  805D84     MOV 0xBB0, W4
002122  780085     MOV W5, W1
002124  780004     MOV W4, W0
002126  070523     RCALL Scale16Bit
002128  780200     MOV W0, W4
00212A  780F04     MOV W4, [W14]
2126:                temp = Scale16Bit(temp, ps_thyr_reservoir_htr.v_adc_cal_gain);
00212C  805E04     MOV 0xBC0, W4
00212E  780084     MOV W4, W1
002130  78001E     MOV [W14], W0
002132  07051D     RCALL Scale16Bit
002134  780200     MOV W0, W4
002136  780F04     MOV W4, [W14]
2127:                temp = temp + ps_thyr_reservoir_htr.v_adc_cal_offset;
002138  805E14     MOV .LSM145, W4
00213A  420F1E     ADD W4, [W14], [W14]
2128:                thyratron_reservoir_heater_PID.controlReference = (temp >> 1);
00213C  78021E     MOV [W14], W4
00213E  D10204     LSR W4, W4
002140  884414     MOV W4, 0x882
2129:                thyratron_reservoir_heater_PID.measuredOutput = (ps_thyr_reservoir_htr.v_adc_reading >> 1);
002142  805DE4     MOV 0xBBC, W4
002144  D10204     LSR W4, W4
002146  884404     MOV W4, .LSM17
2130:                PID(&thyratron_reservoir_heater_PID);
002148  2087A0     MOV #0x87A, W0
00214A  07F027     RCALL _PID
2131:              
2132:              
2133:                temp = Scale16Bit(ps_thyr_cathode_htr.v_scaled_set_point, ps_thyr_cathode_htr.v_adc_scale);
00214C  805B25     MOV 0xB64, W5
00214E  805AB4     MOV .LSM131, W4
002150  780085     MOV W5, W1
002152  780004     MOV W4, W0
002154  07050C     RCALL Scale16Bit
002156  780200     MOV W0, W4
002158  780F04     MOV W4, [W14]
2134:                temp = Scale16Bit(temp, ps_thyr_cathode_htr.v_adc_cal_gain);
00215A  805B34     MOV 0xB66, W4
00215C  780084     MOV W4, W1
00215E  78001E     MOV [W14], W0
002160  070506     RCALL Scale16Bit
002162  780200     MOV W0, W4
002164  780F04     MOV W4, [W14]
2135:                temp = temp + ps_thyr_cathode_htr.v_adc_cal_offset;
002166  805B44     MOV 0xB68, W4
002168  420F1E     ADD W4, [W14], [W14]
2136:                thyratron_cathode_heater_PID.controlReference = (temp >> 1);
00216A  78021E     MOV [W14], W4
00216C  D10204     LSR W4, W4
00216E  884494     MOV W4, .L19, .LSM20
2137:                thyratron_cathode_heater_PID.measuredOutput = (ps_thyr_cathode_htr.v_adc_reading >> 1);
002170  805B14     MOV 0xB62, W4
002172  D10204     LSR W4, W4
002174  884484     MOV W4, .LSM19
2138:                PID(&thyratron_cathode_heater_PID);
002176  2088A0     MOV #0x88A, W0
002178  07F010     RCALL _PID
2139:                
2140:              
2141:                // Update the DAC setting for the Reservoir Heater
2142:                // The output of the PID is Q15, convert to 16 bit unsigned for the DAC
2143:                temp = thyratron_reservoir_heater_PID.controlOutput;
00217A  8043F4     MOV 0x87E, W4
00217C  780F04     MOV W4, [W14]
2144:                if (temp & 0x8000) {
00217E  78021E     MOV [W14], W4
002180  520FE0     SUB W4, #0x0, [W15]
002182  3D0002     BRA GE, .L178, .LSM1009
2145:                  temp = 0x0000;
002184  EB0200     CLR W4
002186  780F04     MOV W4, [W14]
2146:                }
2147:                temp = temp << 1;
002188  78021E     MOV [W14], W4
00218A  420204     ADD W4, W4, W4
00218C  780F04     MOV W4, [W14]
2148:                temp += 0;
2149:                if (temp > THYRATRON_DAC_SATURATED) {
00218E  27D004     MOV #0x7D00, W4
002190  78029E     MOV [W14], W5
002192  528F84     SUB W5, W4, [W15]
002194  360002     BRA LEU, .L179, .LSM1012
2150:                  // The dac output will exceed 2V (20mA from the 4-20mA driver).  Limit the output to 0x7D00
2151:                  temp = THYRATRON_DAC_SATURATED;
002196  27D004     MOV #0x7D00, W4
002198  780F04     MOV W4, [W14]
2152:                }
2153:                ps_thyr_reservoir_htr.v_dac_cal_gain = 0;
00219A  EB0200     CLR W4
00219C  885DC4     MOV W4, 0xBB8
2154:                ps_thyr_reservoir_htr.v_dac_scale = 0;
00219E  EB0200     CLR W4
0021A0  885DB4     MOV W4, 0xBB6
2155:                ps_thyr_reservoir_htr.v_dac_cal_offset = temp;
0021A2  78021E     MOV [W14], W4
0021A4  885DD4     MOV W4, 0xBBA
2156:                
2157:                
2158:                // Update the DAC setting for the Cathode Heater
2159:                // The output of the PID is Q15, convert to 16 bit unsigned for the DAC
2160:                temp = thyratron_cathode_heater_PID.controlOutput;
0021A6  804474     MOV 0x88E, W4
0021A8  780F04     MOV W4, [W14]
2161:                if (temp & 0x8000) {
0021AA  78021E     MOV [W14], W4
0021AC  520FE0     SUB W4, #0x0, [W15]
0021AE  3D0002     BRA GE, .L180, .LSM1018
2162:                  temp = 0x0000;
0021B0  EB0200     CLR W4
0021B2  780F04     MOV W4, [W14]
2163:                }
2164:                temp = temp << 1;
0021B4  78021E     MOV [W14], W4
0021B6  420204     ADD W4, W4, W4
0021B8  780F04     MOV W4, [W14]
2165:                temp += 0; 
2166:                if (temp > THYRATRON_DAC_SATURATED) {
0021BA  27D004     MOV #0x7D00, W4
0021BC  78029E     MOV [W14], W5
0021BE  528F84     SUB W5, W4, [W15]
0021C0  360002     BRA LEU, .L181, .LSM1021
2167:                  // The dac output will exceed 2V (20mA from the 4-20mA driver).  Limit the output to 0x7D00
2168:                  // DPARKER how are thyratron dac saturations detected in faults.c - confirm this works
2169:                  temp = THYRATRON_DAC_SATURATED;
0021C2  27D004     MOV #0x7D00, W4
0021C4  780F04     MOV W4, [W14]
2170:                }
2171:                ps_thyr_cathode_htr.v_dac_cal_gain = 0;
0021C6  EB0200     CLR W4
0021C8  885AF4     MOV W4, .LSM132
2172:                ps_thyr_cathode_htr.v_dac_scale = 0;
0021CA  EB0200     CLR W4
0021CC  885AE4     MOV W4, 0xB5C
2173:                ps_thyr_cathode_htr.v_dac_cal_offset = temp;
0021CE  78021E     MOV [W14], W4
0021D0  885B04     MOV W4, .L46, .LSM133
2174:              
2175:                CalcPowerSupplySettings(&ps_thyr_cathode_htr);
0021D2  20B520     MOV #0xB52, W0
0021D4  07FD18     RCALL CalcPowerSupplySettings
2176:                CalcPowerSupplySettings(&ps_thyr_reservoir_htr);
0021D6  20BAC0     MOV #0xBAC, W0
0021D8  07FD16     RCALL CalcPowerSupplySettings
2177:              }
0021DA  FA8000     ULNK
0021DC  060000     RETURN
2178:              
2179:              void DoMagnetronFilamentAdjust(void) {
0021DE  FA000C     LNK #0xC
2180:                unsigned long temp32;
2181:                unsigned int look_up_position;
2182:                unsigned int filament_scale;
2183:                signed int new_position;
2184:                static unsigned int second_counter;
2185:                static unsigned int heater_scale_factor;
2186:                unsigned int resistance_set_point;
2187:              
2188:                temp32  = ReturnPowerSupplyADCScaledVoltage(&ps_filament, ps_filament.v_adc_reading);
0021E0  805844     MOV 0xB08, W4
0021E2  780084     MOV W4, W1
0021E4  20AF80     MOV #0xAF8, W0
0021E6  070E85     RCALL ReturnPowerSupplyADCScaledVoltage
0021E8  780200     MOV W0, W4
0021EA  200005     MOV #0x0, W5
0021EC  BE8F04     MOV.D W4, [W14]
2189:                temp32 *= 10000;
0021EE  90029E     MOV [W14+2], W5
0021F0  227104     MOV #0x2710, W4
0021F2  B9AA04     MUL.SS W5, W4, W4
0021F4  780304     MOV W4, W6
0021F6  78021E     MOV [W14], W4
0021F8  B92260     MUL.SU W4, #0, W4
0021FA  780204     MOV W4, W4
0021FC  430304     ADD W6, W4, W6
0021FE  78029E     MOV [W14], W5
002200  227104     MOV #0x2710, W4
002202  B82A04     MUL.UU W5, W4, W4
002204  430305     ADD W6, W5, W6
002206  780286     MOV W6, W5
002208  BE8F04     MOV.D W4, [W14]
00220A  BE8F04     MOV.D W4, [W14]
2190:                temp32 /= ReturnPowerSupplyADCScaledCurrent(&ps_filament, ps_filament.i_adc_reading);
00220C  8059A4     MOV 0xB34, W4
00220E  780084     MOV W4, W1
002210  20AF80     MOV #0xAF8, W0
002212  070EA5     RCALL ReturnPowerSupplyADCScaledCurrent
002214  780200     MOV W0, W4
002216  200005     MOV #0x0, W5
002218  BE0104     MOV.D W4, W2
00221A  BE001E     MOV.D [W14], W0
00221C  07F08F     RCALL ___udivsi3
00221E  BE0200     MOV.D W0, W4
002220  BE8F04     MOV.D W4, [W14]
2191:                magnetron_filament_resistance_measurement = temp32;
002222  78021E     MOV [W14], W4
002224  8843A4     MOV W4, magnetron_filament_resistance_measurement
2192:              
2193:              
2194:                
2195:                if (magnetron_filament_control_mode == 0) {
002226  804374     MOV magnetron_filament_control_mode, W4
002228  520FE0     SUB W4, #0x0, [W15]
00222A  3A00B6     BRA NZ, .L183, .LSM1069
2196:                  // run the old routine
2197:                  temp32 = average_energy_per_pulse_milli_joules;
00222C  804284     MOV average_energy_per_pulse_milli_joules, W4
00222E  200005     MOV #0x0, W5
002230  BE8F04     MOV.D W4, [W14]
2198:                  //temp32 *= average_pulse_repetition_frequency_deci_herz;
2199:                  temp32 *= prf_deciherz;
002232  8041F4     MOV prf_deciherz, W4
002234  200005     MOV #0x0, W5
002236  90031E     MOV [W14+2], W6
002238  B9B304     MUL.SS W6, W4, W6
00223A  780306     MOV W6, W6
00223C  78039E     MOV [W14], W7
00223E  B9B805     MUL.SS W7, W5, W0
002240  780380     MOV W0, W7
002242  430307     ADD W6, W7, W6
002244  78039E     MOV [W14], W7
002246  780204     MOV W4, W4
002248  B82207     MUL.UU W4, W7, W4
00224A  430305     ADD W6, W5, W6
00224C  780286     MOV W6, W5
00224E  BE8F04     MOV.D W4, [W14]
002250  BE8F04     MOV.D W4, [W14]
2200:                  temp32 >>= 6;
002252  BE021E     MOV.D [W14], W4
002254  DD2B4A     SL W5, #10, W6
002256  DE2246     LSR W4, #6, W4
002258  730204     IOR W6, W4, W4
00225A  DE2AC6     LSR W5, #6, W5
00225C  BE8F04     MOV.D W4, [W14]
2201:                  temp32 *= 13;
00225E  90021E     MOV [W14+2], W4
002260  B9226D     MUL.SU W4, #13, W4
002262  780304     MOV W4, W6
002264  78021E     MOV [W14], W4
002266  B92260     MUL.SU W4, #0, W4
002268  780204     MOV W4, W4
00226A  430304     ADD W6, W4, W6
00226C  78029E     MOV [W14], W5
00226E  2000D4     MOV #0xD, W4
002270  B82A04     MUL.UU W5, W4, W4
002272  430305     ADD W6, W5, W6
002274  780286     MOV W6, W5
002276  BE8F04     MOV.D W4, [W14]
002278  BE8F04     MOV.D W4, [W14]
2202:                  temp32 >>= 11;
00227A  BE021E     MOV.D [W14], W4
00227C  DD2B45     SL W5, #5, W6
00227E  DE224B     LSR W4, #11, W4
002280  730204     IOR W6, W4, W4
002282  DE2ACB     LSR W5, #11, W5
002284  BE8F04     MOV.D W4, [W14]
2203:                  
2204:                  // DPARKER this will not work at powers greater than 6.5KW because the apparent power will roll around.  This is very bad
2205:                  // Need to truncate for (average output power watts) and properly handel look up position.
2206:                  if (temp32 >= 0xFFFF) {
002286  2FFFE4     MOV #0xFFFE, W4
002288  200005     MOV #0x0, W5
00228A  BE031E     MOV.D [W14], W6
00228C  530F84     SUB W6, W4, [W15]
00228E  5B8F85     SUBB W7, W5, [W15]
002290  360003     BRA LEU, .L184, .LSM1040
2207:                    average_output_power_watts = 0xFFFF;
002292  EB8200     SETM W4
002294  884294     MOV W4, average_output_power_watts
002296  370002     BRA .L185, .LSM1041
2208:                  } else {
2209:                    average_output_power_watts = (temp32 & 0xFFFF);
002298  78021E     MOV [W14], W4
00229A  884294     MOV W4, average_output_power_watts
2210:                  }
2211:                  
2212:                  switch (operation_mode) 
00229C  80B864     MOV operation_mode, W4
00229E  200405     MOV #0x40, W5
0022A0  520F85     SUB W4, W5, [W15]
0022A2  320014     BRA Z, .L189, .LSM1042
0022A4  200405     MOV #0x40, W5
0022A6  520F85     SUB W4, W5, [W15]
0022A8  3E0007     BRA GTU, .L193
0022AA  200205     MOV #0x20, W5
0022AC  520F85     SUB W4, W5, [W15]
0022AE  32001C     BRA Z, .L187, .LSM1046
0022B0  200305     MOV #0x30, W5
0022B2  520F85     SUB W4, W5, [W15]
0022B4  32000F     BRA Z, .L188, .LSM1044
0022B6  37002E     BRA .L186, .LSM1054
0022B8  210305     MOV #0x1030, W5
0022BA  520F85     SUB W4, W5, [W15]
0022BC  32001D     BRA Z, .L191, .LSM1050
0022BE  210405     MOV #0x1040, W5
0022C0  520F85     SUB W4, W5, [W15]
0022C2  320016     BRA Z, .L192, .LSM1048
0022C4  210205     MOV #0x1020, W5
0022C6  520F85     SUB W4, W5, [W15]
0022C8  320021     BRA Z, .L190, .LSM1052
0022CA  370024     BRA .L186, .LSM1054
2213:                    {
2214:                    case MODE_PORTAL_GANTRY_HIGH_ENERGY:
2215:              	temp32 = average_output_power_watts;
0022CC  804294     MOV average_output_power_watts, W4
0022CE  200005     MOV #0x0, W5
0022D0  BE8F04     MOV.D W4, [W14]
2216:              	break;
0022D2  370024     BRA .L194, .LSM1056
2217:              	
2218:                    case MODE_PORTAL_GANTRY_INTERLEAVED:
2219:              	temp32 = ETMScaleFactor2(average_output_power_watts, scale_interleaved, 0);
0022D4  80B875     MOV scale_interleaved, W5
0022D6  804294     MOV average_output_power_watts, W4
0022D8  EB0100     CLR W2
0022DA  780085     MOV W5, W1
0022DC  780004     MOV W4, W0
0022DE  071B64     RCALL .Letext0, .LFE2, _ETMScaleFactor2
0022E0  780200     MOV W0, W4
0022E2  200005     MOV #0x0, W5
0022E4  BE8F04     MOV.D W4, [W14]
2220:              	break;
0022E6  37001A     BRA .L194, .LSM1056
2221:              	
2222:                    case MODE_PORTAL_GANTRY_LOW_ENERGY:
2223:              	temp32 = average_output_power_watts;
0022E8  804294     MOV average_output_power_watts, W4
0022EA  200005     MOV #0x0, W5
0022EC  BE8F04     MOV.D W4, [W14]
2224:              	break;
0022EE  370016     BRA .L194, .LSM1056
2225:              	
2226:                    case MODE_ULTRA_LOW_DOSE_HIGH_ENERGY:
2227:              	temp32 = average_output_power_watts;
0022F0  804294     MOV average_output_power_watts, W4
0022F2  200005     MOV #0x0, W5
0022F4  BE8F04     MOV.D W4, [W14]
2228:              	break;
0022F6  370012     BRA .L194, .LSM1056
2229:              	
2230:                    case MODE_ULTRA_LOW_DOSE_INTERLEAVED:
2231:              	temp32 = ETMScaleFactor2(average_output_power_watts, scale_low_energy, 0);
0022F8  80B885     MOV scale_low_energy, W5
0022FA  804294     MOV average_output_power_watts, W4
0022FC  EB0100     CLR W2
0022FE  780085     MOV W5, W1
002300  780004     MOV W4, W0
002302  071B52     RCALL .Letext0, .LFE2, _ETMScaleFactor2
002304  780200     MOV W0, W4
002306  200005     MOV #0x0, W5
002308  BE8F04     MOV.D W4, [W14]
2232:              	break;
00230A  370008     BRA .L194, .LSM1056
2233:              	
2234:                    case MODE_ULTRA_LOW_DOSE_LOW_ENERGY:
2235:              	temp32 = average_output_power_watts;
00230C  804294     MOV average_output_power_watts, W4
00230E  200005     MOV #0x0, W5
002310  BE8F04     MOV.D W4, [W14]
2236:              	break;
002312  370004     BRA .L194, .LSM1056
2237:              	
2238:                    default:
2239:              	temp32 = average_output_power_watts;
002314  804294     MOV average_output_power_watts, W4
002316  200005     MOV #0x0, W5
002318  BE8F04     MOV.D W4, [W14]
2240:              	break;
00231A  000000     NOP
2241:                    }
2242:                  
2243:                  
2244:                  temp32 >>= 7;
00231C  BE021E     MOV.D [W14], W4
00231E  DD2B49     SL W5, #9, W6
002320  DE2247     LSR W4, #7, W4
002322  730204     IOR W6, W4, W4
002324  DE2AC7     LSR W5, #7, W5
002326  BE8F04     MOV.D W4, [W14]
2245:                  look_up_position = (temp32 & 0b00111111);
002328  78029E     MOV [W14], W5
00232A  2003F4     MOV #0x3F, W4
00232C  628204     AND W5, W4, W4
00232E  980744     MOV W4, [W14+8]
2246:                  new_position = (signed int)look_up_position;
002330  90024E     MOV [W14+8], W4
002332  980724     MOV W4, [W14+4]
2247:                  //new_position += look_up_offset;
2248:                  if (new_position <= 0) {
002334  90022E     MOV [W14+4], W4
002336  520FE0     SUB W4, #0x0, [W15]
002338  3C0002     BRA GT, .L195, .LSM1061
2249:                    new_position = 0;
00233A  EB0200     CLR W4
00233C  980724     MOV W4, [W14+4]
2250:                  }
2251:                  if (new_position >= 63) {
00233E  9002AE     MOV [W14+4], W5
002340  2003E4     MOV #0x3E, W4
002342  528F84     SUB W5, W4, [W15]
002344  340002     BRA LE, .L196, .LSM1063
2252:                    new_position = 63;
002346  2003F4     MOV #0x3F, W4
002348  980724     MOV W4, [W14+4]
2253:                  }
2254:                  look_up_position = new_position;
00234A  9002AE     MOV [W14+4], W5
00234C  980745     MOV W5, [W14+8]
2255:                  look_up_position &= 0b00111111;
00234E  9002CE     MOV [W14+8], W5
002350  2003F4     MOV #0x3F, W4
002352  628204     AND W5, W4, W4
002354  980744     MOV W4, [W14+8]
2256:                  
2257:                  if ((control_state == STATE_HV_ON) || (control_state == STATE_SYSTEM_WARM_READY)  || (control_state == STATE_HV_STARTUP) || (control_state == STATE_FAULT_WARM_FAULT)) {
002356  208585     MOV #0x858, W5
002358  784295     MOV.B [W5], W5
00235A  B3C444     MOV.B #0x44, W4
00235C  52CF84     SUB.B W5, W4, [W15]
00235E  32000F     BRA Z, .L197, .LSM1066
002360  208585     MOV #0x858, W5
002362  784295     MOV.B [W5], W5
002364  B3C344     MOV.B #0x34, W4
002366  52CF84     SUB.B W5, W4, [W15]
002368  32000A     BRA Z, .L197, .LSM1066
00236A  208585     MOV #0x858, W5
00236C  784295     MOV.B [W5], W5
00236E  B3C354     MOV.B #0x35, W4
002370  52CF84     SUB.B W5, W4, [W15]
002372  320005     BRA Z, .L197, .LSM1066
002374  208585     MOV #0x858, W5
002376  784295     MOV.B [W5], W5
002378  B3CA84     MOV.B #0xA8, W4
00237A  52CF84     SUB.B W5, W4, [W15]
00237C  3A0044     BRA NZ, .L182, .LSM1085
2258:                    filament_scale = FilamentLookUpTable[look_up_position];
00237E  90024E     MOV [W14+8], W4
002380  420284     ADD W4, W4, W5
002382  287024     MOV #0x8702, W4
002384  428204     ADD W5, W4, W4
002386  780314     MOV [W4], W6
002388  980756     MOV W6, [W14+10]
2259:                    ScalePowerSupply(&ps_filament,filament_scale,100);
00238A  200642     MOV #0x64, W2
00238C  9000DE     MOV [W14+10], W1
00238E  20AF80     MOV #0xAF8, W0
002390  07FBE9     RCALL ScalePowerSupply
2260:                    heater_scale_factor = filament_scale;
002392  90025E     MOV [W14+10], W4
002394  88B924     MOV W4, _heater_scale_factor.8304
002396  370037     BRA .L182, .LSM1085
2261:                  }
2262:                } else {
2263:                  // Manage the current based on healter resistance
2264:                  if (time_since_last_trigger > 100) {
002398  804365     MOV time_since_last_trigger, W5
00239A  200644     MOV #0x64, W4
00239C  528F84     SUB W5, W4, [W15]
00239E  360003     BRA LEU, .L199, .LSM1071
2265:                    resistance_set_point = magnetron_filament_off_resistance;
0023A0  804385     MOV magnetron_filament_off_resistance, W5
0023A2  980735     MOV W5, [W14+6]
0023A4  370002     BRA .L200, .LSM1072
2266:                  } else {
2267:                    resistance_set_point = magnetron_filament_on_resistance;
0023A6  804396     MOV magnetron_filament_on_resistance, W6
0023A8  980736     MOV W6, [W14+6]
2268:                  }
2269:                  
2270:              
2271:              #define RESISTANCE_HYSTERESIS 50
2272:                  
2273:                  // Only update heater once per second
2274:                  second_counter++;
0023AA  80B934     MOV _second_counter.8303, W4
0023AC  E80204     INC W4, W4
0023AE  88B934     MOV W4, _second_counter.8303
2275:                  if (second_counter >= 100) {
0023B0  80B935     MOV _second_counter.8303, W5
0023B2  200634     MOV #0x63, W4
0023B4  528F84     SUB W5, W4, [W15]
0023B6  360027     BRA LEU, .L182, .LSM1085
2276:                    second_counter = 0;
0023B8  EB0200     CLR W4
0023BA  88B934     MOV W4, _second_counter.8303
2277:                    if (magnetron_filament_resistance_measurement < (resistance_set_point - RESISTANCE_HYSTERESIS)) {
0023BC  90023E     MOV [W14+6], W4
0023BE  2FFCE5     MOV #0xFFCE, W5
0023C0  428284     ADD W5, W4, W5
0023C2  8043A4     MOV magnetron_filament_resistance_measurement, W4
0023C4  528F84     SUB W5, W4, [W15]
0023C6  360009     BRA LEU, .L201, .LSM1079
2278:              	// current is too low, incease it
2279:              	heater_scale_factor++;
0023C8  80B924     MOV _heater_scale_factor.8304, W4
0023CA  E80204     INC W4, W4
0023CC  88B924     MOV W4, _heater_scale_factor.8304
2280:              	if (heater_scale_factor > 100) {
0023CE  80B925     MOV _heater_scale_factor.8304, W5
0023D0  200644     MOV #0x64, W4
0023D2  528F84     SUB W5, W4, [W15]
0023D4  360002     BRA LEU, .L201, .LSM1079
2281:              	  heater_scale_factor = 100;
0023D6  200644     MOV #0x64, W4
0023D8  88B924     MOV W4, _heater_scale_factor.8304
2282:              	}
2283:                    }
2284:              
2285:                    if (magnetron_filament_resistance_measurement > (resistance_set_point + RESISTANCE_HYSTERESIS)) {
0023DA  90023E     MOV [W14+6], W4
0023DC  200325     MOV #0x32, W5
0023DE  428284     ADD W5, W4, W5
0023E0  8043A4     MOV magnetron_filament_resistance_measurement, W4
0023E2  528F84     SUB W5, W4, [W15]
0023E4  310006     BRA C, .L202, .LSM1082
2286:              	// current is too high, decrease it
2287:              	if (heater_scale_factor) {
0023E6  80B924     MOV _heater_scale_factor.8304, W4
0023E8  520FE0     SUB W4, #0x0, [W15]
0023EA  320003     BRA Z, .L202, .LSM1082
2288:              	  heater_scale_factor--;
0023EC  80B924     MOV _heater_scale_factor.8304, W4
0023EE  E90204     DEC W4, W4
0023F0  88B924     MOV W4, _heater_scale_factor.8304
2289:              	}
2290:                    }
2291:              
2292:                    if (heater_scale_factor < 30) {
0023F2  80B924     MOV _heater_scale_factor.8304, W4
0023F4  520FFD     SUB W4, #0x1D, [W15]
0023F6  3E0002     BRA GTU, .L203, .LSM1084
2293:              	heater_scale_factor = 30;
0023F8  2001E4     MOV #0x1E, W4
0023FA  88B924     MOV W4, _heater_scale_factor.8304
2294:                    }
2295:                    ScalePowerSupply(&ps_filament,heater_scale_factor,100);
0023FC  80B924     MOV _heater_scale_factor.8304, W4
0023FE  200642     MOV #0x64, W2
002400  780084     MOV W4, W1
002402  20AF80     MOV #0xAF8, W0
002404  07FBAF     RCALL ScalePowerSupply
2296:                  }
2297:                }
2298:              }
002406  FA8000     ULNK
002408  060000     RETURN
2299:              
2300:              
2301:              void ReadIsolatedAdcToRam(void) {
00240A  FA0004     LNK #0x4
2302:                /*
2303:                  This function reads back data from the external AD7686.
2304:                  When this function is called, the data has already been sampled, and the conversion is complete.
2305:                  The convert pin to the two AD7686 should be active
2306:              
2307:                  DO NOT COPY THIS FUNCTION TO OTHER APPLICATIONS - IT WILL NOT WORK BECAUSE THIS DOES NOT INCLUDE TO CODE TO SAMPLE THE INPUTS
2308:                */
2309:              
2310:                // reads data into global variable 
2311:                unsigned long adc_read;
2312:              
2313:              
2314:                last_known_action = LAST_ACTION_READ_ISOLATED_ADC;
00240C  200074     MOV #0x7, W4
00240E  88BDE4     MOV W4, last_known_action
2315:              
2316:                if (PIN_PULSE_ADC_TRIGGER == OLL_TRIGGER_PULSE_ADCS) {
002410  801625     MOV LATA, W5
002412  202004     MOV #0x200, W4
002414  628204     AND W5, W4, W4
002416  520FE0     SUB W4, #0x0, [W15]
002418  320037     BRA Z, .L205, .LSM1107
2317:                  // The convert signal is asserted like it should be
2318:              
2319:              
2320:                  // ----------  READ BACK THE CURRENT ADC CONVERSION ------------------------- //
2321:                  PIN_PULSE_IMON_CS = OLL_SELECT_PULSE_IMON_ADC;   // Select the Current Monitor ADC
00241A  A9C2D6     BCLR LATD, #6
2322:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
00241C  2024D0     MOV #0x24D, W0
00241E  200001     MOV #0x0, W1
002420  071B36     RCALL ___delay32
2323:                  adc_read = SendAndReceiveSPI(0, SPI_PORT_2);     // ReadData 16 bit value off of the Current Monitor ADC
002422  B3C021     MOV.B #0x2, W1
002424  EB0000     CLR W0
002426  071923     RCALL SendAndReceiveSPI
002428  BE0200     MOV.D W0, W4
00242A  BE8F04     MOV.D W4, [W14]
2324:                  if (adc_read == 0x11110000) {
00242C  200004     MOV #0x0, W4
00242E  211115     MOV #0x1111, W5
002430  BE031E     MOV.D [W14], W6
002432  530F84     SUB W6, W4, [W15]
002434  5B8F85     SUBB W7, W5, [W15]
002436  3A0006     BRA NZ, .L206, .LSM1095
2325:                    // THERE WAS an SPI ERROR
2326:                    pulse_magnetron_current_adc_reading = 0;
002438  EB0200     CLR W4
00243A  8843B4     MOV W4, pulse_magnetron_current_adc_reading
2327:                    global_debug_counter.spi2_bus_error++;
00243C  80B984     MOV .LSM631, W4
00243E  E80204     INC W4, W4
002440  88B984     MOV W4, .LSM631
002442  370002     BRA .L207, .LSM1096
2328:                  } else {
2329:                    pulse_magnetron_current_adc_reading = adc_read & 0xFFFF;
002444  78021E     MOV [W14], W4
002446  8843B4     MOV W4, pulse_magnetron_current_adc_reading
2330:                  }
2331:                  PIN_PULSE_IMON_CS = !OLL_SELECT_PULSE_IMON_ADC;  // De - Select the Current Monitor ADC  
002448  A8C2D6     BSET LATD, #6
2332:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
00244A  2024D0     MOV #0x24D, W0
00244C  200001     MOV #0x0, W1
00244E  071B1F     RCALL ___delay32
2333:                  
2334:                  
2335:              
2336:                  // ----------  READ BACK THE VOLTAGE ADC CONVERSION ------------------------- //
2337:                  PIN_PULSE_VMON_CS = OLL_SELECT_PULSE_VMON_ADC;   // Select the Voltage Monitor ADC
002450  A9A2D6     BCLR LATD, #5
2338:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);      // Wait for the cable select signal to propagate
002452  2024D0     MOV #0x24D, W0
002454  200001     MOV #0x0, W1
002456  071B1B     RCALL ___delay32
2339:                  adc_read = SendAndReceiveSPI(0, SPI_PORT_2);     // ReadData 16 bit value off of the Voltage Monitor ADC
002458  B3C021     MOV.B #0x2, W1
00245A  EB0000     CLR W0
00245C  071908     RCALL SendAndReceiveSPI
00245E  BE0200     MOV.D W0, W4
002460  BE8F04     MOV.D W4, [W14]
2340:                  if (adc_read == 0x11110000) {
002462  200004     MOV #0x0, W4
002464  211115     MOV #0x1111, W5
002466  BE031E     MOV.D [W14], W6
002468  530F84     SUB W6, W4, [W15]
00246A  5B8F85     SUBB W7, W5, [W15]
00246C  3A0006     BRA NZ, .L208, .LSM1104
2341:                    // THERE WAS an SPI ERROR
2342:                    pulse_magnetron_voltage_adc_reading = 0;
00246E  EB0200     CLR W4
002470  8843C4     MOV W4, pulse_magnetron_voltage_adc_reading
2343:                    global_debug_counter.spi2_bus_error++;
002472  80B984     MOV .LSM631, W4
002474  E80204     INC W4, W4
002476  88B984     MOV W4, .LSM631
002478  370002     BRA .L209, .LSM1105
2344:                  } else {
2345:                    pulse_magnetron_voltage_adc_reading = adc_read & 0xFFFF;
00247A  78021E     MOV [W14], W4
00247C  8843C4     MOV W4, pulse_magnetron_voltage_adc_reading
2346:                  }
2347:                  PIN_PULSE_VMON_CS = !OLL_SELECT_PULSE_VMON_ADC;  // De - Select the Current Monitor ADC  
00247E  A8A2D6     BSET LATD, #5
2348:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
002480  2024D0     MOV #0x24D, W0
002482  200001     MOV #0x0, W1
002484  071B04     RCALL ___delay32
002486  370007     BRA .L210, .LSM1110
2349:                
2350:                } else {
2351:                  // This function was called when the ADC convert signal was not asserted.  Something very bad happened 
2352:                  pulse_magnetron_voltage_adc_reading = 0;
002488  EB0200     CLR W4
00248A  8843C4     MOV W4, pulse_magnetron_voltage_adc_reading
2353:                  pulse_magnetron_current_adc_reading = 0;
00248C  EB0200     CLR W4
00248E  8843B4     MOV W4, pulse_magnetron_current_adc_reading
2354:                  global_debug_counter.external_adc_false_trigger++;
002490  80B994     MOV .LSM632, W4
002492  E80204     INC W4, W4
002494  88B994     MOV W4, .LSM632
2355:                }
2356:                PIN_PULSE_ADC_TRIGGER = !OLL_TRIGGER_PULSE_ADCS;   // Clear the convert trigger signal
002496  A922C5     BCLR 0x2C5, #1
2357:              } 
002498  FA8000     ULNK
00249A  060000     RETURN
2358:              
2359:              
2360:              
2361:              
2362:              void FilterADCs(void) {
00249C  FA0002     LNK #0x2
2363:                /*
2364:                  This function should be called once every 10mS from Do10msTicToc()
2365:                  The ADC value array is averaged and the the result of that average is low pass filtered.
2366:              
2367:                  From Internal DAC
2368:                  AN3 -  PFN Rev Current           - Only sampled after a pulse
2369:               
2370:                  AN4 - pac_#1                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2371:                  AN5 - pac_#2                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2372:              
2373:                  AN6 - Thyratron Cathode Heater   - 160mS tau - Analog Input Bandwidth = 10 Hz
2374:                  AN7 - Thyratron Reservoir Heater - 160mS tau - Analog Input Bandwidth = 10 Hz
2375:              
2376:                  AN8  - magnet_current            - 160mS tau - Analog Input Bandwidth = 200 Hz
2377:                  AN9  - magnet_voltage            - 160mS tau - Analog Input Bandwidth = 200 Hz
2378:               
2379:                  AN10 - filament_voltage          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2380:                  AN11 - filament_current          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2381:               
2382:                  AN12 - lambda_vpeak              - 640mS tau - Analog Input Bandwidth = 200 Hz
2383:                  AN13 - lambda_vmon               - Only Sampled at EOC
2384:                */
2385:                
2386:                unsigned int adc_reading;
2387:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
2388:                //unsigned int vtemp;
2389:              #endif
2390:              
2391:                last_known_action = LAST_ACTION_FILTER_ADC;
00249E  200064     MOV #0x6, W4
0024A0  88BDE4     MOV W4, last_known_action
2392:              
2393:                // AN3 -  PFN Rev Current           - Only Sampled after a pulse
2394:                // PFN Rev Current is read after a pulse
2395:              
2396:                //AN4 - pac_#1                     - 256 samples/tau - Analog Input Bandwidth = 200 Hz  
2397:                adc_reading = AverageADC128(pac_1_array);
0024A2  20D080     MOV #0xD08, W0
0024A4  071B02     RCALL _AverageADC128
0024A6  780200     MOV W0, W4
0024A8  780F04     MOV W4, [W14]
2398:                pac_1_adc_reading = RCFilter16Tau(pac_1_adc_reading, adc_reading);
0024AA  8042D4     MOV pac_1_adc_reading, W4
0024AC  78009E     MOV [W14], W1
0024AE  780004     MOV W4, W0
0024B0  070404     RCALL RCFilter16Tau
0024B2  780200     MOV W0, W4
0024B4  8842D4     MOV W4, pac_1_adc_reading
2399:              
2400:              
2401:                //AN5 - pac_#2                     - 256 samples/tau - Analog Input Bandwidth = 200 Hz
2402:                adc_reading = AverageADC128(pac_2_array);
0024B6  20E080     MOV #0xE08, W0
0024B8  071AF8     RCALL _AverageADC128
0024BA  780200     MOV W0, W4
0024BC  780F04     MOV W4, [W14]
2403:                pac_2_adc_reading = RCFilter16Tau(pac_2_adc_reading, adc_reading);
0024BE  8042E4     MOV pac_2_adc_reading, W4
0024C0  78009E     MOV [W14], W1
0024C2  780004     MOV W4, W0
0024C4  0703FA     RCALL RCFilter16Tau
0024C6  780200     MOV W0, W4
0024C8  8842E4     MOV W4, pac_2_adc_reading
2404:                
2405:              
2406:                if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
0024CA  801735     MOV PORTG, W5
0024CC  240004     MOV #0x4000, W4
0024CE  628204     AND W5, W4, W4
0024D0  520FE0     SUB W4, #0x0, [W15]
0024D2  3A0002     BRA NZ, .L212, .LSM1120
2407:                  default_pac_2_adc_reading = pac_2_adc_reading;
0024D4  8042E4     MOV pac_2_adc_reading, W4
0024D6  8840F4     MOV W4, default_pac_2_adc_reading
2408:                }
2409:              
2410:              
2411:                //AN6 - Thyratron Cathode Heater   - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2412:                //adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
2413:                //ps_thyr_cathode_htr.v_adc_reading = RCFilter16Tau(ps_thyr_cathode_htr.v_adc_reading, adc_reading);
2414:              
2415:              
2416:                //AN7 - Thyratron Reservoir Heater - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2417:                //adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
2418:                //ps_thyr_reservoir_htr.v_adc_reading = RCFilter16Tau(ps_thyr_reservoir_htr.v_adc_reading, adc_reading);
2419:              
2420:              
2421:                //AN8  - magnet_current            - 16 samples/tau - Analog Input Bandwidth = 200 Hz  
2422:                adc_reading = AverageADC128(magnetron_magnet_current_array);
0024D8  211080     MOV #0x1108, W0
0024DA  071AE7     RCALL _AverageADC128
0024DC  780200     MOV W0, W4
0024DE  780F04     MOV W4, [W14]
2423:                ps_magnet.i_adc_reading = RCFilter16Tau(ps_magnet.i_adc_reading, adc_reading);
0024E0  8056D4     MOV .LSM109, W4
0024E2  78009E     MOV [W14], W1
0024E4  780004     MOV W4, W0
0024E6  0703E9     RCALL RCFilter16Tau
0024E8  780200     MOV W0, W4
0024EA  8856D4     MOV W4, .LSM109
2424:              
2425:                //AN9  - magnet_voltage            - 16 samples/tau - Analog Input Bandwidth = 200 Hz
2426:                adc_reading = AverageADC128(magnetron_magnet_voltage_array);
0024EC  212080     MOV #0x1208, W0
0024EE  071ADD     RCALL _AverageADC128
0024F0  780200     MOV W0, W4
0024F2  780F04     MOV W4, [W14]
2427:                ps_magnet.v_adc_reading = RCFilter16Tau(ps_magnet.v_adc_reading, adc_reading);
0024F4  805574     MOV 0xAAE, W4
0024F6  78009E     MOV [W14], W1
0024F8  780004     MOV W4, W0
0024FA  0703DF     RCALL RCFilter16Tau
0024FC  780200     MOV W0, W4
0024FE  885574     MOV W4, 0xAAE
2428:               
2429:                //AN10 - filament_voltage          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2430:                adc_reading = AverageADC128(magnetron_filament_voltage_array);
002500  214080     MOV #0x1408, W0
002502  071AD3     RCALL _AverageADC128
002504  780200     MOV W0, W4
002506  780F04     MOV W4, [W14]
2431:                ps_filament.v_adc_reading = RCFilter16Tau(ps_filament.v_adc_reading, adc_reading);
002508  805844     MOV 0xB08, W4
00250A  78009E     MOV [W14], W1
00250C  780004     MOV W4, W0
00250E  0703D5     RCALL RCFilter16Tau
002510  780200     MOV W0, W4
002512  885844     MOV W4, 0xB08
2432:              
2433:                //AN11 - filament_current          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2434:                adc_reading = AverageADC128(magnetron_filament_current_array);
002514  213080     MOV #0x1308, W0
002516  071AC9     RCALL _AverageADC128
002518  780200     MOV W0, W4
00251A  780F04     MOV W4, [W14]
2435:                ps_filament.i_adc_reading = RCFilter16Tau(ps_filament.i_adc_reading, adc_reading);
00251C  8059A4     MOV 0xB34, W4
00251E  78009E     MOV [W14], W1
002520  780004     MOV W4, W0
002522  0703CB     RCALL RCFilter16Tau
002524  780200     MOV W0, W4
002526  8859A4     MOV W4, 0xB34
2436:              
2437:                //AN12 - lambda_vpeak              - 64 samples/tau - Analog Input Bandwidth = 200 Hz
2438:                adc_reading = AverageADC128(lambda_vpeak_array);
002528  215080     MOV #0x1508, W0
00252A  071ABF     RCALL _AverageADC128
00252C  780200     MOV W0, W4
00252E  780F04     MOV W4, [W14]
2439:                ps_hv_lambda_mode_A.v_adc_reading = RCFilter16Tau(ps_hv_lambda_mode_A.v_adc_reading, adc_reading);
002530  804A34     MOV .LSM52, W4
002532  78009E     MOV [W14], W1
002534  780004     MOV W4, W0
002536  0703C1     RCALL RCFilter16Tau
002538  780200     MOV W0, W4
00253A  884A34     MOV W4, .LSM52
2440:              
2441:                //AN13 - lambda_vmon               - not averaged / filtered  - Analog Input Bandwidth = 200 Hz
2442:                adc_reading = AverageADC128(lambda_vmon_array);
00253C  216080     MOV #0x1608, W0
00253E  071AB5     RCALL _AverageADC128
002540  780200     MOV W0, W4
002542  780F04     MOV W4, [W14]
2443:                ps_hv_lambda_mode_B.v_adc_reading = RCFilter16Tau(ps_hv_lambda_mode_B.v_adc_reading, adc_reading);
002544  804FD4     MOV 0x9FA, W4
002546  78009E     MOV [W14], W1
002548  780004     MOV W4, W0
00254A  0703B7     RCALL RCFilter16Tau
00254C  780200     MOV W0, W4
00254E  884FD4     MOV W4, 0x9FA
2444:                // lambda_vmon is read at EOC
2445:                
2446:              }
002550  FA8000     ULNK
002552  060000     RETURN
2447:              
2448:              
2449:              
2450:              
2451:              
2452:              void FastReadAndFilterFeedbacks(void) {
002554  FA0006     LNK #0x6
2453:                /*
2454:                  This function should be called once durring fast restart.
2455:                  The ADC value array is populated, averaged and the the result of that average used to set initial condition for RC Filter.
2456:              
2457:                  From Internal DAC
2458:                  AN3 -  PFN Rev Current           - Only sampled after a pulse 
2459:               
2460:                  AN4 - pac_#1                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2461:                  AN5 - pac_#2                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2462:              
2463:                  AN6 - Thyratron Cathode Heater   - 160mS tau - Analog Input Bandwidth = 10 Hz
2464:                  AN7 - Thyratron Reservoir Heater - 160mS tau - Analog Input Bandwidth = 10 Hz
2465:              
2466:                  AN8  - magnet_current            - 160mS tau - Analog Input Bandwidth = 200 Hz
2467:                  AN9  - magnet_voltage            - 160mS tau - Analog Input Bandwidth = 200 Hz
2468:               
2469:                  AN10 - filament_voltage          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2470:                  AN11 - filament_current          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2471:               
2472:                  AN12 - lambda_vpeak              - 640mS tau - Analog Input Bandwidth = 200 Hz
2473:                  AN13 - lambda_vmon               - Only Sampled at EOC
2474:                */
2475:              
2476:              
2477:                unsigned int index;
2478:                unsigned int n;
2479:                unsigned int adc_reading;
2480:                
2481:                // Configure ADC for this particular operation
2482:                ADCON1 = A34760_ADCON1_VALUE;
002556  27CFF4     MOV #0x7CFF, W4
002558  881504     MOV W4, ADCON1
2483:                ADCON2 = (ADC_VREF_AVDD_AVSS & ADC_SCAN_ON & ADC_SAMPLES_PER_INT_8 & ADC_ALT_BUF_ON & ADC_ALT_INPUT_OFF);
00255A  20FDE4     MOV #0xFDE, W4
00255C  881514     MOV W4, ADCON2
2484:                ADCON3 = A34760_ADCON3_VALUE;
00255E  2E3534     MOV #0xE353, W4
002560  881524     MOV W4, ADCON3
2485:                ADCHS  = A34760_ADCHS_VALUE;
002562  2EFE34     MOV #0xEFE3, W4
002564  881534     MOV W4, ADCHS
2486:                ADPCFG = A34760_ADPCFG_VALUE;
002566  2C0074     MOV #0xC007, W4
002568  881544     MOV W4, ADPCFG
2487:                ADCSSL = (SKIP_SCAN_AN0 & SKIP_SCAN_AN1 & SKIP_SCAN_AN2 & SKIP_SCAN_AN3 & SKIP_SCAN_AN4 & SKIP_SCAN_AN5 & SKIP_SCAN_AN14 & SKIP_SCAN_AN15);
00256A  23FC04     MOV #0x3FC0, W4
00256C  881554     MOV W4, ADCSSL
2488:                ADCON1bits.ADON = 1;
00256E  A8E2A1     BSET 0x2A1, #7
2489:              
2490:                index = 0;
002570  EB0200     CLR W4
002572  780F04     MOV W4, [W14]
2491:                while (index < 128) {
002574  370080     BRA .L214, .LSM1165
002676  2007F4     MOV #0x7F, W4
002678  78029E     MOV [W14], W5
00267A  528F84     SUB W5, W4, [W15]
00267C  36FF7C     BRA LEU, .L222, .LSM1143
2492:                  while(!_BUFS);
002576  000000     NOP
002578  801515     MOV ADCON2, W5
00257A  200804     MOV #0x80, W4
00257C  628204     AND W5, W4, W4
00257E  520FE0     SUB W4, #0x0, [W15]
002580  32FFFB     BRA Z, .L215
2493:                  // Copy each reading into 8 data readings 
2494:                  for (n = 0; n < 8; n++) {
002582  EB0200     CLR W4
002584  980714     MOV W4, [W14+2]
002586  370034     BRA .L216
0025EA  90021E     MOV [W14+2], W4
0025EC  E80204     INC W4, W4
0025EE  980714     MOV W4, [W14+2]
0025F0  90021E     MOV [W14+2], W4
0025F2  520FE7     SUB W4, #0x7, [W15]
0025F4  36FFC9     BRA LEU, .L217, .LSM1145
2495:                    thyratron_cathode_heater_voltage_array[index] = ADCBUF0;
002588  801405     MOV ADCBUF0, W5
00258A  78021E     MOV [W14], W4
00258C  420304     ADD W4, W4, W6
00258E  20F084     MOV #0xF08, W4
002590  430204     ADD W6, W4, W4
002592  780A05     MOV W5, [W4]
2496:                    thyratron_reservoir_heater_voltage_array[index] = ADCBUF1;
002594  801415     MOV ADCBUF1, W5
002596  78021E     MOV [W14], W4
002598  420304     ADD W4, W4, W6
00259A  210084     MOV #0x1008, W4
00259C  430204     ADD W6, W4, W4
00259E  780A05     MOV W5, [W4]
2497:                    magnetron_magnet_current_array[index] = ADCBUF2;
0025A0  801425     MOV ADCBUF2, W5
0025A2  78021E     MOV [W14], W4
0025A4  420304     ADD W4, W4, W6
0025A6  211084     MOV #0x1108, W4
0025A8  430204     ADD W6, W4, W4
0025AA  780A05     MOV W5, [W4]
2498:                    magnetron_magnet_voltage_array[index] = ADCBUF3;
0025AC  801435     MOV ADCBUF3, W5
0025AE  78021E     MOV [W14], W4
0025B0  420304     ADD W4, W4, W6
0025B2  212084     MOV #0x1208, W4
0025B4  430204     ADD W6, W4, W4
0025B6  780A05     MOV W5, [W4]
2499:                    magnetron_filament_current_array[index] = ADCBUF4;
0025B8  801445     MOV ADCBUF4, W5
0025BA  78021E     MOV [W14], W4
0025BC  420304     ADD W4, W4, W6
0025BE  213084     MOV #0x1308, W4
0025C0  430204     ADD W6, W4, W4
0025C2  780A05     MOV W5, [W4]
2500:                    magnetron_filament_voltage_array[index] = ADCBUF5;
0025C4  801455     MOV ADCBUF5, W5
0025C6  78021E     MOV [W14], W4
0025C8  420304     ADD W4, W4, W6
0025CA  214084     MOV #0x1408, W4
0025CC  430204     ADD W6, W4, W4
0025CE  780A05     MOV W5, [W4]
2501:                    lambda_vpeak_array[index] = ADCBUF6;
0025D0  801465     MOV ADCBUF6, W5
0025D2  78021E     MOV [W14], W4
0025D4  420304     ADD W4, W4, W6
0025D6  215084     MOV #0x1508, W4
0025D8  430204     ADD W6, W4, W4
0025DA  780A05     MOV W5, [W4]
2502:                    lambda_vmon_array[index++] = ADCBUF7;
0025DC  801475     MOV ADCBUF7, W5
0025DE  78021E     MOV [W14], W4
0025E0  420304     ADD W4, W4, W6
0025E2  216084     MOV #0x1608, W4
0025E4  430204     ADD W6, W4, W4
0025E6  780A05     MOV W5, [W4]
0025E8  E80F1E     INC [W14], [W14]
2503:                  }
2504:                  while(_BUFS);
0025F6  000000     NOP
0025F8  801515     MOV ADCON2, W5
0025FA  200804     MOV #0x80, W4
0025FC  628204     AND W5, W4, W4
0025FE  520FE0     SUB W4, #0x0, [W15]
002600  3AFFFB     BRA NZ, .L218
2505:                  // Copy each reading into 8 data readings 
2506:                  for (n = 0; n < 8; n++) {
002602  EB0200     CLR W4
002604  980714     MOV W4, [W14+2]
002606  370034     BRA .L219
00266A  90021E     MOV [W14+2], W4
00266C  E80204     INC W4, W4
00266E  980714     MOV W4, [W14+2]
002670  90021E     MOV [W14+2], W4
002672  520FE7     SUB W4, #0x7, [W15]
002674  36FFC9     BRA LEU, .L220, .LSM1156
2507:                    thyratron_cathode_heater_voltage_array[index] = ADCBUF8;
002608  801485     MOV ADCBUF8, W5
00260A  78021E     MOV [W14], W4
00260C  420304     ADD W4, W4, W6
00260E  20F084     MOV #0xF08, W4
002610  430204     ADD W6, W4, W4
002612  780A05     MOV W5, [W4]
2508:                    thyratron_reservoir_heater_voltage_array[index] = ADCBUF9;
002614  801495     MOV ADCBUF9, W5
002616  78021E     MOV [W14], W4
002618  420304     ADD W4, W4, W6
00261A  210084     MOV #0x1008, W4
00261C  430204     ADD W6, W4, W4
00261E  780A05     MOV W5, [W4]
2509:                    magnetron_magnet_current_array[index] = ADCBUFA;
002620  8014A5     MOV ADCBUFA, W5
002622  78021E     MOV [W14], W4
002624  420304     ADD W4, W4, W6
002626  211084     MOV #0x1108, W4
002628  430204     ADD W6, W4, W4
00262A  780A05     MOV W5, [W4]
2510:                    magnetron_magnet_voltage_array[index] = ADCBUFB;
00262C  8014B5     MOV ADCBUFB, W5
00262E  78021E     MOV [W14], W4
002630  420304     ADD W4, W4, W6
002632  212084     MOV #0x1208, W4
002634  430204     ADD W6, W4, W4
002636  780A05     MOV W5, [W4]
2511:                    magnetron_filament_current_array[index] = ADCBUFC;
002638  8014C5     MOV ADCBUFC, W5
00263A  78021E     MOV [W14], W4
00263C  420304     ADD W4, W4, W6
00263E  213084     MOV #0x1308, W4
002640  430204     ADD W6, W4, W4
002642  780A05     MOV W5, [W4]
2512:                    magnetron_filament_voltage_array[index] = ADCBUFD;
002644  8014D5     MOV ADCBUFD, W5
002646  78021E     MOV [W14], W4
002648  420304     ADD W4, W4, W6
00264A  214084     MOV #0x1408, W4
00264C  430204     ADD W6, W4, W4
00264E  780A05     MOV W5, [W4]
2513:                    lambda_vpeak_array[index] = ADCBUFE;
002650  8014E5     MOV ADCBUFE, W5
002652  78021E     MOV [W14], W4
002654  420304     ADD W4, W4, W6
002656  215084     MOV #0x1508, W4
002658  430204     ADD W6, W4, W4
00265A  780A05     MOV W5, [W4]
2514:                    lambda_vmon_array[index++] = ADCBUFF;
00265C  8014F5     MOV ADCBUFF, W5
00265E  78021E     MOV [W14], W4
002660  420304     ADD W4, W4, W6
002662  216084     MOV #0x1608, W4
002664  430204     ADD W6, W4, W4
002666  780A05     MOV W5, [W4]
002668  E80F1E     INC [W14], [W14]
2515:                  }
2516:                }
2517:                ADCON1bits.ADON = 0;
00267E  A9E2A1     BCLR 0x2A1, #7
2518:              
2519:                //AN6 - Thyratron Cathode Heater   - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2520:                adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
002680  20F080     MOV #0xF08, W0
002682  071A13     RCALL _AverageADC128
002684  780200     MOV W0, W4
002686  980724     MOV W4, [W14+4]
2521:                ps_thyr_cathode_htr.v_adc_reading = adc_reading;
002688  90022E     MOV [W14+4], W4
00268A  885B14     MOV W4, 0xB62
2522:              
2523:                //AN7 - Thyratron Reservoir Heater - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2524:                adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
00268C  210080     MOV #0x1008, W0
00268E  071A0D     RCALL _AverageADC128
002690  780200     MOV W0, W4
002692  980724     MOV W4, [W14+4]
2525:                ps_thyr_reservoir_htr.v_adc_reading = adc_reading;
002694  90022E     MOV [W14+4], W4
002696  885DE4     MOV W4, 0xBBC
2526:              
2527:                //AN8  - magnet_current            - 16 samples/tau - Analog Input Bandwidth = 200 Hz  
2528:                adc_reading = AverageADC128(magnetron_magnet_current_array);
002698  211080     MOV #0x1108, W0
00269A  071A07     RCALL _AverageADC128
00269C  780200     MOV W0, W4
00269E  980724     MOV W4, [W14+4]
2529:                ps_magnet.i_adc_reading = adc_reading;
0026A0  90022E     MOV [W14+4], W4
0026A2  8856D4     MOV W4, .LSM109
2530:              
2531:                //AN9  - magnet_voltage            - 16 samples/tau - Analog Input Bandwidth = 200 Hz
2532:                adc_reading = AverageADC128(magnetron_magnet_voltage_array);
0026A4  212080     MOV #0x1208, W0
0026A6  071A01     RCALL _AverageADC128
0026A8  780200     MOV W0, W4
0026AA  980724     MOV W4, [W14+4]
2533:                ps_magnet.v_adc_reading = adc_reading;
0026AC  90022E     MOV [W14+4], W4
0026AE  885574     MOV W4, 0xAAE
2534:               
2535:                //AN10 - filament_voltage          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2536:                adc_reading = AverageADC128(magnetron_filament_voltage_array);
0026B0  214080     MOV #0x1408, W0
0026B2  0719FB     RCALL _AverageADC128
0026B4  780200     MOV W0, W4
0026B6  980724     MOV W4, [W14+4]
2537:                ps_filament.v_adc_reading = adc_reading;
0026B8  90022E     MOV [W14+4], W4
0026BA  885844     MOV W4, 0xB08
2538:              
2539:                //AN11 - filament_current          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2540:                adc_reading = AverageADC128(magnetron_filament_current_array);
0026BC  213080     MOV #0x1308, W0
0026BE  0719F5     RCALL _AverageADC128
0026C0  780200     MOV W0, W4
0026C2  980724     MOV W4, [W14+4]
2541:                ps_filament.i_adc_reading = adc_reading;
0026C4  90022E     MOV [W14+4], W4
0026C6  8859A4     MOV W4, 0xB34
2542:              
2543:                //AN12 - lambda_vpeak              - 64 samples/tau - Analog Input Bandwidth = 200 Hz
2544:                adc_reading = AverageADC128(lambda_vpeak_array);
0026C8  215080     MOV #0x1508, W0
0026CA  0719EF     RCALL _AverageADC128
0026CC  780200     MOV W0, W4
0026CE  980724     MOV W4, [W14+4]
2545:                ps_hv_lambda_mode_A.v_adc_reading = adc_reading;
0026D0  90022E     MOV [W14+4], W4
0026D2  884A34     MOV W4, .LSM52
2546:              
2547:                //AN13 - lambda_vmon               - not averaged / filtered  - Analog Input Bandwidth = 200 Hz
2548:                adc_reading = AverageADC128(lambda_vmon_array);
0026D4  216080     MOV #0x1608, W0
0026D6  0719E9     RCALL _AverageADC128
0026D8  780200     MOV W0, W4
0026DA  980724     MOV W4, [W14+4]
2549:                ps_hv_lambda_mode_B.v_adc_reading = adc_reading;
0026DC  90022E     MOV [W14+4], W4
0026DE  884FD4     MOV W4, 0x9FA
2550:              
2551:              }
0026E0  FA8000     ULNK
0026E2  060000     RETURN
2552:              
2553:              
2554:              
2555:              
2556:              void FastReadAndFilterPACInputs(void) {
0026E4  FA0006     LNK #0x6
2557:                unsigned int index;
2558:                unsigned int n;
2559:                unsigned int adc_reading;
2560:                
2561:                // Configure ADC for this particular operation
2562:                ADCON1 = A34760_ADCON1_VALUE;
0026E6  27CFF4     MOV #0x7CFF, W4
0026E8  881504     MOV W4, ADCON1
2563:                ADCON2 = (ADC_VREF_AVDD_AVSS & ADC_SCAN_ON & ADC_SAMPLES_PER_INT_8 & ADC_ALT_BUF_ON & ADC_ALT_INPUT_OFF);
0026EA  20FDE4     MOV #0xFDE, W4
0026EC  881514     MOV W4, ADCON2
2564:                ADCON3 = A34760_ADCON3_VALUE;
0026EE  2E3534     MOV #0xE353, W4
0026F0  881524     MOV W4, ADCON3
2565:                ADCHS  = A34760_ADCHS_VALUE;
0026F2  2EFE34     MOV #0xEFE3, W4
0026F4  881534     MOV W4, ADCHS
2566:                ADPCFG = A34760_ADPCFG_VALUE;
0026F6  2C0074     MOV #0xC007, W4
0026F8  881544     MOV W4, ADPCFG
2567:                ADCSSL = (SKIP_SCAN_AN0 & SKIP_SCAN_AN1 & SKIP_SCAN_AN2 & SKIP_SCAN_AN3 & SKIP_SCAN_AN6 & SKIP_SCAN_AN7 & SKIP_SCAN_AN8 & SKIP_SCAN_AN9 & SKIP_SCAN_AN10 & SKIP_SCAN_AN11 & SKIP_SCAN_AN12 & SKIP_SCAN_AN13 & SKIP_SCAN_AN14 & SKIP_SCAN_AN15);
0026FA  200304     MOV #0x30, W4
0026FC  881554     MOV W4, ADCSSL
2568:                ADCON1bits.ADON = 1;
0026FE  A8E2A1     BSET 0x2A1, #7
2569:              
2570:                
2571:                // Repeate the sample sequence until we have filled up the pac arrays
2572:                index = 0;
002700  EB0200     CLR W4
002702  780F04     MOV W4, [W14]
2573:                while (index < 128) {
002704  370086     BRA .L224, .LSM1216
002812  2007F4     MOV #0x7F, W4
002814  78029E     MOV [W14], W5
002816  528F84     SUB W5, W4, [W15]
002818  36FF76     BRA LEU, .L232, .LSM1194
2574:                  // wait for buffer 0-8 to fill up
2575:                  while(!_BUFS);
002706  000000     NOP
002708  801515     MOV ADCON2, W5
00270A  200804     MOV #0x80, W4
00270C  628204     AND W5, W4, W4
00270E  520FE0     SUB W4, #0x0, [W15]
002710  32FFFB     BRA Z, .L225
2576:                  for (n = 0; n < 4; n++) {
002712  EB0200     CLR W4
002714  980714     MOV W4, [W14+2]
002716  370037     BRA .L226
002780  90021E     MOV [W14+2], W4
002782  E80204     INC W4, W4
002784  980714     MOV W4, [W14+2]
002786  90021E     MOV [W14+2], W4
002788  520FE3     SUB W4, #0x3, [W15]
00278A  36FFC6     BRA LEU, .L227, .LSM1196
2577:                    pac_1_array[index] = ADCBUF0;
002718  801405     MOV ADCBUF0, W5
00271A  78021E     MOV [W14], W4
00271C  420304     ADD W4, W4, W6
00271E  20D084     MOV #0xD08, W4
002720  430204     ADD W6, W4, W4
002722  780A05     MOV W5, [W4]
2578:                    pac_2_array[index++] = ADCBUF1;
002724  801415     MOV ADCBUF1, W5
002726  78021E     MOV [W14], W4
002728  420304     ADD W4, W4, W6
00272A  20E084     MOV #0xE08, W4
00272C  430204     ADD W6, W4, W4
00272E  780A05     MOV W5, [W4]
002730  E80F1E     INC [W14], [W14]
2579:                    pac_1_array[index] = ADCBUF2;
002732  801425     MOV ADCBUF2, W5
002734  78021E     MOV [W14], W4
002736  420304     ADD W4, W4, W6
002738  20D084     MOV #0xD08, W4
00273A  430204     ADD W6, W4, W4
00273C  780A05     MOV W5, [W4]
2580:                    pac_2_array[index++] = ADCBUF3;
00273E  801435     MOV ADCBUF3, W5
002740  78021E     MOV [W14], W4
002742  420304     ADD W4, W4, W6
002744  20E084     MOV #0xE08, W4
002746  430204     ADD W6, W4, W4
002748  780A05     MOV W5, [W4]
00274A  E80F1E     INC [W14], [W14]
2581:                    pac_1_array[index] = ADCBUF4;
00274C  801445     MOV ADCBUF4, W5
00274E  78021E     MOV [W14], W4
002750  420304     ADD W4, W4, W6
002752  20D084     MOV #0xD08, W4
002754  430204     ADD W6, W4, W4
002756  780A05     MOV W5, [W4]
2582:                    pac_2_array[index++] = ADCBUF5;
002758  801455     MOV ADCBUF5, W5
00275A  78021E     MOV [W14], W4
00275C  420304     ADD W4, W4, W6
00275E  20E084     MOV #0xE08, W4
002760  430204     ADD W6, W4, W4
002762  780A05     MOV W5, [W4]
002764  E80F1E     INC [W14], [W14]
2583:                    pac_1_array[index] = ADCBUF6;
002766  801465     MOV ADCBUF6, W5
002768  78021E     MOV [W14], W4
00276A  420304     ADD W4, W4, W6
00276C  20D084     MOV #0xD08, W4
00276E  430204     ADD W6, W4, W4
002770  780A05     MOV W5, [W4]
2584:                    pac_2_array[index++] = ADCBUF7;  
002772  801475     MOV ADCBUF7, W5
002774  78021E     MOV [W14], W4
002776  420304     ADD W4, W4, W6
002778  20E084     MOV #0xE08, W4
00277A  430204     ADD W6, W4, W4
00277C  780A05     MOV W5, [W4]
00277E  E80F1E     INC [W14], [W14]
2585:                  }
2586:                  
2587:                  // wait for buffers 9-F to fill up
2588:                  while(_BUFS);
00278C  000000     NOP
00278E  801515     MOV ADCON2, W5
002790  200804     MOV #0x80, W4
002792  628204     AND W5, W4, W4
002794  520FE0     SUB W4, #0x0, [W15]
002796  3AFFFB     BRA NZ, .L228
2589:                  for (n = 0; n < 4; n++) {
002798  EB0200     CLR W4
00279A  980714     MOV W4, [W14+2]
00279C  370037     BRA .L229
002806  90021E     MOV [W14+2], W4
002808  E80204     INC W4, W4
00280A  980714     MOV W4, [W14+2]
00280C  90021E     MOV [W14+2], W4
00280E  520FE3     SUB W4, #0x3, [W15]
002810  36FFC6     BRA LEU, .L230, .LSM1207
2590:                    pac_1_array[index] = ADCBUF8;
00279E  801485     MOV ADCBUF8, W5
0027A0  78021E     MOV [W14], W4
0027A2  420304     ADD W4, W4, W6
0027A4  20D084     MOV #0xD08, W4
0027A6  430204     ADD W6, W4, W4
0027A8  780A05     MOV W5, [W4]
2591:                    pac_2_array[index++] = ADCBUF9;
0027AA  801495     MOV ADCBUF9, W5
0027AC  78021E     MOV [W14], W4
0027AE  420304     ADD W4, W4, W6
0027B0  20E084     MOV #0xE08, W4
0027B2  430204     ADD W6, W4, W4
0027B4  780A05     MOV W5, [W4]
0027B6  E80F1E     INC [W14], [W14]
2592:                    pac_1_array[index] = ADCBUFA;
0027B8  8014A5     MOV ADCBUFA, W5
0027BA  78021E     MOV [W14], W4
0027BC  420304     ADD W4, W4, W6
0027BE  20D084     MOV #0xD08, W4
0027C0  430204     ADD W6, W4, W4
0027C2  780A05     MOV W5, [W4]
2593:                    pac_2_array[index++] = ADCBUFB;
0027C4  8014B5     MOV ADCBUFB, W5
0027C6  78021E     MOV [W14], W4
0027C8  420304     ADD W4, W4, W6
0027CA  20E084     MOV #0xE08, W4
0027CC  430204     ADD W6, W4, W4
0027CE  780A05     MOV W5, [W4]
0027D0  E80F1E     INC [W14], [W14]
2594:                    pac_1_array[index] = ADCBUFC;
0027D2  8014C5     MOV ADCBUFC, W5
0027D4  78021E     MOV [W14], W4
0027D6  420304     ADD W4, W4, W6
0027D8  20D084     MOV #0xD08, W4
0027DA  430204     ADD W6, W4, W4
0027DC  780A05     MOV W5, [W4]
2595:                    pac_2_array[index++] = ADCBUFD;
0027DE  8014D5     MOV ADCBUFD, W5
0027E0  78021E     MOV [W14], W4
0027E2  420304     ADD W4, W4, W6
0027E4  20E084     MOV #0xE08, W4
0027E6  430204     ADD W6, W4, W4
0027E8  780A05     MOV W5, [W4]
0027EA  E80F1E     INC [W14], [W14]
2596:                    pac_1_array[index] = ADCBUFE;
0027EC  8014E5     MOV ADCBUFE, W5
0027EE  78021E     MOV [W14], W4
0027F0  420304     ADD W4, W4, W6
0027F2  20D084     MOV #0xD08, W4
0027F4  430204     ADD W6, W4, W4
0027F6  780A05     MOV W5, [W4]
2597:                    pac_2_array[index++] = ADCBUFF;  
0027F8  8014F5     MOV ADCBUFF, W5
0027FA  78021E     MOV [W14], W4
0027FC  420304     ADD W4, W4, W6
0027FE  20E084     MOV #0xE08, W4
002800  430204     ADD W6, W4, W4
002802  780A05     MOV W5, [W4]
002804  E80F1E     INC [W14], [W14]
2598:                  }    
2599:                }
2600:                ADCON1bits.ADON = 0;
00281A  A9E2A1     BCLR 0x2A1, #7
2601:                
2602:              
2603:                // Average Pac Array and Populte the RC Filter
2604:                // This is just copied from Filter ADCs
2605:                adc_reading = AverageADC128(pac_1_array);
00281C  20D080     MOV #0xD08, W0
00281E  071945     RCALL _AverageADC128
002820  780200     MOV W0, W4
002822  980724     MOV W4, [W14+4]
2606:                pac_1_adc_reading = adc_reading;
002824  90022E     MOV [W14+4], W4
002826  8842D4     MOV W4, pac_1_adc_reading
2607:                
2608:                adc_reading = AverageADC128(pac_2_array);
002828  20E080     MOV #0xE08, W0
00282A  07193F     RCALL _AverageADC128
00282C  780200     MOV W0, W4
00282E  980724     MOV W4, [W14+4]
2609:                pac_2_adc_reading = adc_reading;
002830  90022E     MOV [W14+4], W4
002832  8842E4     MOV W4, pac_2_adc_reading
2610:              }
002834  FA8000     ULNK
002836  060000     RETURN
2611:              
2612:              
2613:              
2614:              
2615:              
2616:              
2617:              void ExitHvOnState(void) {
002838  FA0004     LNK #0x4
2618:                // this subroutine is called to properly shut down the HV on state
2619:                // This required interrupts to be disabled/cleared/ect
2620:                
2621:                SET_CPU_IPL(7); // Disable all interrupts
00283A  800294     MOV DISICNT, W4
00283C  780F04     MOV W4, [W14]
00283E  FC3FFF     DISI #0x3FFF
002840  800214     MOV SR, W4
002842  A05004     BSET W4, #5
002844  A06004     BSET W4, #6
002846  A07004     BSET W4, #7
002848  880214     MOV W4, SR
00284A  78021E     MOV [W14], W4
00284C  880294     MOV W4, DISICNT
00284E  880000     MOV W0, WREG0
2622:                Nop();
002850  000000     NOP
2623:                Nop();
002852  000000     NOP
2624:                Nop();
002854  000000     NOP
2625:                Nop();
002856  000000     NOP
2626:                _T1IE = 0;      // Disable the T1 interrupt.  The T1 interrupt enables INT1 Interrupt
002858  A9608C     BCLR IEC0, #3
2627:                _INT1IE = 0;    // Disable the INT1 Interrupt.  INT1 enables T1 Interrupt.
00285A  A9008E     BCLR IEC1, #0
2628:                SET_CPU_IPL(0); // Enable all interrupts
00285C  800294     MOV DISICNT, W4
00285E  980714     MOV W4, [W14+2]
002860  FC3FFF     DISI #0x3FFF
002862  800214     MOV SR, W4
002864  A15004     BCLR W4, #5
002866  A16004     BCLR W4, #6
002868  A17004     BCLR W4, #7
00286A  880214     MOV W4, SR
00286C  90021E     MOV [W14+2], W4
00286E  880294     MOV W4, DISICNT
002870  880000     MOV W0, WREG0
2629:                SavePulseCountersToEEPROM();
002872  070003     RCALL SavePulseCountersToEEPROM
2630:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;
002874  A8E2CB     BSET 0x2CB, #7
2631:              }
002876  FA8000     ULNK
002878  060000     RETURN
2632:              
2633:              void SavePulseCountersToEEPROM(void) {
00287A  FA0022     LNK #0x22
2634:                unsigned int *unsigned_int_ptr;
2635:                unsigned int eeprom_write_data[16];
2636:              
2637:                unsigned_int_ptr = (unsigned int*)&pulse_counter_persistent;              //unsigned_int_ptr now points to the Least Significant word of pulse_counter_persistent
00287C  2179E4     MOV #0x179E, W4
00287E  780F04     MOV W4, [W14]
2638:                eeprom_write_data[3] = *unsigned_int_ptr; 
002880  78021E     MOV [W14], W4
002882  780214     MOV [W4], W4
002884  980744     MOV W4, [W14+8]
2639:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
002886  E88F1E     INC2 [W14], [W14]
2640:                eeprom_write_data[2] = *unsigned_int_ptr;
002888  78021E     MOV [W14], W4
00288A  780214     MOV [W4], W4
00288C  980734     MOV W4, [W14+6]
2641:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
00288E  E88F1E     INC2 [W14], [W14]
2642:                eeprom_write_data[1] = *unsigned_int_ptr;
002890  78021E     MOV [W14], W4
002892  780214     MOV [W4], W4
002894  980724     MOV W4, [W14+4]
2643:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of pulse_counter_persistent
002896  E88F1E     INC2 [W14], [W14]
2644:                eeprom_write_data[0] = *unsigned_int_ptr;
002898  78021E     MOV [W14], W4
00289A  780214     MOV [W4], W4
00289C  980714     MOV W4, [W14+2]
2645:                
2646:                
2647:                unsigned_int_ptr = (unsigned int*)&arc_counter_persistent;                //unsigned_int_ptr now points to the Least Significant word of arc_counter_persistent
00289E  217AC4     MOV #0x17AC, W4
0028A0  780F04     MOV W4, [W14]
2648:                eeprom_write_data[5] = *unsigned_int_ptr;
0028A2  78021E     MOV [W14], W4
0028A4  780214     MOV [W4], W4
0028A6  980764     MOV W4, [W14+12]
2649:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of arc_counter_persistent
0028A8  E88F1E     INC2 [W14], [W14]
2650:                eeprom_write_data[4] = *unsigned_int_ptr;
0028AA  78021E     MOV [W14], W4
0028AC  780214     MOV [W4], W4
0028AE  980754     MOV W4, [W14+10]
2651:              
2652:                // The values have now been saved to the array in RAM.  Save the RAM data to EEPROM
2653:                ETMEEPromWritePageFast(PAGE_1_PULSE_COUNTERS, eeprom_write_data);
0028B0  E8820E     INC2 W14, W4
0028B2  780084     MOV W4, W1
0028B4  200010     MOV #0x1, W0
0028B6  07111E     RCALL ETMEEPromWritePageFast
2654:                /*
2655:                _wait_eedata();
2656:                _erase_eedata(EE_address_pulse_counter_repository_in_EEPROM, _EE_ROW);
2657:                _wait_eedata();
2658:                _write_eedata_row(EE_address_pulse_counter_repository_in_EEPROM, pulse_counter_repository_ram_copy);
2659:                */
2660:              }
0028B8  FA8000     ULNK
0028BA  060000     RETURN
2661:              
2662:              
2663:              void DoColdShutDown(void) {
0028BC  FA0000     LNK #0x0
2664:                /*
2665:                  This is a function to safely move from any state to cold state
2666:              
2667:                  The following actions occur
2668:                  * The HV Lambda is disabled
2669:                  * The Filament supply is disabled
2670:                  * The magnet supply is disabled
2671:                  * The thyratron DACs are set to Zero //DPARKER how to do with without PID taking over
2672:                  
2673:                  // DPARKER when do we write values from EEPROM to RAM
2674:                  */
2675:                DisableHVLambdaSupply();
0028BE  07005C     RCALL DisableHVLambdaSupply
2676:                DisableMagnetronFilamentSupply();
0028C0  07004F     RCALL DisableMagnetronFilamentSupply
2677:                DisableMagnetronMagnetSupply();
0028C2  070056     RCALL DisableMagnetronMagnetSupply
2678:                ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
0028C4  200642     MOV #0x64, W2
0028C6  EB0080     CLR W1
0028C8  209360     MOV #0x936, W0
0028CA  07F94C     RCALL ScalePowerSupply
2679:                ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
0028CC  200642     MOV #0x64, W2
0028CE  EB0080     CLR W1
0028D0  209360     MOV #0x936, W0
0028D2  07F948     RCALL ScalePowerSupply
2680:                ScalePowerSupply(&ps_filament,0,100);
0028D4  200642     MOV #0x64, W2
0028D6  EB0080     CLR W1
0028D8  20AF80     MOV #0xAF8, W0
0028DA  07F944     RCALL ScalePowerSupply
2681:                ScalePowerSupply(&ps_magnet,0,100);
0028DC  200642     MOV #0x64, W2
0028DE  EB0080     CLR W1
0028E0  20A9E0     MOV #0xA9E, W0
0028E2  07F940     RCALL ScalePowerSupply
2682:                ScalePowerSupply(&ps_thyr_reservoir_htr,0,100);
0028E4  200642     MOV #0x64, W2
0028E6  EB0080     CLR W1
0028E8  20BAC0     MOV #0xBAC, W0
0028EA  07F93C     RCALL ScalePowerSupply
2683:                ScalePowerSupply(&ps_thyr_cathode_htr,0,100);
0028EC  200642     MOV #0x64, W2
0028EE  EB0080     CLR W1
0028F0  20B520     MOV #0xB52, W0
0028F2  07F938     RCALL ScalePowerSupply
2684:              
2685:                //DPARKER need to do more to shut down the PID loops
2686:                PIDInit(&thyratron_reservoir_heater_PID);
0028F4  2087A0     MOV #0x87A, W0
0028F6  07EC6D     RCALL _PIDInit
2687:                PIDInit(&thyratron_cathode_heater_PID);
0028F8  2088A0     MOV #0x88A, W0
0028FA  07EC6B     RCALL _PIDInit
2688:              
2689:                T1CONbits.TON = 0;
0028FC  A9E105     BCLR 0x105, #7
2690:                _INT1IE = 0;
0028FE  A9008E     BCLR IEC1, #0
2691:                _T1IE = 0;
002900  A9608C     BCLR IEC0, #3
2692:                _INT1IF = 0;
002902  A90086     BCLR IFS1, #0
2693:                _T1IF = 0;
002904  A96084     BCLR IFS0, #3
2694:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
002906  A9C2C4     BCLR LATA, #6
2695:              }
002908  FA8000     ULNK
00290A  060000     RETURN
2696:              
2697:              
2698:              void DoWarmShutDown(void) {
00290C  FA0000     LNK #0x0
2699:                /*
2700:                  This function is called to safely move from any warm/HV on state to, warm state
2701:              
2702:                  The Following Actions occur
2703:                  * The HV Lambda is disabled
2704:                  * Clean up Interupts associated with pulsing
2705:                  
2706:                  // DPARKER when do we write values from EEPROM TO RAM???
2707:                  */
2708:                DisableHVLambdaSupply();
00290E  070034     RCALL DisableHVLambdaSupply
2709:                T1CONbits.TON = 0;
002910  A9E105     BCLR 0x105, #7
2710:                _INT1IE = 0;
002912  A9008E     BCLR IEC1, #0
2711:                _T1IE = 0;
002914  A9608C     BCLR IEC0, #3
2712:                _INT1IF = 0;
002916  A90086     BCLR IFS1, #0
2713:                _T1IF = 0;
002918  A96084     BCLR IFS0, #3
2714:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
00291A  A9C2C4     BCLR LATA, #6
2715:              }
00291C  FA8000     ULNK
00291E  060000     RETURN
2716:              
2717:              
2718:              
2719:              
2720:              void StartWarmUp(void) {
002920  FA0000     LNK #0x0
2721:                /*
2722:                  This subroutine is called at the start of the warmup process.
2723:                  It enables the heater and magnet supplies at zero and starts the ramp process
2724:                  
2725:                  + Set all outputs to Zero
2726:                  + Setup TMR2 for 100ms Intervals
2727:                */  
2728:              
2729:                PIDInit(&thyratron_reservoir_heater_PID);
002922  2087A0     MOV #0x87A, W0
002924  07EC56     RCALL _PIDInit
2730:                PIDInit(&thyratron_cathode_heater_PID);
002926  2088A0     MOV #0x88A, W0
002928  07EC54     RCALL _PIDInit
2731:              
2732:                ScalePowerSupply(&ps_magnet, 0, 100);
00292A  200642     MOV #0x64, W2
00292C  EB0080     CLR W1
00292E  20A9E0     MOV #0xA9E, W0
002930  07F919     RCALL ScalePowerSupply
2733:                ScalePowerSupply(&ps_filament, 0, 100);
002932  200642     MOV #0x64, W2
002934  EB0080     CLR W1
002936  20AF80     MOV #0xAF8, W0
002938  07F915     RCALL ScalePowerSupply
2734:                ScalePowerSupply(&ps_thyr_cathode_htr, 0, 100);
00293A  200642     MOV #0x64, W2
00293C  EB0080     CLR W1
00293E  20B520     MOV #0xB52, W0
002940  07F911     RCALL ScalePowerSupply
2735:                ScalePowerSupply(&ps_thyr_reservoir_htr, 0, 100);
002942  200642     MOV #0x64, W2
002944  EB0080     CLR W1
002946  20BAC0     MOV #0xBAC, W0
002948  07F90D     RCALL ScalePowerSupply
2736:              
2737:                EnableMagnetronMagnetSupply();
00294A  07000E     RCALL EnableMagnetronMagnetSupply
2738:                EnableMagnetronFilamentSupply();
00294C  070005     RCALL EnableMagnetronFilamentSupply
2739:              
2740:                TMR2 = 0;
00294E  EB0200     CLR W4
002950  880834     MOV W4, TMR2
2741:                _T2IF = 0;
002952  A9C084     BCLR IFS0, #6
2742:              }
002954  FA8000     ULNK
002956  060000     RETURN
2743:              
2744:              
2745:              
2746:              
2747:              void EnableMagnetronFilamentSupply(void) {
002958  FA0000     LNK #0x0
2748:                PIN_MAGNETRON_FILAMENT_ENABLE = OLL_MAGNETRON_FILAMENT_ENABLED;
00295A  A802D7     BSET 0x2D7, #0
2749:              }
00295C  FA8000     ULNK
00295E  060000     RETURN
2750:              
2751:              void DisableMagnetronFilamentSupply(void) {
002960  FA0000     LNK #0x0
2752:                PIN_MAGNETRON_FILAMENT_ENABLE = !OLL_MAGNETRON_FILAMENT_ENABLED;
002962  A902D7     BCLR 0x2D7, #0
2753:              }
002964  FA8000     ULNK
002966  060000     RETURN
2754:              
2755:              void EnableMagnetronMagnetSupply(void) {
002968  FA0000     LNK #0x0
2756:                PIN_MAGNETRON_MAGNET_ENABLE = OLL_MAGNETRON_MAGNET_ENABLED;
00296A  A822D7     BSET 0x2D7, #1
2757:              }
00296C  FA8000     ULNK
00296E  060000     RETURN
2758:              
2759:              void DisableMagnetronMagnetSupply(void) {
002970  FA0000     LNK #0x0
2760:                PIN_MAGNETRON_MAGNET_ENABLE = !OLL_MAGNETRON_MAGNET_ENABLED;
002972  A922D7     BCLR 0x2D7, #1
2761:              }
002974  FA8000     ULNK
002976  060000     RETURN
2762:              
2763:              
2764:              void DisableHVLambdaSupply(void) {
002978  FA0000     LNK #0x0
2765:                PIN_HV_LAMBDA_ENABLE = !OLL_HV_LAMBDA_ENABLED;
00297A  A962D7     BCLR 0x2D7, #3
2766:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;
00297C  A802D6     BSET LATD, #0
2767:              }
00297E  FA8000     ULNK
002980  060000     RETURN
2768:              
2769:              
2770:              void UpdateIOExpanderOutputs(void) {
002982  FA0004     LNK #0x4
2771:                // This updates all of the LED/Digital Outputs From the Control Board
2772:                // See 34-34357 for the configuration of the output polarities
2773:              
2774:                // All of the outputs are "Active Low"
2775:                // For Faults - The Fault state is "NOT ACTIVE" or a "high output"
2776:                // FOr HV ON - HV On is the "Not Active" state or "high otuput"
2777:              
2778:                unsigned int temp_lat_a;
2779:                unsigned int temp_lat_b;
2780:                
2781:                temp_lat_a = 0x00;
002984  EB0200     CLR W4
002986  780F04     MOV W4, [W14]
2782:                temp_lat_b = 0x00;
002988  EB0200     CLR W4
00298A  980714     MOV W4, [W14+2]
2783:              
2784:                last_known_action = LAST_ACTION_UPDATE_IO_EXPANDER;
00298C  200054     MOV #0x5, W4
00298E  88BDE4     MOV W4, last_known_action
2785:                
2786:                if ((control_state == STATE_SYSTEM_WARM_READY) || (control_state == STATE_HV_ON) || (control_state == STATE_FAULT_WARM_FAULT) || (control_state == STATE_HV_STARTUP)) {
002990  208585     MOV #0x858, W5
002992  784295     MOV.B [W5], W5
002994  B3C344     MOV.B #0x34, W4
002996  52CF84     SUB.B W5, W4, [W15]
002998  32000F     BRA Z, .L244, .LSM1311
00299A  208585     MOV #0x858, W5
00299C  784295     MOV.B [W5], W5
00299E  B3C444     MOV.B #0x44, W4
0029A0  52CF84     SUB.B W5, W4, [W15]
0029A2  32000A     BRA Z, .L244, .LSM1311
0029A4  208585     MOV #0x858, W5
0029A6  784295     MOV.B [W5], W5
0029A8  B3CA84     MOV.B #0xA8, W4
0029AA  52CF84     SUB.B W5, W4, [W15]
0029AC  320005     BRA Z, .L244, .LSM1311
0029AE  208585     MOV #0x858, W5
0029B0  784295     MOV.B [W5], W5
0029B2  B3C354     MOV.B #0x35, W4
0029B4  52CF84     SUB.B W5, W4, [W15]
0029B6  3A0005     BRA NZ, .L245, .LSM1312
2787:                  // warmup_done bit is active.  Clear this bit
2788:                  temp_lat_b &= ~BIT_OUTPUT_MODULATOR_WARMUP_DONE;
0029B8  90029E     MOV [W14+2], W5
0029BA  2FF7F4     MOV #0xFF7F, W4
0029BC  628204     AND W5, W4, W4
0029BE  980714     MOV W4, [W14+2]
0029C0  370004     BRA .L246, .LSM1313
2789:                } else {
2790:                  temp_lat_b |= BIT_OUTPUT_MODULATOR_WARMUP_DONE;
0029C2  90029E     MOV [W14+2], W5
0029C4  200804     MOV #0x80, W4
0029C6  720205     IOR W4, W5, W4
0029C8  980714     MOV W4, [W14+2]
2791:                }
2792:              
2793:                if (faults_control_board_fault_reg) {
0029CA  80BB04     MOV faults_control_board_fault_reg, W4
0029CC  520FE0     SUB W4, #0x0, [W15]
0029CE  320004     BRA Z, .L247, .LSM1315
2794:                  temp_lat_b |= BIT_OUTPUT_CONTROL_BOARD_FAULT;   
0029D0  90021E     MOV [W14+2], W4
0029D2  A00004     BSET W4, #0
0029D4  980714     MOV W4, [W14+2]
0029D6  370004     BRA .L248, .LSM1316
2795:                } else {
2796:                  temp_lat_b &= ~BIT_OUTPUT_CONTROL_BOARD_FAULT;
0029D8  90029E     MOV [W14+2], W5
0029DA  2FFFE4     MOV #0xFFFE, W4
0029DC  628204     AND W5, W4, W4
0029DE  980714     MOV W4, [W14+2]
2797:                }
2798:                
2799:                if (faults_thyratron_fault_reg) {
0029E0  80BAD4     MOV faults_thyratron_fault_reg, W4
0029E2  520FE0     SUB W4, #0x0, [W15]
0029E4  320002     BRA Z, .L249, .LSM1318
2800:                  // a thyratron fault is active - Set this bit
2801:                  temp_lat_a |= BIT_OUTPUT_THYRATRON_FAULT;
0029E6  A0201E     BSET [W14], #2
0029E8  370002     BRA .L250, .LSM1319
2802:                } else {
2803:                  temp_lat_a &= ~BIT_OUTPUT_THYRATRON_FAULT;
0029EA  2FFFB4     MOV #0xFFFB, W4
0029EC  620F1E     AND W4, [W14], [W14]
2804:                }
2805:                
2806:                if (faults_magnetron_fault_reg & 0xFF00) {
0029EE  80BA15     MOV faults_magnetron_fault_reg, W5
0029F0  2FF004     MOV #0xFF00, W4
0029F2  628204     AND W5, W4, W4
0029F4  520FE0     SUB W4, #0x0, [W15]
0029F6  320004     BRA Z, .L251, .LSM1321
2807:                  // an electromagnet fault is active - Set this bit
2808:                  temp_lat_b |= BIT_OUTPUT_ELECTROMAGNET_FAULT;
0029F8  90021E     MOV [W14+2], W4
0029FA  A04004     BSET W4, #4
0029FC  980714     MOV W4, [W14+2]
0029FE  370004     BRA .L252, .LSM1322
2809:                } else {
2810:                  temp_lat_b &= ~BIT_OUTPUT_ELECTROMAGNET_FAULT;
002A00  90029E     MOV [W14+2], W5
002A02  2FFEF4     MOV #0xFFEF, W4
002A04  628204     AND W5, W4, W4
002A06  980714     MOV W4, [W14+2]
2811:                }
2812:              
2813:                if (faults_magnetron_fault_reg & 0x00FF) {
002A08  80BA15     MOV faults_magnetron_fault_reg, W5
002A0A  200FF4     MOV #0xFF, W4
002A0C  628204     AND W5, W4, W4
002A0E  520FE0     SUB W4, #0x0, [W15]
002A10  320004     BRA Z, .L253, .LSM1324
2814:                  // an magnetron filament fault is active - Set this bit
2815:                  temp_lat_b |= BIT_OUTPUT_FILAMENT_FAULT;
002A12  90021E     MOV [W14+2], W4
002A14  A01004     BSET W4, #1
002A16  980714     MOV W4, [W14+2]
002A18  370004     BRA .L254, .LSM1325
2816:                } else {
2817:                  temp_lat_b &= ~BIT_OUTPUT_FILAMENT_FAULT;
002A1A  90029E     MOV [W14+2], W5
002A1C  2FFFD4     MOV #0xFFFD, W4
002A1E  628204     AND W5, W4, W4
002A20  980714     MOV W4, [W14+2]
2818:                }
2819:              
2820:                if (faults_high_voltage_fault_reg & 0xFF00) {
002A22  80BA45     MOV faults_high_voltage_fault_reg, W5
002A24  2FF004     MOV #0xFF00, W4
002A26  628204     AND W5, W4, W4
002A28  520FE0     SUB W4, #0x0, [W15]
002A2A  320002     BRA Z, .L255, .LSM1327
2821:                  // Lambda Faultis active - Set this bit
2822:                  temp_lat_a |= BIT_OUTPUT_HV_FAULT;
002A2C  A0001E     BSET [W14], #0
002A2E  370002     BRA .L256, .LSM1328
2823:                } else {
2824:                  temp_lat_a &= ~BIT_OUTPUT_HV_FAULT;
002A30  2FFFE4     MOV #0xFFFE, W4
002A32  620F1E     AND W4, [W14], [W14]
2825:                }
2826:              
2827:                if (faults_high_voltage_fault_reg & 0x00FF) {
002A34  80BA45     MOV faults_high_voltage_fault_reg, W5
002A36  200FF4     MOV #0xFF, W4
002A38  628204     AND W5, W4, W4
002A3A  520FE0     SUB W4, #0x0, [W15]
002A3C  320002     BRA Z, .L257, .LSM1330
2828:                  // Pulse Fault is active - Set this bit
2829:                  temp_lat_a |= BIT_OUTPUT_PULSE_FAULT;
002A3E  A0101E     BSET [W14], #1
002A40  370002     BRA .L258, .LSM1331
2830:                } else {
2831:                  temp_lat_a &= ~BIT_OUTPUT_PULSE_FAULT;
002A42  2FFFD4     MOV #0xFFFD, W4
002A44  620F1E     AND W4, [W14], [W14]
2832:                }
2833:                
2834:                if (control_state == STATE_HV_ON) {
002A46  208585     MOV #0x858, W5
002A48  784295     MOV.B [W5], W5
002A4A  B3C444     MOV.B #0x44, W4
002A4C  52CF84     SUB.B W5, W4, [W15]
002A4E  3A0004     BRA NZ, .L259, .LSM1333
2835:                  // HV is ON - Set this bit
2836:                  temp_lat_b |= BIT_OUTPUT_HV_ON_READBACK;
002A50  90021E     MOV [W14+2], W4
002A52  A02004     BSET W4, #2
002A54  980714     MOV W4, [W14+2]
002A56  370004     BRA .L260, .LSM1334
2837:                } else {
2838:                  temp_lat_b &= ~BIT_OUTPUT_HV_ON_READBACK;
002A58  90029E     MOV [W14+2], W5
002A5A  2FFFB4     MOV #0xFFFB, W4
002A5C  628204     AND W5, W4, W4
002A5E  980714     MOV W4, [W14+2]
2839:                }
2840:              
2841:              
2842:                // We only want to update if there is a change in state.  Otherwise we have a lot of unnessary I2C traffic
2843:                if (U64_MCP23017.output_latch_a_in_ram != temp_lat_a) {
002A60  209324     MOV #0x932, W4
002A62  784214     MOV.B [W4], W4
002A64  FB8204     ZE W4, W4
002A66  520F9E     SUB W4, [W14], [W15]
002A68  320010     BRA Z, .L261, .LSM1338
2844:                  U64_MCP23017.output_latch_a_in_ram = temp_lat_a;
002A6A  78021E     MOV [W14], W4
002A6C  784204     MOV.B W4, W4
002A6E  780004     MOV W4, W0
002A70  B7E932     MOV.B WREG, .LSM50
2845:                  if (MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATA, U64_MCP23017.output_latch_a_in_ram) != 0) {
002A72  209324     MOV #0x932, W4
002A74  784214     MOV.B [W4], W4
002A76  784104     MOV.B W4, W2
002A78  B3C141     MOV.B #0x14, W1
002A7A  2092A0     MOV #0x92A, W0
002A7C  071684     RCALL MCP23017WriteSingleByte
002A7E  780200     MOV W0, W4
002A80  520FE0     SUB W4, #0x0, [W15]
002A82  320003     BRA Z, .L261, .LSM1338
2846:                    global_debug_counter.i2c_bus_error++;
002A84  80B964     MOV .LSM629, W4
002A86  E80204     INC W4, W4
002A88  88B964     MOV W4, .LSM629
2847:                  }
2848:                }
2849:              
2850:                // We only want to update if there is a change in state.  Otherwise we have a lot of unnessary I2C traffic
2851:                if (U64_MCP23017.output_latch_b_in_ram != temp_lat_b) {
002A8A  209334     MOV #0x933, W4
002A8C  784214     MOV.B [W4], W4
002A8E  FB8284     ZE W4, W5
002A90  90021E     MOV [W14+2], W4
002A92  528F84     SUB W5, W4, [W15]
002A94  320010     BRA Z, .L243, .LSM1342
2852:                  U64_MCP23017.output_latch_b_in_ram = temp_lat_b;
002A96  90021E     MOV [W14+2], W4
002A98  784204     MOV.B W4, W4
002A9A  780004     MOV W4, W0
002A9C  B7E933     MOV.B WREG, 0x933
2853:                  if (MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATB, U64_MCP23017.output_latch_b_in_ram) != 0) { 
002A9E  209334     MOV #0x933, W4
002AA0  784214     MOV.B [W4], W4
002AA2  784104     MOV.B W4, W2
002AA4  B3C151     MOV.B #0x15, W1
002AA6  2092A0     MOV #0x92A, W0
002AA8  07166E     RCALL MCP23017WriteSingleByte
002AAA  780200     MOV W0, W4
002AAC  520FE0     SUB W4, #0x0, [W15]
002AAE  320003     BRA Z, .L243, .LSM1342
2854:                    global_debug_counter.i2c_bus_error++;
002AB0  80B964     MOV .LSM629, W4
002AB2  E80204     INC W4, W4
002AB4  88B964     MOV W4, .LSM629
2855:                  }
2856:                }
2857:              }
002AB6  FA8000     ULNK
002AB8  060000     RETURN
2858:              
2859:              
2860:              void HVLambdaStartCharging(void) {
002ABA  FA0000     LNK #0x0
2861:                /*
2862:                  This starts the charging process . . .
2863:                  The following ocurrs . . .
2864:                  * The Lamabda is enabled via the ENABLE Pin
2865:                  * The Lamabda Inhibit input is set to NOT INHIBIT
2866:                  * TMR1 is set up to time the charging process and ensure the lamabda reaches EOC before the first pulse
2867:                  * TMR2 is set up to time the 100ms Timeout for the next pulse
2868:                  * HouseKeeping - global_run_post_pulse_process is cleared
2869:                  
2870:                */
2871:              
2872:                // --------  Select A or B mode based on the input ----------- //
2873:                if (PIN_A_B_MODE_SELECT == ILL_A_MODE_SELECTED) {
002ABC  801615     MOV PORTA, W5
002ABE  220004     MOV #0x2000, W4
002AC0  628204     AND W5, W4, W4
002AC2  520FE0     SUB W4, #0x0, [W15]
002AC4  320006     BRA Z, .L264, .LSM1347
2874:                  a_b_selected_mode = PULSE_MODE_A;
002AC6  EB4200     CLR.B W4
002AC8  FD0200     EXCH W0, W4
002ACA  B7F70A     MOV.B WREG, a_b_selected_mode
002ACC  FD0200     EXCH W0, W4
2875:                  PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002ACE  A9C2CB     BCLR 0x2CB, #6
002AD0  370004     BRA .L265, .LSM1349
2876:                } else {
2877:                  a_b_selected_mode = PULSE_MODE_B;
002AD2  B3C014     MOV.B #0x1, W4
002AD4  780004     MOV W4, W0
002AD6  B7F70A     MOV.B WREG, a_b_selected_mode
2878:                  PIN_LAMBDA_VOLTAGE_SELECT = !OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002AD8  A8C2CB     BSET 0x2CB, #6
2879:                }
2880:              
2881:                // Actually enable the Lambda
2882:                PIN_HV_LAMBDA_ENABLE = OLL_HV_LAMBDA_ENABLED;
002ADA  A862D7     BSET 0x2D7, #3
2883:                PIN_HV_LAMBDA_INHIBIT = !OLL_HV_LAMBDA_INHIBITED;
002ADC  A902D6     BCLR LATD, #0
2884:                
2885:              
2886:                // Setup T1 to time to first charge
2887:                T1CONbits.TON = 0;
002ADE  A9E105     BCLR 0x105, #7
2888:                TMR1 = 0;
002AE0  EB0200     CLR W4
002AE2  880804     MOV W4, TMR1
2889:                _T1IF = 0;
002AE4  A96084     BCLR IFS0, #3
2890:                _T1IE = 1;
002AE6  A8608C     BSET IEC0, #3
2891:                PR1 = (TMR1_LAMBDA_CHARGE_PERIOD_TURN_ON);
002AE8  203B04     MOV #0x3B0, W4
002AEA  880814     MOV W4, PR1
2892:                T1CONbits.TON = 1;
002AEC  A8E105     BSET 0x105, #7
2893:              
2894:                // Setup T2 to roll in 100ms if there are no pulses
2895:                TMR2 = 0;  
002AEE  EB0200     CLR W4
002AF0  880834     MOV W4, TMR2
2896:                _T2IF = 0;
002AF2  A9C084     BCLR IFS0, #6
2897:              }
002AF4  FA8000     ULNK
002AF6  060000     RETURN
2898:              
2899:              
2900:              
2901:              /*
2902:                Scaling
2903:                
2904:                Scaling is up as Q13.
2905:                0x0000 = 0
2906:                0xFFFF = 7.99988
2907:                
2908:                Scaling = (num/den) * (2^13))
2909:              */
2910:              
2911:              unsigned int MakeScale(unsigned int num, unsigned int den) {
002AF8  FA000A     LNK #0xA
002AFA  980730     MOV W0, [W14+6]
002AFC  980741     MOV W1, [W14+8]
2912:                unsigned long temp;
2913:                unsigned int return_value;
2914:                
2915:                temp = num;
002AFE  90023E     MOV [W14+6], W4
002B00  200005     MOV #0x0, W5
002B02  980714     MOV W4, [W14+2]
002B04  980725     MOV W5, [W14+4]
2916:                temp = temp << 16;
002B06  90021E     MOV [W14+2], W4
002B08  9002AE     MOV [W14+4], W5
002B0A  DD22C0     SL W4, #0, W5
002B0C  200004     MOV #0x0, W4
002B0E  980714     MOV W4, [W14+2]
002B10  980725     MOV W5, [W14+4]
2917:                temp /= den;
002B12  90024E     MOV [W14+8], W4
002B14  200005     MOV #0x0, W5
002B16  BE0104     MOV.D W4, W2
002B18  90001E     MOV [W14+2], W0
002B1A  9000AE     MOV [W14+4], W1
002B1C  07EC0F     RCALL ___udivsi3
002B1E  BE0200     MOV.D W0, W4
002B20  980714     MOV W4, [W14+2]
002B22  980725     MOV W5, [W14+4]
2918:                temp = temp >> 3;
002B24  90021E     MOV [W14+2], W4
002B26  9002AE     MOV [W14+4], W5
002B28  DD2B4D     SL W5, #13, W6
002B2A  DE2243     LSR W4, #3, W4
002B2C  730204     IOR W6, W4, W4
002B2E  DE2AC3     LSR W5, #3, W5
002B30  980714     MOV W4, [W14+2]
002B32  980725     MOV W5, [W14+4]
2919:                
2920:                if (temp & 0xFFFF0000) {
002B34  90031E     MOV [W14+2], W6
002B36  9003AE     MOV [W14+4], W7
002B38  200004     MOV #0x0, W4
002B3A  2FFFF5     MOV #0xFFFF, W5
002B3C  780006     MOV W6, W0
002B3E  780307     MOV W7, W6
002B40  780384     MOV W4, W7
002B42  780205     MOV W5, W4
002B44  600007     AND W0, W7, W0
002B46  630204     AND W6, W4, W4
002B48  200005     MOV #0x0, W5
002B4A  DD22C0     SL W4, #0, W5
002B4C  200004     MOV #0x0, W4
002B4E  BE0304     MOV.D W4, W6
002B50  B80261     MUL.UU W0, #1, W4
002B52  730304     IOR W6, W4, W6
002B54  738385     IOR W7, W5, W7
002B56  530FE0     SUB W6, #0x0, [W15]
002B58  5B8FE0     SUBB W7, #0x0, [W15]
002B5A  320003     BRA Z, .L267, .LSM1367
2921:                  // DPARKER saturation error
2922:                  return_value = 0xFFFF;
002B5C  EB8200     SETM W4
002B5E  780F04     MOV W4, [W14]
002B60  370002     BRA .L268, .LSM1368
2923:                } else {
2924:                  return_value = temp & 0xFFFF;
002B62  90021E     MOV [W14+2], W4
002B64  780F04     MOV W4, [W14]
2925:                }
2926:                return return_value;
002B66  78021E     MOV [W14], W4
2927:              }
002B68  780004     MOV W4, W0
002B6A  FA8000     ULNK
002B6C  060000     RETURN
2928:              
2929:              
2930:              unsigned int Scale16Bit(unsigned int value, unsigned int scale) {
002B6E  FA0008     LNK #0x8
002B70  980720     MOV W0, [W14+4]
002B72  980731     MOV W1, [W14+6]
2931:                unsigned long temp;
2932:                temp = value;
002B74  90022E     MOV [W14+4], W4
002B76  200005     MOV #0x0, W5
002B78  BE8F04     MOV.D W4, [W14]
2933:                temp *= scale;
002B7A  90023E     MOV [W14+6], W4
002B7C  200005     MOV #0x0, W5
002B7E  90031E     MOV [W14+2], W6
002B80  B9B304     MUL.SS W6, W4, W6
002B82  780306     MOV W6, W6
002B84  78039E     MOV [W14], W7
002B86  B9B805     MUL.SS W7, W5, W0
002B88  780380     MOV W0, W7
002B8A  430307     ADD W6, W7, W6
002B8C  78039E     MOV [W14], W7
002B8E  780204     MOV W4, W4
002B90  B82207     MUL.UU W4, W7, W4
002B92  430305     ADD W6, W5, W6
002B94  780286     MOV W6, W5
002B96  BE8F04     MOV.D W4, [W14]
002B98  BE8F04     MOV.D W4, [W14]
2934:                temp = temp >> 13;
002B9A  BE021E     MOV.D [W14], W4
002B9C  DD2B43     SL W5, #3, W6
002B9E  DE224D     LSR W4, #13, W4
002BA0  730204     IOR W6, W4, W4
002BA2  DE2ACD     LSR W5, #13, W5
002BA4  BE8F04     MOV.D W4, [W14]
2935:                if (temp > 0x0000FFFF) {
002BA6  2FFFF4     MOV #0xFFFF, W4
002BA8  200005     MOV #0x0, W5
002BAA  BE031E     MOV.D [W14], W6
002BAC  530F84     SUB W6, W4, [W15]
002BAE  5B8F85     SUBB W7, W5, [W15]
002BB0  360006     BRA LEU, .L270, .LSM1377
2936:                  temp = 0x0000FFFF;
002BB2  2FFFF4     MOV #0xFFFF, W4
002BB4  200005     MOV #0x0, W5
002BB6  BE8F04     MOV.D W4, [W14]
2937:                  global_debug_counter.scale16bit_saturation++;
002BB8  80B9C4     MOV .LSM635, W4
002BBA  E80204     INC W4, W4
002BBC  88B9C4     MOV W4, .LSM635
2938:                }
2939:                value = temp & 0xFFFF;
002BBE  78021E     MOV [W14], W4
002BC0  980724     MOV W4, [W14+4]
2940:                return value;
002BC2  90022E     MOV [W14+4], W4
2941:              }
002BC4  780004     MOV W4, W0
002BC6  FA8000     ULNK
002BC8  060000     RETURN
2942:              
2943:              
2944:              
2945:              unsigned int RCFilter256Tau(unsigned int previous_value, unsigned int current_reading) {
002BCA  FA000A     LNK #0xA
002BCC  980730     MOV W0, [W14+6]
002BCE  980741     MOV W1, [W14+8]
2946:                unsigned long temp32;
2947:                unsigned int temp16;
2948:                if (previous_value == 0) {
002BD0  90023E     MOV [W14+6], W4
002BD2  520FE0     SUB W4, #0x0, [W15]
002BD4  3A0002     BRA NZ, .L272, .LSM1383
2949:                  previous_value = current_reading;
002BD6  90024E     MOV [W14+8], W4
002BD8  980734     MOV W4, [W14+6]
2950:                }
2951:                temp32 = previous_value;
002BDA  90023E     MOV [W14+6], W4
002BDC  200005     MOV #0x0, W5
002BDE  980714     MOV W4, [W14+2]
002BE0  980725     MOV W5, [W14+4]
2952:                temp32 *= 255;
002BE2  9002AE     MOV [W14+4], W5
002BE4  200FF4     MOV #0xFF, W4
002BE6  B9AA04     MUL.SS W5, W4, W4
002BE8  780304     MOV W4, W6
002BEA  90021E     MOV [W14+2], W4
002BEC  B92260     MUL.SU W4, #0, W4
002BEE  780204     MOV W4, W4
002BF0  430304     ADD W6, W4, W6
002BF2  90029E     MOV [W14+2], W5
002BF4  200FF4     MOV #0xFF, W4
002BF6  B82A04     MUL.UU W5, W4, W4
002BF8  430305     ADD W6, W5, W6
002BFA  780286     MOV W6, W5
002BFC  980714     MOV W4, [W14+2]
002BFE  980725     MOV W5, [W14+4]
002C00  980714     MOV W4, [W14+2]
002C02  980725     MOV W5, [W14+4]
2953:                temp32 += current_reading;
002C04  90024E     MOV [W14+8], W4
002C06  200005     MOV #0x0, W5
002C08  90031E     MOV [W14+2], W6
002C0A  9003AE     MOV [W14+4], W7
002C0C  420206     ADD W4, W6, W4
002C0E  4A8287     ADDC W5, W7, W5
002C10  980714     MOV W4, [W14+2]
002C12  980725     MOV W5, [W14+4]
2954:                temp32 = temp32 >> 8;
002C14  90021E     MOV [W14+2], W4
002C16  9002AE     MOV [W14+4], W5
002C18  DD2B48     SL W5, #8, W6
002C1A  DE2248     LSR W4, #8, W4
002C1C  730204     IOR W6, W4, W4
002C1E  DE2AC8     LSR W5, #8, W5
002C20  980714     MOV W4, [W14+2]
002C22  980725     MOV W5, [W14+4]
2955:                temp16 = temp32;
002C24  90021E     MOV [W14+2], W4
002C26  780F04     MOV W4, [W14]
2956:                if (current_reading > temp16) {
002C28  90024E     MOV [W14+8], W4
002C2A  520F9E     SUB W4, [W14], [W15]
002C2C  360002     BRA LEU, .L273, .LSM1390
2957:                  temp16++;
002C2E  E80F1E     INC [W14], [W14]
002C30  370004     BRA .L274, .LSM1392
2958:                } else if (current_reading < temp16) {
002C32  90024E     MOV [W14+8], W4
002C34  520F9E     SUB W4, [W14], [W15]
002C36  310001     BRA C, .L274, .LSM1392
2959:                  temp16--;
002C38  E90F1E     DEC [W14], [W14]
2960:                }
2961:                return temp16;
002C3A  78021E     MOV [W14], W4
2962:              }
002C3C  780004     MOV W4, W0
002C3E  FA8000     ULNK
002C40  060000     RETURN
2963:              
2964:              
2965:              unsigned int RCFilter64Tau(unsigned int previous_value, unsigned int current_reading) {
002C42  FA000A     LNK #0xA
002C44  980730     MOV W0, [W14+6]
002C46  980741     MOV W1, [W14+8]
2966:                unsigned long temp32;
2967:                unsigned int temp16;
2968:                if (previous_value == 0) {
002C48  90023E     MOV [W14+6], W4
002C4A  520FE0     SUB W4, #0x0, [W15]
002C4C  3A0002     BRA NZ, .L276, .LSM1397
2969:                  previous_value = current_reading;
002C4E  90024E     MOV [W14+8], W4
002C50  980734     MOV W4, [W14+6]
2970:                }
2971:                temp32 = previous_value;
002C52  90023E     MOV [W14+6], W4
002C54  200005     MOV #0x0, W5
002C56  980714     MOV W4, [W14+2]
002C58  980725     MOV W5, [W14+4]
2972:                temp32 *= 63;
002C5A  9002AE     MOV [W14+4], W5
002C5C  2003F4     MOV #0x3F, W4
002C5E  B9AA04     MUL.SS W5, W4, W4
002C60  780304     MOV W4, W6
002C62  90021E     MOV [W14+2], W4
002C64  B92260     MUL.SU W4, #0, W4
002C66  780204     MOV W4, W4
002C68  430304     ADD W6, W4, W6
002C6A  90029E     MOV [W14+2], W5
002C6C  2003F4     MOV #0x3F, W4
002C6E  B82A04     MUL.UU W5, W4, W4
002C70  430305     ADD W6, W5, W6
002C72  780286     MOV W6, W5
002C74  980714     MOV W4, [W14+2]
002C76  980725     MOV W5, [W14+4]
002C78  980714     MOV W4, [W14+2]
002C7A  980725     MOV W5, [W14+4]
2973:                temp32 += current_reading;
002C7C  90024E     MOV [W14+8], W4
002C7E  200005     MOV #0x0, W5
002C80  90031E     MOV [W14+2], W6
002C82  9003AE     MOV [W14+4], W7
002C84  420206     ADD W4, W6, W4
002C86  4A8287     ADDC W5, W7, W5
002C88  980714     MOV W4, [W14+2]
002C8A  980725     MOV W5, [W14+4]
2974:                temp32 = temp32 >> 6;
002C8C  90021E     MOV [W14+2], W4
002C8E  9002AE     MOV [W14+4], W5
002C90  DD2B4A     SL W5, #10, W6
002C92  DE2246     LSR W4, #6, W4
002C94  730204     IOR W6, W4, W4
002C96  DE2AC6     LSR W5, #6, W5
002C98  980714     MOV W4, [W14+2]
002C9A  980725     MOV W5, [W14+4]
2975:                temp16 = temp32;
002C9C  90021E     MOV [W14+2], W4
002C9E  780F04     MOV W4, [W14]
2976:                if (current_reading > temp16) {
002CA0  90024E     MOV [W14+8], W4
002CA2  520F9E     SUB W4, [W14], [W15]
002CA4  360002     BRA LEU, .L277, .LSM1404
2977:                  temp16++;
002CA6  E80F1E     INC [W14], [W14]
002CA8  370004     BRA .L278, .LSM1406
2978:                } else if (current_reading < temp16) {
002CAA  90024E     MOV [W14+8], W4
002CAC  520F9E     SUB W4, [W14], [W15]
002CAE  310001     BRA C, .L278, .LSM1406
2979:                  temp16--;
002CB0  E90F1E     DEC [W14], [W14]
2980:                }
2981:                return temp16;
002CB2  78021E     MOV [W14], W4
2982:              }
002CB4  780004     MOV W4, W0
002CB6  FA8000     ULNK
002CB8  060000     RETURN
2983:              
2984:              
2985:              unsigned int RCFilter16Tau(unsigned int previous_value, unsigned int current_reading) {
002CBA  FA000A     LNK #0xA
002CBC  980730     MOV W0, [W14+6]
002CBE  980741     MOV W1, [W14+8]
2986:                unsigned long temp32;
2987:                unsigned int temp16;
2988:                if (previous_value == 0) {
002CC0  90023E     MOV [W14+6], W4
002CC2  520FE0     SUB W4, #0x0, [W15]
002CC4  3A0002     BRA NZ, .L280, .LSM1411
2989:                  previous_value = current_reading;
002CC6  90024E     MOV [W14+8], W4
002CC8  980734     MOV W4, [W14+6]
2990:                }
2991:                temp32 = previous_value;
002CCA  90023E     MOV [W14+6], W4
002CCC  200005     MOV #0x0, W5
002CCE  980714     MOV W4, [W14+2]
002CD0  980725     MOV W5, [W14+4]
2992:                temp32 *= 15;
002CD2  90022E     MOV [W14+4], W4
002CD4  B9226F     MUL.SU W4, #15, W4
002CD6  780304     MOV W4, W6
002CD8  90021E     MOV [W14+2], W4
002CDA  B92260     MUL.SU W4, #0, W4
002CDC  780204     MOV W4, W4
002CDE  430304     ADD W6, W4, W6
002CE0  90029E     MOV [W14+2], W5
002CE2  2000F4     MOV #0xF, W4
002CE4  B82A04     MUL.UU W5, W4, W4
002CE6  430305     ADD W6, W5, W6
002CE8  780286     MOV W6, W5
002CEA  980714     MOV W4, [W14+2]
002CEC  980725     MOV W5, [W14+4]
002CEE  980714     MOV W4, [W14+2]
002CF0  980725     MOV W5, [W14+4]
2993:                temp32 += current_reading;
002CF2  90024E     MOV [W14+8], W4
002CF4  200005     MOV #0x0, W5
002CF6  90031E     MOV [W14+2], W6
002CF8  9003AE     MOV [W14+4], W7
002CFA  420206     ADD W4, W6, W4
002CFC  4A8287     ADDC W5, W7, W5
002CFE  980714     MOV W4, [W14+2]
002D00  980725     MOV W5, [W14+4]
2994:                temp32 = temp32 >> 4;
002D02  90021E     MOV [W14+2], W4
002D04  9002AE     MOV [W14+4], W5
002D06  DD2B4C     SL W5, #12, W6
002D08  DE2244     LSR W4, #4, W4
002D0A  730204     IOR W6, W4, W4
002D0C  DE2AC4     LSR W5, #4, W5
002D0E  980714     MOV W4, [W14+2]
002D10  980725     MOV W5, [W14+4]
2995:                temp16 = temp32;
002D12  90021E     MOV [W14+2], W4
002D14  780F04     MOV W4, [W14]
2996:                if (current_reading > temp16) {
002D16  90024E     MOV [W14+8], W4
002D18  520F9E     SUB W4, [W14], [W15]
002D1A  360002     BRA LEU, .L281, .LSM1418
2997:                  temp16++;
002D1C  E80F1E     INC [W14], [W14]
002D1E  370004     BRA .L282, .LSM1420
2998:                } else if (current_reading < temp16) {
002D20  90024E     MOV [W14+8], W4
002D22  520F9E     SUB W4, [W14], [W15]
002D24  310001     BRA C, .L282, .LSM1420
2999:                  temp16--;
002D26  E90F1E     DEC [W14], [W14]
3000:                }
3001:                return temp16;
002D28  78021E     MOV [W14], W4
3002:              }
002D2A  780004     MOV W4, W0
002D2C  FA8000     ULNK
002D2E  060000     RETURN
3003:              
3004:              
3005:              
3006:              
3007:              
3008:              
3009:              
3010:              
3011:              
3012:              
3013:              void _ISRFASTNOPSV _INT1Interrupt(void) {
002D30  FEA000     PUSH.S
002D32  F80036     PUSH RCOUNT
002D34  BE9F84     MOV.D W4, [W15++]
002D36  BE9F86     MOV.D W6, [W15++]
002D38  781F88     MOV W8, [W15++]
002D3A  FA0000     LNK #0x0
3014:                /*
3015:                  This interrupt does NOTHING TO CONTROL THE TYHRATRON TRIGGER
3016:                  By the time this interrupt is called, the trigger has already been routed to the thyratron
3017:                  This interrupt just schedules data acquisition and prepares for the NEXT pulse.
3018:                  
3019:                  This interrupt is enabled when the PIN_THYRATRON_TRIGGER_ENABLE is set (and disabled when that output is cleared).
3020:                  Therefore, if this interrupt has been entered then a trigger pulse was probably sent to the thyratron.
3021:                  It is possible that a trigger pulse was masked by a hardware fault BEFORE the software could detect it.
3022:                  If this were to happen then, the hardware faults will be detected in the next flow through the control loop
3023:                  and the system will detect Magnetron Undervoltage Undercurrent faults (because it is expecting a pulse that does not happen)
3024:                  
3025:                  Assuming a sucessful trigger, this interupt will do the following conecptual steps
3026:                  (1) Wait a set amount of time to sample the Magnetron Voltage, Magnetron Current, and PFN Fault Current at the approriate time
3027:                  (2) Wait for the pulse EMI to pass
3028:                  (2) Read the Magnetron Voltage and Magnetron Current into RAM.
3029:                  (3) Inhibit the HV supply a set amount of time.
3030:                  (4) After the inhibt time has passed, !Inhibit the power supply, and start the EOC timer
3031:                  (5) Set the status bit that indicates a pulse occured
3032:                */ 
3033:              
3034:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;  
002D3C  A802D6     BSET LATD, #0
3035:              
3036:                // Trigger Delay is 800ns
3037:                // ADC Trigger Delay Across barrier is 950ns (this should be made faster)
3038:                // ISR Call Delay from trigger to output going high is 10 TCy
3039:                // Repeat stament will exexute N+1 Times
3040:                // Repeate statement itself is 1 Cycle
3041:                // There fore to calculate the trigger delay (from the start of the pulse)
3042:                // ((PFN_Sample_Point_US + 800ns (trigger delay) - 950ns (ADC Trigger Delay)) = Total Delay
3043:                // Total Delay/Tcy = Total Clock Delay
3044:                // Repeat Call = Total Clock Delay - 10 - 2
3045:              
3046:                Nop();
002D3E  000000     NOP
3047:                Nop();
002D40  000000     NOP
3048:                Nop();
002D42  000000     NOP
3049:                Nop();
002D44  000000     NOP
3050:              
3051:              
3052:                // ADD in 17 more instruction cycle delay
3053:                __delay32(17);
002D46  200110     MOV #0x11, W0
002D48  200001     MOV #0x0, W1
002D4A  0716A1     RCALL ___delay32
3054:                  
3055:              
3056:                PIN_PULSE_ADC_TRIGGER = OLL_TRIGGER_PULSE_ADCS;                  // Trigger the conversion process on both ADCs
002D4C  A822C5     BSET 0x2C5, #1
3057:                _INT1IF = 0;
002D4E  A90086     BCLR IFS1, #0
3058:                _INT1IE = 0;
002D50  A9008E     BCLR IEC1, #0
3059:              
3060:                last_known_action = LAST_ACTION_INT1_INT;
002D52  200044     MOV #0x4, W4
002D54  88BDE4     MOV W4, last_known_action
3061:              
3062:                // Setup timer1 to time the time it takes the PFN EMI to dissipate
3063:                T1CONbits.TON = 0;
002D56  A9E105     BCLR 0x105, #7
3064:                TMR1 = 0;
002D58  EB0200     CLR W4
002D5A  880804     MOV W4, TMR1
3065:                PR1 = TMR1_DELAY_HOLDOFF;
002D5C  200174     MOV #0x17, W4
002D5E  880814     MOV W4, PR1
3066:                _T1IE = 0;
002D60  A9608C     BCLR IEC0, #3
3067:                _T1IF = 0;
002D62  A96084     BCLR IFS0, #3
3068:                T1CONbits.TON = 1;
002D64  A8E105     BSET 0x105, #7
3069:                
3070:                false_trigger = 0;
002D66  EB0200     CLR W4
002D68  8841E4     MOV W4, false_trigger
3071:              
3072:                while (TMR1 < 2);  // 128 clock cycles, 12.8uS
002D6A  000000     NOP
002D6C  800804     MOV TMR1, W4
002D6E  520FE1     SUB W4, #0x1, [W15]
002D70  36FFFD     BRA LEU, .L284
3073:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
002D72  801615     MOV PORTA, W5
002D74  210004     MOV #0x1000, W4
002D76  628204     AND W5, W4, W4
002D78  520FE0     SUB W4, #0x0, [W15]
002D7A  3A0003     BRA NZ, .L307
3074:                  false_trigger = 1;
002D7C  200014     MOV #0x1, W4
002D7E  8841E4     MOV W4, false_trigger
3075:                }
3076:              
3077:                while (TMR1 < 3);  // 192 clock cycles, 19.2uS
002D80  370001     BRA .L286
002D82  000000     NOP
002D84  800804     MOV TMR1, W4
002D86  520FE2     SUB W4, #0x2, [W15]
002D88  36FFFD     BRA LEU, .L286
3078:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
002D8A  801615     MOV PORTA, W5
002D8C  210004     MOV #0x1000, W4
002D8E  628204     AND W5, W4, W4
002D90  520FE0     SUB W4, #0x0, [W15]
002D92  3A0003     BRA NZ, .L308
3079:                  false_trigger = 1;
002D94  200014     MOV #0x1, W4
002D96  8841E4     MOV W4, false_trigger
3080:                }
3081:              
3082:                while (TMR1 < 4);  // 256 clock cycles, 25.6uS
002D98  370001     BRA .L288
002D9A  000000     NOP
002D9C  800804     MOV TMR1, W4
002D9E  520FE3     SUB W4, #0x3, [W15]
002DA0  36FFFD     BRA LEU, .L288
3083:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
002DA2  801615     MOV PORTA, W5
002DA4  210004     MOV #0x1000, W4
002DA6  628204     AND W5, W4, W4
002DA8  520FE0     SUB W4, #0x0, [W15]
002DAA  3A0002     BRA NZ, .L289, .LSM1449
3084:                  false_trigger = 1;
002DAC  200014     MOV #0x1, W4
002DAE  8841E4     MOV W4, false_trigger
3085:                }
3086:              
3087:                arc_detected = 0;
002DB0  EB0200     CLR W4
002DB2  8840B4     MOV W4, arc_detected
3088:                if ((PIN_PULSE_OVER_CUR_LATCH == ILL_PULSE_OVER_CURRENT_FAULT) || (PIN_PULSE_MIN_CUR_LATCH == ILL_PULSE_MIN_CURRENT_FAULT)) {
002DB4  8016A4     MOV PORTD, W4
002DB6  620270     AND W4, #0x10, W4
002DB8  520FE0     SUB W4, #0x0, [W15]
002DBA  320005     BRA Z, .L290, .LSM1451
002DBC  8016A5     MOV PORTD, W5
002DBE  200804     MOV #0x80, W4
002DC0  628204     AND W5, W4, W4
002DC2  520FE0     SUB W4, #0x0, [W15]
002DC4  320002     BRA Z, .L291, .LSM1452
3089:                  arc_detected = 1;
002DC6  200014     MOV #0x1, W4
002DC8  8840B4     MOV W4, arc_detected
3090:                }
3091:              
3092:                PIN_PULSE_LATCH_RESET = OLL_PULSE_LATCH_RESET;  // Clear the pulse latches so we can detect a false trigger
002DCA  A9A2E2     BCLR LATF, #5
3093:              
3094:                // Calculate the PRF
3095:                last_period = TMR3;
002DCC  800854     MOV TMR3, W4
002DCE  88BCE4     MOV W4, .LSM669
3096:                TMR3 = 0;
002DD0  EB0200     CLR W4
002DD2  880854     MOV W4, TMR3
3097:                if (_T3IF) {
002DD4  800425     MOV IFS0, W5
002DD6  200804     MOV #0x80, W4
002DD8  628204     AND W5, W4, W4
002DDA  520FE0     SUB W4, #0x0, [W15]
002DDC  320003     BRA Z, .L292, .LSM1457
3098:                  // The timer exceed it's period
3099:                  last_period = PR3 + 1; // Indicated that the PRF is below the value that can be measured  
002DDE  800874     MOV PR3, W4
002DE0  E80204     INC W4, W4
002DE2  88BCE4     MOV W4, .LSM669
3100:                }
3101:                _T3IF = 0;
002DE4  A9E084     BCLR IFS0, #7
3102:              
3103:                while(!_T1IF);                                                   // what for the holdoff time to pass
002DE6  000000     NOP
002DE8  800424     MOV IFS0, W4
002DEA  620268     AND W4, #0x8, W4
002DEC  520FE0     SUB W4, #0x0, [W15]
002DEE  32FFFC     BRA Z, .L293
3104:              
3105:              
3106:                // Read the state of the A_B select Optical input and adjust the system as nesseasry
3107:                if (PIN_A_B_MODE_SELECT == ILL_A_MODE_SELECTED) {
002DF0  801615     MOV PORTA, W5
002DF2  220004     MOV #0x2000, W4
002DF4  628204     AND W5, W4, W4
002DF6  520FE0     SUB W4, #0x0, [W15]
002DF8  320006     BRA Z, .L294, .LSM1462
3108:                  next_pulse_a_b_selected_mode = PULSE_MODE_A;
002DFA  EB4200     CLR.B W4
002DFC  FD0200     EXCH W0, W4
002DFE  B7F70B     MOV.B WREG, next_pulse_a_b_selected_mode
002E00  FD0200     EXCH W0, W4
3109:                  PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002E02  A9C2CB     BCLR 0x2CB, #6
002E04  370005     BRA .L295, .LSM1464
3110:                } else {
3111:                  next_pulse_a_b_selected_mode = PULSE_MODE_B;
002E06  B3C014     MOV.B #0x1, W4
002E08  FD0200     EXCH W0, W4
002E0A  B7F70B     MOV.B WREG, next_pulse_a_b_selected_mode
002E0C  FD0200     EXCH W0, W4
3112:                  PIN_LAMBDA_VOLTAGE_SELECT = !OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002E0E  A8C2CB     BSET 0x2CB, #6
3113:                }
3114:              
3115:              
3116:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;   // Disable the Pic trigger signal gate
002E10  A9C2C4     BCLR LATA, #6
3117:                PIN_HV_LAMBDA_INHIBIT = !OLL_HV_LAMBDA_INHIBITED;                // Start the lambda charge process
002E12  A902D6     BCLR LATD, #0
3118:              
3119:                // Set up Timer1 to produce interupt at end of charge period
3120:                T1CONbits.TON = 0;
002E14  A9E105     BCLR 0x105, #7
3121:                TMR1 = 0;
002E16  EB0200     CLR W4
002E18  880804     MOV W4, TMR1
3122:                _T1IF = 0;
002E1A  A96084     BCLR IFS0, #3
3123:                _T1IE = 1;
002E1C  A8608C     BSET IEC0, #3
3124:                PR1 = (TMR1_LAMBDA_CHARGE_PERIOD - TMR1_DELAY_HOLDOFF);
002E1E  201CB4     MOV #0x1CB, W4
002E20  880814     MOV W4, PR1
3125:                T1CONbits.TON = 1;
002E22  A8E105     BSET 0x105, #7
3126:              
3127:              #define MAX_LATCH_RESET_TIME (FCY_CLK_MHZ * 2) // 128uS
3128:                
3129:                // Wait for the pulse latches to clear
3130:                while ((PIN_PULSE_OVER_CUR_LATCH == ILL_PULSE_OVER_CURRENT_FAULT) && (TMR1 < MAX_LATCH_RESET_TIME));
002E24  000000     NOP
002E26  8016A4     MOV PORTD, W4
002E28  620270     AND W4, #0x10, W4
002E2A  520FE0     SUB W4, #0x0, [W15]
002E2C  3A0011     BRA NZ, .L309
002E2E  800804     MOV TMR1, W4
002E30  200005     MOV #0x0, W5
002E32  BE0004     MOV.D W4, W0
002E34  07EA38     RCALL ___floatunsisf
002E36  BE0200     MOV.D W0, W4
002E38  B3C018     MOV.B #0x1, W8
002E3A  2F5C32     MOV #0xF5C3, W2
002E3C  2426B3     MOV #0x426B, W3
002E3E  BE0004     MOV.D W4, W0
002E40  07EA13     RCALL ___ltsf2, ___eqsf2, ___lesf2
002E42  780200     MOV W0, W4
002E44  520FE0     SUB W4, #0x0, [W15]
002E46  350001     BRA LT, .L297
002E48  EB4400     CLR.B W8
002E4A  544FE0     SUB.B W8, #0x0, [W15]
002E4C  3AFFEC     BRA NZ, .L298
3131:                while ((PIN_PULSE_MIN_CUR_LATCH == ILL_PULSE_MIN_CURRENT_FAULT) && (TMR1 < MAX_LATCH_RESET_TIME));
002E4E  370001     BRA .L301
002E50  000000     NOP
002E52  8016A5     MOV PORTD, W5
002E54  200804     MOV #0x80, W4
002E56  628204     AND W5, W4, W4
002E58  520FE0     SUB W4, #0x0, [W15]
002E5A  320010     BRA Z, .L299, .LSM1474
002E5C  800804     MOV TMR1, W4
002E5E  200005     MOV #0x0, W5
002E60  BE0004     MOV.D W4, W0
002E62  07EA21     RCALL ___floatunsisf
002E64  BE0200     MOV.D W0, W4
002E66  B3C018     MOV.B #0x1, W8
002E68  2F5C32     MOV #0xF5C3, W2
002E6A  2426B3     MOV #0x426B, W3
002E6C  BE0004     MOV.D W4, W0
002E6E  07E9FC     RCALL ___ltsf2, ___eqsf2, ___lesf2
002E70  780200     MOV W0, W4
002E72  520FE0     SUB W4, #0x0, [W15]
002E74  350001     BRA LT, .L300
002E76  EB4400     CLR.B W8
002E78  544FE0     SUB.B W8, #0x0, [W15]
002E7A  3AFFEB     BRA NZ, .L301
3132:                
3133:                if (TMR1 >= MAX_LATCH_RESET_TIME) {
002E7C  800804     MOV TMR1, W4
002E7E  200005     MOV #0x0, W5
002E80  BE0004     MOV.D W4, W0
002E82  07EA11     RCALL ___floatunsisf
002E84  BE0200     MOV.D W0, W4
002E86  B3C018     MOV.B #0x1, W8
002E88  2F5C32     MOV #0xF5C3, W2
002E8A  2426B3     MOV #0x426B, W3
002E8C  BE0004     MOV.D W4, W0
002E8E  07E9EE     RCALL ___gesf2, ___gtsf2
002E90  780200     MOV W0, W4
002E92  520FE0     SUB W4, #0x0, [W15]
002E94  3D0001     BRA GE, .L302
002E96  EB4400     CLR.B W8
002E98  544FE0     SUB.B W8, #0x0, [W15]
002E9A  320003     BRA Z, .L303, .LSM1476
3134:                  // there was an error with the pulse latch reset 
3135:                  global_debug_counter.pulse_latch_reset_error++; 
002E9C  80B9E4     MOV .LSM637, W4
002E9E  E80204     INC W4, W4
002EA0  88B9E4     MOV W4, .LSM637
3136:                }
3137:              	 
3138:              	 
3139:              
3140:                PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
002EA2  A8A2E2     BSET LATF, #5
3141:                
3142:                // Clear the Change Notification data that is used to detect a false trigger
3143:                if (PIN_PULSE_MIN_CUR_LATCH); // We need to read this port in order to clear CN data
002EA4  8016A4     MOV PORTD, W4
3144:                _CNIF = 0; // Clear the interrupt flag that gets set when we have a valid pulse
002EA6  A9E085     BCLR 0x85, #7
3145:                
3146:                
3147:                
3148:                if (global_run_post_pulse_process) {
002EA8  217084     MOV #0x1708, W4
002EAA  784214     MOV.B [W4], W4
002EAC  524FE0     SUB.B W4, #0x0, [W15]
002EAE  320003     BRA Z, .L304, .LSM1481
3149:                  timing_error_int1_count++;
002EB0  804204     MOV timing_error_int1_count, W4
002EB2  E80204     INC W4, W4
002EB4  884204     MOV W4, timing_error_int1_count
3150:                }
3151:              
3152:              
3153:                if (this_pulse_skipped) {
002EB6  804264     MOV this_pulse_skipped, W4
002EB8  520FE0     SUB W4, #0x0, [W15]
002EBA  320003     BRA Z, .L305, .LSM1483
3154:                  arc_detected = 0;
002EBC  EB0200     CLR W4
002EBE  8840B4     MOV W4, arc_detected
002EC0  370003     BRA .L306, .LSM1484
3155:                } else {
3156:                  global_run_post_pulse_process = 1; // This tells the main control loop that a pulse has occured and that it should run the post pulse process once (and only once) 
002EC2  B3C014     MOV.B #0x1, W4
002EC4  780004     MOV W4, W0
002EC6  B7F708     MOV.B WREG, global_run_post_pulse_process
3157:                }
3158:              
3159:                global_adc_ignore_this_sample = 1;  // This allows the internal ADC ISR to know that there was a pulse and to discard all the data from the sequence where the pulse occured
002EC8  B3C014     MOV.B #0x1, W4
002ECA  780004     MOV W4, W0
002ECC  B7F709     MOV.B WREG, global_adc_ignore_this_sample
3160:              }
002ECE  FA8000     ULNK
002ED0  78044F     MOV [--W15], W8
002ED2  BE034F     MOV.D [--W15], W6
002ED4  BE024F     MOV.D [--W15], W4
002ED6  F90036     POP RCOUNT
002ED8  FE8000     POP.S
002EDA  064000     RETFIE
3161:              
3162:              
3163:              
3164:              void _ISRNOPSV _T1Interrupt(void) {
002EDC  F80036     PUSH RCOUNT
002EDE  BE9F80     MOV.D W0, [W15++]
002EE0  BE9F82     MOV.D W2, [W15++]
002EE2  BE9F84     MOV.D W4, [W15++]
002EE4  BE9F86     MOV.D W6, [W15++]
002EE6  FA0002     LNK #0x2
3165:                /*
3166:                  This interrupt indicates that the cap charger should have finished charging and it is time to enable the trigger pulse.
3167:              
3168:                  This interrupt is called X us after charging starts
3169:                  If the lambda is not at EOC, it does not enable the trigger and sets the Lambda EOC Timeout Fault bit
3170:                  If the lambda is at EOC, It enables the trigger & sets status bits to show that the lambda is not charging and that the system is ready to fire.    
3171:                */
3172:                unsigned char lambda_eoc_happened = 0;
002EE8  EB4200     CLR.B W4
002EEA  784F04     MOV.B W4, [W14]
3173:                unsigned char n;
3174:              
3175:                last_known_action = LAST_ACTION_T1_INT;
002EEC  200034     MOV #0x3, W4
002EEE  88BDE4     MOV W4, last_known_action
3176:                
3177:                _T1IF = 0;         // Clear the interrupt flag
002EF0  A96084     BCLR IFS0, #3
3178:                _T1IE = 0;         // Disable the interrupt (This will be enabled the next time that a capacitor charging sequence starts)
002EF2  A9608C     BCLR IEC0, #3
3179:                T1CONbits.TON = 0;   // Stop the timer from incrementing (Again this will be restarted with the next time the capacitor charge sequence starts)
002EF4  A9E105     BCLR 0x105, #7
3180:                
3181:                // DPARKER - Consider adding more checks - Magnet Current, Actual Lambda Voltage, Check all the fault registers to confirm good to go!!!!
3182:                
3183:                if (!lambda_eoc_fault) {  
002EF6  2174C4     MOV #0x174C, W4
002EF8  784214     MOV.B [W4], W4
002EFA  524FE0     SUB.B W4, #0x0, [W15]
002EFC  3A0094     BRA NZ, .L311, .LSM1529
3184:              	  lambda_eoc_happened = 0;
002EFE  EB4200     CLR.B W4
002F00  784F04     MOV.B W4, [W14]
3185:              	  if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002F02  8016A4     MOV PORTD, W4
002F04  620264     AND W4, #0x4, W4
002F06  520FE0     SUB W4, #0x0, [W15]
002F08  320021     BRA Z, .L312, .LSM1505
3186:              	    __delay32(DELAY_TCY_10US);
002F0A  201260     MOV #0x126, W0
002F0C  200001     MOV #0x0, W1
002F0E  0715BF     RCALL ___delay32
3187:              	    if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002F10  8016A4     MOV PORTD, W4
002F12  620264     AND W4, #0x4, W4
002F14  520FE0     SUB W4, #0x0, [W15]
002F16  32001A     BRA Z, .L312, .LSM1505
3188:              	      __delay32(DELAY_TCY_10US);
002F18  201260     MOV #0x126, W0
002F1A  200001     MOV #0x0, W1
002F1C  0715B8     RCALL ___delay32
3189:              	      if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002F1E  8016A4     MOV PORTD, W4
002F20  620264     AND W4, #0x4, W4
002F22  520FE0     SUB W4, #0x0, [W15]
002F24  320013     BRA Z, .L312, .LSM1505
3190:              		__delay32(DELAY_TCY_10US);
002F26  201260     MOV #0x126, W0
002F28  200001     MOV #0x0, W1
002F2A  0715B1     RCALL ___delay32
3191:              		if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002F2C  8016A4     MOV PORTD, W4
002F2E  620264     AND W4, #0x4, W4
002F30  520FE0     SUB W4, #0x0, [W15]
002F32  32000C     BRA Z, .L312, .LSM1505
3192:              		  __delay32(DELAY_TCY_10US);
002F34  201260     MOV #0x126, W0
002F36  200001     MOV #0x0, W1
002F38  0715AA     RCALL ___delay32
3193:              		  if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002F3A  8016A4     MOV PORTD, W4
002F3C  620264     AND W4, #0x4, W4
002F3E  520FE0     SUB W4, #0x0, [W15]
002F40  320005     BRA Z, .L312, .LSM1505
3194:              	 //	    RecordThisHighVoltageFault(FAULT_HV_LAMBDA_EOC_TIMEOUT);
3195:              	  			lambda_eoc_happened = 1;
002F42  B3C014     MOV.B #0x1, W4
002F44  784F04     MOV.B W4, [W14]
3196:                              eoc_counts_total++;	        
002F46  80BAB4     MOV eoc_counts_total, W4
002F48  E80204     INC W4, W4
002F4A  88BAB4     MOV W4, eoc_counts_total
3197:              		  }
3198:              		} 
3199:              	      }
3200:              	    }
3201:              	  }
3202:              
3203:                    if (lambda_eoc_happened) {
002F4C  78421E     MOV.B [W14], W4
002F4E  524FE0     SUB.B W4, #0x0, [W15]
002F50  320027     BRA Z, .L313, .LSM1514
3204:                    	if (!eoc_counts) {
002F52  2174D4     MOV #0x174D, W4
002F54  784214     MOV.B [W4], W4
002F56  524FE0     SUB.B W4, #0x0, [W15]
002F58  3A0007     BRA NZ, .L314, .LSM1509
3205:              		   eoc_10ms_timer[0] = EOC_TIMER_WINDOW;
002F5A  200644     MOV #0x64, W4
002F5C  88BA84     MOV W4, eoc_10ms_timer
3206:              		   eoc_counts = 1;
002F5E  B3C014     MOV.B #0x1, W4
002F60  FD0200     EXCH W0, W4
002F62  B7F74D     MOV.B WREG, eoc_counts
002F64  FD0200     EXCH W0, W4
002F66  37001C     BRA .L313, .LSM1514
3207:              		}
3208:              	    else {
3209:              	       eoc_counts++;
002F68  2174D4     MOV #0x174D, W4
002F6A  784214     MOV.B [W4], W4
002F6C  E84204     INC.B W4, W4
002F6E  FD0200     EXCH W0, W4
002F70  B7F74D     MOV.B WREG, eoc_counts
002F72  FD0200     EXCH W0, W4
3210:              	       if (eoc_counts >= EOC_MAX_COUNT) {
002F74  2174D4     MOV #0x174D, W4
002F76  784214     MOV.B [W4], W4
002F78  524FE2     SUB.B W4, #0x2, [W15]
002F7A  360009     BRA LEU, .L315, .LSM1513
3211:              	          eoc_counts = EOC_MAX_COUNT;
002F7C  B3C034     MOV.B #0x3, W4
002F7E  FD0200     EXCH W0, W4
002F80  B7F74D     MOV.B WREG, eoc_counts
002F82  FD0200     EXCH W0, W4
3212:              	          lambda_eoc_fault = 1;  // declare EOC fault            
002F84  B3C014     MOV.B #0x1, W4
002F86  FD0200     EXCH W0, W4
002F88  B7F74C     MOV.B WREG, lambda_eoc_fault
002F8A  FD0200     EXCH W0, W4
002F8C  370009     BRA .L313, .LSM1514
3213:              	       }
3214:              	       else {
3215:              	          eoc_10ms_timer[eoc_counts - 1] = EOC_TIMER_WINDOW;  // remember the new window start time
002F8E  2174D4     MOV #0x174D, W4
002F90  784214     MOV.B [W4], W4
002F92  FB8204     ZE W4, W4
002F94  E90204     DEC W4, W4
002F96  420284     ADD W4, W4, W5
002F98  217504     MOV #0x1750, W4
002F9A  428204     ADD W5, W4, W4
002F9C  200645     MOV #0x64, W5
002F9E  780A05     MOV W5, [W4]
3216:              	       }
3217:              	    }
3218:              
3219:                    }
3220:                    
3221:              	  if (lambda_eoc_fault) {
002FA0  2174C4     MOV #0x174C, W4
002FA2  784214     MOV.B [W4], W4
002FA4  524FE0     SUB.B W4, #0x0, [W15]
002FA6  320003     BRA Z, .L316, .LSM1516
3222:              	  	 // == 10, need to hold 1s to find more PS info before declaring a fault 
3223:                       eoc_max_reached_timer = 100;    
002FA8  200644     MOV #0x64, W4
002FAA  88BA74     MOV W4, eoc_max_reached_timer
002FAC  37003C     BRA .L311, .LSM1529
3224:              	  }
3225:              	  else if (lambda_eoc_happened) {
002FAE  78421E     MOV.B [W14], W4
002FB0  524FE0     SUB.B W4, #0x0, [W15]
002FB2  320007     BRA Z, .L317, .LSM1521
3226:              	  	 // == 1, reset HV PS, skip one pulse
3227:              	       PIN_HV_LAMBDA_ENABLE = !OLL_HV_LAMBDA_ENABLED;
002FB4  A962D7     BCLR 0x2D7, #3
3228:                		   PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;
002FB6  A802D6     BSET LATD, #0
3229:                         __delay32(EOC_RESET_TIME);
002FB8  2ACD20     MOV #0xACD2, W0
002FBA  200001     MOV #0x0, W1
002FBC  071568     RCALL ___delay32
3230:              
3231:              		 // Actually enable the Lambda
3232:                        HVLambdaStartCharging();
002FBE  07FD7D     RCALL HVLambdaStartCharging
002FC0  370032     BRA .L311, .LSM1529
3233:              	  }
3234:              	  else if (eoc_counts && (eoc_counts < EOC_MAX_COUNT)) 
002FC2  2174D4     MOV #0x174D, W4
002FC4  784214     MOV.B [W4], W4
002FC6  524FE0     SUB.B W4, #0x0, [W15]
002FC8  32002E     BRA Z, .L311, .LSM1529
002FCA  2174D4     MOV #0x174D, W4
002FCC  784214     MOV.B [W4], W4
002FCE  524FE2     SUB.B W4, #0x2, [W15]
002FD0  3E002A     BRA GTU, .L311, .LSM1529
3235:              	  {
3236:              		   // check window timeout for eoc_counts
3237:              		  while (eoc_counts && (eoc_10ms_timer[0] <= 0)) 
002FD2  370022     BRA .L318, .LSM1528
003018  2174D4     MOV #0x174D, W4
00301A  784214     MOV.B [W4], W4
00301C  524FE0     SUB.B W4, #0x0, [W15]
00301E  320003     BRA Z, .L311, .LSM1529
003020  80BA84     MOV eoc_10ms_timer, W4
003022  520FE0     SUB W4, #0x0, [W15]
003024  34FFD7     BRA LE, .L321, .LSM1523
3238:              	      {
3239:              		  	 eoc_counts--;
002FD4  2174D4     MOV #0x174D, W4
002FD6  784214     MOV.B [W4], W4
002FD8  E94204     DEC.B W4, W4
002FDA  FD0200     EXCH W0, W4
002FDC  B7F74D     MOV.B WREG, eoc_counts
002FDE  FD0200     EXCH W0, W4
3240:              	         if (eoc_counts) 
002FE0  2174D4     MOV #0x174D, W4
002FE2  784214     MOV.B [W4], W4
002FE4  524FE0     SUB.B W4, #0x0, [W15]
002FE6  320018     BRA Z, .L318, .LSM1528
3241:              	         { // move 10ms window timer up
3242:              	         	for (n = 0; n < eoc_counts; n++) 
002FE8  EB4200     CLR.B W4
002FEA  984714     MOV.B W4, [W14+1]
002FEC  370010     BRA .L319
003008  90421E     MOV.B [W14+1], W4
00300A  E84204     INC.B W4, W4
00300C  984714     MOV.B W4, [W14+1]
00300E  2174D4     MOV #0x174D, W4
003010  784214     MOV.B [W4], W4
003012  90429E     MOV.B [W14+1], W5
003014  52CF84     SUB.B W5, W4, [W15]
003016  39FFEB     BRA NC, .L320, .LSM1526
3243:              	            {
3244:              	               eoc_10ms_timer[n] = eoc_10ms_timer[n+1];
002FEE  90421E     MOV.B [W14+1], W4
002FF0  FB8284     ZE W4, W5
002FF2  90421E     MOV.B [W14+1], W4
002FF4  FB8204     ZE W4, W4
002FF6  E80204     INC W4, W4
002FF8  420304     ADD W4, W4, W6
002FFA  217504     MOV #0x1750, W4
002FFC  430204     ADD W6, W4, W4
002FFE  780314     MOV [W4], W6
003000  428285     ADD W5, W5, W5
003002  217504     MOV #0x1750, W4
003004  428204     ADD W5, W4, W4
003006  780A06     MOV W6, [W4]
3245:              	            }
3246:              	         }
3247:              		  }
3248:              	  }
3249:                }
3250:                
3251:              
3252:                //DPARER CHECK FOR REQUENCY MODULATION HERE
3253:                if (lambda_eoc_fault || lambda_eoc_happened) {
003026  2174C4     MOV #0x174C, W4
003028  784214     MOV.B [W4], W4
00302A  524FE0     SUB.B W4, #0x0, [W15]
00302C  3A0003     BRA NZ, .L322, .LSM1530
00302E  78421E     MOV.B [W14], W4
003030  524FE0     SUB.B W4, #0x0, [W15]
003032  320003     BRA Z, .L323, .LSM1531
3254:                    this_pulse_skipped = 1;
003034  200014     MOV #0x1, W4
003036  884264     MOV W4, this_pulse_skipped
003038  37000C     BRA .L310, .LSM1537
3255:                } else {
3256:              	  if (CheckSkipNextPulse()) {
00303A  070012     RCALL CheckSkipNextPulse
00303C  780200     MOV W0, W4
00303E  520FE0     SUB W4, #0x0, [W15]
003040  320003     BRA Z, .L325, .LSM1533
3257:              	    this_pulse_skipped = 1;
003042  200014     MOV #0x1, W4
003044  884264     MOV W4, this_pulse_skipped
003046  370003     BRA .L326, .LSM1535
3258:              	  } else {
3259:              	    this_pulse_skipped = 0;
003048  EB0200     CLR W4
00304A  884264     MOV W4, this_pulse_skipped
3260:              	  // Enable the the thyratron trigger and Enable the Trigger Interrupt
3261:              	    PIN_THYRATRON_TRIGGER_ENABLE = OLL_THYRATRON_TRIGGER_ENABLED; // Enable the thyratron trigger pass through.
00304C  A8C2C4     BSET LATA, #6
3262:                    }
3263:                   
3264:                    _INT1IF = 0;                                                  // Enable INT1 (thyratron trigger) interrupt
00304E  A90086     BCLR IFS1, #0
3265:                    _INT1IE = 1;
003050  A8008E     BSET IEC1, #0
3266:              
3267:                }
3268:              
3269:                
3270:                
3271:              }  
003052  FA8000     ULNK
003054  BE034F     MOV.D [--W15], W6
003056  BE024F     MOV.D [--W15], W4
003058  BE014F     MOV.D [--W15], W2
00305A  BE004F     MOV.D [--W15], W0
00305C  F90036     POP RCOUNT
00305E  064000     RETFIE
3272:              
3273:              
3274:              unsigned int loop_counter;
3275:              
3276:              unsigned int CheckSkipNextPulse(void) {
003060  FA0000     LNK #0x0
3277:              
3278:              
3279:                if ((prf_mult == 0) || (prf_divider == 0)) {
003062  80BDA4     MOV .LSM673, W4
003064  520FE0     SUB W4, #0x0, [W15]
003066  320003     BRA Z, .L328, .LSM1540
003068  80BDB4     MOV .LSM674, W4
00306A  520FE0     SUB W4, #0x0, [W15]
00306C  3A0002     BRA NZ, .L329, .LSM1541
3280:                  return 0;
00306E  EB0200     CLR W4
003070  370018     BRA .L330, .LSM1549
3281:                }
3282:                
3283:                if ((prf_mult == 1) && (prf_divider == 1)) {
003072  80BDA4     MOV .LSM673, W4
003074  520FE1     SUB W4, #0x1, [W15]
003076  3A0005     BRA NZ, .L331, .LSM1543
003078  80BDB4     MOV .LSM674, W4
00307A  520FE1     SUB W4, #0x1, [W15]
00307C  3A0002     BRA NZ, .L331, .LSM1543
3284:                  return 0;
00307E  EB0200     CLR W4
003080  370010     BRA .L330, .LSM1549
3285:                }
3286:                
3287:                loop_counter++;
003082  80B914     MOV loop_counter, W4
003084  E80204     INC W4, W4
003086  88B914     MOV W4, loop_counter
3288:              
3289:                if (loop_counter >= prf_divider) {
003088  80B915     MOV loop_counter, W5
00308A  80BDB4     MOV .LSM674, W4
00308C  528F84     SUB W5, W4, [W15]
00308E  390002     BRA NC, .L332, .LSM1546
3290:                  loop_counter = 0;
003090  EB0200     CLR W4
003092  88B914     MOV W4, loop_counter
3291:                }
3292:              
3293:                
3294:                if (loop_counter < prf_mult) {
003094  80B915     MOV loop_counter, W5
003096  80BDA4     MOV .LSM673, W4
003098  528F84     SUB W5, W4, [W15]
00309A  310002     BRA C, .L333, .LSM1548
3295:                  return 0;
00309C  EB0200     CLR W4
00309E  370001     BRA .L330, .LSM1549
3296:                } else {
3297:                  return 1;
0030A0  200014     MOV #0x1, W4
3298:                }
3299:              }
0030A2  780004     MOV W4, W0
0030A4  FA8000     ULNK
0030A6  060000     RETURN
3300:              
3301:              
3302:              void _ISRNOPSV _ADCInterrupt(void) {
0030A8  781F80     MOV W0, [W15++]
0030AA  BE9F84     MOV.D W4, [W15++]
0030AC  781F86     MOV W6, [W15++]
0030AE  FA0000     LNK #0x0
3303:                _ASAM = 0; // Stop Auto Sampling
0030B0  A942A0     BCLR ADCON1, #2
3304:                _ADIF = 0;
0030B2  A96085     BCLR 0x85, #3
3305:                
3306:                // Switch the sate of PIN_UART2_TX (debugging info)
3307:                if (PIN_UART2_TX) {
0030B4  801655     MOV LATB, W5
0030B6  200404     MOV #0x40, W4
0030B8  628204     AND W5, W4, W4
0030BA  520FE0     SUB W4, #0x0, [W15]
0030BC  320002     BRA Z, .L335, .LSM1555
3308:                  PIN_UART2_TX = 0;
0030BE  A9C2CA     BCLR LATB, #6
0030C0  370001     BRA .L336, .LSM1556
3309:                } else {
3310:                  PIN_UART2_TX = 1;
0030C2  A8C2CA     BSET LATB, #6
3311:                }
3312:              
3313:                last_known_action = LAST_ACTION_ADC_INTERRUPT;
0030C4  200014     MOV #0x1, W4
0030C6  88BDE4     MOV W4, last_known_action
3314:                // DPARKER what for the conversion to complete???
3315:                
3316:                if (global_adc_ignore_this_sample) {
0030C8  217094     MOV #0x1709, W4
0030CA  784214     MOV.B [W4], W4
0030CC  524FE0     SUB.B W4, #0x0, [W15]
0030CE  320005     BRA Z, .L337, .LSM1559
3317:                  // There was a pulse durring the sample sequence.  Throw the data away!!!
3318:                  global_adc_ignore_this_sample = 0;
0030D0  EB4200     CLR.B W4
0030D2  FD0200     EXCH W0, W4
0030D4  B7F709     MOV.B WREG, global_adc_ignore_this_sample
0030D6  FD0200     EXCH W0, W4
0030D8  370062     BRA .L338, .LSM1572
3319:                } else {
3320:                  // Copy Data From Buffer to RAM
3321:                  pfn_rev_current_array[adc_result_index] = ADCBUF0;
0030DA  20C064     MOV #0xC06, W4
0030DC  784214     MOV.B [W4], W4
0030DE  FB8204     ZE W4, W4
0030E0  801405     MOV ADCBUF0, W5
0030E2  420304     ADD W4, W4, W6
0030E4  20C084     MOV #0xC08, W4
0030E6  430204     ADD W6, W4, W4
0030E8  780A05     MOV W5, [W4]
3322:                  
3323:                  pac_1_array[adc_result_index] = ADCBUF1;
0030EA  20C064     MOV #0xC06, W4
0030EC  784214     MOV.B [W4], W4
0030EE  FB8204     ZE W4, W4
0030F0  801415     MOV ADCBUF1, W5
0030F2  420304     ADD W4, W4, W6
0030F4  20D084     MOV #0xD08, W4
0030F6  430204     ADD W6, W4, W4
0030F8  780A05     MOV W5, [W4]
3324:                  pac_2_array[adc_result_index] = ADCBUF2;
0030FA  20C064     MOV #0xC06, W4
0030FC  784214     MOV.B [W4], W4
0030FE  FB8204     ZE W4, W4
003100  801425     MOV ADCBUF2, W5
003102  420304     ADD W4, W4, W6
003104  20E084     MOV #0xE08, W4
003106  430204     ADD W6, W4, W4
003108  780A05     MOV W5, [W4]
3325:                  
3326:                  thyratron_cathode_heater_voltage_array[adc_result_index] = ADCBUF3;
00310A  20C064     MOV #0xC06, W4
00310C  784214     MOV.B [W4], W4
00310E  FB8204     ZE W4, W4
003110  801435     MOV ADCBUF3, W5
003112  420304     ADD W4, W4, W6
003114  20F084     MOV #0xF08, W4
003116  430204     ADD W6, W4, W4
003118  780A05     MOV W5, [W4]
3327:                  thyratron_reservoir_heater_voltage_array[adc_result_index] = ADCBUF4;
00311A  20C064     MOV #0xC06, W4
00311C  784214     MOV.B [W4], W4
00311E  FB8204     ZE W4, W4
003120  801445     MOV ADCBUF4, W5
003122  420304     ADD W4, W4, W6
003124  210084     MOV #0x1008, W4
003126  430204     ADD W6, W4, W4
003128  780A05     MOV W5, [W4]
3328:                  
3329:                  magnetron_magnet_current_array[adc_result_index]= ADCBUF5;
00312A  20C064     MOV #0xC06, W4
00312C  784214     MOV.B [W4], W4
00312E  FB8204     ZE W4, W4
003130  801455     MOV ADCBUF5, W5
003132  420304     ADD W4, W4, W6
003134  211084     MOV #0x1108, W4
003136  430204     ADD W6, W4, W4
003138  780A05     MOV W5, [W4]
3330:                  magnetron_magnet_voltage_array[adc_result_index]= ADCBUF6;
00313A  20C064     MOV #0xC06, W4
00313C  784214     MOV.B [W4], W4
00313E  FB8204     ZE W4, W4
003140  801465     MOV ADCBUF6, W5
003142  420304     ADD W4, W4, W6
003144  212084     MOV #0x1208, W4
003146  430204     ADD W6, W4, W4
003148  780A05     MOV W5, [W4]
3331:                  
3332:                  magnetron_filament_voltage_array[adc_result_index] = ADCBUF7;
00314A  20C064     MOV #0xC06, W4
00314C  784214     MOV.B [W4], W4
00314E  FB8204     ZE W4, W4
003150  801475     MOV ADCBUF7, W5
003152  420304     ADD W4, W4, W6
003154  214084     MOV #0x1408, W4
003156  430204     ADD W6, W4, W4
003158  780A05     MOV W5, [W4]
3333:                  magnetron_filament_current_array[adc_result_index] = ADCBUF8;
00315A  20C064     MOV #0xC06, W4
00315C  784214     MOV.B [W4], W4
00315E  FB8204     ZE W4, W4
003160  801485     MOV ADCBUF8, W5
003162  420304     ADD W4, W4, W6
003164  213084     MOV #0x1308, W4
003166  430204     ADD W6, W4, W4
003168  780A05     MOV W5, [W4]
3334:              
3335:                  
3336:                  lambda_vpeak_array[adc_result_index] = ADCBUF9;
00316A  20C064     MOV #0xC06, W4
00316C  784214     MOV.B [W4], W4
00316E  FB8204     ZE W4, W4
003170  801495     MOV ADCBUF9, W5
003172  420304     ADD W4, W4, W6
003174  215084     MOV #0x1508, W4
003176  430204     ADD W6, W4, W4
003178  780A05     MOV W5, [W4]
3337:                  lambda_vmon_array[adc_result_index] = ADCBUFA;
00317A  20C064     MOV #0xC06, W4
00317C  784214     MOV.B [W4], W4
00317E  FB8204     ZE W4, W4
003180  8014A5     MOV ADCBUFA, W5
003182  420304     ADD W4, W4, W6
003184  216084     MOV #0x1608, W4
003186  430204     ADD W6, W4, W4
003188  780A05     MOV W5, [W4]
3338:                  
3339:                  adc_result_index++;
00318A  20C064     MOV #0xC06, W4
00318C  784214     MOV.B [W4], W4
00318E  E84204     INC.B W4, W4
003190  780004     MOV W4, W0
003192  B7EC06     MOV.B WREG, adc_result_index
3340:                  adc_result_index &= 0b01111111;
003194  20C064     MOV #0xC06, W4
003196  784214     MOV.B [W4], W4
003198  A17404     BCLR.B W4, #7
00319A  780004     MOV W4, W0
00319C  B7EC06     MOV.B WREG, adc_result_index
3341:                }
3342:                _ASAM = 1; // Start Auto Sampling
00319E  A842A0     BSET ADCON1, #2
3343:              }
0031A0  FA8000     ULNK
0031A2  78034F     MOV [--W15], W6
0031A4  BE024F     MOV.D [--W15], W4
0031A6  78004F     MOV [--W15], W0
0031A8  064000     RETFIE
3344:              
3345:              
3346:              void _ISRNOPSV _CNInterrupt(void) {
0031AA  F80036     PUSH RCOUNT
0031AC  BE9F80     MOV.D W0, [W15++]
0031AE  BE9F82     MOV.D W2, [W15++]
0031B0  BE9F84     MOV.D W4, [W15++]
0031B2  BE9F86     MOV.D W6, [W15++]
0031B4  FA0000     LNK #0x0
3347:                if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
0031B6  8016A5     MOV PORTD, W5
0031B8  200804     MOV #0x80, W4
0031BA  628204     AND W5, W4, W4
0031BC  520FE0     SUB W4, #0x0, [W15]
0031BE  3A0012     BRA NZ, .L340, .LSM1581
3348:                  __delay32(100); // 10uS
0031C0  200640     MOV #0x64, W0
0031C2  200001     MOV #0x0, W1
0031C4  071464     RCALL ___delay32
3349:                  if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
0031C6  8016A5     MOV PORTD, W5
0031C8  200804     MOV #0x80, W4
0031CA  628204     AND W5, W4, W4
0031CC  520FE0     SUB W4, #0x0, [W15]
0031CE  3A000A     BRA NZ, .L340, .LSM1581
3350:                    __delay32(100); // 10uS
0031D0  200640     MOV #0x64, W0
0031D2  200001     MOV #0x0, W1
0031D4  07145C     RCALL ___delay32
3351:                    if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
0031D6  8016A5     MOV PORTD, W5
0031D8  200804     MOV #0x80, W4
0031DA  628204     AND W5, W4, W4
0031DC  520FE0     SUB W4, #0x0, [W15]
0031DE  3A0002     BRA NZ, .L340, .LSM1581
3352:              	RecordThisThyratronFault(FAULT_THYR_FALSE_TRIGGER);
0031E0  204000     MOV #0x400, W0
0031E2  070B4A     RCALL RecordThisThyratronFault
3353:                    }
3354:                  }
3355:                }
3356:                _CNIF = 0;
0031E4  A9E085     BCLR 0x85, #7
3357:              }
0031E6  FA8000     ULNK
0031E8  BE034F     MOV.D [--W15], W6
0031EA  BE024F     MOV.D [--W15], W4
0031EC  BE014F     MOV.D [--W15], W2
0031EE  BE004F     MOV.D [--W15], W0
0031F0  F90036     POP RCOUNT
0031F2  064000     RETFIE
3358:              
3359:              
3360:              void _ISRNOPSV _LVDInterrupt(void) {
0031F4  781F80     MOV W0, [W15++]
0031F6  781F84     MOV W4, [W15++]
0031F8  FA0000     LNK #0x0
3361:                last_known_action = LAST_ACTION_LVD_INT;
0031FA  200024     MOV #0x2, W4
0031FC  88BDE4     MOV W4, last_known_action
3362:                _LVDIF = 0;
0031FE  A94089     BCLR 0x89, #2
3363:                lvdinterrupt_counter++;
003200  804244     MOV lvdinterrupt_counter, W4
003202  E80204     INC W4, W4
003204  884244     MOV W4, lvdinterrupt_counter
3364:              }
003206  FA8000     ULNK
003208  78024F     MOV [--W15], W4
00320A  78004F     MOV [--W15], W0
00320C  064000     RETFIE
3365:              
3366:              
3367:              void _ISRNOPSV _OscillatorFail(void) {
00320E  781F84     MOV W4, [W15++]
003210  FA0000     LNK #0x0
3368:               last_known_action = LAST_ACTION_OSC_FAIL;
003212  2000D4     MOV #0xD, W4
003214  88BDE4     MOV W4, last_known_action
3369:               last_osccon = OSCCON;
003216  803A14     MOV OSCCON, W4
003218  88BDF4     MOV W4, last_osccon
3370:                Nop();
00321A  000000     NOP
3371:                Nop();
00321C  000000     NOP
3372:                __asm__ ("Reset");
00321E  FE0000     RESET
3373:              }
003220  FA8000     ULNK
003222  78024F     MOV [--W15], W4
003224  064000     RETFIE
3374:              
3375:              void _ISRNOPSV _AddressError(void) {
003226  781F84     MOV W4, [W15++]
003228  FA0000     LNK #0x0
3376:               last_known_action = LAST_ACTION_ADDRESS_ERROR;
00322A  2000E4     MOV #0xE, W4
00322C  88BDE4     MOV W4, last_known_action
3377:                Nop();
00322E  000000     NOP
3378:                Nop();
003230  000000     NOP
3379:                __asm__ ("Reset");
003232  FE0000     RESET
3380:              }
003234  FA8000     ULNK
003236  78024F     MOV [--W15], W4
003238  064000     RETFIE
3381:              
3382:              void _ISRNOPSV _StackError(void) {
00323A  781F84     MOV W4, [W15++]
00323C  FA0000     LNK #0x0
3383:               last_known_action = LAST_ACTION_STACK_ERROR;
00323E  2000F4     MOV #0xF, W4
003240  88BDE4     MOV W4, last_known_action
3384:                Nop();
003242  000000     NOP
3385:                Nop();
003244  000000     NOP
3386:                __asm__ ("Reset");
003246  FE0000     RESET
3387:              }
003248  FA8000     ULNK
00324A  78024F     MOV [--W15], W4
00324C  064000     RETFIE
3388:              
3389:              void _ISRNOPSV _MathError(void) {
00324E  781F84     MOV W4, [W15++]
003250  FA0000     LNK #0x0
3390:               last_known_action = LAST_ACTION_MATH_ERROR;
003252  200104     MOV #0x10, W4
003254  88BDE4     MOV W4, last_known_action
3391:                Nop();
003256  000000     NOP
3392:                Nop();
003258  000000     NOP
3393:                __asm__ ("Reset");
00325A  FE0000     RESET
3394:              }
00325C  FA8000     ULNK
00325E  78024F     MOV [--W15], W4
003260  064000     RETFIE
3395:              
3396:              
3397:              
3398:              // DPARKER THIS FUNCTION FOR DEBUGGING ONLY
3399:              void _ISRNOPSV _DefaultInterrupt(void) {
003262  781F84     MOV W4, [W15++]
003264  FA0000     LNK #0x0
3400:                /*
3401:                control_state = STATE_FAULT_ILLEGAL_INTERRUPT;
3402:                global_debug_counter.magnetron_current_adc_glitch = IFS0;
3403:                global_debug_counter.magnetron_voltage_adc_glitch = IFS1;
3404:                global_debug_counter.i2c_bus_error = IFS2;
3405:              
3406:                global_debug_counter.spi1_bus_error = IEC0;
3407:                global_debug_counter.spi2_bus_error = IEC1;
3408:                global_debug_counter.external_adc_false_trigger = IEC2;
3409:              
3410:                while (1) {
3411:                  ClrWdt();
3412:                  DoSerialCommand();
3413:                }
3414:                */
3415:                last_known_action = LAST_ACTION_DEFAULT_INT;
003266  2FABC4     MOV #0xFABC, W4
003268  88BDE4     MOV W4, last_known_action
3416:                Nop();
00326A  000000     NOP
3417:                Nop();
00326C  000000     NOP
3418:                __asm__ ("Reset");
00326E  FE0000     RESET
3419:              }
003270  FA8000     ULNK
003272  78024F     MOV [--W15], W4
003274  064000     RETFIE
3420:              
3421:              
3422:              
3423:              
3424:              unsigned int CalculatePoly(unsigned int set_point) {
003276  FA000C     LNK #0xC
003278  980750     MOV W0, [W14+10]
3425:              
3426:                signed long sum;
3427:                signed long temp;
3428:                unsigned int value;
3429:              
3430:                temp = set_point;
00327A  90025E     MOV [W14+10], W4
00327C  200005     MOV #0x0, W5
00327E  BE8F04     MOV.D W4, [W14]
3431:                temp *= set_point;
003280  90025E     MOV [W14+10], W4
003282  200005     MOV #0x0, W5
003284  90031E     MOV [W14+2], W6
003286  B9B304     MUL.SS W6, W4, W6
003288  780306     MOV W6, W6
00328A  78039E     MOV [W14], W7
00328C  B9B805     MUL.SS W7, W5, W0
00328E  780380     MOV W0, W7
003290  430307     ADD W6, W7, W6
003292  78039E     MOV [W14], W7
003294  780204     MOV W4, W4
003296  B82207     MUL.UU W4, W7, W4
003298  430305     ADD W6, W5, W6
00329A  780286     MOV W6, W5
00329C  BE8F04     MOV.D W4, [W14]
00329E  BE8F04     MOV.D W4, [W14]
3432:                temp = temp >> 14;
0032A0  BE021E     MOV.D [W14], W4
0032A2  DD2B42     SL W5, #2, W6
0032A4  DE224E     LSR W4, #14, W4
0032A6  730204     IOR W6, W4, W4
0032A8  DEAACE     ASR W5, #14, W5
0032AA  BE8F04     MOV.D W4, [W14]
3433:                temp *= 0;  // We never use the sqaured factor
0032AC  B82260     MUL.UU W4, #0, W4
0032AE  BE8F04     MOV.D W4, [W14]
3434:                temp = temp >> 10;
0032B0  BE021E     MOV.D [W14], W4
0032B2  DD2BC6     SL W5, #6, W7
0032B4  DE224A     LSR W4, #10, W4
0032B6  738204     IOR W7, W4, W4
0032B8  DEAACA     ASR W5, #10, W5
0032BA  BE8F04     MOV.D W4, [W14]
3435:                sum = temp;
0032BC  BE021E     MOV.D [W14], W4
0032BE  980724     MOV W4, [W14+4]
0032C0  980735     MOV W5, [W14+6]
3436:              
3437:                temp = set_point;
0032C2  90025E     MOV [W14+10], W4
0032C4  200005     MOV #0x0, W5
0032C6  BE8F04     MOV.D W4, [W14]
3438:                temp *= magnet_scaling_linear_factor;
0032C8  804064     MOV magnet_scaling_linear_factor, W4
0032CA  200005     MOV #0x0, W5
0032CC  90031E     MOV [W14+2], W6
0032CE  B9B304     MUL.SS W6, W4, W6
0032D0  780306     MOV W6, W6
0032D2  78039E     MOV [W14], W7
0032D4  B9B805     MUL.SS W7, W5, W0
0032D6  780380     MOV W0, W7
0032D8  430307     ADD W6, W7, W6
0032DA  78039E     MOV [W14], W7
0032DC  780204     MOV W4, W4
0032DE  B82207     MUL.UU W4, W7, W4
0032E0  430305     ADD W6, W5, W6
0032E2  780286     MOV W6, W5
0032E4  BE8F04     MOV.D W4, [W14]
0032E6  BE8F04     MOV.D W4, [W14]
3439:                temp = temp >> 10;
0032E8  BE021E     MOV.D [W14], W4
0032EA  DD2B46     SL W5, #6, W6
0032EC  DE224A     LSR W4, #10, W4
0032EE  730204     IOR W6, W4, W4
0032F0  DEAACA     ASR W5, #10, W5
0032F2  BE8F04     MOV.D W4, [W14]
3440:              
3441:                sum += temp;
0032F4  90022E     MOV [W14+4], W4
0032F6  9002BE     MOV [W14+6], W5
0032F8  42033E     ADD W4, [W14++], W6
0032FA  4A83AE     ADDC W5, [W14--], W7
0032FC  BE0206     MOV.D W6, W4
0032FE  980724     MOV W4, [W14+4]
003300  980735     MOV W5, [W14+6]
3442:              
3443:                temp = magnet_scaling_constant_factor;
003302  804074     MOV magnet_scaling_constant_factor, W4
003304  200005     MOV #0x0, W5
003306  BE8F04     MOV.D W4, [W14]
3444:                
3445:                temp = temp << 2;
003308  BE031E     MOV.D [W14], W6
00330A  DD3A42     SL W7, #2, W4
00330C  DE32CE     LSR W6, #14, W5
00330E  720285     IOR W4, W5, W5
003310  DD3242     SL W6, #2, W4
003312  BE8F04     MOV.D W4, [W14]
3446:              
3447:                sum += temp;
003314  90022E     MOV [W14+4], W4
003316  9002BE     MOV [W14+6], W5
003318  42033E     ADD W4, [W14++], W6
00331A  4A83AE     ADDC W5, [W14--], W7
00331C  BE0206     MOV.D W6, W4
00331E  980724     MOV W4, [W14+4]
003320  980735     MOV W5, [W14+6]
3448:              
3449:                value = (sum & 0xFFFF);
003322  9003AE     MOV [W14+4], W7
003324  980747     MOV W7, [W14+8]
3450:                
3451:                return value; 
003326  90024E     MOV [W14+8], W4
3452:              }
003328  780004     MOV W4, W0
00332A  FA8000     ULNK
00332C  060000     RETURN
3453:              
3454:              
3455:              
