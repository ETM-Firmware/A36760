Disassembly Listing for A34760
Generated From:
C:/Users/dparker/Documents/GitHub/TestDan/A34760.X/dist/default/production/A34760.X.production.elf
Sep 12, 2014 8:03:19 AM

---  C:/Users/dparker/Documents/GitHub/TestDan/faults.c  ------------------------------------------------
1:                 #include "A34760.h"
2:                 #include "faults.h"
3:                 #include "A34760_PINS.h"
4:                 #include <libpic30.h>
5:                 #include "Config.h"
6:                 #include "MCP23017.h"
7:                 
8:                 
9:                 TYPE_DEBUG_COUNTER global_debug_counter;
10:                
11:                unsigned int CalculatePulseEnergyMilliJoules(unsigned int lambda_voltage);
12:                
13:                void StorePulseData(POWERSUPPLY* ptr);
14:                
15:                // The status register used for debug purposes
16:                unsigned int debug_status_register;
17:                
18:                // MAGNETRON CONTROL FAULT REGISTERS
19:                unsigned int faults_magnetron_status_reg;
20:                unsigned int faults_magnetron_fault_reg;
21:                unsigned int faults_magnetron_warning_reg;
22:                
23:                // HIGH VOLTAGE FAULT REGISTERS
24:                unsigned int faults_high_voltage_status_reg;
25:                unsigned int faults_high_voltage_fault_reg;
26:                unsigned int faults_high_voltage_warning_reg;
27:                
28:                // THYRATRON HEATER FAULT REGISTERS
29:                unsigned int faults_thyratron_status_reg;
30:                unsigned int faults_thyratron_fault_reg;
31:                unsigned int faults_thyratron_warning_reg;
32:                
33:                
34:                // CONTROL BOARD FAULT REGISTERS
35:                unsigned int faults_control_board_status_reg;
36:                unsigned int faults_control_board_fault_reg;
37:                unsigned int faults_control_board_warning_reg;
38:                
39:                
40:                
41:                // Variables to save the active fault/warning masks for this control loop state
42:                unsigned int magnetron_fault_mask;
43:                unsigned int high_voltage_fault_mask;
44:                unsigned int thyratron_fault_mask;
45:                unsigned int control_board_fault_mask;
46:                
47:                unsigned int magnetron_warning_mask;
48:                unsigned int high_voltage_warning_mask;
49:                unsigned int thyratron_warning_mask;
50:                unsigned int control_board_warning_mask;
51:                
52:                
53:                void LoadFaultMaskRegisters(void);
54:                void WriteToEventLog(unsigned char fault_register, unsigned int fault_bit);
55:                unsigned char CheckOverVoltFault(POWERSUPPLY* ptr);
56:                unsigned char CheckUnderVoltFault(POWERSUPPLY* ptr);
57:                unsigned char CheckOverCurrentFault(POWERSUPPLY* ptr);
58:                unsigned char CheckUnderCurrentFault(POWERSUPPLY* ptr);
59:                
60:                
61:                /*
62:                  FAULT EVALUATION
63:                  
64:                  10_ms_tic_toc
65:                  Once every 10ms, the internal ADC is read and faults are updated
66:                
67:                  After Every Pulse
68:                
69:                  DPARKER give a big description of each fault here - How the input is measured, how the data is filtered, how the fault is generated (delay if included)
70:                
71:                */
72:                
73:                
74:                /*
75:                  In each State, Each fault input can do one of the following . . .
76:                
77:                  1) It can be totally ignored (This is the default behavior - If the warning mask & the fault mask are NOT set)
78:                  2) It can cause a fault  (This is set by the fault MASK)
79:                     There are no "warm" or "cold" faults.  Any fault in state warm_ready or hv_on will go to state warm fault.
80:                     If the fault is still active in the warm state fault then it will move to cold fault.
81:                  3) It can cause a latched warning (This is set the warning MASK)
82:                     NOTE: the warning register is independent of the fault mask.  To be latched as a warning, the fault input MUST BE IN THE WARNING REGISTER
83:                  4) Special state at startup to handle board level failures . . . ????
84:                */
85:                
86:                /*  
87:                    Fault Log
88:                    
89:                    Each entry in the fault log contains the following information
90:                    4 bits for fault register bit
91:                    2 bits for fault register select
92:                    2 bits for the calling state (HV_ON, WARM_READY, FAULT, STARTUP)
93:                */
94:                
95:                /*
96:                  For each state there are three fault masks for each fault register.
97:                  Warning Ignore Mask - This shows which fault inputs will NOT generate a warning (this is mainly for debugging and and is used to filter out non-events, if a fault is in the warning ignore mask and in the warm or cold fault mask it will still generate a fault)
98:                  Faul Mask - this shows which fault inputs will generate a fault in the current state
99:                
100:               
101:               */
102:               
103:               /*
104:               
105:                 Status_Register -> This register shows the current states of all the Inputs.  It IS NOT LATCHED.
106:                 Fault_Register -> This register latches any fault input that matches the fault_mask for the current state.
107:                 Warning_Latch_Regisiter -> Any fault input that matches the fault_mask or the warning_mask will be latched in this register.
108:               
109:                 How faults are checked . . .
110:                 
111:                 Every time through a control loop, 50us->500us depending upon the state, all faults registeres are updated and checked.
112:                 Faults like magnetron_heater_over_current - The limit is compared to the filtered data in RAM every time, even though the filtered data in ram is only update once every 10mS
113:                 The fault status register is then compared to the masks to generate the warnings and faults.
114:               
115:                */
116:               
117:               /* ----------------------FAULT MANAGEMENT ----------------------*/
118:               
119:               /*
120:                 There are lots of Fault Conditions, see A34335.h for a list of fault registeres and faults.
121:                 For a given state a particular Input may
122:                 1) No Action - But set a non latching status bit indicating the state of the fault input
123:                 2) No Action - But set a latching "warning" bit 
124:                 3) Generate a fault Condition - This will change the state to warm fault (or cold fault if the fault is globably defined as a cold fault)
125:                
126:               
127:                 How are faults handeled . . .
128:                 There a 3 data storage locations for each fault register.
129:                 Status_Register -> This register shows the current states of all the Inputs.  It IS NOT LATCHED.
130:                 Latch_Regisiter -> This is a latched version of the the status register.
131:                 Fault_Register  -> If the Input is a Fault (it matches the warm_fault OR cold_fault mask) it is latched into the Fault Register
132:                 
133:                 How external data and faults are processesed . . . 
134:               
135:                 Data is read from the external ADCs and inernal ADCs on a regular 10ms interval or after a pulse (for pulse data types).
136:                 This inerval is scheduled to occur directly proceding a pulse if possible (pulse rate > 100 Hz).
137:                 At PRF less than 100Hz (or in any other state) the readings will take place at opproximate 10ms intervals
138:                 ADC values are filtered with software RC/glitch filters when they are read.
139:                
140:                
141:                 Faults are evaluated durring the 10ms_tic_toc the occurs once every (approximatly) 10mS
142:                 The following steps occur
143:                 1) Status registers are reset to zero
144:                 2) The input condition is tested, if it is a "logical fault" then (record_this_xxxxx_fault) is called which does the following
145:                   a) Sets the appropriate bit in the status register
146:                   b) If the bit matches the fault_mask, 
147:                      ^ The appropriate bit in the fault register is set
148:                      ^ The fault is added to the error log - TO BE IMPLEMENTED
149:                   c) If the bit matches the warning_mask, the appropriate bit in the warning register is set 
150:                 
151:                 STEP 2 is repeated for all fault conditions.
152:               
153:                 Some faults can not be tested durring the 10ms TicToc.
154:                 These faults will have record_this_xxxxx_fault called when the fault is checked.
155:                 These faults are . . .
156:                 FAULT_HV_LAMBDA_EOC_TIMEOUT - this is evaluated in the TMR1 interrupt and set there.
157:               
158:               
159:                 After all the faults have been tested and the fault registers updated the following action occurs
160:                 
161:                 + A cold shutdown occurs
162:                 + A warm shutdown occurs
163:                 
164:                 + The fault is added to the Log
165:                 + For *some* important faults, the fault counter is incremented.
166:               
167:                 + The fault is added to the Log
168:                 + For *some* important faults, the fault counter is incremented.
169:                 
170:               */
171:               
172:               
173:               
174:               // DPARKER update pulse fault must be called at 10ms Interval or the sections that count "out of range" counts will be arbitrary time lengths
175:               
176:               void UpdateFaults(void) {
0038C0  FA0002     LNK #0x2
177:                 // See h file for documentation
178:                 unsigned int temp_u16int;
179:               
180:                 // The status registers are not latched so they are reset to zero each time the faults are evaluated
181:                 faults_magnetron_status_reg = 0;  
0038C2  EB0200     CLR W4
0038C4  88C304     MOV W4, faults_magnetron_status_reg
182:                 faults_high_voltage_status_reg = 0;
0038C6  EB0200     CLR W4
0038C8  88C334     MOV W4, faults_high_voltage_status_reg
183:                 faults_thyratron_status_reg = 0;
0038CA  EB0200     CLR W4
0038CC  88C364     MOV W4, faults_thyratron_status_reg
184:                 faults_control_board_status_reg = 0;
0038CE  EB0200     CLR W4
0038D0  88C394     MOV W4, faults_control_board_status_reg
185:                 
186:                 
187:                 // Load the fault masks for the current state
188:                 LoadFaultMaskRegisters();
0038D2  07025F     RCALL LoadFaultMaskRegisters
189:                 
190:                 //------------------------- START MAGNETRON FAULTS ------------------------------//
191:                 
192:                 // Check External Magnetron Heater Over Voltage Latch
193:                 if (PIN_FILAMENT_OV_LATCH == ILL_FILAMENT_OV_FAULT) {
0038D4  8016A5     MOV PORTD, W5
0038D6  220004     MOV #0x2000, W4
0038D8  628204     AND W5, W4, W4
0038DA  520FE0     SUB W4, #0x0, [W15]
0038DC  3A0002     BRA NZ, 0x38E2
194:                   RecordThisMagnetronFault(FAULT_HW_MAGNETRON_FILAMENT_OV);
0038DE  200010     MOV #0x1, W0
0038E0  070305     RCALL RecordThisMagnetronFault
195:                 } 
196:                 
197:                 // Check that the magnetron heater voltage ADC reading has exceed fixed value set Config.h 
198:                 if (ps_filament.v_adc_reading > ps_filament.v_adc_over_abs) {
0038E2  805665     MOV 0xACC, W5
0038E4  8056A4     MOV 0xAD4, W4
0038E6  528F84     SUB W5, W4, [W15]
0038E8  360002     BRA LEU, 0x38EE
199:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OV_HARD_LIMIT);
0038EA  200020     MOV #0x2, W0
0038EC  0702FF     RCALL RecordThisMagnetronFault
200:                 }
201:                 
202:                 // Check that the magnetron heater voltage ADC reading is not greater than X% of its program point (set in Config.h)
203:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
204:                 if (CheckOverVoltFault(&ps_filament)) {
0038EE  20ABC0     MOV #0xABC, W0
0038F0  07038D     RCALL CheckOverVoltFault
0038F2  784200     MOV.B W0, W4
0038F4  524FE0     SUB.B W4, #0x0, [W15]
0038F6  320002     BRA Z, 0x38FC
205:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OV);
0038F8  200040     MOV #0x4, W0
0038FA  0702F8     RCALL RecordThisMagnetronFault
206:                 }
207:                 
208:                 // Check that the magnetron heater voltage ADC reading is not less than X% of its program point (set in Config.h)
209:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
210:                 if (CheckUnderVoltFault(&ps_filament)) {
0038FC  20ABC0     MOV #0xABC, W0
0038FE  0703AD     RCALL CheckUnderVoltFault
003900  784200     MOV.B W0, W4
003902  524FE0     SUB.B W4, #0x0, [W15]
003904  320002     BRA Z, 0x390A
211:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_UV);
003906  200080     MOV #0x8, W0
003908  0702F1     RCALL RecordThisMagnetronFault
212:                 }
213:                 
214:                 // Check that the magnetron heater current ADC reading is not greater than X% of its expected point (set in Config.h)
215:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
216:                 if (CheckOverCurrentFault(&ps_filament)) {
00390A  20ABC0     MOV #0xABC, W0
00390C  0703D4     RCALL CheckOverCurrentFault
00390E  784200     MOV.B W0, W4
003910  524FE0     SUB.B W4, #0x0, [W15]
003912  320002     BRA Z, 0x3918
217:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OC);
003914  200100     MOV #0x10, W0
003916  0702EA     RCALL RecordThisMagnetronFault
218:                 }
219:                 
220:                 
221:                 // Check that the magnetron heater current ADC reading is not less than X% of its expected point (set in Config.h)
222:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
223:                 if (CheckUnderCurrentFault(&ps_filament)) {
003918  20ABC0     MOV #0xABC, W0
00391A  0703F4     RCALL CheckUnderCurrentFault
00391C  784200     MOV.B W0, W4
00391E  524FE0     SUB.B W4, #0x0, [W15]
003920  320002     BRA Z, 0x3926
224:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_UC);
003922  200200     MOV #0x20, W0
003924  0702E3     RCALL RecordThisMagnetronFault
225:                 }
226:                 
227:                 
228:                 // Check External Magnetron Magnet Current Out of Range Latch
229:                 if (PIN_MAGNET_CURRENT_OOR_LATCH == ILL_MAGNET_CURRENT_OOR_FAULT) {
003926  8016A5     MOV PORTD, W5
003928  210004     MOV #0x1000, W4
00392A  628204     AND W5, W4, W4
00392C  520FE0     SUB W4, #0x0, [W15]
00392E  3A0002     BRA NZ, 0x3934
230:                   RecordThisMagnetronFault(FAULT_HW_MAGNETRON_MAGNET_COOR);
003930  201000     MOV #0x100, W0
003932  0702DC     RCALL RecordThisMagnetronFault
231:                 }
232:                 
233:                 // Check that the magnetron magnet current ADC reading has no exceeded fixed value set Config.h 
234:                 if (ps_magnet.i_adc_reading > ps_magnet.i_adc_over_abs) {
003934  8054F5     MOV 0xA9E, W5
003936  805534     MOV 0xAA6, W4
003938  528F84     SUB W5, W4, [W15]
00393A  360002     BRA LEU, 0x3940
235:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OC_HARD_LIMIT);
00393C  202000     MOV #0x200, W0
00393E  0702D6     RCALL RecordThisMagnetronFault
236:                 }
237:                 
238:                 // Check that the magnetron magnet current ADC reading is not greater than X% of its program point (set in Config.h)
239:                 if (CheckOverCurrentFault(&ps_magnet)) {
003940  20A620     MOV #0xA62, W0
003942  0703B9     RCALL CheckOverCurrentFault
003944  784200     MOV.B W0, W4
003946  524FE0     SUB.B W4, #0x0, [W15]
003948  320002     BRA Z, 0x394E
240:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OC);
00394A  204000     MOV #0x400, W0
00394C  0702CF     RCALL RecordThisMagnetronFault
241:                 }
242:                 
243:                 // Check that the magnetron magnet current ADC reading is not less than X% of its program point (set in Config.h)
244:                 if (CheckUnderCurrentFault(&ps_magnet)) {
00394E  20A620     MOV #0xA62, W0
003950  0703D9     RCALL CheckUnderCurrentFault
003952  784200     MOV.B W0, W4
003954  524FE0     SUB.B W4, #0x0, [W15]
003956  320002     BRA Z, 0x395C
245:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_UC);
003958  208000     MOV #0x800, W0
00395A  0702C8     RCALL RecordThisMagnetronFault
246:                 }
247:                 
248:                 // Check that the magnetron magnet voltage ADC reading is not greater than X% of its expected value (set in Config.h)
249:                 if (CheckOverVoltFault(&ps_magnet)) {
00395C  20A620     MOV #0xA62, W0
00395E  070356     RCALL CheckOverVoltFault
003960  784200     MOV.B W0, W4
003962  524FE0     SUB.B W4, #0x0, [W15]
003964  320002     BRA Z, 0x396A
250:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OV);
003966  210000     MOV #0x1000, W0
003968  0702C1     RCALL RecordThisMagnetronFault
251:                 }
252:                 
253:                 // Check that the magnetron magnet voltage ADC reading is not less than X% of its expected value (set in Config.h)
254:                 if (CheckUnderVoltFault(&ps_magnet)) {
00396A  20A620     MOV #0xA62, W0
00396C  070376     RCALL CheckUnderVoltFault
00396E  784200     MOV.B W0, W4
003970  524FE0     SUB.B W4, #0x0, [W15]
003972  320002     BRA Z, 0x3978
255:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_UV);
003974  220000     MOV #0x2000, W0
003976  0702BA     RCALL RecordThisMagnetronFault
256:                 }
257:                 
258:                 
259:                 //------------------------- START HIGH VOLTAGE FAULTS ------------------------------//
260:                 
261:                 // THE ARC FAULTS ARE CURRENTLY SET IN UpdatePulseData()
262:                 // UpdatesPulseData() is called after every pulse.
263:                 
264:                 // Check the digital fault outputs from from HV LAMBDA -
265:                 // The sum fault line must be set for HV_LAMBDA_SUM_FAULT_COUNTER_TRIP_POINT consective readings before a trip will occur
266:                 
267:                 
268:                 
269:                 if (PIN_HV_LAMBDA_SUM_FAULT == ILL_HV_LAMBDA_SUM_FAULT_FAULTED) {
003978  801675     MOV PORTC, W5
00397A  240004     MOV #0x4000, W4
00397C  628204     AND W5, W4, W4
00397E  520FE0     SUB W4, #0x0, [W15]
003980  3A0035     BRA NZ, 0x39EC
270:                   // Record the sum fault and check the other fault lines
271:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_SUM_FAULT);
003982  201000     MOV #0x100, W0
003984  0702CF     RCALL RecordThisHighVoltageFault
272:                   
273:                   temp_u16int = MCP23017ReadSingleByte(&U64_MCP23017, MCP23017_REGISTER_GPIOA);
003986  B3C121     MOV #0x12, W1
003988  208EE0     MOV #0x8EE, W0
00398A  07091F     RCALL MCP23017ReadSingleByte
00398C  780200     MOV W0, W4
00398E  780F04     MOV W4, [W14]
274:                   if (temp_u16int >= 0xFA00) {
003990  2F9FF4     MOV #0xF9FF, W4
003992  78029E     MOV [W14], W5
003994  528F84     SUB W5, W4, [W15]
003996  360004     BRA LEU, 0x39A0
275:                     global_debug_counter.i2c_bus_error++;
003998  80C264     MOV 0x184C, W4
00399A  E80204     INC W4, W4
00399C  88C264     MOV W4, 0x184C
00399E  370026     BRA 0x39EC
276:                   } else {
277:                     U64_MCP23017.input_port_a_in_ram = temp_u16int & 0xFF;
0039A0  78021E     MOV [W14], W4
0039A2  784204     MOV.B W4, W4
0039A4  784004     MOV.B W4, W0
0039A6  B7E8F8     MOV.B WREG, 0x8F8
278:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_OVER_TEMP) {
0039A8  208F84     MOV #0x8F8, W4
0039AA  784214     MOV.B [W4], W4
0039AC  FB8284     ZE W4, W5
0039AE  200404     MOV #0x40, W4
0039B0  628204     AND W5, W4, W4
0039B2  520FE0     SUB W4, #0x0, [W15]
0039B4  320002     BRA Z, 0x39BA
279:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_OVER_TEMP);
0039B6  210000     MOV #0x1000, W0
0039B8  0702B5     RCALL RecordThisHighVoltageFault
280:                     }
281:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_INTERLOCK_FAULT) {
0039BA  208F84     MOV #0x8F8, W4
0039BC  784214     MOV.B [W4], W4
0039BE  FB8284     ZE W4, W5
0039C0  200204     MOV #0x20, W4
0039C2  628204     AND W5, W4, W4
0039C4  520FE0     SUB W4, #0x0, [W15]
0039C6  320002     BRA Z, 0x39CC
282:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_INTERLOCK_FAULT);
0039C8  220000     MOV #0x2000, W0
0039CA  0702AC     RCALL RecordThisHighVoltageFault
283:                     }
284:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_LOAD_FLT) {
0039CC  208F84     MOV #0x8F8, W4
0039CE  784214     MOV.B [W4], W4
0039D0  FB8204     ZE W4, W4
0039D2  620270     AND W4, #0x10, W4
0039D4  520FE0     SUB W4, #0x0, [W15]
0039D6  320002     BRA Z, 0x39DC
285:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_LOAD_FAULT);
0039D8  240000     MOV #0x4000, W0
0039DA  0702A4     RCALL RecordThisHighVoltageFault
286:                     }
287:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_PHASE_LOSS) {
0039DC  208F84     MOV #0x8F8, W4
0039DE  784214     MOV.B [W4], W4
0039E0  FB8204     ZE W4, W4
0039E2  620268     AND W4, #0x8, W4
0039E4  520FE0     SUB W4, #0x0, [W15]
0039E6  320002     BRA Z, 0x39EC
288:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_PHASE_LOSS);
0039E8  280000     MOV #0x8000, W0
0039EA  07029C     RCALL RecordThisHighVoltageFault
289:                     }
290:                   }
291:                 }
292:                 
293:                 /*
294:                   FAULT_LAMBDA_EOC_TIMEOUT is checked/set by the TMR1 Interrupt
295:                 */
296:               
297:               
298:                 // DPARKER these vpeak readings . . . do we need them?  do they serve any purpose????
299:                 /*
300:               
301:                 // Check that the lambda vpeak ADC reading is not greater than X% of its set point (set in Config.h)
302:                 // It must remain outside this range for at least HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT before a fault is generated
303:                 if (hv_lambda_vpeak_adc_reading > hv_lambda_vpeak_adc_over_trip_point) {
304:                   hv_lambda_vpeak_over_voltage_count++;
305:                 } else if (hv_lambda_vpeak_over_voltage_count >= 1) {
306:                   hv_lambda_vpeak_over_voltage_count--;
307:                 }
308:                 if (hv_lambda_vpeak_over_voltage_count > HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT) {
309:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_VPEAK_OVER_VOLTAGE);
310:                 }
311:               
312:                 // Check that the lambda vpeak ADC reading is not less than X% of its set point (set in Config.h)
313:                 // It must remain outside this range for at least HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT before a fault is generated
314:                 if (hv_lambda_vpeak_adc_reading < hv_lambda_vpeak_adc_under_trip_point) {
315:                   hv_lambda_vpeak_under_voltage_count++;
316:                 } else if (hv_lambda_vpeak_under_voltage_count >= 1) {
317:                   hv_lambda_vpeak_under_voltage_count--;
318:                 }
319:                 if (hv_lambda_vpeak_under_voltage_count > HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT) {
320:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_VPEAK_UNDER_VOLTAGE);
321:                 }
322:                 */
323:                 
324:                 //------------------------- START THYRATRON FAULTS ------------------------------//
325:                
326:                 // Check that the thyratron cathode heater voltage ADC reading has exceed fixed value set Config.h 
327:                 if (ps_thyr_cathode_htr.v_adc_reading > ps_thyr_cathode_htr.v_adc_over_abs) {
0039EC  805935     MOV 0xB26, W5
0039EE  805974     MOV 0xB2E, W4
0039F0  528F84     SUB W5, W4, [W15]
0039F2  360002     BRA LEU, 0x39F8
328:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_OV_HARD_LIMIT);
0039F4  200010     MOV #0x1, W0
0039F6  0702B2     RCALL RecordThisThyratronFault
329:                 }
330:                   
331:                 // Check that the thyratron heater voltage ADC reading is not greater than X% of its program point (set in Config.h)
332:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated  
333:                 if (CheckOverVoltFault(&ps_thyr_cathode_htr)) {
0039F8  20B160     MOV #0xB16, W0
0039FA  070308     RCALL CheckOverVoltFault
0039FC  784200     MOV.B W0, W4
0039FE  524FE0     SUB.B W4, #0x0, [W15]
003A00  320002     BRA Z, 0x3A06
334:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_OV);
003A02  200020     MOV #0x2, W0
003A04  0702AB     RCALL RecordThisThyratronFault
335:                 }
336:               
337:                 // Check that the thyratron heater voltage ADC reading is not less than X% of its program point (set in Config.h)
338:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated
339:                 if (CheckUnderVoltFault(&ps_thyr_cathode_htr)) {
003A06  20B160     MOV #0xB16, W0
003A08  070328     RCALL CheckUnderVoltFault
003A0A  784200     MOV.B W0, W4
003A0C  524FE0     SUB.B W4, #0x0, [W15]
003A0E  320002     BRA Z, 0x3A14
340:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_UV);
003A10  200040     MOV #0x4, W0
003A12  0702A4     RCALL RecordThisThyratronFault
341:                 }
342:                   
343:                 // Check if the 4-20ma Driver has reported a fault
344:                 if (PIN_4_20_DRVR_FLT == ILL_4_20_DRIVER_FAULT) {
003A14  801615     MOV PORTA, W5
003A16  204004     MOV #0x400, W4
003A18  628204     AND W5, W4, W4
003A1A  520FE0     SUB W4, #0x0, [W15]
003A1C  3A0002     BRA NZ, 0x3A22
345:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_DRVR_FLT);
003A1E  200080     MOV #0x8, W0
003A20  07029D     RCALL RecordThisThyratronFault
346:                 }
347:               
348:                 // Check to see if the control loop has saturated.
349:                 // If it has that means that the SCR controller is no longer responding and it should be shut down
350:                 temp_u16int = thyratron_cathode_heater_PID.controlOutput;
003A22  8042C4     MOV 0x858, W4
003A24  780F04     MOV W4, [W14]
351:                 if (temp_u16int & 0x8000) {
003A26  78021E     MOV [W14], W4
003A28  520FE0     SUB W4, #0x0, [W15]
003A2A  3D0002     BRA GE, 0x3A30
352:                   temp_u16int = 0x0000;
003A2C  EB0200     CLR W4
003A2E  780F04     MOV W4, [W14]
353:                 }
354:                 temp_u16int = temp_u16int << 1;
003A30  78021E     MOV [W14], W4
003A32  420204     ADD W4, W4, W4
003A34  780F04     MOV W4, [W14]
355:                 if (temp_u16int >= THYRATRON_DAC_SATURATED) {
003A36  27CFF4     MOV #0x7CFF, W4
003A38  78029E     MOV [W14], W5
003A3A  528F84     SUB W5, W4, [W15]
003A3C  360002     BRA LEU, 0x3A42
356:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_CONTROL_SAT);
003A3E  200100     MOV #0x10, W0
003A40  07028D     RCALL RecordThisThyratronFault
357:                 }
358:                 
359:               
360:               
361:                 // Check if the thyratron reservoir ADC reading has exceed fixed value set Config.h 
362:                 if (ps_thyr_reservoir_htr.v_adc_reading > ps_thyr_reservoir_htr.v_adc_over_abs) {
003A42  805C05     MOV 0xB80, W5
003A44  805C44     MOV 0xB88, W4
003A46  528F84     SUB W5, W4, [W15]
003A48  360002     BRA LEU, 0x3A4E
363:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_OV_HARD_LIMIT);
003A4A  200200     MOV #0x20, W0
003A4C  070287     RCALL RecordThisThyratronFault
364:                 }
365:               
366:               
367:                 // Check that the thyratron reservoir voltage ADC reading is not greater than X% of its program point (set in Config.h)
368:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated  
369:                 if (CheckOverVoltFault(&ps_thyr_reservoir_htr)) {
003A4E  20B700     MOV #0xB70, W0
003A50  0702DD     RCALL CheckOverVoltFault
003A52  784200     MOV.B W0, W4
003A54  524FE0     SUB.B W4, #0x0, [W15]
003A56  320002     BRA Z, 0x3A5C
370:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_OV);
003A58  200400     MOV #0x40, W0
003A5A  070280     RCALL RecordThisThyratronFault
371:                 }
372:               
373:                 // Check that the thyratron reservoir voltage ADC reading is not less than X% of its program point (set in Config.h)
374:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated
375:                 if (CheckUnderVoltFault(&ps_thyr_reservoir_htr)) {
003A5C  20B700     MOV #0xB70, W0
003A5E  0702FD     RCALL CheckUnderVoltFault
003A60  784200     MOV.B W0, W4
003A62  524FE0     SUB.B W4, #0x0, [W15]
003A64  320002     BRA Z, 0x3A6A
376:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_UV);
003A66  200800     MOV #0x80, W0
003A68  070279     RCALL RecordThisThyratronFault
377:                 }
378:               
379:                 // Check if the 4-20ma Driver has reported a fault
380:                 if (PIN_4_20_DRVR_FLT == ILL_4_20_DRIVER_FAULT) {
003A6A  801615     MOV PORTA, W5
003A6C  204004     MOV #0x400, W4
003A6E  628204     AND W5, W4, W4
003A70  520FE0     SUB W4, #0x0, [W15]
003A72  3A0002     BRA NZ, 0x3A78
381:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_DRVR_FLT);
003A74  201000     MOV #0x100, W0
003A76  070272     RCALL RecordThisThyratronFault
382:                 }
383:                 
384:                 // Check to see if the control loop has saturated.
385:                 // If it has that means that the SCR controller is no longer responding and it should be shut down
386:                 temp_u16int = thyratron_reservoir_heater_PID.controlOutput;
003A78  804274     MOV 0x84E, W4
003A7A  780F04     MOV W4, [W14]
387:                 if (temp_u16int & 0x8000) {
003A7C  78021E     MOV [W14], W4
003A7E  520FE0     SUB W4, #0x0, [W15]
003A80  3D0002     BRA GE, 0x3A86
388:                   temp_u16int = 0x0000;
003A82  EB0200     CLR W4
003A84  780F04     MOV W4, [W14]
389:                 }
390:                 temp_u16int = temp_u16int << 1;
003A86  78021E     MOV [W14], W4
003A88  420204     ADD W4, W4, W4
003A8A  780F04     MOV W4, [W14]
391:                 if (temp_u16int >= THYRATRON_DAC_SATURATED) {
003A8C  27CFF4     MOV #0x7CFF, W4
003A8E  78029E     MOV [W14], W5
003A90  528F84     SUB W5, W4, [W15]
003A92  360002     BRA LEU, 0x3A98
392:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_CONTROL_SAT);
003A94  202000     MOV #0x200, W0
003A96  070262     RCALL RecordThisThyratronFault
393:                 }
394:               
395:               
396:                 //------------------------- START CONTROL BOARD FAULTS ------------------------------//
397:               
398:               
399:                 // Check that the lambda supply powered up
400:                 if (PIN_HV_LAMBDA_POWER_UP == ILL_PIN_HV_LAMBDA_DID_NOT_POWER_UP) {
003A98  8016A4     MOV PORTD, W4
003A9A  620262     AND W4, #0x2, W4
003A9C  520FE0     SUB W4, #0x0, [W15]
003A9E  320002     BRA Z, 0x3AA4
401:                   RecordThisControlBoardFault(FAULT_LAMBDA_OFF);
003AA0  200010     MOV #0x1, W0
003AA2  070278     RCALL RecordThisControlBoardFault
402:                 }
403:                 
404:                 // Check to see if digital interlock 1 is open  
405:                 if (PIN_INTERLOCK_1 == ILL_INTERLOCK_OPEN) {
003AA4  801674     MOV PORTC, W4
003AA6  620268     AND W4, #0x8, W4
003AA8  520FE0     SUB W4, #0x0, [W15]
003AAA  320002     BRA Z, 0x3AB0
406:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_1);
003AAC  200020     MOV #0x2, W0
003AAE  070272     RCALL RecordThisControlBoardFault
407:                 }
408:                 
409:                 // Check to see if digital interlock 2 is open  
410:                 if (PIN_INTERLOCK_2 == ILL_INTERLOCK_OPEN) {
003AB0  801674     MOV PORTC, W4
003AB2  620270     AND W4, #0x10, W4
003AB4  520FE0     SUB W4, #0x0, [W15]
003AB6  320002     BRA Z, 0x3ABC
411:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_2);
003AB8  200040     MOV #0x4, W0
003ABA  07026C     RCALL RecordThisControlBoardFault
412:                 }
413:                 
414:                 // Check to see if digital interlock 3 is open  
415:                 if (PIN_INTERLOCK_3 == ILL_INTERLOCK_OPEN) {
003ABC  801735     MOV PORTG, W5
003ABE  201004     MOV #0x100, W4
003AC0  628204     AND W5, W4, W4
003AC2  520FE0     SUB W4, #0x0, [W15]
003AC4  320002     BRA Z, 0x3ACA
416:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_3);
003AC6  200080     MOV #0x8, W0
003AC8  070265     RCALL RecordThisControlBoardFault
417:                 }
418:                 
419:                 // Check to see if digital interlock 4 is open  
420:                 if (PIN_INTERLOCK_4 == ILL_INTERLOCK_OPEN) {
003ACA  801735     MOV PORTG, W5
003ACC  202004     MOV #0x200, W4
003ACE  628204     AND W5, W4, W4
003AD0  520FE0     SUB W4, #0x0, [W15]
003AD2  320002     BRA Z, 0x3AD8
421:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_4);
003AD4  200100     MOV #0x10, W0
003AD6  07025E     RCALL RecordThisControlBoardFault
422:                 }
423:                 
424:               }
003AD8  FA8000     ULNK
003ADA  060000     RETURN
425:               
426:               void ResetPulseLatches(void) {
003ADC  FA0000     LNK #0x0
427:                 PIN_PULSE_LATCH_RESET = OLL_PULSE_LATCH_RESET;
003ADE  A922E8     BCLR LATG, #1
428:                 __delay32(DELAY_PULSE_LATCH_RESET);
003AE0  20BB80     MOV #0xBB8, W0
003AE2  200001     MOV #0x0, W1
003AE4  07092C     RCALL ___delay32
429:                 PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
003AE6  A822E8     BSET LATG, #1
430:               }
003AE8  FA8000     ULNK
003AEA  060000     RETURN
431:               
432:               
433:               void ResetHWLatches(void) {
003AEC  FA0000     LNK #0x0
434:                 // Reset the latches
435:                 PIN_LATCH_RESET = OLL_RESET_LATCH;
003AEE  A962D6     BCLR LATD, #3
436:                 __delay32(DELAY_LATCH_RESET);
003AF0  2003C0     MOV #0x3C, W0
003AF2  200001     MOV #0x0, W1
003AF4  070924     RCALL ___delay32
437:                 PIN_LATCH_RESET = !OLL_RESET_LATCH;
003AF6  A862D6     BSET LATD, #3
438:               }
003AF8  FA8000     ULNK
003AFA  060000     RETURN
439:               
440:               void ResetAllFaults(void) {
003AFC  FA0000     LNK #0x0
441:                 ResetHWLatches();
003AFE  07FFF6     RCALL ResetHWLatches
442:               
443:                 // Clear all fault registers
444:               
445:                 // MAGNETRON CONTROL FAULT REGISTERS
446:                 faults_magnetron_fault_reg       = 0;
003B00  EB0200     CLR W4
003B02  88C314     MOV W4, faults_magnetron_fault_reg
447:                 faults_magnetron_warning_reg     = 0;
003B04  EB0200     CLR W4
003B06  88C324     MOV W4, faults_magnetron_warning_reg
448:                 
449:                 // HIGH VOLTAGE FAULT REGISTERS
450:                 faults_high_voltage_fault_reg    = 0;
003B08  EB0200     CLR W4
003B0A  88C344     MOV W4, faults_high_voltage_fault_reg
451:                 faults_high_voltage_warning_reg  = 0;
003B0C  EB0200     CLR W4
003B0E  88C354     MOV W4, faults_high_voltage_warning_reg
452:                 
453:                 // THYRATRON HEATER FAULT REGISTERS
454:                 faults_thyratron_fault_reg       = 0;
003B10  EB0200     CLR W4
003B12  88C374     MOV W4, faults_thyratron_fault_reg
455:                 faults_thyratron_warning_reg     = 0;
003B14  EB0200     CLR W4
003B16  88C384     MOV W4, faults_thyratron_warning_reg
456:                   
457:                 // CONTROL BOARD FAULT REGISTERS
458:                 faults_control_board_fault_reg   = 0;
003B18  EB0200     CLR W4
003B1A  88C3A4     MOV W4, faults_control_board_fault_reg
459:                 faults_control_board_warning_reg = 0;
003B1C  EB0200     CLR W4
003B1E  88C3B4     MOV W4, faults_control_board_warning_reg
460:               }
003B20  FA8000     ULNK
003B22  060000     RETURN
461:               
462:               
463:               void UpdatePulseData(unsigned char mode) {
003B24  FA0004     LNK #0x4
003B26  984720     MOV.B W0, [W14+2]
464:                 unsigned int pulse_energy_milli_joules;
465:               
466:                 /*
467:                   FAULT_PFN_TRIGGER_PERIOD_TOO_SHORT is evaluated by the TMR1 Interrupt
468:                 */
469:                 
470:                 /* 
471:                    First Perform Data itegrity checks on the data from the AD converter
472:                    
473:                    Arc detection is the responsibility of the HW circuits.
474:               
475:                    In the event of an ARC the current readback IS NOT INCLUDED in the filtered Values.
476:               
477:                    If there was NOT AN ARC, further checking is done on the current readback to insure it is valid.
478:                    
479:                    If the current is inside a specified value (ADC_PULSE_CURRENT_UNDER_GLITCH -> ADC_PULSE_CURRENT_OVER_GLITCH) it is included in filtering math.
480:                    If not the value is ignored from a filtering point of view
481:               
482:                    Sowftware over/under current/voltage detection.
483:                       
484:                 */
485:               
486:                 /*
487:                   Tracking  Arcs
488:               
489:               
490:                   Hardware Arc is defined as 
491:                        (1) setting Overcurrent Latch 
492:                     OR (2) failing to set Undercurrent Latch
493:               
494:               
495:                   Software Glitch is defined as 
496:                        (1) Not setting the ( Hardware ARC OR Software ARC)
497:                    AND (2) Reading outside the Hardware range limits
498:               
499:                   There is an Arc Counter that increments with every Hardware Arc (this is stored in EEPROM) (32 bit)
500:                   There is an Arc Counter in RAM that counts number of Hardware arc since the last HV_ON Command (32 bit)
501:               
502:               
503:                   If (overcurrent latch is set) OR (undercurrent latch is not set)
504:                      Then Hardware Arc
505:                   Else if (ADC reading > overcurrent set point) OR (ADC reading < undercurrent set point)
506:                      Then Software Glitch
507:                   Else 
508:                      The Pulse was good, record the pulse info into the A or B register
509:               
510:               
511:                   Hardware Arcs can generate faults in the following ways.
512:                   1) Too many consecutive arcs.
513:                   2) Too many arcs per 300 pulses (per second 300 Hz)
514:                   3) Too many arcs per 18000 pulses (per minute at 300 Hz)
515:                   
516:                 */
517:                 
518:                 if (arc_detected == 1) {
003B28  804064     MOV arc_detected, W4
003B2A  520FE1     SUB W4, #0x1, [W15]
003B2C  3A0015     BRA NZ, 0x3B58
519:                   // The high voltage tank current was too high (indicating an arc) or was too low (indicating a short in the modulator)
520:                   // Record and arc and throw away the data from the ADC
521:                   arc_detected = 0;
003B2E  EB0200     CLR W4
003B30  884064     MOV W4, arc_detected
522:                   arc_counter_persistent++;
003B32  80C564     MOV arc_counter_persistent, W4
003B34  80C575     MOV 0x18AE, W5
003B36  420261     ADD W4, #0x1, W4
003B38  4A82E0     ADDC W5, #0x0, W5
003B3A  88C564     MOV W4, arc_counter_persistent
003B3C  88C575     MOV W5, 0x18AE
523:                   arc_counter_this_hv_on++;
003B3E  80C5D4     MOV arc_counter_this_hv_on, W4
003B40  E80204     INC W4, W4
003B42  88C5D4     MOV W4, arc_counter_this_hv_on
524:                   
525:                   arc_counter_consecutive++;
003B44  8041D4     MOV arc_counter_consecutive, W4
003B46  E80204     INC W4, W4
003B48  8841D4     MOV W4, arc_counter_consecutive
526:                   arc_counter_fast++;
003B4A  8041E4     MOV arc_counter_fast, W4
003B4C  E80204     INC W4, W4
003B4E  8841E4     MOV W4, arc_counter_fast
527:                   arc_counter_slow++;
003B50  8041F4     MOV arc_counter_slow, W4
003B52  E80204     INC W4, W4
003B54  8841F4     MOV W4, arc_counter_slow
003B56  37001A     BRA 0x3B8C
528:                 } else {
529:                   // Hardware did not detect an arc.  Software appears to have read a valid pulse.  Update all data
530:                   
531:                   arc_counter_consecutive = 0;
003B58  EB0200     CLR W4
003B5A  8841D4     MOV W4, arc_counter_consecutive
532:                   
533:                   if (mode == PULSE_MODE_A) {
003B5C  90422E     MOV.B [W14+2], W4
003B5E  524FE0     SUB.B W4, #0x0, [W15]
003B60  3A0008     BRA NZ, 0x3B72
534:                     StorePulseData(&ps_magnetron_mode_A);
003B62  209540     MOV #0x954, W0
003B64  070090     RCALL StorePulseData
535:                     pulse_energy_milli_joules = CalculatePulseEnergyMilliJoules(ps_hv_lambda_mode_A.v_command_set_point);
003B66  8047E4     MOV 0x8FC, W4
003B68  780004     MOV W4, W0
003B6A  0700C3     RCALL CalculatePulseEnergyMilliJoules
003B6C  780200     MOV W0, W4
003B6E  780F04     MOV W4, [W14]
003B70  370007     BRA 0x3B80
536:                   } else {
537:                     StorePulseData(&ps_magnetron_mode_B);
003B72  20A080     MOV #0xA08, W0
003B74  070088     RCALL StorePulseData
538:                     pulse_energy_milli_joules = CalculatePulseEnergyMilliJoules(ps_hv_lambda_mode_B.v_command_set_point);
003B76  804D84     MOV 0x9B0, W4
003B78  780004     MOV W4, W0
003B7A  0700BB     RCALL CalculatePulseEnergyMilliJoules
003B7C  780200     MOV W0, W4
003B7E  780F04     MOV W4, [W14]
539:                   }
540:                   average_energy_per_pulse_milli_joules = RCFilter64Tau(average_energy_per_pulse_milli_joules, pulse_energy_milli_joules);
003B80  804154     MOV average_energy_per_pulse_milli_joules, W4
003B82  78009E     MOV [W14], W1
003B84  780004     MOV W4, W0
003B86  07F409     RCALL RCFilter64Tau
003B88  780200     MOV W0, W4
003B8A  884154     MOV W4, average_energy_per_pulse_milli_joules
541:                 }   
542:                 
543:                 
544:                 if ((pulse_magnetron_current_adc_reading > ADC_PULSE_CURRENT_OVER_GLITCH) || (pulse_magnetron_current_adc_reading < ADC_PULSE_CURRENT_UNDER_GLITCH)) {
003B8C  804235     MOV pulse_magnetron_current_adc_reading, W5
003B8E  2FA004     MOV #0xFA00, W4
003B90  528F84     SUB W5, W4, [W15]
003B92  3E0004     BRA GTU, 0x3B9C
003B94  804235     MOV pulse_magnetron_current_adc_reading, W5
003B96  22FFF4     MOV #0x2FFF, W4
003B98  528F84     SUB W5, W4, [W15]
003B9A  3E0003     BRA GTU, 0x3BA2
545:                   // The current readback was outside of the "GLITCH" limits.  Assume it was an error with the ADC and record an ADC error
546:                   global_debug_counter.magnetron_current_adc_glitch++;
003B9C  80C244     MOV global_debug_counter, W4
003B9E  E80204     INC W4, W4
003BA0  88C244     MOV W4, global_debug_counter
547:                 }
548:               
549:                 if ((pulse_magnetron_voltage_adc_reading > ADC_PULSE_VOLTAGE_OVER_GLITCH) || (pulse_magnetron_voltage_adc_reading < ADC_PULSE_VOLTAGE_UNDER_GLITCH)) {
003BA2  804245     MOV pulse_magnetron_voltage_adc_reading, W5
003BA4  2F0004     MOV #0xF000, W4
003BA6  528F84     SUB W5, W4, [W15]
003BA8  3E0004     BRA GTU, 0x3BB2
003BAA  804245     MOV pulse_magnetron_voltage_adc_reading, W5
003BAC  207FF4     MOV #0x7FF, W4
003BAE  528F84     SUB W5, W4, [W15]
003BB0  3E0003     BRA GTU, 0x3BB8
550:                   global_debug_counter.magnetron_voltage_adc_glitch++;
003BB2  80C254     MOV 0x184A, W4
003BB4  E80204     INC W4, W4
003BB6  88C254     MOV W4, 0x184A
551:                 }
552:                 
553:                 //ResetPulseLatches();  // This must be called to clear the over/under current latches.  //DPARKER the pulse latches are now reset in the pulse interrupt
554:                 
555:                 // Decrement the arc_counter_fast if we need to
556:                 pulse_counter_fast++;
003BB8  804204     MOV pulse_counter_fast, W4
003BBA  E80204     INC W4, W4
003BBC  884204     MOV W4, pulse_counter_fast
557:                 if (pulse_counter_fast > ARC_COUNTER_FAST_DECREMENT_INTERVAL) {
003BBE  804204     MOV pulse_counter_fast, W4
003BC0  520FF0     SUB W4, #0x10, [W15]
003BC2  360008     BRA LEU, 0x3BD4
558:                   pulse_counter_fast = 0;
003BC4  EB0200     CLR W4
003BC6  884204     MOV W4, pulse_counter_fast
559:                   if (arc_counter_fast) {
003BC8  8041E4     MOV arc_counter_fast, W4
003BCA  520FE0     SUB W4, #0x0, [W15]
003BCC  320003     BRA Z, 0x3BD4
560:                     arc_counter_fast--;
003BCE  8041E4     MOV arc_counter_fast, W4
003BD0  E90204     DEC W4, W4
003BD2  8841E4     MOV W4, arc_counter_fast
561:                   }
562:                 }
563:                 
564:                 // decrement the arc_counter_slow if we need to
565:                 pulse_counter_slow++;
003BD4  804214     MOV pulse_counter_slow, W4
003BD6  E80204     INC W4, W4
003BD8  884214     MOV W4, pulse_counter_slow
566:                 if (pulse_counter_slow > ARC_COUNTER_SLOW_DECREMENT_INTERVAL) {
003BDA  804215     MOV pulse_counter_slow, W5
003BDC  200F04     MOV #0xF0, W4
003BDE  528F84     SUB W5, W4, [W15]
003BE0  360008     BRA LEU, 0x3BF2
567:                   pulse_counter_slow = 0;
003BE2  EB0200     CLR W4
003BE4  884214     MOV W4, pulse_counter_slow
568:                   if (arc_counter_slow) {
003BE6  8041F4     MOV arc_counter_slow, W4
003BE8  520FE0     SUB W4, #0x0, [W15]
003BEA  320003     BRA Z, 0x3BF2
569:                     arc_counter_slow--;
003BEC  8041F4     MOV arc_counter_slow, W4
003BEE  E90204     DEC W4, W4
003BF0  8841F4     MOV W4, arc_counter_slow
570:                   }
571:                 }
572:                 
573:               
574:                 // CHECK FOR PULSE FAULTS - Too many arcs, voltage/current out of range
575:                 
576:                 // Check for too many consecutive arcs
577:                 if (arc_counter_consecutive > ARC_COUNTER_MAX_CONSECUTIVE) {
003BF2  8041D4     MOV arc_counter_consecutive, W4
003BF4  520FE5     SUB W4, #0x5, [W15]
003BF6  360002     BRA LEU, 0x3BFC
578:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_CONSECUTIVE);
003BF8  200010     MOV #0x1, W0
003BFA  070194     RCALL RecordThisHighVoltageFault
579:                 }
580:                 
581:                 // Check for too many arcs in a short amount of time
582:                 if (arc_counter_fast > ARC_COUNTER_FAST_MAX_ARCS) {
003BFC  8041E4     MOV arc_counter_fast, W4
003BFE  520FF9     SUB W4, #0x19, [W15]
003C00  360002     BRA LEU, 0x3C06
583:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_FAST);
003C02  200020     MOV #0x2, W0
003C04  07018F     RCALL RecordThisHighVoltageFault
584:                 }
585:                 
586:                 // Check for too many arc is a long amount of time
587:                 if (arc_counter_slow > ARC_COUNTER_SLOW_MAX_ARCS) {
003C06  8041F5     MOV arc_counter_slow, W5
003C08  200644     MOV #0x64, W4
003C0A  528F84     SUB W5, W4, [W15]
003C0C  360002     BRA LEU, 0x3C12
588:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_SLOW);
003C0E  200040     MOV #0x4, W0
003C10  070189     RCALL RecordThisHighVoltageFault
589:                 }
590:                 
591:               
592:                 // Check that the magnetron voltage ADC reading is not greater than X% of its program point (set in Config.h)
593:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
594:                 if (CheckOverVoltFault(&ps_magnetron_mode_A)) {
003C12  209540     MOV #0x954, W0
003C14  0701FB     RCALL CheckOverVoltFault
003C16  784200     MOV.B W0, W4
003C18  524FE0     SUB.B W4, #0x0, [W15]
003C1A  320002     BRA Z, 0x3C20
595:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_A);
003C1C  200400     MOV #0x40, W0
003C1E  070182     RCALL RecordThisHighVoltageFault
596:                 }
597:                 
598:                 // Check that the magnetron voltage ADC reading is not less than X% of its program point (set in Config.h)
599:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
600:                 if (CheckUnderVoltFault(&ps_magnetron_mode_A)) {
003C20  209540     MOV #0x954, W0
003C22  07021B     RCALL CheckUnderVoltFault
003C24  784200     MOV.B W0, W4
003C26  524FE0     SUB.B W4, #0x0, [W15]
003C28  320002     BRA Z, 0x3C2E
601:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_A);
003C2A  200400     MOV #0x40, W0
003C2C  07017B     RCALL RecordThisHighVoltageFault
602:                 }
603:               
604:                 // Check that the magnetron current ADC reading is not greater than X% of its program point (set in Config.h)
605:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
606:                 if (CheckOverCurrentFault(&ps_magnetron_mode_A)) {
003C2E  209540     MOV #0x954, W0
003C30  070242     RCALL CheckOverCurrentFault
003C32  784200     MOV.B W0, W4
003C34  524FE0     SUB.B W4, #0x0, [W15]
003C36  320002     BRA Z, 0x3C3C
607:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_A);
003C38  200100     MOV #0x10, W0
003C3A  070174     RCALL RecordThisHighVoltageFault
608:                 }
609:                 
610:                 // Check that the magnetron current ADC reading is not less than X% of its program point (set in Config.h)
611:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
612:                 if (CheckUnderCurrentFault(&ps_magnetron_mode_A)) {
003C3C  209540     MOV #0x954, W0
003C3E  070262     RCALL CheckUnderCurrentFault
003C40  784200     MOV.B W0, W4
003C42  524FE0     SUB.B W4, #0x0, [W15]
003C44  320002     BRA Z, 0x3C4A
613:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_A);
003C46  200100     MOV #0x10, W0
003C48  07016D     RCALL RecordThisHighVoltageFault
614:                 }
615:               
616:               
617:                 // Check that the magnetron voltage ADC reading is not greater than X% of its program point (set in Config.h)
618:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
619:                 if (CheckOverVoltFault(&ps_magnetron_mode_B)) {
003C4A  20A080     MOV #0xA08, W0
003C4C  0701DF     RCALL CheckOverVoltFault
003C4E  784200     MOV.B W0, W4
003C50  524FE0     SUB.B W4, #0x0, [W15]
003C52  320002     BRA Z, 0x3C58
620:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_B);
003C54  200800     MOV #0x80, W0
003C56  070166     RCALL RecordThisHighVoltageFault
621:                 }
622:                 
623:                 // Check that the magnetron voltage ADC reading is not less than X% of its program point (set in Config.h)
624:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
625:                 if (CheckUnderVoltFault(&ps_magnetron_mode_B)) {
003C58  20A080     MOV #0xA08, W0
003C5A  0701FF     RCALL CheckUnderVoltFault
003C5C  784200     MOV.B W0, W4
003C5E  524FE0     SUB.B W4, #0x0, [W15]
003C60  320002     BRA Z, 0x3C66
626:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_B);
003C62  200800     MOV #0x80, W0
003C64  07015F     RCALL RecordThisHighVoltageFault
627:                 }
628:                 
629:                 // Check that the magnetron current ADC reading is not greater than X% of its program point (set in Config.h)
630:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
631:                 if (CheckOverCurrentFault(&ps_magnetron_mode_B)) {
003C66  20A080     MOV #0xA08, W0
003C68  070226     RCALL CheckOverCurrentFault
003C6A  784200     MOV.B W0, W4
003C6C  524FE0     SUB.B W4, #0x0, [W15]
003C6E  320002     BRA Z, 0x3C74
632:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_B);
003C70  200200     MOV #0x20, W0
003C72  070158     RCALL RecordThisHighVoltageFault
633:                 }
634:                 
635:                 // Check that the magnetron current ADC reading is not less than X% of its program point (set in Config.h)
636:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
637:                 if (CheckUnderCurrentFault(&ps_magnetron_mode_B)) {
003C74  20A080     MOV #0xA08, W0
003C76  070246     RCALL CheckUnderCurrentFault
003C78  784200     MOV.B W0, W4
003C7A  524FE0     SUB.B W4, #0x0, [W15]
003C7C  320002     BRA Z, 0x3C82
638:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_B);
003C7E  200200     MOV #0x20, W0
003C80  070151     RCALL RecordThisHighVoltageFault
639:                 }
640:                 
641:               
642:                 // DPARKER NEED TO IMPLEMENT and TEST the PFN fault current input Logic
643:               }
003C82  FA8000     ULNK
003C84  060000     RETURN
644:               
645:               void StorePulseData(POWERSUPPLY* ptr) {
003C86  FA0002     LNK #0x2
003C88  780F00     MOV W0, [W14]
646:                 
647:                 ptr->i_adc_reading = RCFilter16Tau(ptr->i_adc_reading, pulse_magnetron_current_adc_reading);
003C8A  804235     MOV pulse_magnetron_current_adc_reading, W5
003C8C  78021E     MOV [W14], W4
003C8E  901A64     MOV [W4+60], W4
003C90  780085     MOV W5, W1
003C92  780004     MOV W4, W0
003C94  07F3BE     RCALL RCFilter16Tau
003C96  780200     MOV W0, W4
003C98  78029E     MOV [W14], W5
003C9A  981AE4     MOV W4, [W5+60]
648:                 ptr->v_adc_reading = RCFilter16Tau(ptr->v_adc_reading, pulse_magnetron_voltage_adc_reading);
003C9C  804245     MOV pulse_magnetron_voltage_adc_reading, W5
003C9E  78021E     MOV [W14], W4
003CA0  900A04     MOV [W4+16], W4
003CA2  780085     MOV W5, W1
003CA4  780004     MOV W4, W0
003CA6  07F3B5     RCALL RCFilter16Tau
003CA8  780200     MOV W0, W4
003CAA  78029E     MOV [W14], W5
003CAC  980A84     MOV W4, [W5+16]
649:                 
650:                 // record min/max current
651:                 if (pulse_magnetron_current_adc_reading > ptr->i_adc_max_reading) {
003CAE  78021E     MOV [W14], W4
003CB0  902AB4     MOV [W4+86], W5
003CB2  804234     MOV pulse_magnetron_current_adc_reading, W4
003CB4  528F84     SUB W5, W4, [W15]
003CB6  310003     BRA C, 0x3CBE
652:                   ptr->i_adc_max_reading = pulse_magnetron_current_adc_reading;
003CB8  804235     MOV pulse_magnetron_current_adc_reading, W5
003CBA  78021E     MOV [W14], W4
003CBC  982A35     MOV W5, [W4+86]
653:                 }
654:                 if (pulse_magnetron_current_adc_reading < ptr->i_adc_min_reading) {
003CBE  78021E     MOV [W14], W4
003CC0  902AC4     MOV [W4+88], W5
003CC2  804234     MOV pulse_magnetron_current_adc_reading, W4
003CC4  528F84     SUB W5, W4, [W15]
003CC6  360003     BRA LEU, 0x3CCE
655:                   ptr->i_adc_min_reading = pulse_magnetron_current_adc_reading;
003CC8  804235     MOV pulse_magnetron_current_adc_reading, W5
003CCA  78021E     MOV [W14], W4
003CCC  982A45     MOV W5, [W4+88]
656:                 }
657:               
658:                 // record min/max voltage
659:                 if (pulse_magnetron_voltage_adc_reading > ptr->v_adc_max_reading) {
003CCE  78021E     MOV [W14], W4
003CD0  9012D4     MOV [W4+42], W5
003CD2  804244     MOV pulse_magnetron_voltage_adc_reading, W4
003CD4  528F84     SUB W5, W4, [W15]
003CD6  310003     BRA C, 0x3CDE
660:                   ptr->v_adc_max_reading = pulse_magnetron_voltage_adc_reading;
003CD8  804245     MOV pulse_magnetron_voltage_adc_reading, W5
003CDA  78021E     MOV [W14], W4
003CDC  981255     MOV W5, [W4+42]
661:                 }
662:                 if (pulse_magnetron_voltage_adc_reading < ptr->v_adc_min_reading) {
003CDE  78021E     MOV [W14], W4
003CE0  9012E4     MOV [W4+44], W5
003CE2  804244     MOV pulse_magnetron_voltage_adc_reading, W4
003CE4  528F84     SUB W5, W4, [W15]
003CE6  360003     BRA LEU, 0x3CEE
663:                   ptr->v_adc_min_reading = pulse_magnetron_voltage_adc_reading;
003CE8  804245     MOV pulse_magnetron_voltage_adc_reading, W5
003CEA  78021E     MOV [W14], W4
003CEC  981265     MOV W5, [W4+44]
664:                 }
665:               
666:               }
003CEE  FA8000     ULNK
003CF0  060000     RETURN
667:               
668:               unsigned int CalculatePulseEnergyMilliJoules(unsigned int lambda_voltage) {
003CF2  FA0008     LNK #0x8
003CF4  980730     MOV W0, [W14+6]
669:                 unsigned long power_milli_joule;
670:                 unsigned int return_data;
671:               
672:                 /*
673:                   The Pulse Energy is Calculated for Each Pulse
674:                   The Pulse Energy is Filtered/Averaged with a 64 pulse/tau filter
675:                   The Average Pulse Energy is then multiplied by the PRF to generate the power.
676:                   The filament heater voltage is generated from the power.
677:               
678:                   Power = 1/2 * C * V^2
679:                   C = 90nF
680:                   In Floating Point Math
681:                   power(milli_joule) = .5 * 90e-9 * V^2 * 1000
682:               
683:                   power_milli_joule = .5 * 90e-9 * V^2 * 1000
684:                                     = v^2/22222.22
685:               		      = v*v / 2^6 / 347.22
686:               		      = v*v / 2^6 * 47 / 2^14 (.4% fixed point error)
687:               		      
688:                 */
689:               
690:                 power_milli_joule = lambda_voltage;
003CF6  90023E     MOV [W14+6], W4
003CF8  200005     MOV #0x0, W5
003CFA  BE8F04     MOV.D W4, [W14]
691:                 power_milli_joule *= lambda_voltage;
003CFC  90023E     MOV [W14+6], W4
003CFE  200005     MOV #0x0, W5
003D00  90031E     MOV [W14+2], W6
003D02  B9B304     MUL.SS W6, W4, W6
003D04  780306     MOV W6, W6
003D06  78039E     MOV [W14], W7
003D08  B9B805     MUL.SS W7, W5, W0
003D0A  780380     MOV W0, W7
003D0C  430307     ADD W6, W7, W6
003D0E  78039E     MOV [W14], W7
003D10  780204     MOV W4, W4
003D12  B82207     MUL.UU W4, W7, W4
003D14  430305     ADD W6, W5, W6
003D16  780286     MOV W6, W5
003D18  BE8F04     MOV.D W4, [W14]
003D1A  BE8F04     MOV.D W4, [W14]
692:                 power_milli_joule >>= 6;
003D1C  BE021E     MOV.D [W14], W4
003D1E  DD2B4A     SL W5, #10, W6
003D20  DE2246     LSR W4, #6, W4
003D22  730204     IOR W6, W4, W4
003D24  DE2AC6     LSR W5, #6, W5
003D26  BE8F04     MOV.D W4, [W14]
693:                 power_milli_joule *= 47;
003D28  90029E     MOV [W14+2], W5
003D2A  2002F4     MOV #0x2F, W4
003D2C  B9AA04     MUL.SS W5, W4, W4
003D2E  780304     MOV W4, W6
003D30  78021E     MOV [W14], W4
003D32  B92260     MUL.SU W4, #0, W4
003D34  780204     MOV W4, W4
003D36  430304     ADD W6, W4, W6
003D38  78029E     MOV [W14], W5
003D3A  2002F4     MOV #0x2F, W4
003D3C  B82A04     MUL.UU W5, W4, W4
003D3E  430305     ADD W6, W5, W6
003D40  780286     MOV W6, W5
003D42  BE8F04     MOV.D W4, [W14]
003D44  BE8F04     MOV.D W4, [W14]
694:                 power_milli_joule >>= 14;
003D46  BE021E     MOV.D [W14], W4
003D48  DD2B42     SL W5, #2, W6
003D4A  DE224E     LSR W4, #14, W4
003D4C  730204     IOR W6, W4, W4
003D4E  DE2ACE     LSR W5, #14, W5
003D50  BE8F04     MOV.D W4, [W14]
695:               
696:                 if (power_milli_joule >= 0xFFFF) {
003D52  2FFFE4     MOV #0xFFFE, W4
003D54  200005     MOV #0x0, W5
003D56  BE031E     MOV.D [W14], W6
003D58  530F84     SUB W6, W4, [W15]
003D5A  5B8F85     SUBB W7, W5, [W15]
003D5C  360003     BRA LEU, 0x3D64
697:                   power_milli_joule = 0xFFFF;
003D5E  2FFFF4     MOV #0xFFFF, W4
003D60  200005     MOV #0x0, W5
003D62  BE8F04     MOV.D W4, [W14]
698:                 }
699:                 power_milli_joule &= 0xFFFF;
003D64  2FFFF4     MOV #0xFFFF, W4
003D66  200005     MOV #0x0, W5
003D68  BE031E     MOV.D [W14], W6
003D6A  780006     MOV W6, W0
003D6C  780307     MOV W7, W6
003D6E  780384     MOV W4, W7
003D70  780205     MOV W5, W4
003D72  600007     AND W0, W7, W0
003D74  630204     AND W6, W4, W4
003D76  200005     MOV #0x0, W5
003D78  DD22C0     SL W4, #0, W5
003D7A  200004     MOV #0x0, W4
003D7C  BE0304     MOV.D W4, W6
003D7E  B80261     MUL.UU W0, #1, W4
003D80  730304     IOR W6, W4, W6
003D82  738385     IOR W7, W5, W7
003D84  BE8F06     MOV.D W6, [W14]
700:               
701:                 return_data = power_milli_joule;
003D86  78021E     MOV [W14], W4
003D88  980724     MOV W4, [W14+4]
702:               
703:                 return return_data;
003D8A  90022E     MOV [W14+4], W4
704:               }
003D8C  780004     MOV W4, W0
003D8E  FA8000     ULNK
003D90  060000     RETURN
705:               
706:               
707:               void LoadFaultMaskRegisters(void) {
003D92  FA0000     LNK #0x0
708:                 
709:                 switch(control_state) {
003D94  208324     MOV #0x832, W4
003D96  784214     MOV.B [W4], W4
003D98  FB8204     ZE W4, W4
003D9A  200345     MOV #0x34, W5
003D9C  520F85     SUB W4, W5, [W15]
003D9E  32004F     BRA Z, 0x3E3E
003DA0  200345     MOV #0x34, W5
003DA2  520F85     SUB W4, W5, [W15]
003DA4  3C0008     BRA GT, 0x3DB6
003DA6  520FF4     SUB W4, #0x14, [W15]
003DA8  320028     BRA Z, 0x3DFA
003DAA  200245     MOV #0x24, W5
003DAC  520F85     SUB W4, W5, [W15]
003DAE  320036     BRA Z, 0x3E1C
003DB0  520FE4     SUB W4, #0x4, [W15]
003DB2  320012     BRA Z, 0x3DD8
003DB4  370099     BRA 0x3EE8
003DB6  200445     MOV #0x44, W5
003DB8  520F85     SUB W4, W5, [W15]
003DBA  320063     BRA Z, 0x3E82
003DBC  200445     MOV #0x44, W5
003DBE  520F85     SUB W4, W5, [W15]
003DC0  3C0004     BRA GT, 0x3DCA
003DC2  200355     MOV #0x35, W5
003DC4  520F85     SUB W4, W5, [W15]
003DC6  32004C     BRA Z, 0x3E60
003DC8  37008F     BRA 0x3EE8
003DCA  200A45     MOV #0xA4, W5
003DCC  520F85     SUB W4, W5, [W15]
003DCE  32007B     BRA Z, 0x3EC6
003DD0  200A85     MOV #0xA8, W5
003DD2  520F85     SUB W4, W5, [W15]
003DD4  320067     BRA Z, 0x3EA4
003DD6  370088     BRA 0x3EE8
710:                   
711:                 case STATE_START_UP:
712:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_START_UP;
003DD8  EB0200     CLR W4
003DDA  88C3C4     MOV W4, magnetron_fault_mask
713:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_START_UP;
003DDC  EB0200     CLR W4
003DDE  88C3E4     MOV W4, thyratron_fault_mask
714:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_START_UP;
003DE0  EB0200     CLR W4
003DE2  88C3D4     MOV W4, high_voltage_fault_mask
715:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_START_UP;
003DE4  EB0200     CLR W4
003DE6  88C3F4     MOV W4, control_board_fault_mask
716:                
717:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_START_UP;
003DE8  EB0200     CLR W4
003DEA  88C404     MOV W4, magnetron_warning_mask
718:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_START_UP;
003DEC  EB0200     CLR W4
003DEE  88C424     MOV W4, thyratron_warning_mask
719:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_START_UP;
003DF0  EB0200     CLR W4
003DF2  88C414     MOV W4, high_voltage_warning_mask
720:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_START_UP;
003DF4  EB0200     CLR W4
003DF6  88C434     MOV W4, control_board_warning_mask
721:                   break;  
003DF8  370077     BRA 0x3EE8
722:               
723:                 case STATE_SYSTEM_COLD_READY:
724:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_COLD_READY;
003DFA  EB0200     CLR W4
003DFC  88C3C4     MOV W4, magnetron_fault_mask
725:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_COLD_READY;
003DFE  EB0200     CLR W4
003E00  88C3E4     MOV W4, thyratron_fault_mask
726:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_COLD_READY;
003E02  EB0200     CLR W4
003E04  88C3D4     MOV W4, high_voltage_fault_mask
727:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_COLD_READY;
003E06  EB0200     CLR W4
003E08  88C3F4     MOV W4, control_board_fault_mask
728:                
729:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_COLD_READY;
003E0A  EB0200     CLR W4
003E0C  88C404     MOV W4, magnetron_warning_mask
730:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_COLD_READY;
003E0E  EB0200     CLR W4
003E10  88C424     MOV W4, thyratron_warning_mask
731:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_COLD_READY;
003E12  EB0200     CLR W4
003E14  88C414     MOV W4, high_voltage_warning_mask
732:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_COLD_READY;
003E16  EB0200     CLR W4
003E18  88C434     MOV W4, control_board_warning_mask
733:                   break;
003E1A  370066     BRA 0x3EE8
734:                   
735:                 case STATE_WARM_UP:
736:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_UP;
003E1C  202034     MOV #0x203, W4
003E1E  88C3C4     MOV W4, magnetron_fault_mask
737:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_UP;
003E20  204004     MOV #0x400, W4
003E22  88C3E4     MOV W4, thyratron_fault_mask
738:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_UP;
003E24  EB0200     CLR W4
003E26  88C3D4     MOV W4, high_voltage_fault_mask
739:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_UP;
003E28  EB0200     CLR W4
003E2A  88C3F4     MOV W4, control_board_fault_mask
740:                
741:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_UP;
003E2C  EB0200     CLR W4
003E2E  88C404     MOV W4, magnetron_warning_mask
742:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_UP;
003E30  EB0200     CLR W4
003E32  88C424     MOV W4, thyratron_warning_mask
743:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_UP;
003E34  EB0200     CLR W4
003E36  88C414     MOV W4, high_voltage_warning_mask
744:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_UP;
003E38  EB0200     CLR W4
003E3A  88C434     MOV W4, control_board_warning_mask
745:                   break;
003E3C  370055     BRA 0x3EE8
746:               
747:                 case STATE_SYSTEM_WARM_READY:
748:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_READY;
003E3E  2013F4     MOV #0x13F, W4
003E40  88C3C4     MOV W4, magnetron_fault_mask
749:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_READY;
003E42  204004     MOV #0x400, W4
003E44  88C3E4     MOV W4, thyratron_fault_mask
750:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
003E46  EB0200     CLR W4
003E48  88C3D4     MOV W4, high_voltage_fault_mask
751:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_READY;
003E4A  EB0200     CLR W4
003E4C  88C3F4     MOV W4, control_board_fault_mask
752:                
753:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_READY;
003E4E  EB0200     CLR W4
003E50  88C404     MOV W4, magnetron_warning_mask
754:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_READY;
003E52  EB0200     CLR W4
003E54  88C424     MOV W4, thyratron_warning_mask
755:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
003E56  EB0200     CLR W4
003E58  88C414     MOV W4, high_voltage_warning_mask
756:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_READY;
003E5A  EB0200     CLR W4
003E5C  88C434     MOV W4, control_board_warning_mask
757:                   break;
003E5E  370044     BRA 0x3EE8
758:               
759:               
760:                 case STATE_HV_STARTUP:
761:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_READY;
003E60  2013F4     MOV #0x13F, W4
003E62  88C3C4     MOV W4, magnetron_fault_mask
762:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_READY;
003E64  204004     MOV #0x400, W4
003E66  88C3E4     MOV W4, thyratron_fault_mask
763:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
003E68  EB0200     CLR W4
003E6A  88C3D4     MOV W4, high_voltage_fault_mask
764:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_READY;
003E6C  EB0200     CLR W4
003E6E  88C3F4     MOV W4, control_board_fault_mask
765:                
766:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_READY;
003E70  EB0200     CLR W4
003E72  88C404     MOV W4, magnetron_warning_mask
767:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_READY;
003E74  EB0200     CLR W4
003E76  88C424     MOV W4, thyratron_warning_mask
768:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
003E78  EB0200     CLR W4
003E7A  88C414     MOV W4, high_voltage_warning_mask
769:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_READY;
003E7C  EB0200     CLR W4
003E7E  88C434     MOV W4, control_board_warning_mask
770:                   break;
003E80  370033     BRA 0x3EE8
771:               
772:               
773:                 case STATE_HV_ON:
774:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_HV_ON;
003E82  2013F4     MOV #0x13F, W4
003E84  88C3C4     MOV W4, magnetron_fault_mask
775:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_HV_ON;
003E86  204004     MOV #0x400, W4
003E88  88C3E4     MOV W4, thyratron_fault_mask
776:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_HV_ON;
003E8A  203064     MOV #0x306, W4
003E8C  88C3D4     MOV W4, high_voltage_fault_mask
777:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_HV_ON;
003E8E  200014     MOV #0x1, W4
003E90  88C3F4     MOV W4, control_board_fault_mask
778:                
779:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_HV_ON;
003E92  EB0200     CLR W4
003E94  88C404     MOV W4, magnetron_warning_mask
780:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_HV_ON;
003E96  EB0200     CLR W4
003E98  88C424     MOV W4, thyratron_warning_mask
781:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_HV_ON;
003E9A  EB0200     CLR W4
003E9C  88C414     MOV W4, high_voltage_warning_mask
782:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_HV_ON;
003E9E  EB0200     CLR W4
003EA0  88C434     MOV W4, control_board_warning_mask
783:                   break;
003EA2  370022     BRA 0x3EE8
784:               
785:                 case STATE_FAULT_WARM_FAULT:
786:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_FAULT;
003EA4  202004     MOV #0x200, W4
003EA6  88C3C4     MOV W4, magnetron_fault_mask
787:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_FAULT;
003EA8  EB0200     CLR W4
003EAA  88C3E4     MOV W4, thyratron_fault_mask
788:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_FAULT;
003EAC  EB0200     CLR W4
003EAE  88C3D4     MOV W4, high_voltage_fault_mask
789:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_FAULT;
003EB0  EB0200     CLR W4
003EB2  88C3F4     MOV W4, control_board_fault_mask
790:                
791:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_FAULT;
003EB4  EB0200     CLR W4
003EB6  88C404     MOV W4, magnetron_warning_mask
792:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_FAULT;
003EB8  EB0200     CLR W4
003EBA  88C424     MOV W4, thyratron_warning_mask
793:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_FAULT;
003EBC  EB0200     CLR W4
003EBE  88C414     MOV W4, high_voltage_warning_mask
794:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_FAULT;
003EC0  EB0200     CLR W4
003EC2  88C434     MOV W4, control_board_warning_mask
795:                   break;
003EC4  370011     BRA 0x3EE8
796:                   
797:                 case STATE_FAULT_COLD_FAULT:
798:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_COLD_FAULT;
003EC6  EB0200     CLR W4
003EC8  88C3C4     MOV W4, magnetron_fault_mask
799:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_COLD_FAULT;
003ECA  EB0200     CLR W4
003ECC  88C3E4     MOV W4, thyratron_fault_mask
800:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_COLD_FAULT;
003ECE  EB0200     CLR W4
003ED0  88C3D4     MOV W4, high_voltage_fault_mask
801:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_COLD_FAULT;
003ED2  EB0200     CLR W4
003ED4  88C3F4     MOV W4, control_board_fault_mask
802:                
803:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_COLD_FAULT;
003ED6  EB0200     CLR W4
003ED8  88C404     MOV W4, magnetron_warning_mask
804:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_COLD_FAULT;
003EDA  EB0200     CLR W4
003EDC  88C424     MOV W4, thyratron_warning_mask
805:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_COLD_FAULT;
003EDE  EB0200     CLR W4
003EE0  88C414     MOV W4, high_voltage_warning_mask
806:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_COLD_FAULT;
003EE2  EB0200     CLR W4
003EE4  88C434     MOV W4, control_board_warning_mask
807:                   break;
003EE6  000000     NOP
808:                 }
809:               }
003EE8  FA8000     ULNK
003EEA  060000     RETURN
810:               
811:               
812:               
813:               void RecordThisMagnetronFault(unsigned int fault_bit) {  
003EEC  FA0002     LNK #0x2
003EEE  780F00     MOV W0, [W14]
814:               
815:                 faults_magnetron_status_reg |= fault_bit;
003EF0  80C304     MOV faults_magnetron_status_reg, W4
003EF2  72021E     IOR W4, [W14], W4
003EF4  88C304     MOV W4, faults_magnetron_status_reg
816:               
817:                 if (fault_bit & magnetron_warning_mask) {
003EF6  80C404     MOV magnetron_warning_mask, W4
003EF8  62021E     AND W4, [W14], W4
003EFA  520FE0     SUB W4, #0x0, [W15]
003EFC  320003     BRA Z, 0x3F04
818:                   faults_magnetron_warning_reg |= fault_bit;
003EFE  80C324     MOV faults_magnetron_warning_reg, W4
003F00  72021E     IOR W4, [W14], W4
003F02  88C324     MOV W4, faults_magnetron_warning_reg
819:                 }
820:               
821:                 if (fault_bit & magnetron_fault_mask) {
003F04  80C3C4     MOV magnetron_fault_mask, W4
003F06  62021E     AND W4, [W14], W4
003F08  520FE0     SUB W4, #0x0, [W15]
003F0A  32000A     BRA Z, 0x3F20
822:                   if (!(faults_magnetron_fault_reg & fault_bit)) {
003F0C  80C314     MOV faults_magnetron_fault_reg, W4
003F0E  62021E     AND W4, [W14], W4
003F10  520FE0     SUB W4, #0x0, [W15]
003F12  3A0006     BRA NZ, 0x3F20
823:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
824:                     // Set the coresponding bit and save the fault
825:                     faults_magnetron_fault_reg |= fault_bit;
003F14  80C314     MOV faults_magnetron_fault_reg, W4
003F16  72021E     IOR W4, [W14], W4
003F18  88C314     MOV W4, faults_magnetron_fault_reg
826:                     WriteToEventLog(MAGNETRON_FAULT,fault_bit);
003F1A  78009E     MOV [W14], W1
003F1C  EB4000     CLR.B W0
003F1E  070056     RCALL WriteToEventLog
827:                   }
828:                 }
829:               }
003F20  FA8000     ULNK
003F22  060000     RETURN
830:               
831:               
832:               
833:               void RecordThisHighVoltageFault(unsigned int fault_bit) {
003F24  FA0002     LNK #0x2
003F26  780F00     MOV W0, [W14]
834:               
835:                 faults_high_voltage_status_reg |= fault_bit;
003F28  80C334     MOV faults_high_voltage_status_reg, W4
003F2A  72021E     IOR W4, [W14], W4
003F2C  88C334     MOV W4, faults_high_voltage_status_reg
836:               
837:                 if (fault_bit & high_voltage_warning_mask) {
003F2E  80C414     MOV high_voltage_warning_mask, W4
003F30  62021E     AND W4, [W14], W4
003F32  520FE0     SUB W4, #0x0, [W15]
003F34  320003     BRA Z, 0x3F3C
838:                   faults_high_voltage_warning_reg |= fault_bit;
003F36  80C354     MOV faults_high_voltage_warning_reg, W4
003F38  72021E     IOR W4, [W14], W4
003F3A  88C354     MOV W4, faults_high_voltage_warning_reg
839:                 }
840:               
841:                 if (fault_bit & high_voltage_fault_mask) {
003F3C  80C3D4     MOV high_voltage_fault_mask, W4
003F3E  62021E     AND W4, [W14], W4
003F40  520FE0     SUB W4, #0x0, [W15]
003F42  32000A     BRA Z, 0x3F58
842:                   if (!(faults_high_voltage_fault_reg & fault_bit)) {
003F44  80C344     MOV faults_high_voltage_fault_reg, W4
003F46  62021E     AND W4, [W14], W4
003F48  520FE0     SUB W4, #0x0, [W15]
003F4A  3A0006     BRA NZ, 0x3F58
843:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
844:                     // Set the coresponding bit and save the fault
845:                     faults_high_voltage_fault_reg |= fault_bit;
003F4C  80C344     MOV faults_high_voltage_fault_reg, W4
003F4E  72021E     IOR W4, [W14], W4
003F50  88C344     MOV W4, faults_high_voltage_fault_reg
846:                     WriteToEventLog(HIGH_VOLTAGE_FAULT,fault_bit);
003F52  78009E     MOV [W14], W1
003F54  B3C010     MOV #0x1, W0
003F56  07003A     RCALL WriteToEventLog
847:                   }
848:                 }
849:               }
003F58  FA8000     ULNK
003F5A  060000     RETURN
850:               
851:               void RecordThisThyratronFault(unsigned int fault_bit) {
003F5C  FA0002     LNK #0x2
003F5E  780F00     MOV W0, [W14]
852:                 
853:                 faults_thyratron_status_reg |= fault_bit;
003F60  80C364     MOV faults_thyratron_status_reg, W4
003F62  72021E     IOR W4, [W14], W4
003F64  88C364     MOV W4, faults_thyratron_status_reg
854:                 
855:                 if (fault_bit & thyratron_warning_mask) {
003F66  80C424     MOV thyratron_warning_mask, W4
003F68  62021E     AND W4, [W14], W4
003F6A  520FE0     SUB W4, #0x0, [W15]
003F6C  320003     BRA Z, 0x3F74
856:                   faults_thyratron_warning_reg |= fault_bit;
003F6E  80C384     MOV faults_thyratron_warning_reg, W4
003F70  72021E     IOR W4, [W14], W4
003F72  88C384     MOV W4, faults_thyratron_warning_reg
857:                 }
858:               
859:                 if (fault_bit & thyratron_fault_mask) {
003F74  80C3E4     MOV thyratron_fault_mask, W4
003F76  62021E     AND W4, [W14], W4
003F78  520FE0     SUB W4, #0x0, [W15]
003F7A  32000A     BRA Z, 0x3F90
860:                   if (!(faults_thyratron_fault_reg & fault_bit)) {
003F7C  80C374     MOV faults_thyratron_fault_reg, W4
003F7E  62021E     AND W4, [W14], W4
003F80  520FE0     SUB W4, #0x0, [W15]
003F82  3A0006     BRA NZ, 0x3F90
861:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
862:                     // Set the coresponding bit and save the fault
863:                     faults_thyratron_fault_reg |= fault_bit;
003F84  80C374     MOV faults_thyratron_fault_reg, W4
003F86  72021E     IOR W4, [W14], W4
003F88  88C374     MOV W4, faults_thyratron_fault_reg
864:                     WriteToEventLog(THYRATRON_FAULT,fault_bit);
003F8A  78009E     MOV [W14], W1
003F8C  B3C020     MOV #0x2, W0
003F8E  07001E     RCALL WriteToEventLog
865:                   }
866:                 }
867:               }
003F90  FA8000     ULNK
003F92  060000     RETURN
868:               
869:               
870:               void RecordThisControlBoardFault(unsigned int fault_bit) { 
003F94  FA0002     LNK #0x2
003F96  780F00     MOV W0, [W14]
871:               
872:                 faults_control_board_status_reg |= fault_bit;
003F98  80C394     MOV faults_control_board_status_reg, W4
003F9A  72021E     IOR W4, [W14], W4
003F9C  88C394     MOV W4, faults_control_board_status_reg
873:               
874:                 if (fault_bit & control_board_warning_mask) {
003F9E  80C434     MOV control_board_warning_mask, W4
003FA0  62021E     AND W4, [W14], W4
003FA2  520FE0     SUB W4, #0x0, [W15]
003FA4  320003     BRA Z, 0x3FAC
875:                   faults_control_board_warning_reg |= fault_bit;
003FA6  80C3B4     MOV faults_control_board_warning_reg, W4
003FA8  72021E     IOR W4, [W14], W4
003FAA  88C3B4     MOV W4, faults_control_board_warning_reg
876:                 }
877:               
878:                 if (fault_bit & control_board_fault_mask) {
003FAC  80C3F4     MOV control_board_fault_mask, W4
003FAE  62021E     AND W4, [W14], W4
003FB0  520FE0     SUB W4, #0x0, [W15]
003FB2  32000A     BRA Z, 0x3FC8
879:                   if (!(faults_control_board_fault_reg & fault_bit)) {
003FB4  80C3A4     MOV faults_control_board_fault_reg, W4
003FB6  62021E     AND W4, [W14], W4
003FB8  520FE0     SUB W4, #0x0, [W15]
003FBA  3A0006     BRA NZ, 0x3FC8
880:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
881:                     // Set the coresponding bit and save the fault
882:                     faults_control_board_fault_reg |= fault_bit;
003FBC  80C3A4     MOV faults_control_board_fault_reg, W4
003FBE  72021E     IOR W4, [W14], W4
003FC0  88C3A4     MOV W4, faults_control_board_fault_reg
883:                     WriteToEventLog(CONTROL_BOARD_FAULT,fault_bit);
003FC2  78009E     MOV [W14], W1
003FC4  B3C030     MOV #0x3, W0
003FC6  070002     RCALL WriteToEventLog
884:                   }
885:                 }
886:               }
003FC8  FA8000     ULNK
003FCA  060000     RETURN
887:               
888:               
889:               void WriteToEventLog(unsigned char fault_register, unsigned int fault_bit) {
003FCC  FA0004     LNK #0x4
003FCE  784F00     MOV.B W0, [W14]
003FD0  980711     MOV W1, [W14+2]
890:                 // DPARKER this function should write to the event log in ram and update the fault counter in RAM
891:                 // These values are moved to EEPROM later on  . . . like programmed later on
892:               }
003FD2  FA8000     ULNK
003FD4  060000     RETURN
893:               
894:               
895:               unsigned int CheckStartupFailed(void) {
003FD6  FA0000     LNK #0x0
896:                 return 0;
003FD8  EB0200     CLR W4
897:               }
003FDA  780004     MOV W4, W0
003FDC  FA8000     ULNK
003FDE  060000     RETURN
898:               
899:               unsigned int CheckFaultActive(void) {
003FE0  FA0000     LNK #0x0
900:                 return (faults_control_board_fault_reg | faults_thyratron_fault_reg | faults_magnetron_fault_reg | faults_high_voltage_fault_reg);
003FE2  80C3A5     MOV faults_control_board_fault_reg, W5
003FE4  80C374     MOV faults_thyratron_fault_reg, W4
003FE6  728284     IOR W5, W4, W5
003FE8  80C314     MOV faults_magnetron_fault_reg, W4
003FEA  728284     IOR W5, W4, W5
003FEC  80C344     MOV faults_high_voltage_fault_reg, W4
003FEE  728204     IOR W5, W4, W4
901:               }
003FF0  780004     MOV W4, W0
003FF2  FA8000     ULNK
003FF4  060000     RETURN
902:               
903:               
904:               unsigned int CheckColdFaultActive(void) {
003FF6  FA0002     LNK #0x2
905:                 unsigned int temp;
906:                 temp = (faults_control_board_fault_reg & MASK_CONTROL_BOARD_COLD_FAULTS);
003FF8  EB0200     CLR W4
003FFA  780F04     MOV W4, [W14]
907:                 temp |= (faults_thyratron_fault_reg & MASK_THYRATRON_COLD_FAULTS);
908:                 temp |= (faults_magnetron_fault_reg & MASK_MAGNETRON_COLD_FAULTS);
003FFC  80C315     MOV faults_magnetron_fault_reg, W5
003FFE  202034     MOV #0x203, W4
004000  628204     AND W5, W4, W4
004002  720F1E     IOR W4, [W14], [W14]
909:                 temp |= (faults_high_voltage_fault_reg & MASK_HIGH_VOLTAGE_COLD_FAULTS);
910:                 return temp;
004004  78021E     MOV [W14], W4
911:               }
004006  780004     MOV W4, W0
004008  FA8000     ULNK
00400A  060000     RETURN
912:               
913:               
914:               
915:               unsigned char CheckOverVoltFault(POWERSUPPLY* ptr) {
00400C  FA0002     LNK #0x2
00400E  780F00     MOV W0, [W14]
916:                 if (ptr->v_adc_reading > ptr->v_adc_over_rel) {
004010  78021E     MOV [W14], W4
004012  900A84     MOV [W4+16], W5
004014  78021E     MOV [W14], W4
004016  900A54     MOV [W4+26], W4
004018  528F84     SUB W5, W4, [W15]
00401A  360012     BRA LEU, 0x4040
917:                   ptr->v_adc_over_count++;
00401C  78021E     MOV [W14], W4
00401E  901234     MOV [W4+38], W4
004020  E80284     INC W4, W5
004022  78021E     MOV [W14], W4
004024  981235     MOV W5, [W4+38]
918:                   if (ptr->v_adc_over_count > ptr->v_adc_max_oor) {
004026  78021E     MOV [W14], W4
004028  9012B4     MOV [W4+38], W5
00402A  78021E     MOV [W14], W4
00402C  901224     MOV [W4+36], W4
00402E  528F84     SUB W5, W4, [W15]
004030  360010     BRA LEU, 0x4052
919:                     ptr->v_adc_over_count = ptr->v_adc_max_oor + 10;
004032  78021E     MOV [W14], W4
004034  901224     MOV [W4+36], W4
004036  4202EA     ADD W4, #0xA, W5
004038  78021E     MOV [W14], W4
00403A  981235     MOV W5, [W4+38]
920:                     return 1;
00403C  B3C014     MOV #0x1, W4
00403E  37000A     BRA 0x4054
921:                   }
922:                 } else if (ptr->v_adc_over_count >= 1) {
004040  78021E     MOV [W14], W4
004042  901234     MOV [W4+38], W4
004044  520FE0     SUB W4, #0x0, [W15]
004046  320005     BRA Z, 0x4052
923:                   ptr->v_adc_over_count--;
004048  78021E     MOV [W14], W4
00404A  901234     MOV [W4+38], W4
00404C  E90284     DEC W4, W5
00404E  78021E     MOV [W14], W4
004050  981235     MOV W5, [W4+38]
924:                 }
925:                 return 0;
004052  EB4200     CLR.B W4
926:               }
004054  784004     MOV.B W4, W0
004056  FA8000     ULNK
004058  060000     RETURN
927:               
928:               unsigned char CheckUnderVoltFault(POWERSUPPLY* ptr) {
00405A  FA0004     LNK #0x4
00405C  980710     MOV W0, [W14+2]
929:                 unsigned int mod_v_adc_reading;
930:               
931:                 mod_v_adc_reading = ptr->v_adc_reading;
00405E  90021E     MOV [W14+2], W4
004060  900A84     MOV [W4+16], W5
004062  780F05     MOV W5, [W14]
932:                 if (mod_v_adc_reading < 0x0100) {
004064  200FF4     MOV #0xFF, W4
004066  78029E     MOV [W14], W5
004068  528F84     SUB W5, W4, [W15]
00406A  3E0002     BRA GTU, 0x4070
933:                   mod_v_adc_reading = 0x0100; // DPARKER add parameter
00406C  201004     MOV #0x100, W4
00406E  780F04     MOV W4, [W14]
934:                 }
935:                 if (mod_v_adc_reading < ptr->v_adc_under_rel) {
004070  90021E     MOV [W14+2], W4
004072  900A64     MOV [W4+28], W4
004074  520F9E     SUB W4, [W14], [W15]
004076  360012     BRA LEU, 0x409C
936:                   ptr->v_adc_under_count++;
004078  90021E     MOV [W14+2], W4
00407A  901244     MOV [W4+40], W4
00407C  E80284     INC W4, W5
00407E  90021E     MOV [W14+2], W4
004080  981245     MOV W5, [W4+40]
937:                   if (ptr->v_adc_under_count > ptr->v_adc_max_oor) {
004082  90021E     MOV [W14+2], W4
004084  9012C4     MOV [W4+40], W5
004086  90021E     MOV [W14+2], W4
004088  901224     MOV [W4+36], W4
00408A  528F84     SUB W5, W4, [W15]
00408C  360010     BRA LEU, 0x40AE
938:                     ptr->v_adc_under_count = ptr->v_adc_max_oor + 10;
00408E  90021E     MOV [W14+2], W4
004090  901224     MOV [W4+36], W4
004092  4202EA     ADD W4, #0xA, W5
004094  90021E     MOV [W14+2], W4
004096  981245     MOV W5, [W4+40]
939:                     return 1;
004098  B3C014     MOV #0x1, W4
00409A  37000A     BRA 0x40B0
940:                   }
941:                 } else if (ptr->v_adc_under_count >= 1) {
00409C  90021E     MOV [W14+2], W4
00409E  901244     MOV [W4+40], W4
0040A0  520FE0     SUB W4, #0x0, [W15]
0040A2  320005     BRA Z, 0x40AE
942:                   ptr->v_adc_under_count--;
0040A4  90021E     MOV [W14+2], W4
0040A6  901244     MOV [W4+40], W4
0040A8  E90284     DEC W4, W5
0040AA  90021E     MOV [W14+2], W4
0040AC  981245     MOV W5, [W4+40]
943:                 }
944:                 return 0;
0040AE  EB4200     CLR.B W4
945:               }
0040B0  784004     MOV.B W4, W0
0040B2  FA8000     ULNK
0040B4  060000     RETURN
946:               
947:               
948:               unsigned char CheckOverCurrentFault(POWERSUPPLY* ptr) {
0040B6  FA0002     LNK #0x2
0040B8  780F00     MOV W0, [W14]
949:                 if (ptr->i_adc_reading > ptr->i_adc_over_rel) {
0040BA  78021E     MOV [W14], W4
0040BC  901AE4     MOV [W4+60], W5
0040BE  78021E     MOV [W14], W4
0040C0  902234     MOV [W4+70], W4
0040C2  528F84     SUB W5, W4, [W15]
0040C4  360012     BRA LEU, 0x40EA
950:                   ptr->i_adc_over_count++;
0040C6  78021E     MOV [W14], W4
0040C8  902A14     MOV [W4+82], W4
0040CA  E80284     INC W4, W5
0040CC  78021E     MOV [W14], W4
0040CE  982A15     MOV W5, [W4+82]
951:                   if (ptr->i_adc_over_count > ptr->i_adc_max_oor) {
0040D0  78021E     MOV [W14], W4
0040D2  902A94     MOV [W4+82], W5
0040D4  78021E     MOV [W14], W4
0040D6  902A04     MOV [W4+80], W4
0040D8  528F84     SUB W5, W4, [W15]
0040DA  360010     BRA LEU, 0x40FC
952:                     ptr->i_adc_over_count = ptr->i_adc_max_oor + 10;
0040DC  78021E     MOV [W14], W4
0040DE  902A04     MOV [W4+80], W4
0040E0  4202EA     ADD W4, #0xA, W5
0040E2  78021E     MOV [W14], W4
0040E4  982A15     MOV W5, [W4+82]
953:                     return 1; 
0040E6  B3C014     MOV #0x1, W4
0040E8  37000A     BRA 0x40FE
954:                   }
955:                 } else if (ptr->i_adc_over_count >= 1) {
0040EA  78021E     MOV [W14], W4
0040EC  902A14     MOV [W4+82], W4
0040EE  520FE0     SUB W4, #0x0, [W15]
0040F0  320005     BRA Z, 0x40FC
956:                   ptr->i_adc_over_count--;
0040F2  78021E     MOV [W14], W4
0040F4  902A14     MOV [W4+82], W4
0040F6  E90284     DEC W4, W5
0040F8  78021E     MOV [W14], W4
0040FA  982A15     MOV W5, [W4+82]
957:                 }
958:                 return 0;
0040FC  EB4200     CLR.B W4
959:               }
0040FE  784004     MOV.B W4, W0
004100  FA8000     ULNK
004102  060000     RETURN
960:               
961:               unsigned char CheckUnderCurrentFault(POWERSUPPLY* ptr) {
004104  FA0004     LNK #0x4
004106  980710     MOV W0, [W14+2]
962:                 unsigned int mod_i_adc_reading;
963:               
964:                 mod_i_adc_reading = ptr->i_adc_reading;
004108  90021E     MOV [W14+2], W4
00410A  901AE4     MOV [W4+60], W5
00410C  780F05     MOV W5, [W14]
965:                 if (mod_i_adc_reading < 0x0100) {
00410E  200FF4     MOV #0xFF, W4
004110  78029E     MOV [W14], W5
004112  528F84     SUB W5, W4, [W15]
004114  3E0002     BRA GTU, 0x411A
966:                   mod_i_adc_reading = 0x0100;  // DPARKER add parameter
004116  201004     MOV #0x100, W4
004118  780F04     MOV W4, [W14]
967:                 }
968:                 if (mod_i_adc_reading < ptr->i_adc_under_rel) {
00411A  90021E     MOV [W14+2], W4
00411C  902244     MOV [W4+72], W4
00411E  520F9E     SUB W4, [W14], [W15]
004120  360012     BRA LEU, 0x4146
969:                   ptr->i_adc_under_count++;
004122  90021E     MOV [W14+2], W4
004124  902A24     MOV [W4+84], W4
004126  E80284     INC W4, W5
004128  90021E     MOV [W14+2], W4
00412A  982A25     MOV W5, [W4+84]
970:                   if (ptr->i_adc_under_count > ptr->i_adc_max_oor) {
00412C  90021E     MOV [W14+2], W4
00412E  902AA4     MOV [W4+84], W5
004130  90021E     MOV [W14+2], W4
004132  902A04     MOV [W4+80], W4
004134  528F84     SUB W5, W4, [W15]
004136  360010     BRA LEU, 0x4158
971:                     ptr->i_adc_under_count = ptr->i_adc_max_oor + 10;
004138  90021E     MOV [W14+2], W4
00413A  902A04     MOV [W4+80], W4
00413C  4202EA     ADD W4, #0xA, W5
00413E  90021E     MOV [W14+2], W4
004140  982A25     MOV W5, [W4+84]
972:                     return 1;
004142  B3C014     MOV #0x1, W4
004144  37000A     BRA 0x415A
973:                   }
974:                 } else if (ptr->i_adc_under_count >= 1) {
004146  90021E     MOV [W14+2], W4
004148  902A24     MOV [W4+84], W4
00414A  520FE0     SUB W4, #0x0, [W15]
00414C  320005     BRA Z, 0x4158
975:                   ptr->i_adc_under_count--;
00414E  90021E     MOV [W14+2], W4
004150  902A24     MOV [W4+84], W4
004152  E90284     DEC W4, W5
004154  90021E     MOV [W14+2], W4
004156  982A25     MOV W5, [W4+84]
976:                 }
977:                 return 0;
004158  EB4200     CLR.B W4
978:               }
00415A  784004     MOV.B W4, W0
00415C  FA8000     ULNK
00415E  060000     RETURN
979:               
980:               
981:               
---  C:/Users/dparker/Documents/GitHub/TestDan/Serial.c  ------------------------------------------------
1:                 #include "Serial.h"
2:                 #include "A34760_PINS.h"
3:                 #include "Buffer64.h"
4:                 #include "A34760.h"
5:                 #include "config.h"
6:                 #include "faults.h"
7:                 #include "Version.h"
8:                 #include <libpic30.h>
9:                 
10:                /*
11:                  Serial Commands
12:                
13:                  A single command is stored in command_string
14:                  If there is a valid command stored in command_string, then the command_string.data_state = COMMAND_BUFFER_FULL
15:                  If there is NOT a volid command stored in command_string, then command_string.data_state = COMMAND_BUFFER_EMPTY
16:                  
17:                  
18:                  When a byte is received on the UART it is transfered to the "uart1_input_buffer" by the UART receive interrupt - the input buffer is a circular buffer that is 64 Bytes deep
19:                  (see buffer64.h for more infor on the buffer)
20:                  
21:                  Every time through the command loop (200us to 1ms) DoSerialCommand() will be called
22:                  If the command_string is empty, then the input buffer is searched for a valid command (the oldest valid command will be moved to command_string)
23:                
24:                  If a command was found OR the command_string was already full, then the command is executed.
25:                
26:                  Assume an average execution cycle of 1mS and 9 bytes per command.  A command rate of 72 K Baund can be sustained. (57.6 K Baud Standard will work)
27:                  
28:                  Assume an average execution cycle of 500uS and 9 bytes per command, A command rate of 144 K Baud can be sustained (115.2 K Baud Standard should be safe) 
29:                
30:                */
31:                
32:                void LookForCommand(void);
33:                void ExecuteCommand(void);
34:                unsigned char CheckCRC(unsigned int crc);
35:                unsigned int MakeCRC(unsigned char command_byte, unsigned char register_byte, unsigned int data_word);
36:                unsigned int ReadFromRam(unsigned int ram_location);
37:                void SendCommand(unsigned char command_byte, unsigned char register_byte, unsigned int data_word);
38:                
39:                unsigned int GenerateFilamentIprog(unsigned int vprog);
40:                unsigned int GenerateFilamentVprog(unsigned int iprog);
41:                unsigned int GenerateLambdaIprog(unsigned int vprog);
42:                
43:                unsigned int GenerateMagnetronVprog(unsigned int iprog);
44:                
45:                struct CommandStringStruct command_string;
46:                
47:                unsigned char data_logging_to_uart;
48:                
49:                unsigned int ReturnPowerSupplyADCScaledVoltage(POWERSUPPLY* ptr, unsigned int value);
50:                unsigned int ReturnPowerSupplyADCScaledCurrent(POWERSUPPLY* ptr, unsigned int value);
51:                
52:                
53:                unsigned int ReverseScale16Bit(unsigned int value, unsigned int scale);
54:                
55:                
56:                void DoSerialCommand(void) {
0028B8  FA0000     LNK #0x0
57:                  /* 
58:                     Look for a command and execute it.
59:                  */
60:                  if (_OERR) {
0028BA  801074     MOV U1STA, W4
0028BC  620262     AND W4, #0x2, W4
0028BE  520FE0     SUB W4, #0x0, [W15]
0028C0  320001     BRA Z, 0x28C4
61:                    _OERR = 0;
0028C2  A9220E     BCLR U1STA, #1
62:                  }
63:                
64:                  if (command_string.data_state != COMMAND_BUFFER_FULL) {
0028C4  218AA4     MOV #0x18AA, W4
0028C6  784214     MOV.B [W4], W4
0028C8  524FE2     SUB.B W4, #0x2, [W15]
0028CA  320001     BRA Z, 0x28CE
65:                    LookForCommand();
0028CC  070007     RCALL LookForCommand
66:                  }
67:                  if (command_string.data_state == COMMAND_BUFFER_FULL) {
0028CE  218AA4     MOV #0x18AA, W4
0028D0  784214     MOV.B [W4], W4
0028D2  524FE2     SUB.B W4, #0x2, [W15]
0028D4  3A0001     BRA NZ, 0x28D8
68:                    ExecuteCommand();
0028D6  0700F7     RCALL ExecuteCommand
69:                  }
70:                }
0028D8  FA8000     ULNK
0028DA  060000     RETURN
71:                
72:                
73:                
74:                void LookForCommand(void) {
0028DC  FA0004     LNK #0x4
0028DE  781F88     MOV W8, [W15++]
75:                  unsigned char read_byte;
76:                  unsigned int crc;
77:                  /*
78:                    If the state is "waitng for command" then it looks for a command in the buffer, if the state is "executing command" it does nothing
79:                    
80:                    To look for a command in the buffer.
81:                    1) See if there are enough bytes in the buffer to contain a command.
82:                    2) If there are look for command sync
83:                       2b) If there are less bytes in the buffer than it takes to make a command, exit
84:                    3) If command Syncs, check the checksum ^ increment the read_position as each byte is read
85:                       3b) If command does not sync, increment the the read positon and return to step 1    
86:                    4) If the checksum checks out, move the command data into the command data structure
87:                    4b) If the checksum fails, return to step 1     
88:                  */
89:                  
90:                  while ((command_string.data_state == COMMAND_BUFFER_EMPTY) && (Buffer64BytesInBuffer(&uart1_input_buffer) >= COMMAND_LENGTH)) {
0028E0  37003E     BRA 0x295E
00295E  218AA4     MOV #0x18AA, W4
002960  784214     MOV.B [W4], W4
002962  524FE0     SUB.B W4, #0x0, [W15]
002964  3A0005     BRA NZ, 0x2970
002966  2085E0     MOV #0x85E, W0
002968  0711B3     RCALL Buffer64BytesInBuffer
00296A  784200     MOV.B W0, W4
00296C  524FE8     SUB.B W4, #0x8, [W15]
00296E  3EFFB9     BRA GTU, 0x28E2
91:                    // Look for a command
92:                    read_byte = Buffer64ReadByte(&uart1_input_buffer);
0028E2  2085E0     MOV #0x85E, W0
0028E4  0711D7     RCALL Buffer64ReadByte
0028E6  784200     MOV.B W0, W4
0028E8  784F04     MOV.B W4, [W14]
93:                    if (read_byte == SYNC_BYTE_1) {
0028EA  78421E     MOV.B [W14], W4
0028EC  424FEF     ADD.B W4, #0xF, [W15]
0028EE  3A0037     BRA NZ, 0x295E
94:                      read_byte = Buffer64ReadByte(&uart1_input_buffer);
0028F0  2085E0     MOV #0x85E, W0
0028F2  0711D0     RCALL Buffer64ReadByte
0028F4  784200     MOV.B W0, W4
0028F6  784F04     MOV.B W4, [W14]
95:                      if (read_byte == SYNC_BYTE_2) {
0028F8  78421E     MOV.B [W14], W4
0028FA  424FEE     ADD.B W4, #0xE, [W15]
0028FC  3A0030     BRA NZ, 0x295E
96:                	read_byte = Buffer64ReadByte(&uart1_input_buffer);
0028FE  2085E0     MOV #0x85E, W0
002900  0711C9     RCALL Buffer64ReadByte
002902  784200     MOV.B W0, W4
002904  784F04     MOV.B W4, [W14]
97:                	if (read_byte == SYNC_BYTE_3_RECEIVE) {
002906  78421E     MOV.B [W14], W4
002908  424FED     ADD.B W4, #0xD, [W15]
00290A  3A0029     BRA NZ, 0x295E
98:                	  // All of the sync bytes matched, this should be a valid command
99:                	  command_string.command_byte   = Buffer64ReadByte(&uart1_input_buffer);
00290C  2085E0     MOV #0x85E, W0
00290E  0711C2     RCALL Buffer64ReadByte
002910  784200     MOV.B W0, W4
002912  784004     MOV.B W4, W0
002914  B7F8A6     MOV.B WREG, command_string
100:               	  command_string.data_high_byte = Buffer64ReadByte(&uart1_input_buffer);
002916  2085E0     MOV #0x85E, W0
002918  0711BD     RCALL Buffer64ReadByte
00291A  784200     MOV.B W0, W4
00291C  784004     MOV.B W4, W0
00291E  B7F8A8     MOV.B WREG, 0x18A8
101:               	  command_string.data_low_byte  = Buffer64ReadByte(&uart1_input_buffer);
002920  2085E0     MOV #0x85E, W0
002922  0711B8     RCALL Buffer64ReadByte
002924  784200     MOV.B W0, W4
002926  784004     MOV.B W4, W0
002928  B7F8A9     MOV.B WREG, 0x18A9
102:               	  command_string.register_byte  = Buffer64ReadByte(&uart1_input_buffer);
00292A  2085E0     MOV #0x85E, W0
00292C  0711B3     RCALL Buffer64ReadByte
00292E  784200     MOV.B W0, W4
002930  784004     MOV.B W4, W0
002932  B7F8A7     MOV.B WREG, 0x18A7
103:               	  crc                           = Buffer64ReadByte(&uart1_input_buffer);
002934  2085E0     MOV #0x85E, W0
002936  0711AE     RCALL Buffer64ReadByte
002938  784200     MOV.B W0, W4
00293A  FB8204     ZE W4, W4
00293C  980714     MOV W4, [W14+2]
104:               	  crc                           = (crc << 8) + Buffer64ReadByte(&uart1_input_buffer);
00293E  90021E     MOV [W14+2], W4
002940  DD2448     SL W4, #8, W8
002942  2085E0     MOV #0x85E, W0
002944  0711A7     RCALL Buffer64ReadByte
002946  784200     MOV.B W0, W4
002948  FB8204     ZE W4, W4
00294A  440204     ADD W8, W4, W4
00294C  980714     MOV W4, [W14+2]
105:               	  if (CheckCRC(crc)) {
00294E  90001E     MOV [W14+2], W0
002950  070696     RCALL CheckCRC
002952  784200     MOV.B W0, W4
002954  524FE0     SUB.B W4, #0x0, [W15]
002956  320003     BRA Z, 0x295E
106:               	    command_string.data_state = COMMAND_BUFFER_FULL;
002958  B3C024     MOV #0x2, W4
00295A  784004     MOV.B W4, W0
00295C  B7F8AA     MOV.B WREG, 0x18AA
107:               	  }
108:               	}
109:                     }
110:                   }
111:                 }
112:               }
002970  78044F     MOV [--W15], W8
002972  FA8000     ULNK
002974  060000     RETURN
113:               
114:               
115:               void SendLoggingDataToUart() {
002976  FA0000     LNK #0x0
116:                 /* 
117:                    Data that we need to log with each pulse
118:                    byte 0      = 0xFE  - used to sync message
119:                    byte 1,2    = linac_high_energy_target_current_adc_reading
120:                    byte 2,3    = linac_low_energy_target_current_adc_reading
121:                    byte 3,4    = linac_high_energy_program_offset
122:                    byte 5,6    = linac_low_energy_program_offset
123:                    
124:               
125:                    byte 7,8    = pulse_counter_this_run
126:                    byte 9,10   = pulse_magnetron_current_adc_reading
127:                    
128:                 */
129:               
130:                 if (data_logging_to_uart) {
002978  218AB4     MOV #0x18AB, W4
00297A  784214     MOV.B [W4], W4
00297C  524FE0     SUB.B W4, #0x0, [W15]
00297E  32005D     BRA Z, 0x2A3A
131:               
132:                   Buffer64WriteByte(&uart1_output_buffer, 0xFE);
002980  B3CFE1     MOV #0xFE, W1
002982  208A00     MOV #0x8A0, W0
002984  071162     RCALL Buffer64WriteByte
133:                   Buffer64WriteByte(&uart1_output_buffer, 0xF1);
002986  B3CF11     MOV #0xF1, W1
002988  208A00     MOV #0x8A0, W0
00298A  07115F     RCALL Buffer64WriteByte
134:                   Buffer64WriteByte(&uart1_output_buffer, 0xFA);
00298C  B3CFA1     MOV #0xFA, W1
00298E  208A00     MOV #0x8A0, W0
002990  07115C     RCALL Buffer64WriteByte
135:                   Buffer64WriteByte(&uart1_output_buffer, 0xFB);
002992  B3CFB1     MOV #0xFB, W1
002994  208A00     MOV #0x8A0, W0
002996  071159     RCALL Buffer64WriteByte
136:                   
137:               
138:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_target_current_adc_reading >> 8));
002998  804084     MOV linac_high_energy_target_current_adc_reading, W4
00299A  DE2248     LSR W4, #8, W4
00299C  784204     MOV.B W4, W4
00299E  784084     MOV.B W4, W1
0029A0  208A00     MOV #0x8A0, W0
0029A2  071153     RCALL Buffer64WriteByte
139:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_target_current_adc_reading & 0x00FF));
0029A4  804084     MOV linac_high_energy_target_current_adc_reading, W4
0029A6  784204     MOV.B W4, W4
0029A8  784084     MOV.B W4, W1
0029AA  208A00     MOV #0x8A0, W0
0029AC  07114E     RCALL Buffer64WriteByte
140:               
141:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_target_current_adc_reading >> 8));
0029AE  8040A4     MOV linac_low_energy_target_current_adc_reading, W4
0029B0  DE2248     LSR W4, #8, W4
0029B2  784204     MOV.B W4, W4
0029B4  784084     MOV.B W4, W1
0029B6  208A00     MOV #0x8A0, W0
0029B8  071148     RCALL Buffer64WriteByte
142:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_target_current_adc_reading & 0x00FF));
0029BA  8040A4     MOV linac_low_energy_target_current_adc_reading, W4
0029BC  784204     MOV.B W4, W4
0029BE  784084     MOV.B W4, W1
0029C0  208A00     MOV #0x8A0, W0
0029C2  071143     RCALL Buffer64WriteByte
143:               
144:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_program_offset >> 8));
0029C4  8040C4     MOV linac_high_energy_program_offset, W4
0029C6  DEA248     ASR W4, #8, W4
0029C8  784204     MOV.B W4, W4
0029CA  784084     MOV.B W4, W1
0029CC  208A00     MOV #0x8A0, W0
0029CE  07113D     RCALL Buffer64WriteByte
145:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_program_offset & 0x00FF));
0029D0  8040C4     MOV linac_high_energy_program_offset, W4
0029D2  784204     MOV.B W4, W4
0029D4  784084     MOV.B W4, W1
0029D6  208A00     MOV #0x8A0, W0
0029D8  071138     RCALL Buffer64WriteByte
146:               
147:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_program_offset >> 8));
0029DA  8040D4     MOV linac_low_energy_program_offset, W4
0029DC  DEA248     ASR W4, #8, W4
0029DE  784204     MOV.B W4, W4
0029E0  784084     MOV.B W4, W1
0029E2  208A00     MOV #0x8A0, W0
0029E4  071132     RCALL Buffer64WriteByte
148:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_program_offset & 0x00FF));
0029E6  8040D4     MOV linac_low_energy_program_offset, W4
0029E8  784204     MOV.B W4, W4
0029EA  784084     MOV.B W4, W1
0029EC  208A00     MOV #0x8A0, W0
0029EE  07112D     RCALL Buffer64WriteByte
149:               
150:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_counter_this_run >> 8));
0029F0  8040F4     MOV pulse_counter_this_run, W4
0029F2  DE2248     LSR W4, #8, W4
0029F4  784204     MOV.B W4, W4
0029F6  784084     MOV.B W4, W1
0029F8  208A00     MOV #0x8A0, W0
0029FA  071127     RCALL Buffer64WriteByte
151:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_counter_this_run & 0x00FF));
0029FC  8040F4     MOV pulse_counter_this_run, W4
0029FE  784204     MOV.B W4, W4
002A00  784084     MOV.B W4, W1
002A02  208A00     MOV #0x8A0, W0
002A04  071122     RCALL Buffer64WriteByte
152:               
153:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_magnetron_current_adc_reading >> 8));
002A06  804234     MOV pulse_magnetron_current_adc_reading, W4
002A08  DE2248     LSR W4, #8, W4
002A0A  784204     MOV.B W4, W4
002A0C  784084     MOV.B W4, W1
002A0E  208A00     MOV #0x8A0, W0
002A10  07111C     RCALL Buffer64WriteByte
154:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_magnetron_current_adc_reading & 0x00FF));
002A12  804234     MOV pulse_magnetron_current_adc_reading, W4
002A14  784204     MOV.B W4, W4
002A16  784084     MOV.B W4, W1
002A18  208A00     MOV #0x8A0, W0
002A1A  071117     RCALL Buffer64WriteByte
155:               
156:               
157:                   if ((!U1STAbits.UTXBF) && (Buffer64IsNotEmpty(&uart1_output_buffer))) {
002A1C  801075     MOV U1STA, W5
002A1E  202004     MOV #0x200, W4
002A20  628204     AND W5, W4, W4
002A22  520FE0     SUB W4, #0x0, [W15]
002A24  3A000A     BRA NZ, 0x2A3A
002A26  208A00     MOV #0x8A0, W0
002A28  07115E     RCALL Buffer64IsNotEmpty
002A2A  784200     MOV.B W0, W4
002A2C  524FE0     SUB.B W4, #0x0, [W15]
002A2E  320005     BRA Z, 0x2A3A
158:                     /*
159:               	There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
160:               	Move a byte from the output buffer into the transmit buffer
161:               	All subsequent bytes will be moved from the output buffer to the transmit buffer by the U1 TX Interrupt
162:                     */
163:                     U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
002A30  208A00     MOV #0x8A0, W0
002A32  071130     RCALL Buffer64ReadByte
002A34  784200     MOV.B W0, W4
002A36  FB8204     ZE W4, W4
002A38  881084     MOV W4, U1TXREG
164:                   }
165:                 }
166:               }
002A3A  FA8000     ULNK
002A3C  060000     RETURN
167:               
168:               
169:               
170:               void SendCommand(unsigned char command_byte, unsigned char register_byte, unsigned int data_word) {
002A3E  FA0006     LNK #0x6
002A40  984720     MOV.B W0, [W14+2]
002A42  984731     MOV.B W1, [W14+3]
002A44  980722     MOV W2, [W14+4]
171:                 unsigned int crc;
172:                 if (!data_logging_to_uart) {
002A46  218AB4     MOV #0x18AB, W4
002A48  784214     MOV.B [W4], W4
002A4A  524FE0     SUB.B W4, #0x0, [W15]
002A4C  3A003A     BRA NZ, 0x2AC2
173:                   crc = MakeCRC(command_byte, register_byte, data_word);
002A4E  90012E     MOV [W14+4], W2
002A50  9040BE     MOV.B [W14+3], W1
002A52  90402E     MOV.B [W14+2], W0
002A54  0705FD     RCALL MakeCRC
002A56  780200     MOV W0, W4
002A58  780F04     MOV W4, [W14]
174:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_1);
002A5A  B3CF11     MOV #0xF1, W1
002A5C  208A00     MOV #0x8A0, W0
002A5E  0710F5     RCALL Buffer64WriteByte
175:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_2);
002A60  B3CF21     MOV #0xF2, W1
002A62  208A00     MOV #0x8A0, W0
002A64  0710F2     RCALL Buffer64WriteByte
176:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_3_SEND);
002A66  B3CF41     MOV #0xF4, W1
002A68  208A00     MOV #0x8A0, W0
002A6A  0710EF     RCALL Buffer64WriteByte
177:                   Buffer64WriteByte(&uart1_output_buffer, command_byte);
002A6C  9040AE     MOV.B [W14+2], W1
002A6E  208A00     MOV #0x8A0, W0
002A70  0710EC     RCALL Buffer64WriteByte
178:                   Buffer64WriteByte(&uart1_output_buffer, (data_word >> 8));
002A72  90022E     MOV [W14+4], W4
002A74  DE2248     LSR W4, #8, W4
002A76  784204     MOV.B W4, W4
002A78  784084     MOV.B W4, W1
002A7A  208A00     MOV #0x8A0, W0
002A7C  0710E6     RCALL Buffer64WriteByte
179:                   Buffer64WriteByte(&uart1_output_buffer, (data_word & 0x00FF));
002A7E  90022E     MOV [W14+4], W4
002A80  784204     MOV.B W4, W4
002A82  784084     MOV.B W4, W1
002A84  208A00     MOV #0x8A0, W0
002A86  0710E1     RCALL Buffer64WriteByte
180:                   Buffer64WriteByte(&uart1_output_buffer, register_byte);
002A88  9040BE     MOV.B [W14+3], W1
002A8A  208A00     MOV #0x8A0, W0
002A8C  0710DE     RCALL Buffer64WriteByte
181:                   Buffer64WriteByte(&uart1_output_buffer, (crc >> 8));
002A8E  78021E     MOV [W14], W4
002A90  DE2248     LSR W4, #8, W4
002A92  784204     MOV.B W4, W4
002A94  784084     MOV.B W4, W1
002A96  208A00     MOV #0x8A0, W0
002A98  0710D8     RCALL Buffer64WriteByte
182:                   Buffer64WriteByte(&uart1_output_buffer, (crc & 0x00FF));
002A9A  78021E     MOV [W14], W4
002A9C  784204     MOV.B W4, W4
002A9E  784084     MOV.B W4, W1
002AA0  208A00     MOV #0x8A0, W0
002AA2  0710D3     RCALL Buffer64WriteByte
183:                   
184:                   if ((!U1STAbits.UTXBF) && (Buffer64IsNotEmpty(&uart1_output_buffer))) {
002AA4  801075     MOV U1STA, W5
002AA6  202004     MOV #0x200, W4
002AA8  628204     AND W5, W4, W4
002AAA  520FE0     SUB W4, #0x0, [W15]
002AAC  3A000A     BRA NZ, 0x2AC2
002AAE  208A00     MOV #0x8A0, W0
002AB0  07111A     RCALL Buffer64IsNotEmpty
002AB2  784200     MOV.B W0, W4
002AB4  524FE0     SUB.B W4, #0x0, [W15]
002AB6  320005     BRA Z, 0x2AC2
185:                     /*
186:               	There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
187:               	Move a byte from the output buffer into the transmit buffer
188:               	All subsequent bytes will be moved from the output buffer to the transmit buffer by the U1 TX Interrupt
189:                     */
190:                     U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
002AB8  208A00     MOV #0x8A0, W0
002ABA  0710EC     RCALL Buffer64ReadByte
002ABC  784200     MOV.B W0, W4
002ABE  FB8204     ZE W4, W4
002AC0  881084     MOV W4, U1TXREG
191:                   }
192:                 }
193:               }
002AC2  FA8000     ULNK
002AC4  060000     RETURN
194:               
195:               void ExecuteCommand(void) {
002AC6  FA000A     LNK #0xA
196:                 unsigned int itemp;
197:                 unsigned int vtemp;
198:                 unsigned int data_word;
199:                 unsigned int return_data_word;
200:                 unsigned int return_command_byte;
201:                 
202:                 data_word = command_string.data_high_byte;
002AC8  218A84     MOV #0x18A8, W4
002ACA  784214     MOV.B [W4], W4
002ACC  FB8204     ZE W4, W4
002ACE  980714     MOV W4, [W14+2]
203:                 data_word = data_word << 8;
002AD0  90021E     MOV [W14+2], W4
002AD2  DD2248     SL W4, #8, W4
002AD4  980714     MOV W4, [W14+2]
204:                 data_word = data_word + command_string.data_low_byte;
002AD6  218A94     MOV #0x18A9, W4
002AD8  784214     MOV.B [W4], W4
002ADA  FB8204     ZE W4, W4
002ADC  90029E     MOV [W14+2], W5
002ADE  428204     ADD W5, W4, W4
002AE0  980714     MOV W4, [W14+2]
205:                 
206:                 return_data_word = data_word;
002AE2  90001E     MOV [W14+2], W0
002AE4  780F00     MOV W0, [W14]
207:                 return_command_byte = command_string.command_byte;
002AE6  218A64     MOV #0x18A6, W4
002AE8  784214     MOV.B [W4], W4
002AEA  FB8204     ZE W4, W4
002AEC  980724     MOV W4, [W14+4]
208:                 switch (command_string.command_byte) 
002AEE  218A64     MOV #0x18A6, W4
002AF0  784214     MOV.B [W4], W4
002AF2  FB8204     ZE W4, W4
002AF4  B92361     MUL.SU W4, #1, W6
002AF6  2FFF04     MOV #0xFFF0, W4
002AF8  2FFFF5     MOV #0xFFFF, W5
002AFA  420206     ADD W4, W6, W4
002AFC  4A8287     ADDC W5, W7, W5
002AFE  200DA6     MOV #0xDA, W6
002B00  200007     MOV #0x0, W7
002B02  520F86     SUB W4, W6, [W15]
002B04  5A8F87     SUBB W5, W7, [W15]
002B06  3E031B     BRA GTU, 0x313E
002B08  016004     BRA W4
002B0A  3700DA     BRA 0x2CC0
002B0C  3700DD     BRA 0x2CC8
002B0E  370317     BRA 0x313E
002B10  370316     BRA 0x313E
002B12  370315     BRA 0x313E
002B14  370314     BRA 0x313E
002B16  370313     BRA 0x313E
002B18  370312     BRA 0x313E
002B1A  370311     BRA 0x313E
002B1C  370310     BRA 0x313E
002B1E  37030F     BRA 0x313E
002B20  37030E     BRA 0x313E
002B22  37030D     BRA 0x313E
002B24  37030C     BRA 0x313E
002B26  37030B     BRA 0x313E
002B28  37030A     BRA 0x313E
002B2A  370309     BRA 0x313E
002B2C  370308     BRA 0x313E
002B2E  370307     BRA 0x313E
002B30  370306     BRA 0x313E
002B32  370305     BRA 0x313E
002B34  370304     BRA 0x313E
002B36  370303     BRA 0x313E
002B38  370302     BRA 0x313E
002B3A  370301     BRA 0x313E
002B3C  370300     BRA 0x313E
002B3E  3702FF     BRA 0x313E
002B40  3700C7     BRA 0x2CD0
002B42  3702C9     BRA 0x30D6
002B44  3702FC     BRA 0x313E
002B46  3702A4     BRA 0x3090
002B48  3702FA     BRA 0x313E
002B4A  3700E9     BRA 0x2D1E
002B4C  3702F8     BRA 0x313E
002B4E  3702F7     BRA 0x313E
002B50  3702F6     BRA 0x313E
002B52  3702F5     BRA 0x313E
002B54  3702F4     BRA 0x313E
002B56  3702F3     BRA 0x313E
002B58  3702F2     BRA 0x313E
002B5A  3702F1     BRA 0x313E
002B5C  3702F0     BRA 0x313E
002B5E  3702EF     BRA 0x313E
002B60  3702EE     BRA 0x313E
002B62  3702ED     BRA 0x313E
002B64  3702EC     BRA 0x313E
002B66  3702EB     BRA 0x313E
002B68  3702EA     BRA 0x313E
002B6A  3702D8     BRA 0x311C
002B6C  3702E8     BRA 0x313E
002B6E  3702E7     BRA 0x313E
002B70  3702E6     BRA 0x313E
002B72  3702E5     BRA 0x313E
002B74  3702E4     BRA 0x313E
002B76  3702E3     BRA 0x313E
002B78  3702E2     BRA 0x313E
002B7A  3702E1     BRA 0x313E
002B7C  3702E0     BRA 0x313E
002B7E  3702DF     BRA 0x313E
002B80  3702DE     BRA 0x313E
002B82  3702DD     BRA 0x313E
002B84  3702DC     BRA 0x313E
002B86  3702DB     BRA 0x313E
002B88  3702DA     BRA 0x313E
002B8A  3700D1     BRA 0x2D2E
002B8C  3700DC     BRA 0x2D46
002B8E  3700FA     BRA 0x2D84
002B90  3702D6     BRA 0x313E
002B92  3702D5     BRA 0x313E
002B94  3702D4     BRA 0x313E
002B96  3702D3     BRA 0x313E
002B98  3702D2     BRA 0x313E
002B9A  3702D1     BRA 0x313E
002B9C  3702D0     BRA 0x313E
002B9E  3702CF     BRA 0x313E
002BA0  3702CE     BRA 0x313E
002BA2  3702CD     BRA 0x313E
002BA4  3702CC     BRA 0x313E
002BA6  3702CB     BRA 0x313E
002BA8  3702CA     BRA 0x313E
002BAA  3702C9     BRA 0x313E
002BAC  3702C8     BRA 0x313E
002BAE  3702C7     BRA 0x313E
002BB0  3702C6     BRA 0x313E
002BB2  3702C5     BRA 0x313E
002BB4  3702C4     BRA 0x313E
002BB6  3702C3     BRA 0x313E
002BB8  3702C2     BRA 0x313E
002BBA  3702C1     BRA 0x313E
002BBC  3702C0     BRA 0x313E
002BBE  3702BF     BRA 0x313E
002BC0  3702BE     BRA 0x313E
002BC2  3702BD     BRA 0x313E
002BC4  3702BC     BRA 0x313E
002BC6  3702BB     BRA 0x313E
002BC8  3702BA     BRA 0x313E
002BCA  3702B9     BRA 0x313E
002BCC  3702B8     BRA 0x313E
002BCE  3702B7     BRA 0x313E
002BD0  3702B6     BRA 0x313E
002BD2  3702B5     BRA 0x313E
002BD4  3702B4     BRA 0x313E
002BD6  3702B3     BRA 0x313E
002BD8  3702B2     BRA 0x313E
002BDA  3702B1     BRA 0x313E
002BDC  3702B0     BRA 0x313E
002BDE  3702AF     BRA 0x313E
002BE0  3702AE     BRA 0x313E
002BE2  3702AD     BRA 0x313E
002BE4  3702AC     BRA 0x313E
002BE6  3702AB     BRA 0x313E
002BE8  3702AA     BRA 0x313E
002BEA  3702A9     BRA 0x313E
002BEC  3702A8     BRA 0x313E
002BEE  3702A7     BRA 0x313E
002BF0  3702A6     BRA 0x313E
002BF2  3702A5     BRA 0x313E
002BF4  3702A4     BRA 0x313E
002BF6  3702A3     BRA 0x313E
002BF8  3702A2     BRA 0x313E
002BFA  3702A1     BRA 0x313E
002BFC  3702A0     BRA 0x313E
002BFE  37029F     BRA 0x313E
002C00  37029E     BRA 0x313E
002C02  37029D     BRA 0x313E
002C04  37029C     BRA 0x313E
002C06  37029B     BRA 0x313E
002C08  37029A     BRA 0x313E
002C0A  370299     BRA 0x313E
002C0C  370298     BRA 0x313E
002C0E  370297     BRA 0x313E
002C10  370296     BRA 0x313E
002C12  370295     BRA 0x313E
002C14  370294     BRA 0x313E
002C16  370293     BRA 0x313E
002C18  370292     BRA 0x313E
002C1A  370291     BRA 0x313E
002C1C  370290     BRA 0x313E
002C1E  37028F     BRA 0x313E
002C20  37028E     BRA 0x313E
002C22  37028D     BRA 0x313E
002C24  37028C     BRA 0x313E
002C26  37028B     BRA 0x313E
002C28  37028A     BRA 0x313E
002C2A  370289     BRA 0x313E
002C2C  3700CA     BRA 0x2DC2
002C2E  370287     BRA 0x313E
002C30  370286     BRA 0x313E
002C32  370285     BRA 0x313E
002C34  370284     BRA 0x313E
002C36  370283     BRA 0x313E
002C38  370282     BRA 0x313E
002C3A  370281     BRA 0x313E
002C3C  370280     BRA 0x313E
002C3E  37027F     BRA 0x313E
002C40  37027E     BRA 0x313E
002C42  37027D     BRA 0x313E
002C44  37027C     BRA 0x313E
002C46  37027B     BRA 0x313E
002C48  37027A     BRA 0x313E
002C4A  370279     BRA 0x313E
002C4C  370278     BRA 0x313E
002C4E  370277     BRA 0x313E
002C50  370276     BRA 0x313E
002C52  370275     BRA 0x313E
002C54  370274     BRA 0x313E
002C56  370273     BRA 0x313E
002C58  370272     BRA 0x313E
002C5A  370271     BRA 0x313E
002C5C  370270     BRA 0x313E
002C5E  37026F     BRA 0x313E
002C60  37026E     BRA 0x313E
002C62  37026D     BRA 0x313E
002C64  37026C     BRA 0x313E
002C66  37026B     BRA 0x313E
002C68  37026A     BRA 0x313E
002C6A  370269     BRA 0x313E
002C6C  370268     BRA 0x313E
002C6E  370267     BRA 0x313E
002C70  370266     BRA 0x313E
002C72  370265     BRA 0x313E
002C74  370264     BRA 0x313E
002C76  370263     BRA 0x313E
002C78  370262     BRA 0x313E
002C7A  370261     BRA 0x313E
002C7C  370260     BRA 0x313E
002C7E  37025F     BRA 0x313E
002C80  37025E     BRA 0x313E
002C82  37025D     BRA 0x313E
002C84  37025C     BRA 0x313E
002C86  37025B     BRA 0x313E
002C88  37025A     BRA 0x313E
002C8A  3700A3     BRA 0x2DD2
002C8C  3700AB     BRA 0x2DE4
002C8E  3700B3     BRA 0x2DF6
002C90  3700C7     BRA 0x2E20
002C92  3700CF     BRA 0x2E32
002C94  3700D7     BRA 0x2E44
002C96  3700EB     BRA 0x2E6E
002C98  3700F3     BRA 0x2E80
002C9A  3700FB     BRA 0x2E92
002C9C  37010F     BRA 0x2EBC
002C9E  370117     BRA 0x2ECE
002CA0  37011F     BRA 0x2EE0
002CA2  370133     BRA 0x2F0A
002CA4  37013B     BRA 0x2F1C
002CA6  370143     BRA 0x2F2E
002CA8  370157     BRA 0x2F58
002CAA  37015F     BRA 0x2F6A
002CAC  370167     BRA 0x2F7C
002CAE  37017B     BRA 0x2FA6
002CB0  370183     BRA 0x2FB8
002CB2  37018B     BRA 0x2FCA
002CB4  37019F     BRA 0x2FF4
002CB6  3701A7     BRA 0x3006
002CB8  3701AF     BRA 0x3018
002CBA  3701C3     BRA 0x3042
002CBC  3701CB     BRA 0x3054
002CBE  3701D3     BRA 0x3066
209:                   {
210:               
211:               
212:                     
213:               #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
214:                     // We have compiled in the mode that untilizes the serial port to set the magnetron operating parameters (instead of the analong interface)
215:                   case CMD_PAC_SET_MODE_A:
216:                     itemp = data_word;
217:                     vtemp = GenerateMagnetronVprog(itemp);
218:                     SetPowerSupplyTarget(&ps_magnetron_mode_A, vtemp, itemp);
219:                     ps_magnetron_mode_A_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnetron_mode_A.v_command_set_point;
220:                     ps_magnetron_mode_A_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnetron_mode_A.i_command_set_point;
221:                     _wait_eedata();
222:                     _erase_eedata(EE_address_ps_magnetron_mode_A_config_in_EEPROM, _EE_ROW);
223:                     _wait_eedata();
224:                     _write_eedata_row(EE_address_ps_magnetron_mode_A_config_in_EEPROM, ps_magnet_config_ram_copy);
225:                     break;
226:               
227:                   case CMD_PAC_SET_MODE_B:
228:                     itemp = data_word;
229:                     vtemp = GenerateMagnetronVprog(itemp);
230:                     SetPowerSupplyTarget(&ps_magnetron_mode_B, vtemp, itemp);
231:                     ps_magnetron_mode_B_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnetron_mode_B.v_command_set_point;
232:                     ps_magnetron_mode_B_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnetron_mode_B.i_command_set_point;
233:                     _wait_eedata();
234:                     _erase_eedata(EE_address_ps_magnetron_mode_B_config_in_EEPROM, _EE_ROW);
235:                     _wait_eedata();
236:                     _write_eedata_row(EE_address_ps_magnetron_mode_B_config_in_EEPROM, ps_magnet_config_ram_copy);
237:                     break;
238:               #endif
239:               
240:               
241:               
242:               #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
243:                     // The lambda voltage is set directly over the serial interface.
244:                   case CMD_SET_LAMBDA_VOLTAGE_MODE_A:
245:                     vtemp = data_word;
246:                     itemp = GenerateLambdaIprog(vtemp);
247:                     SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp, itemp);
248:                     ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_SET_POINT] = ps_hv_lambda_mode_A.v_command_set_point;
249:                     ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_SET_POINT] = ps_hv_lambda_mode_A.i_command_set_point;
250:                     _wait_eedata();
251:                     _erase_eedata(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, _EE_ROW);
252:                     _wait_eedata();
253:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, ps_hv_lambda_mode_A_config_ram_copy);
254:                     break;
255:               
256:                   case CMD_SET_LAMBDA_VOLTAGE_MODE_B:
257:                     vtemp = data_word;
258:                     itemp = GenerateLambdaIprog(vtemp);
259:                     SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, itemp);
260:                     ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_SET_POINT] = ps_hv_lambda_mode_B.v_command_set_point;
261:                     ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_SET_POINT] = ps_hv_lambda_mode_B.i_command_set_point;
262:                     _wait_eedata();
263:                     _erase_eedata(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, _EE_ROW);
264:                     _wait_eedata();
265:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, ps_hv_lambda_mode_B_config_ram_copy);
266:                     break;
267:               
268:               #endif // #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
269:                   case CMD_SET_MAGNETRON_CURRENT_REMOTE_MODE:
270:                     ram_config_set_magnetron_magnet_current_from_GUI = 0;
002CC0  EB4200     CLR.B W4
002CC2  784004     MOV.B W4, W0
002CC4  B7E822     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
271:                     break;
002CC6  37023B     BRA 0x313E
272:                     
273:                   case CMD_SET_MAGNETRON_CURRENT_LOCAL_MODE:
274:                     ram_config_set_magnetron_magnet_current_from_GUI = 1;
002CC8  B3C014     MOV #0x1, W4
002CCA  784004     MOV.B W4, W0
002CCC  B7E822     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
275:                     break;
002CCE  370237     BRA 0x313E
276:               
277:               
278:                     //#if defined(__SET_MAGNET_CURRENT_OVER_SERIAL_INTERFACE)
279:                   case CMD_SET_MAGNETRON_MAGNET_CURRENT:
280:                     if (ram_config_set_magnetron_magnet_current_from_GUI) {
002CD0  208224     MOV #0x822, W4
002CD2  784214     MOV.B [W4], W4
002CD4  524FE0     SUB.B W4, #0x0, [W15]
002CD6  320230     BRA Z, 0x3138
281:               	itemp = data_word;
002CD8  90021E     MOV [W14+2], W4
002CDA  980734     MOV W4, [W14+6]
282:               	vtemp = GenerateMagnetVprog(itemp);
002CDC  90003E     MOV [W14+6], W0
002CDE  07052F     RCALL GenerateMagnetVprog
002CE0  780200     MOV W0, W4
002CE2  980744     MOV W4, [W14+8]
283:               	SetPowerSupplyTarget(&ps_magnet, vtemp, itemp);
002CE4  90013E     MOV [W14+6], W2
002CE6  9000CE     MOV [W14+8], W1
002CE8  20A620     MOV #0xA62, W0
002CEA  07F3E1     RCALL SetPowerSupplyTarget
284:               	ps_magnet_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnet.v_command_set_point;
002CEC  805324     MOV 0xA64, W4
002CEE  88B724     MOV W4, ps_magnet_config_ram_copy
285:               	ps_magnet_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnet.i_command_set_point;
002CF0  805484     MOV 0xA90, W4
002CF2  88B774     MOV W4, 0x16EE
286:               	_wait_eedata();
002CF4  803B05     MOV NVMCON, W5
002CF6  280004     MOV #0x8000, W4
002CF8  628204     AND W5, W4, W4
002CFA  520FE0     SUB W4, #0x0, [W15]
002CFC  3AFFFB     BRA NZ, 0x2CF4
287:               	_erase_eedata(EE_address_ps_magnet_config_in_EEPROM, _EE_ROW);
002CFE  80B704     MOV EE_address_ps_magnet_config_in_EEPROM, W4
002D00  80B715     MOV 0x16E2, W5
002D02  200202     MOV #0x20, W2
002D04  BE0004     MOV.D W4, W0
002D06  07EA85     RCALL __eedata_helper1
288:               	_wait_eedata();
002D08  803B05     MOV NVMCON, W5
002D0A  280004     MOV #0x8000, W4
002D0C  628204     AND W5, W4, W4
002D0E  520FE0     SUB W4, #0x0, [W15]
002D10  3AFFFB     BRA NZ, 0x2D08
289:               	_write_eedata_row(EE_address_ps_magnet_config_in_EEPROM, ps_magnet_config_ram_copy);
002D12  80B704     MOV EE_address_ps_magnet_config_in_EEPROM, W4
002D14  80B715     MOV 0x16E2, W5
002D16  216E42     MOV #0x16E4, W2
002D18  BE0004     MOV.D W4, W0
002D1A  07EA9A     RCALL __eedata_helper4
290:                     }
291:                     break;
002D1C  370210     BRA 0x313E
003138  000000     NOP
00313A  370001     BRA 0x313E
292:               
293:                     //#endif //#if defined(__SET_MAGNET_CURRENT_OVER_SERIAL_INTERFACE)
294:               
295:                     
296:                   case CMD_READ_RAM_VALUE:
297:                     return_data_word = ReadFromRam(command_string.register_byte);
002D1E  218A74     MOV #0x18A7, W4
002D20  784214     MOV.B [W4], W4
002D22  FB8204     ZE W4, W4
002D24  780004     MOV W4, W0
002D26  070218     RCALL ReadFromRam
002D28  780200     MOV W0, W4
002D2A  780F04     MOV W4, [W14]
298:                     break;
002D2C  370208     BRA 0x313E
299:               
300:                     
301:                   case CMD_DATA_LOGGING:
302:                     if (command_string.register_byte == 1) {
002D2E  218A74     MOV #0x18A7, W4
002D30  784214     MOV.B [W4], W4
002D32  524FE1     SUB.B W4, #0x1, [W15]
002D34  3A0004     BRA NZ, 0x2D3E
303:               	data_logging_to_uart = 1;
002D36  B3C014     MOV #0x1, W4
002D38  784004     MOV.B W4, W0
002D3A  B7F8AB     MOV.B WREG, data_logging_to_uart
304:                     } else {
305:                     	data_logging_to_uart = 0;
002D3E  EB4200     CLR.B W4
002D40  784004     MOV.B W4, W0
002D42  B7F8AB     MOV.B WREG, data_logging_to_uart
306:                     }
307:                     break;
002D3C  370200     BRA 0x313E
002D44  3701FC     BRA 0x313E
308:               
309:               
310:                   case CMD_SET_HIGH_ENERGY_TARGET_CURRENT_SETPOINT:
311:                     linac_high_energy_target_current_set_point = data_word;
002D46  90021E     MOV [W14+2], W4
002D48  884094     MOV W4, linac_high_energy_target_current_set_point
312:                     if (linac_high_energy_target_current_set_point < LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR) {
002D4A  804095     MOV linac_high_energy_target_current_set_point, W5
002D4C  200314     MOV #0x31, W4
002D4E  528F84     SUB W5, W4, [W15]
002D50  3E0002     BRA GTU, 0x2D56
313:               	linac_high_energy_target_current_set_point = LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR;
002D52  200324     MOV #0x32, W4
002D54  884094     MOV W4, linac_high_energy_target_current_set_point
314:                     }
315:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_HIGH_ENERGY_TARGET] = linac_high_energy_target_current_set_point;
002D56  804094     MOV linac_high_energy_target_current_set_point, W4
002D58  88C174     MOV W4, 0x182E
316:                     _wait_eedata();
002D5A  803B05     MOV NVMCON, W5
002D5C  280004     MOV #0x8000, W4
002D5E  628204     AND W5, W4, W4
002D60  520FE0     SUB W4, #0x0, [W15]
002D62  3AFFFB     BRA NZ, 0x2D5A
317:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
002D64  80C124     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
002D66  80C135     MOV 0x1826, W5
002D68  200202     MOV #0x20, W2
002D6A  BE0004     MOV.D W4, W0
002D6C  07EA52     RCALL __eedata_helper1
318:                     _wait_eedata();
002D6E  803B05     MOV NVMCON, W5
002D70  280004     MOV #0x8000, W4
002D72  628204     AND W5, W4, W4
002D74  520FE0     SUB W4, #0x0, [W15]
002D76  3AFFFB     BRA NZ, 0x2D6E
319:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
002D78  80C124     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
002D7A  80C135     MOV 0x1826, W5
002D7C  218282     MOV #0x1828, W2
002D7E  BE0004     MOV.D W4, W0
002D80  07EA67     RCALL __eedata_helper4
320:                     break;
002D82  3701DD     BRA 0x313E
321:                     
322:               
323:                   case CMD_SET_LOW_ENERGY_TARGET_CURRENT_SETPOINT:
324:                     linac_low_energy_target_current_set_point = data_word;
002D84  90001E     MOV [W14+2], W0
002D86  8840B0     MOV W0, linac_low_energy_target_current_set_point
325:                     if (linac_low_energy_target_current_set_point < LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR) {
002D88  8040B5     MOV linac_low_energy_target_current_set_point, W5
002D8A  200314     MOV #0x31, W4
002D8C  528F84     SUB W5, W4, [W15]
002D8E  3E0002     BRA GTU, 0x2D94
326:               	linac_low_energy_target_current_set_point = LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR;
002D90  200324     MOV #0x32, W4
002D92  8840B4     MOV W4, linac_low_energy_target_current_set_point
327:                     }
328:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_TARGET] = linac_low_energy_target_current_set_point;
002D94  8040B4     MOV linac_low_energy_target_current_set_point, W4
002D96  88C184     MOV W4, 0x1830
329:                     _wait_eedata();
002D98  803B05     MOV NVMCON, W5
002D9A  280004     MOV #0x8000, W4
002D9C  628204     AND W5, W4, W4
002D9E  520FE0     SUB W4, #0x0, [W15]
002DA0  3AFFFB     BRA NZ, 0x2D98
330:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
002DA2  80C124     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
002DA4  80C135     MOV 0x1826, W5
002DA6  200202     MOV #0x20, W2
002DA8  BE0004     MOV.D W4, W0
002DAA  07EA33     RCALL __eedata_helper1
331:                     _wait_eedata();
002DAC  803B05     MOV NVMCON, W5
002DAE  280004     MOV #0x8000, W4
002DB0  628204     AND W5, W4, W4
002DB2  520FE0     SUB W4, #0x0, [W15]
002DB4  3AFFFB     BRA NZ, 0x2DAC
332:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
002DB6  80C124     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
002DB8  80C135     MOV 0x1826, W5
002DBA  218282     MOV #0x1828, W2
002DBC  BE0004     MOV.D W4, W0
002DBE  07EA48     RCALL __eedata_helper4
333:                     break;
002DC0  3701BE     BRA 0x313E
334:               
335:               
336:                   case CMD_FORCE_SOFTWARE_RESTART:
337:                     /*
338:               	We don't want to be forcing software resets on a production system
339:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
340:                     __delay32(100000); // this should be 10ms
341:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 1;
342:                     __delay32(100);
343:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
344:                    __asm__ ("Reset");
345:                     */
346:                     break;
347:               
348:                   case CMD_SOFTWARE_SKIP_WARMUP:
349:                     if (control_state == STATE_WARM_UP) {
002DC2  208325     MOV #0x832, W5
002DC4  784295     MOV.B [W5], W5
002DC6  B3C244     MOV #0x24, W4
002DC8  52CF84     SUB.B W5, W4, [W15]
002DCA  3A01B8     BRA NZ, 0x313C
350:               	software_skip_warmup = 1;
002DCC  200014     MOV #0x1, W4
002DCE  88C474     MOV W4, software_skip_warmup
351:                     }
352:                     break;
002DD0  3701B6     BRA 0x313E
00313C  000000     NOP
353:               
354:                   case CMD_SET_MAGNET_PS_CAL_DATA:
355:                     ps_magnet_config_ram_copy[command_string.register_byte] = data_word;
002DD2  218A74     MOV #0x18A7, W4
002DD4  784214     MOV.B [W4], W4
002DD6  FB8204     ZE W4, W4
002DD8  90029E     MOV [W14+2], W5
002DDA  420304     ADD W4, W4, W6
002DDC  216E44     MOV #0x16E4, W4
002DDE  430204     ADD W6, W4, W4
002DE0  780A05     MOV W5, [W4]
356:                     break;
002DE2  3701AD     BRA 0x313E
357:                     
358:                   case CMD_READ_MAGNET_PS_CAL_DATA:
359:                     return_data_word = ps_magnet_config_ram_copy[command_string.register_byte];
002DE4  218A74     MOV #0x18A7, W4
002DE6  784214     MOV.B [W4], W4
002DE8  FB8204     ZE W4, W4
002DEA  420284     ADD W4, W4, W5
002DEC  216E44     MOV #0x16E4, W4
002DEE  428204     ADD W5, W4, W4
002DF0  780214     MOV [W4], W4
002DF2  780F04     MOV W4, [W14]
360:                     break;
002DF4  3701A4     BRA 0x313E
361:                     
362:                   case CMD_SAVE_MAGNET_PS_CAL_DATA_TO_EEPROM:
363:                     _wait_eedata();
002DF6  803B05     MOV NVMCON, W5
002DF8  280004     MOV #0x8000, W4
002DFA  628204     AND W5, W4, W4
002DFC  520FE0     SUB W4, #0x0, [W15]
002DFE  3AFFFB     BRA NZ, 0x2DF6
364:                     _erase_eedata(EE_address_ps_magnet_config_in_EEPROM, _EE_ROW);
002E00  80B704     MOV EE_address_ps_magnet_config_in_EEPROM, W4
002E02  80B715     MOV 0x16E2, W5
002E04  200202     MOV #0x20, W2
002E06  BE0004     MOV.D W4, W0
002E08  07EA04     RCALL __eedata_helper1
365:                     _wait_eedata();
002E0A  803B05     MOV NVMCON, W5
002E0C  280004     MOV #0x8000, W4
002E0E  628204     AND W5, W4, W4
002E10  520FE0     SUB W4, #0x0, [W15]
002E12  3AFFFB     BRA NZ, 0x2E0A
366:                     _write_eedata_row(EE_address_ps_magnet_config_in_EEPROM, ps_magnet_config_ram_copy);
002E14  80B704     MOV EE_address_ps_magnet_config_in_EEPROM, W4
002E16  80B715     MOV 0x16E2, W5
002E18  216E42     MOV #0x16E4, W2
002E1A  BE0004     MOV.D W4, W0
002E1C  07EA19     RCALL __eedata_helper4
367:                     break;
002E1E  37018F     BRA 0x313E
368:               
369:                   case CMD_SET_FILAMENT_PS_CAL_DATA:
370:                     ps_filament_config_ram_copy[command_string.register_byte] = data_word;
002E20  218A74     MOV #0x18A7, W4
002E22  784214     MOV.B [W4], W4
002E24  FB8204     ZE W4, W4
002E26  90029E     MOV [W14+2], W5
002E28  420304     ADD W4, W4, W6
002E2A  217084     MOV #0x1708, W4
002E2C  430204     ADD W6, W4, W4
002E2E  780A05     MOV W5, [W4]
371:                     break;
002E30  370186     BRA 0x313E
372:                     
373:                   case CMD_READ_FILAMENT_PS_CAL_DATA:
374:                     return_data_word = ps_filament_config_ram_copy[command_string.register_byte];
002E32  218A74     MOV #0x18A7, W4
002E34  784214     MOV.B [W4], W4
002E36  FB8204     ZE W4, W4
002E38  420284     ADD W4, W4, W5
002E3A  217084     MOV #0x1708, W4
002E3C  428204     ADD W5, W4, W4
002E3E  780214     MOV [W4], W4
002E40  780F04     MOV W4, [W14]
375:                     break;
002E42  37017D     BRA 0x313E
376:                     
377:                   case CMD_SAVE_FILAMENT_PS_CAL_DATA_TO_EEPROM:
378:                     _wait_eedata();
002E44  803B05     MOV NVMCON, W5
002E46  280004     MOV #0x8000, W4
002E48  628204     AND W5, W4, W4
002E4A  520FE0     SUB W4, #0x0, [W15]
002E4C  3AFFFB     BRA NZ, 0x2E44
379:                     _erase_eedata(EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
002E4E  80B824     MOV EE_address_ps_filament_config_in_EEPROM, W4
002E50  80B835     MOV 0x1706, W5
002E52  200202     MOV #0x20, W2
002E54  BE0004     MOV.D W4, W0
002E56  07E9DD     RCALL __eedata_helper1
380:                     _wait_eedata();
002E58  803B05     MOV NVMCON, W5
002E5A  280004     MOV #0x8000, W4
002E5C  628204     AND W5, W4, W4
002E5E  520FE0     SUB W4, #0x0, [W15]
002E60  3AFFFB     BRA NZ, 0x2E58
381:                     _write_eedata_row(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_ram_copy);
002E62  80B824     MOV EE_address_ps_filament_config_in_EEPROM, W4
002E64  80B835     MOV 0x1706, W5
002E66  217082     MOV #0x1708, W2
002E68  BE0004     MOV.D W4, W0
002E6A  07E9F2     RCALL __eedata_helper4
382:                     break;
002E6C  370168     BRA 0x313E
383:               
384:                   case CMD_SET_THYR_CATHODE_PS_CAL_DATA:
385:                     ps_thyr_cathode_htr_config_ram_copy[command_string.register_byte] = data_word;
002E6E  218A74     MOV #0x18A7, W4
002E70  784214     MOV.B [W4], W4
002E72  FB8204     ZE W4, W4
002E74  90029E     MOV [W14+2], W5
002E76  420304     ADD W4, W4, W6
002E78  2172C4     MOV #0x172C, W4
002E7A  430204     ADD W6, W4, W4
002E7C  780A05     MOV W5, [W4]
386:                     break;
002E7E  37015F     BRA 0x313E
387:                     
388:                   case CMD_READ_THYR_CATHODE_PS_CAL_DATA:
389:                     return_data_word = ps_thyr_cathode_htr_config_ram_copy[command_string.register_byte];
002E80  218A74     MOV #0x18A7, W4
002E82  784214     MOV.B [W4], W4
002E84  FB8204     ZE W4, W4
002E86  420284     ADD W4, W4, W5
002E88  2172C4     MOV #0x172C, W4
002E8A  428204     ADD W5, W4, W4
002E8C  780214     MOV [W4], W4
002E8E  780F04     MOV W4, [W14]
390:                     break;
002E90  370156     BRA 0x313E
391:                     
392:                   case CMD_SAVE_THYR_CATHODE_PS_CAL_DATA_TO_EEPROM:
393:                     _wait_eedata();
002E92  803B05     MOV NVMCON, W5
002E94  280004     MOV #0x8000, W4
002E96  628204     AND W5, W4, W4
002E98  520FE0     SUB W4, #0x0, [W15]
002E9A  3AFFFB     BRA NZ, 0x2E92
394:                     _erase_eedata(EE_address_ps_thyr_cathode_htr_config_in_EEPROM, _EE_ROW);
002E9C  80B944     MOV EE_address_ps_thyr_cathode_htr_config_in_EEPROM, W4
002E9E  80B955     MOV 0x172A, W5
002EA0  200202     MOV #0x20, W2
002EA2  BE0004     MOV.D W4, W0
002EA4  07E9B6     RCALL __eedata_helper1
395:                     _wait_eedata();
002EA6  803B05     MOV NVMCON, W5
002EA8  280004     MOV #0x8000, W4
002EAA  628204     AND W5, W4, W4
002EAC  520FE0     SUB W4, #0x0, [W15]
002EAE  3AFFFB     BRA NZ, 0x2EA6
396:                     _write_eedata_row(EE_address_ps_thyr_cathode_htr_config_in_EEPROM, ps_thyr_cathode_htr_config_ram_copy);
002EB0  80B944     MOV EE_address_ps_thyr_cathode_htr_config_in_EEPROM, W4
002EB2  80B955     MOV 0x172A, W5
002EB4  2172C2     MOV #0x172C, W2
002EB6  BE0004     MOV.D W4, W0
002EB8  07E9CB     RCALL __eedata_helper4
397:                     break;
002EBA  370141     BRA 0x313E
398:               
399:                   case CMD_SET_THYR_RESERVOIR_PS_CAL_DATA:
400:                     ps_thyr_reservoir_htr_config_ram_copy[command_string.register_byte] = data_word;
002EBC  218A74     MOV #0x18A7, W4
002EBE  784214     MOV.B [W4], W4
002EC0  FB8204     ZE W4, W4
002EC2  90029E     MOV [W14+2], W5
002EC4  420304     ADD W4, W4, W6
002EC6  217504     MOV #0x1750, W4
002EC8  430204     ADD W6, W4, W4
002ECA  780A05     MOV W5, [W4]
401:                     break;
002ECC  370138     BRA 0x313E
402:                     
403:                   case CMD_READ_THYR_RESERVOIR_PS_CAL_DATA:
404:                     return_data_word = ps_thyr_reservoir_htr_config_ram_copy[command_string.register_byte];
002ECE  218A74     MOV #0x18A7, W4
002ED0  784214     MOV.B [W4], W4
002ED2  FB8204     ZE W4, W4
002ED4  420284     ADD W4, W4, W5
002ED6  217504     MOV #0x1750, W4
002ED8  428204     ADD W5, W4, W4
002EDA  780214     MOV [W4], W4
002EDC  780F04     MOV W4, [W14]
405:                     break;
002EDE  37012F     BRA 0x313E
406:                     
407:                   case CMD_SAVE_THYR_RESERVOIR_PS_CAL_DATA_TO_EEPROM:
408:                     _wait_eedata();
002EE0  803B05     MOV NVMCON, W5
002EE2  280004     MOV #0x8000, W4
002EE4  628204     AND W5, W4, W4
002EE6  520FE0     SUB W4, #0x0, [W15]
002EE8  3AFFFB     BRA NZ, 0x2EE0
409:                     _erase_eedata(EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, _EE_ROW);
002EEA  80BA64     MOV EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, W4
002EEC  80BA75     MOV 0x174E, W5
002EEE  200202     MOV #0x20, W2
002EF0  BE0004     MOV.D W4, W0
002EF2  07E98F     RCALL __eedata_helper1
410:                     _wait_eedata();
002EF4  803B05     MOV NVMCON, W5
002EF6  280004     MOV #0x8000, W4
002EF8  628204     AND W5, W4, W4
002EFA  520FE0     SUB W4, #0x0, [W15]
002EFC  3AFFFB     BRA NZ, 0x2EF4
411:                     _write_eedata_row(EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, ps_thyr_reservoir_htr_config_ram_copy);
002EFE  80BA64     MOV EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, W4
002F00  80BA75     MOV 0x174E, W5
002F02  217502     MOV #0x1750, W2
002F04  BE0004     MOV.D W4, W0
002F06  07E9A4     RCALL __eedata_helper4
412:                     break;
002F08  37011A     BRA 0x313E
413:               
414:                   case CMD_SET_HV_LAMBDA_MODE_A_CAL_DATA:
415:                     ps_hv_lambda_mode_A_config_ram_copy[command_string.register_byte] = data_word;
002F0A  218A74     MOV #0x18A7, W4
002F0C  784214     MOV.B [W4], W4
002F0E  FB8204     ZE W4, W4
002F10  90029E     MOV [W14+2], W5
002F12  420304     ADD W4, W4, W6
002F14  217744     MOV #0x1774, W4
002F16  430204     ADD W6, W4, W4
002F18  780A05     MOV W5, [W4]
416:                     break;
002F1A  370111     BRA 0x313E
417:                     
418:                   case CMD_READ_HV_LAMBDA_MODE_A_CAL_DATA:
419:                     return_data_word = ps_hv_lambda_mode_A_config_ram_copy[command_string.register_byte];
002F1C  218A74     MOV #0x18A7, W4
002F1E  784214     MOV.B [W4], W4
002F20  FB8204     ZE W4, W4
002F22  420284     ADD W4, W4, W5
002F24  217744     MOV #0x1774, W4
002F26  428204     ADD W5, W4, W4
002F28  780214     MOV [W4], W4
002F2A  780F04     MOV W4, [W14]
420:                     break;
002F2C  370108     BRA 0x313E
421:                     
422:                   case CMD_SAVE_HV_LAMBDA_MODE_A_CAL_DATA_TO_EEPROM:
423:                     _wait_eedata();
002F2E  803B05     MOV NVMCON, W5
002F30  280004     MOV #0x8000, W4
002F32  628204     AND W5, W4, W4
002F34  520FE0     SUB W4, #0x0, [W15]
002F36  3AFFFB     BRA NZ, 0x2F2E
424:                     _erase_eedata(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, _EE_ROW);
002F38  80BB84     MOV EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, W4
002F3A  80BB95     MOV 0x1772, W5
002F3C  200202     MOV #0x20, W2
002F3E  BE0004     MOV.D W4, W0
002F40  07E968     RCALL __eedata_helper1
425:                     _wait_eedata();
002F42  803B05     MOV NVMCON, W5
002F44  280004     MOV #0x8000, W4
002F46  628204     AND W5, W4, W4
002F48  520FE0     SUB W4, #0x0, [W15]
002F4A  3AFFFB     BRA NZ, 0x2F42
426:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, ps_hv_lambda_mode_A_config_ram_copy);
002F4C  80BB84     MOV EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, W4
002F4E  80BB95     MOV 0x1772, W5
002F50  217742     MOV #0x1774, W2
002F52  BE0004     MOV.D W4, W0
002F54  07E97D     RCALL __eedata_helper4
427:                     break;
002F56  3700F3     BRA 0x313E
428:               
429:                   case CMD_SET_HV_LAMBDA_MODE_B_CAL_DATA:
430:                     ps_hv_lambda_mode_B_config_ram_copy[command_string.register_byte] = data_word;
002F58  218A74     MOV #0x18A7, W4
002F5A  784214     MOV.B [W4], W4
002F5C  FB8204     ZE W4, W4
002F5E  90029E     MOV [W14+2], W5
002F60  420304     ADD W4, W4, W6
002F62  217984     MOV #0x1798, W4
002F64  430204     ADD W6, W4, W4
002F66  780A05     MOV W5, [W4]
431:                     break;
002F68  3700EA     BRA 0x313E
432:                     
433:                   case CMD_READ_HV_LAMBDA_MODE_B_CAL_DATA:
434:                     return_data_word = ps_hv_lambda_mode_B_config_ram_copy[command_string.register_byte];
002F6A  218A74     MOV #0x18A7, W4
002F6C  784214     MOV.B [W4], W4
002F6E  FB8204     ZE W4, W4
002F70  420284     ADD W4, W4, W5
002F72  217984     MOV #0x1798, W4
002F74  428204     ADD W5, W4, W4
002F76  780214     MOV [W4], W4
002F78  780F04     MOV W4, [W14]
435:                     break;
002F7A  3700E1     BRA 0x313E
436:                     
437:                   case CMD_SAVE_HV_LAMBDA_MODE_B_CAL_DATA_TO_EEPROM:
438:                     _wait_eedata();
002F7C  803B05     MOV NVMCON, W5
002F7E  280004     MOV #0x8000, W4
002F80  628204     AND W5, W4, W4
002F82  520FE0     SUB W4, #0x0, [W15]
002F84  3AFFFB     BRA NZ, 0x2F7C
439:                     _erase_eedata(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, _EE_ROW);
002F86  80BCA4     MOV EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, W4
002F88  80BCB5     MOV 0x1796, W5
002F8A  200202     MOV #0x20, W2
002F8C  BE0004     MOV.D W4, W0
002F8E  07E941     RCALL __eedata_helper1
440:                     _wait_eedata();
002F90  803B05     MOV NVMCON, W5
002F92  280004     MOV #0x8000, W4
002F94  628204     AND W5, W4, W4
002F96  520FE0     SUB W4, #0x0, [W15]
002F98  3AFFFB     BRA NZ, 0x2F90
441:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, ps_hv_lambda_mode_B_config_ram_copy);
002F9A  80BCA4     MOV EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, W4
002F9C  80BCB5     MOV 0x1796, W5
002F9E  217982     MOV #0x1798, W2
002FA0  BE0004     MOV.D W4, W0
002FA2  07E956     RCALL __eedata_helper4
442:                     break;
002FA4  3700CC     BRA 0x313E
443:               
444:                   case CMD_SET_MAGNETRON_MODE_A_CAL_DATA:
445:                     ps_magnetron_mode_A_config_ram_copy[command_string.register_byte] = data_word;
002FA6  218A74     MOV #0x18A7, W4
002FA8  784214     MOV.B [W4], W4
002FAA  FB8204     ZE W4, W4
002FAC  90029E     MOV [W14+2], W5
002FAE  420304     ADD W4, W4, W6
002FB0  217BC4     MOV #0x17BC, W4
002FB2  430204     ADD W6, W4, W4
002FB4  780A05     MOV W5, [W4]
446:                     break;
002FB6  3700C3     BRA 0x313E
447:                     
448:                   case CMD_READ_MAGNETRON_MODE_A_CAL_DATA:
449:                     return_data_word = ps_magnetron_mode_A_config_ram_copy[command_string.register_byte];
002FB8  218A74     MOV #0x18A7, W4
002FBA  784214     MOV.B [W4], W4
002FBC  FB8204     ZE W4, W4
002FBE  420284     ADD W4, W4, W5
002FC0  217BC4     MOV #0x17BC, W4
002FC2  428204     ADD W5, W4, W4
002FC4  780214     MOV [W4], W4
002FC6  780F04     MOV W4, [W14]
450:                     break;
002FC8  3700BA     BRA 0x313E
451:                     
452:                   case CMD_SAVE_MAGNETRON_MODE_A_CAL_DATA_TO_EEPROM:
453:                     _wait_eedata();
002FCA  803B05     MOV NVMCON, W5
002FCC  280004     MOV #0x8000, W4
002FCE  628204     AND W5, W4, W4
002FD0  520FE0     SUB W4, #0x0, [W15]
002FD2  3AFFFB     BRA NZ, 0x2FCA
454:                     _erase_eedata(EE_address_ps_magnetron_mode_A_config_in_EEPROM, _EE_ROW);
002FD4  80BDC4     MOV EE_address_ps_magnetron_mode_A_config_in_EEPROM, W4
002FD6  80BDD5     MOV 0x17BA, W5
002FD8  200202     MOV #0x20, W2
002FDA  BE0004     MOV.D W4, W0
002FDC  07E91A     RCALL __eedata_helper1
455:                     _wait_eedata();
002FDE  803B05     MOV NVMCON, W5
002FE0  280004     MOV #0x8000, W4
002FE2  628204     AND W5, W4, W4
002FE4  520FE0     SUB W4, #0x0, [W15]
002FE6  3AFFFB     BRA NZ, 0x2FDE
456:                     _write_eedata_row(EE_address_ps_magnetron_mode_A_config_in_EEPROM, ps_magnetron_mode_A_config_ram_copy);
002FE8  80BDC4     MOV EE_address_ps_magnetron_mode_A_config_in_EEPROM, W4
002FEA  80BDD5     MOV 0x17BA, W5
002FEC  217BC2     MOV #0x17BC, W2
002FEE  BE0004     MOV.D W4, W0
002FF0  07E92F     RCALL __eedata_helper4
457:                     break;
002FF2  3700A5     BRA 0x313E
458:               
459:                   case CMD_SET_MAGNETRON_MODE_B_CAL_DATA:
460:                     ps_magnetron_mode_B_config_ram_copy[command_string.register_byte] = data_word;
002FF4  218A74     MOV #0x18A7, W4
002FF6  784214     MOV.B [W4], W4
002FF8  FB8204     ZE W4, W4
002FFA  90029E     MOV [W14+2], W5
002FFC  420304     ADD W4, W4, W6
002FFE  217E04     MOV #0x17E0, W4
003000  430204     ADD W6, W4, W4
003002  780A05     MOV W5, [W4]
461:                     break;
003004  37009C     BRA 0x313E
462:                     
463:                   case CMD_READ_MAGNETRON_MODE_B_CAL_DATA:
464:                     return_data_word = ps_magnetron_mode_B_config_ram_copy[command_string.register_byte];
003006  218A74     MOV #0x18A7, W4
003008  784214     MOV.B [W4], W4
00300A  FB8204     ZE W4, W4
00300C  420284     ADD W4, W4, W5
00300E  217E04     MOV #0x17E0, W4
003010  428204     ADD W5, W4, W4
003012  780214     MOV [W4], W4
003014  780F04     MOV W4, [W14]
465:                     break;
003016  370093     BRA 0x313E
466:                     
467:                   case CMD_SAVE_MAGNETRON_MODE_B_CAL_DATA_TO_EEPROM:
468:                     _wait_eedata();
003018  803B05     MOV NVMCON, W5
00301A  280004     MOV #0x8000, W4
00301C  628204     AND W5, W4, W4
00301E  520FE0     SUB W4, #0x0, [W15]
003020  3AFFFB     BRA NZ, 0x3018
469:                     _erase_eedata(EE_address_ps_magnetron_mode_B_config_in_EEPROM, _EE_ROW);
003022  80BEE4     MOV EE_address_ps_magnetron_mode_B_config_in_EEPROM, W4
003024  80BEF5     MOV 0x17DE, W5
003026  200202     MOV #0x20, W2
003028  BE0004     MOV.D W4, W0
00302A  07E8F3     RCALL __eedata_helper1
470:                     _wait_eedata();
00302C  803B05     MOV NVMCON, W5
00302E  280004     MOV #0x8000, W4
003030  628204     AND W5, W4, W4
003032  520FE0     SUB W4, #0x0, [W15]
003034  3AFFFB     BRA NZ, 0x302C
471:                     _write_eedata_row(EE_address_ps_magnetron_mode_B_config_in_EEPROM, ps_magnetron_mode_B_config_ram_copy);
003036  80BEE4     MOV EE_address_ps_magnetron_mode_B_config_in_EEPROM, W4
003038  80BEF5     MOV 0x17DE, W5
00303A  217E02     MOV #0x17E0, W2
00303C  BE0004     MOV.D W4, W0
00303E  07E908     RCALL __eedata_helper4
472:                     break;
003040  37007E     BRA 0x313E
473:               
474:                   case CMD_SET_CNTRL_CAL_DATA:
475:                     control_loop_cal_data_ram_copy[command_string.register_byte] = data_word;
003042  218A74     MOV #0x18A7, W4
003044  784214     MOV.B [W4], W4
003046  FB8204     ZE W4, W4
003048  90029E     MOV [W14+2], W5
00304A  420304     ADD W4, W4, W6
00304C  218284     MOV #0x1828, W4
00304E  430204     ADD W6, W4, W4
003050  780A05     MOV W5, [W4]
476:                     break;
003052  370075     BRA 0x313E
477:               
478:                   case CMD_READ_CNTRL_CAL_DATA:
479:                     return_data_word = control_loop_cal_data_ram_copy[command_string.register_byte];
003054  218A74     MOV #0x18A7, W4
003056  784214     MOV.B [W4], W4
003058  FB8204     ZE W4, W4
00305A  420284     ADD W4, W4, W5
00305C  218284     MOV #0x1828, W4
00305E  428204     ADD W5, W4, W4
003060  780214     MOV [W4], W4
003062  780F04     MOV W4, [W14]
480:                     break;
003064  37006C     BRA 0x313E
481:                     
482:                   case CMD_SAVE_CNTRL_CAL_DATA_TO_EEPROM:
483:                     _wait_eedata();
003066  803B05     MOV NVMCON, W5
003068  280004     MOV #0x8000, W4
00306A  628204     AND W5, W4, W4
00306C  520FE0     SUB W4, #0x0, [W15]
00306E  3AFFFB     BRA NZ, 0x3066
484:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
003070  80C124     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003072  80C135     MOV 0x1826, W5
003074  200202     MOV #0x20, W2
003076  BE0004     MOV.D W4, W0
003078  07E8CC     RCALL __eedata_helper1
485:                     _wait_eedata();
00307A  803B05     MOV NVMCON, W5
00307C  280004     MOV #0x8000, W4
00307E  628204     AND W5, W4, W4
003080  520FE0     SUB W4, #0x0, [W15]
003082  3AFFFB     BRA NZ, 0x307A
486:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);
003084  80C124     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003086  80C135     MOV 0x1826, W5
003088  218282     MOV #0x1828, W2
00308A  BE0004     MOV.D W4, W0
00308C  07E8E1     RCALL __eedata_helper4
487:                     break;
00308E  370057     BRA 0x313E
488:               
489:               
490:               
491:                   case CMD_SET_MAGNETRON_FILAMENT_CURRENT:
492:                     itemp = data_word;
003090  90021E     MOV [W14+2], W4
003092  980734     MOV W4, [W14+6]
493:                     vtemp = GenerateFilamentVprog(itemp);
003094  90003E     MOV [W14+6], W0
003096  070369     RCALL GenerateFilamentVprog
003098  780200     MOV W0, W4
00309A  980744     MOV W4, [W14+8]
494:                     SetPowerSupplyTarget(&ps_filament, vtemp, itemp);
00309C  90013E     MOV [W14+6], W2
00309E  9000CE     MOV [W14+8], W1
0030A0  20ABC0     MOV #0xABC, W0
0030A2  07F205     RCALL SetPowerSupplyTarget
495:                     ps_filament_config_ram_copy[EEPROM_V_SET_POINT] = ps_filament.v_command_set_point;
0030A4  8055F4     MOV 0xABE, W4
0030A6  88B844     MOV W4, ps_filament_config_ram_copy
496:                     ps_filament_config_ram_copy[EEPROM_I_SET_POINT] = ps_filament.i_command_set_point;
0030A8  805754     MOV 0xAEA, W4
0030AA  88B894     MOV W4, 0x1712
497:                     _wait_eedata();
0030AC  803B05     MOV NVMCON, W5
0030AE  280004     MOV #0x8000, W4
0030B0  628204     AND W5, W4, W4
0030B2  520FE0     SUB W4, #0x0, [W15]
0030B4  3AFFFB     BRA NZ, 0x30AC
498:                     _erase_eedata(EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
0030B6  80B824     MOV EE_address_ps_filament_config_in_EEPROM, W4
0030B8  80B835     MOV 0x1706, W5
0030BA  200202     MOV #0x20, W2
0030BC  BE0004     MOV.D W4, W0
0030BE  07E8A9     RCALL __eedata_helper1
499:                     _wait_eedata();
0030C0  803B05     MOV NVMCON, W5
0030C2  280004     MOV #0x8000, W4
0030C4  628204     AND W5, W4, W4
0030C6  520FE0     SUB W4, #0x0, [W15]
0030C8  3AFFFB     BRA NZ, 0x30C0
500:                     _write_eedata_row(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_ram_copy);
0030CA  80B824     MOV EE_address_ps_filament_config_in_EEPROM, W4
0030CC  80B835     MOV 0x1706, W5
0030CE  217082     MOV #0x1708, W2
0030D0  BE0004     MOV.D W4, W0
0030D2  07E8BE     RCALL __eedata_helper4
501:                     break;
0030D4  370034     BRA 0x313E
502:               
503:                   case CMD_SET_MAGNETRON_FILAMENT_VOLTAGE:
504:                     vtemp = data_word;
0030D6  90001E     MOV [W14+2], W0
0030D8  980740     MOV W0, [W14+8]
505:                     itemp = GenerateFilamentIprog(vtemp);
0030DA  90004E     MOV [W14+8], W0
0030DC  07033B     RCALL GenerateFilamentIprog
0030DE  780200     MOV W0, W4
0030E0  980734     MOV W4, [W14+6]
506:                     SetPowerSupplyTarget(&ps_filament, vtemp, itemp);
0030E2  90013E     MOV [W14+6], W2
0030E4  9000CE     MOV [W14+8], W1
0030E6  20ABC0     MOV #0xABC, W0
0030E8  07F1E2     RCALL SetPowerSupplyTarget
507:                     ps_filament_config_ram_copy[EEPROM_V_SET_POINT] = ps_filament.v_command_set_point;
0030EA  8055F4     MOV 0xABE, W4
0030EC  88B844     MOV W4, ps_filament_config_ram_copy
508:                     ps_filament_config_ram_copy[EEPROM_I_SET_POINT] = ps_filament.i_command_set_point;
0030EE  805754     MOV 0xAEA, W4
0030F0  88B894     MOV W4, 0x1712
509:                     _wait_eedata();
0030F2  803B05     MOV NVMCON, W5
0030F4  280004     MOV #0x8000, W4
0030F6  628204     AND W5, W4, W4
0030F8  520FE0     SUB W4, #0x0, [W15]
0030FA  3AFFFB     BRA NZ, 0x30F2
510:                     _erase_eedata(EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
0030FC  80B824     MOV EE_address_ps_filament_config_in_EEPROM, W4
0030FE  80B835     MOV 0x1706, W5
003100  200202     MOV #0x20, W2
003102  BE0004     MOV.D W4, W0
003104  07E886     RCALL __eedata_helper1
511:                     _wait_eedata();
003106  803B05     MOV NVMCON, W5
003108  280004     MOV #0x8000, W4
00310A  628204     AND W5, W4, W4
00310C  520FE0     SUB W4, #0x0, [W15]
00310E  3AFFFB     BRA NZ, 0x3106
512:                     _write_eedata_row(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_ram_copy);
003110  80B824     MOV EE_address_ps_filament_config_in_EEPROM, W4
003112  80B835     MOV 0x1706, W5
003114  217082     MOV #0x1708, W2
003116  BE0004     MOV.D W4, W0
003118  07E89B     RCALL __eedata_helper4
513:                     break;
00311A  370011     BRA 0x313E
514:               
515:                   case CMD_CLEAR_PROCESSOR_RESET_DATA:
516:                     // DPARKER using this command to reset "reset data"
517:                     debug_status_register = 0;
00311C  EB0200     CLR W4
00311E  88C2F4     MOV W4, debug_status_register
518:                     _POR = 0;
003120  A90740     BCLR RCON, #0
519:                     _EXTR = 0;
003122  A9E740     BCLR RCON, #7
520:                     _SWR = 0;
003124  A9C740     BCLR RCON, #6
521:                     _BOR = 0;
003126  A92740     BCLR RCON, #1
522:                     _TRAPR = 0;
003128  A9E741     BCLR 0x741, #7
523:                     _WDTO = 0;
00312A  A98740     BCLR RCON, #4
524:                     _IOPUWR = 0;
00312C  A9C741     BCLR 0x741, #6
525:                     last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
00312E  EB0200     CLR W4
003130  88C5A4     MOV W4, last_known_action
526:                     processor_crash_count = 0;
003132  EB0200     CLR W4
003134  88C5C4     MOV W4, processor_crash_count
527:                     break;
003136  370003     BRA 0x313E
528:               
529:               
530:                   }
531:                 
532:                 // Echo the command that was recieved back to the controller
533:                 SendCommand(return_command_byte, command_string.register_byte, return_data_word);
00313E  218A75     MOV #0x18A7, W5
003140  784295     MOV.B [W5], W5
003142  90022E     MOV [W14+4], W4
003144  784204     MOV.B W4, W4
003146  78011E     MOV [W14], W2
003148  784085     MOV.B W5, W1
00314A  784004     MOV.B W4, W0
00314C  07FC78     RCALL SendCommand
534:                 
535:                 command_string.data_state = COMMAND_BUFFER_EMPTY;
00314E  EB4200     CLR.B W4
003150  784004     MOV.B W4, W0
003152  B7F8AA     MOV.B WREG, 0x18AA
536:               }
003154  FA8000     ULNK
003156  060000     RETURN
537:               
538:               
539:               
540:               unsigned int ReadFromRam(unsigned int ram_location) {
003158  FA0010     LNK #0x10
00315A  BE9F88     MOV.D W8, [W15++]
00315C  BE9F8A     MOV.D W10, [W15++]
00315E  980770     MOV W0, [W14+14]
541:                 unsigned long temp_long;
542:                 unsigned int data_return;
543:                 unsigned long long int temp_long_long;
544:                 switch (ram_location) 
003160  90027E     MOV [W14+14], W4
003162  B82361     MUL.UU W4, #1, W6
003164  EB8200     SETM W4
003166  EB8280     SETM W5
003168  420206     ADD W4, W6, W4
00316A  4A8287     ADDC W5, W7, W5
00316C  200B26     MOV #0xB2, W6
00316E  200007     MOV #0x0, W7
003170  520F86     SUB W4, W6, [W15]
003172  5A8F87     SUBB W5, W7, [W15]
003174  3E0267     BRA GTU, 0x3644
003176  016004     BRA W4
003178  370216     BRA 0x35A6
00317A  37021A     BRA 0x35B0
00317C  37021C     BRA 0x35B6
00317E  370220     BRA 0x35C0
003180  370222     BRA 0x35C6
003182  370260     BRA 0x3644
003184  37025F     BRA 0x3644
003186  37025E     BRA 0x3644
003188  37025D     BRA 0x3644
00318A  37025C     BRA 0x3644
00318C  37025B     BRA 0x3644
00318E  37025A     BRA 0x3644
003190  370259     BRA 0x3644
003192  370258     BRA 0x3644
003194  370257     BRA 0x3644
003196  3700D1     BRA 0x333A
003198  3700CD     BRA 0x3334
00319A  3700D9     BRA 0x334E
00319C  3700D5     BRA 0x3348
00319E  370252     BRA 0x3644
0031A0  370251     BRA 0x3644
0031A2  370250     BRA 0x3644
0031A4  37024F     BRA 0x3644
0031A6  37024E     BRA 0x3644
0031A8  37024D     BRA 0x3644
0031AA  37024C     BRA 0x3644
0031AC  37024B     BRA 0x3644
0031AE  37024A     BRA 0x3644
0031B0  370249     BRA 0x3644
0031B2  370248     BRA 0x3644
0031B4  370247     BRA 0x3644
0031B6  3700A4     BRA 0x3300
0031B8  3700B1     BRA 0x331C
0031BA  3700A9     BRA 0x330E
0031BC  3700B2     BRA 0x3322
0031BE  370242     BRA 0x3644
0031C0  370241     BRA 0x3644
0031C2  370240     BRA 0x3644
0031C4  37023F     BRA 0x3644
0031C6  37023E     BRA 0x3644
0031C8  37023D     BRA 0x3644
0031CA  37023C     BRA 0x3644
0031CC  37023B     BRA 0x3644
0031CE  37023A     BRA 0x3644
0031D0  370239     BRA 0x3644
0031D2  370238     BRA 0x3644
0031D4  370237     BRA 0x3644
0031D6  37008A     BRA 0x32EC
0031D8  370090     BRA 0x32FA
0031DA  370081     BRA 0x32DE
0031DC  370233     BRA 0x3644
0031DE  370232     BRA 0x3644
0031E0  370231     BRA 0x3644
0031E2  370230     BRA 0x3644
0031E4  37022F     BRA 0x3644
0031E6  37022E     BRA 0x3644
0031E8  37022D     BRA 0x3644
0031EA  37022C     BRA 0x3644
0031EC  37022B     BRA 0x3644
0031EE  37022A     BRA 0x3644
0031F0  370229     BRA 0x3644
0031F2  370228     BRA 0x3644
0031F4  370227     BRA 0x3644
0031F6  370098     BRA 0x3328
0031F8  370225     BRA 0x3644
0031FA  370224     BRA 0x3644
0031FC  370223     BRA 0x3644
0031FE  370222     BRA 0x3644
003200  370221     BRA 0x3644
003202  370220     BRA 0x3644
003204  37021F     BRA 0x3644
003206  370093     BRA 0x332E
003208  37021D     BRA 0x3644
00320A  37021C     BRA 0x3644
00320C  37021B     BRA 0x3644
00320E  37021A     BRA 0x3644
003210  370219     BRA 0x3644
003212  370218     BRA 0x3644
003214  370217     BRA 0x3644
003216  3700F6     BRA 0x3404
003218  3700FC     BRA 0x3412
00321A  370214     BRA 0x3644
00321C  370213     BRA 0x3644
00321E  370212     BRA 0x3644
003220  370211     BRA 0x3644
003222  3700FE     BRA 0x3420
003224  37010A     BRA 0x343A
003226  370110     BRA 0x3448
003228  370112     BRA 0x344E
00322A  370125     BRA 0x3476
00322C  370138     BRA 0x349E
00322E  37014C     BRA 0x34C8
003230  370155     BRA 0x34DC
003232  370161     BRA 0x34F6
003234  370207     BRA 0x3644
003236  370179     BRA 0x352A
003238  37017B     BRA 0x3530
00323A  37017D     BRA 0x3536
00323C  37017F     BRA 0x353C
00323E  370185     BRA 0x354A
003240  370201     BRA 0x3644
003242  370200     BRA 0x3644
003244  3701FF     BRA 0x3644
003246  3701FE     BRA 0x3644
003248  3701FD     BRA 0x3644
00324A  3701FC     BRA 0x3644
00324C  3701FB     BRA 0x3644
00324E  3701FA     BRA 0x3644
003250  3701F9     BRA 0x3644
003252  3701F8     BRA 0x3644
003254  3701F7     BRA 0x3644
003256  370082     BRA 0x335C
003258  370088     BRA 0x336A
00325A  37008E     BRA 0x3378
00325C  370094     BRA 0x3386
00325E  37009A     BRA 0x3394
003260  3700A0     BRA 0x33A2
003262  3701F0     BRA 0x3644
003264  3701EF     BRA 0x3644
003266  3700A4     BRA 0x33B0
003268  3700AA     BRA 0x33BE
00326A  3700B0     BRA 0x33CC
00326C  3700B6     BRA 0x33DA
00326E  3700BC     BRA 0x33E8
003270  3700C2     BRA 0x33F6
003272  3701E8     BRA 0x3644
003274  3701E7     BRA 0x3644
003276  3701E6     BRA 0x3644
003278  3701E5     BRA 0x3644
00327A  3701E4     BRA 0x3644
00327C  3701E3     BRA 0x3644
00327E  3701E2     BRA 0x3644
003280  3701E1     BRA 0x3644
003282  3701E0     BRA 0x3644
003284  3701DF     BRA 0x3644
003286  3701DE     BRA 0x3644
003288  3701DD     BRA 0x3644
00328A  3701DC     BRA 0x3644
00328C  3701DB     BRA 0x3644
00328E  3701DA     BRA 0x3644
003290  3701D9     BRA 0x3644
003292  3701D8     BRA 0x3644
003294  3701D7     BRA 0x3644
003296  370160     BRA 0x3558
003298  370162     BRA 0x355E
00329A  370164     BRA 0x3564
00329C  370166     BRA 0x356A
00329E  370168     BRA 0x3570
0032A0  37016A     BRA 0x3576
0032A2  37016C     BRA 0x357C
0032A4  37016E     BRA 0x3582
0032A6  370170     BRA 0x3588
0032A8  370172     BRA 0x358E
0032AA  370174     BRA 0x3594
0032AC  370176     BRA 0x359A
0032AE  370178     BRA 0x35A0
0032B0  3701C9     BRA 0x3644
0032B2  3701C8     BRA 0x3644
0032B4  3701C7     BRA 0x3644
0032B6  37018A     BRA 0x35CC
0032B8  37018C     BRA 0x35D2
0032BA  37018E     BRA 0x35D8
0032BC  370190     BRA 0x35DE
0032BE  370192     BRA 0x35E4
0032C0  370194     BRA 0x35EA
0032C2  370196     BRA 0x35F0
0032C4  370198     BRA 0x35F6
0032C6  37019A     BRA 0x35FC
0032C8  3701A2     BRA 0x360E
0032CA  3701AD     BRA 0x3626
0032CC  3701A9     BRA 0x3620
0032CE  3701A5     BRA 0x361A
0032D0  3701A1     BRA 0x3614
0032D2  370197     BRA 0x3602
0032D4  370199     BRA 0x3608
0032D6  3701AA     BRA 0x362C
0032D8  3701AC     BRA 0x3632
0032DA  3701AE     BRA 0x3638
0032DC  3701B0     BRA 0x363E
545:                   {
546:               
547:                     // Magnet Supply Data
548:                   case RAM_READ_MAGNETRON_MAGNET_VOLTAGE_ADC:
549:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnet, ps_magnet.v_adc_reading);
0032DE  805394     MOV 0xA72, W4
0032E0  780084     MOV W4, W1
0032E2  20A620     MOV #0xA62, W0
0032E4  07024D     RCALL ReturnPowerSupplyADCScaledVoltage
0032E6  780200     MOV W0, W4
0032E8  780F04     MOV W4, [W14]
550:                     break;
0032EA  3701AC     BRA 0x3644
551:                     
552:                   case RAM_READ_MAGNETRON_MAGNET_CURRENT_ADC:
553:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnet, ps_magnet.i_adc_reading);
0032EC  8054F4     MOV 0xA9E, W4
0032EE  780084     MOV W4, W1
0032F0  20A620     MOV #0xA62, W0
0032F2  07027C     RCALL ReturnPowerSupplyADCScaledCurrent
0032F4  780200     MOV W0, W4
0032F6  780F04     MOV W4, [W14]
554:                     break;
0032F8  3701A5     BRA 0x3644
555:                     
556:                   case RAM_READ_MAGNETRON_MAGNET_CURRENT_SET_POINT:
557:                     data_return = ps_magnet.i_command_set_point;
0032FA  805481     MOV 0xA90, W1
0032FC  780F01     MOV W1, [W14]
558:                     break;
0032FE  3701A2     BRA 0x3644
559:               
560:               
561:                     // Filament Supply Data
562:                   case RAM_READ_MAGNETRON_FILAMENT_VOLTAGE_ADC:
563:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_filament, ps_filament.v_adc_reading);
003300  805664     MOV 0xACC, W4
003302  780084     MOV W4, W1
003304  20ABC0     MOV #0xABC, W0
003306  07023C     RCALL ReturnPowerSupplyADCScaledVoltage
003308  780200     MOV W0, W4
00330A  780F04     MOV W4, [W14]
564:                     break;
00330C  37019B     BRA 0x3644
565:                     
566:                   case RAM_READ_MAGNETRON_FILAMENT_CURRENT_ADC:
567:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_filament, ps_filament.i_adc_reading);
00330E  8057C4     MOV 0xAF8, W4
003310  780084     MOV W4, W1
003312  20ABC0     MOV #0xABC, W0
003314  07026B     RCALL ReturnPowerSupplyADCScaledCurrent
003316  780200     MOV W0, W4
003318  780F04     MOV W4, [W14]
568:                     break;
00331A  370194     BRA 0x3644
569:                     
570:                   case RAM_READ_MAGNETRON_FILAMENT_VOLTAGE_SET_POINT:
571:                     data_return = ps_filament.v_command_set_point;
00331C  8055F4     MOV 0xABE, W4
00331E  780F04     MOV W4, [W14]
572:                     break;
003320  370191     BRA 0x3644
573:               
574:                   case RAM_READ_MAGNETRON_FILAMENT_CURRENT_SET_POINT:
575:                     data_return = ps_filament.i_command_set_point;
003322  805755     MOV 0xAEA, W5
003324  780F05     MOV W5, [W14]
576:                     break;
003326  37018E     BRA 0x3644
577:               
578:               
579:                     // Lambda Mode A Data
580:                   case RAM_READ_HV_LAMBDA_SET_POINT_MODE_A:
581:                     data_return = ps_hv_lambda_mode_A.v_command_set_point;
003328  8047E8     MOV 0x8FC, W8
00332A  780F08     MOV W8, [W14]
582:                     break;
00332C  37018B     BRA 0x3644
583:               
584:               
585:                     // Lambda Mode B Data
586:                   case RAM_READ_HV_LAMBDA_SET_POINT_MODE_B:
587:                     data_return = ps_hv_lambda_mode_B.v_command_set_point;
00332E  804D89     MOV 0x9B0, W9
003330  780F09     MOV W9, [W14]
588:                     break;
003332  370188     BRA 0x3644
589:               
590:                     
591:                     // Thyratron Cathode Heater data
592:                   case RAM_READ_THYR_CATH_HTR_VOTAGE_SET_POINT:
593:                     data_return = ps_thyr_cathode_htr.v_command_set_point;
003334  8058CA     MOV 0xB18, W10
003336  780F0A     MOV W10, [W14]
594:                     break;
003338  370185     BRA 0x3644
595:                     
596:                   case RAM_READ_THYR_CATH_HTR_VOTAGE_ADC:
597:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_thyr_cathode_htr, ps_thyr_cathode_htr.v_adc_reading);
00333A  805934     MOV 0xB26, W4
00333C  780084     MOV W4, W1
00333E  20B160     MOV #0xB16, W0
003340  07021F     RCALL ReturnPowerSupplyADCScaledVoltage
003342  780200     MOV W0, W4
003344  780F04     MOV W4, [W14]
598:                     break;
003346  37017E     BRA 0x3644
599:               
600:               
601:                     // Thyratron Reservoir Heater data
602:                   case RAM_READ_THYR_RESER_HTR_VOLTAGE_SET_POINT:
603:                     data_return = ps_thyr_reservoir_htr.v_command_set_point;
003348  805B9B     MOV 0xB72, W11
00334A  780F0B     MOV W11, [W14]
604:                     break;
00334C  37017B     BRA 0x3644
605:                     
606:                   case RAM_READ_THYR_RESER_HTR_VOLTAGE_ADC:
607:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_thyr_reservoir_htr, ps_thyr_reservoir_htr.v_adc_reading);
00334E  805C04     MOV 0xB80, W4
003350  780084     MOV W4, W1
003352  20B700     MOV #0xB70, W0
003354  070215     RCALL ReturnPowerSupplyADCScaledVoltage
003356  780200     MOV W0, W4
003358  780F04     MOV W4, [W14]
608:                     break;
00335A  370174     BRA 0x3644
609:                     
610:               
611:                     // PULSE MODE A DATA
612:                   case RAM_READ_PULSE_MODE_A_FILTERED_CURRENT:
613:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_reading);
00335C  804C84     MOV 0x990, W4
00335E  780084     MOV W4, W1
003360  209540     MOV #0x954, W0
003362  070244     RCALL ReturnPowerSupplyADCScaledCurrent
003364  780200     MOV W0, W4
003366  780F04     MOV W4, [W14]
614:                     break;
003368  37016D     BRA 0x3644
615:               
616:                   case RAM_READ_PULSE_MODE_A_FILTERED_VOLTAGE:
617:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_reading);
00336A  804B24     MOV 0x964, W4
00336C  780084     MOV W4, W1
00336E  209540     MOV #0x954, W0
003370  070207     RCALL ReturnPowerSupplyADCScaledVoltage
003372  780200     MOV W0, W4
003374  780F04     MOV W4, [W14]
618:                     break;
003376  370166     BRA 0x3644
619:               
620:                   case RAM_READ_PULSE_MODE_A_MAX_CURRENT:
621:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_max_reading);
003378  804D54     MOV 0x9AA, W4
00337A  780084     MOV W4, W1
00337C  209540     MOV #0x954, W0
00337E  070236     RCALL ReturnPowerSupplyADCScaledCurrent
003380  780200     MOV W0, W4
003382  780F04     MOV W4, [W14]
622:                     break;
003384  37015F     BRA 0x3644
623:               
624:                   case RAM_READ_PULSE_MODE_A_MIN_CURRENT:
625:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_min_reading);
003386  804D64     MOV 0x9AC, W4
003388  780084     MOV W4, W1
00338A  209540     MOV #0x954, W0
00338C  07022F     RCALL ReturnPowerSupplyADCScaledCurrent
00338E  780200     MOV W0, W4
003390  780F04     MOV W4, [W14]
626:                     break;
003392  370158     BRA 0x3644
627:               
628:                  case RAM_READ_PULSE_MODE_A_MAX_VOLTAGE:
629:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_max_reading);
003394  804BF4     MOV 0x97E, W4
003396  780084     MOV W4, W1
003398  209540     MOV #0x954, W0
00339A  0701F2     RCALL ReturnPowerSupplyADCScaledVoltage
00339C  780200     MOV W0, W4
00339E  780F04     MOV W4, [W14]
630:                     break;
0033A0  370151     BRA 0x3644
631:               
632:                   case RAM_READ_PULSE_MODE_A_MIN_VOLTAGE:
633:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_min_reading);
0033A2  804C04     MOV 0x980, W4
0033A4  780084     MOV W4, W1
0033A6  209540     MOV #0x954, W0
0033A8  0701EB     RCALL ReturnPowerSupplyADCScaledVoltage
0033AA  780200     MOV W0, W4
0033AC  780F04     MOV W4, [W14]
634:                     break;
0033AE  37014A     BRA 0x3644
635:               
636:               
637:                   // PULSE MODE B DATA
638:                   case RAM_READ_PULSE_MODE_B_FILTERED_CURRENT:
639:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_reading);
0033B0  805224     MOV 0xA44, W4
0033B2  780084     MOV W4, W1
0033B4  20A080     MOV #0xA08, W0
0033B6  07021A     RCALL ReturnPowerSupplyADCScaledCurrent
0033B8  780200     MOV W0, W4
0033BA  780F04     MOV W4, [W14]
640:                     break;
0033BC  370143     BRA 0x3644
641:               
642:                   case RAM_READ_PULSE_MODE_B_FILTERED_VOLTAGE:
643:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_reading);
0033BE  8050C4     MOV 0xA18, W4
0033C0  780084     MOV W4, W1
0033C2  20A080     MOV #0xA08, W0
0033C4  0701DD     RCALL ReturnPowerSupplyADCScaledVoltage
0033C6  780200     MOV W0, W4
0033C8  780F04     MOV W4, [W14]
644:                     break;
0033CA  37013C     BRA 0x3644
645:               
646:                   case RAM_READ_PULSE_MODE_B_MAX_CURRENT:
647:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_max_reading);
0033CC  8052F4     MOV 0xA5E, W4
0033CE  780084     MOV W4, W1
0033D0  20A080     MOV #0xA08, W0
0033D2  07020C     RCALL ReturnPowerSupplyADCScaledCurrent
0033D4  780200     MOV W0, W4
0033D6  780F04     MOV W4, [W14]
648:                     break;
0033D8  370135     BRA 0x3644
649:               
650:                   case RAM_READ_PULSE_MODE_B_MIN_CURRENT:
651:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_min_reading);
0033DA  805304     MOV 0xA60, W4
0033DC  780084     MOV W4, W1
0033DE  20A080     MOV #0xA08, W0
0033E0  070205     RCALL ReturnPowerSupplyADCScaledCurrent
0033E2  780200     MOV W0, W4
0033E4  780F04     MOV W4, [W14]
652:                     break;      
0033E6  37012E     BRA 0x3644
653:               
654:                   case RAM_READ_PULSE_MODE_B_MAX_VOLTAGE:
655:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_max_reading);
0033E8  805194     MOV 0xA32, W4
0033EA  780084     MOV W4, W1
0033EC  20A080     MOV #0xA08, W0
0033EE  0701C8     RCALL ReturnPowerSupplyADCScaledVoltage
0033F0  780200     MOV W0, W4
0033F2  780F04     MOV W4, [W14]
656:                     break;     
0033F4  370127     BRA 0x3644
657:               
658:                   case RAM_READ_PULSE_MODE_B_MIN_VOLTAGE:
659:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_min_reading);
0033F6  8051A4     MOV 0xA34, W4
0033F8  780084     MOV W4, W1
0033FA  20A080     MOV #0xA08, W0
0033FC  0701C1     RCALL ReturnPowerSupplyADCScaledVoltage
0033FE  780200     MOV W0, W4
003400  780F04     MOV W4, [W14]
660:                     break;
003402  370120     BRA 0x3644
661:               
662:               
663:                     // Magnetron Data
664:                   case RAM_READ_PREVIOUS_PULSE_MAGNETRON_VOLTAGE_ADC:
665:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, pulse_magnetron_voltage_adc_reading);
003404  804244     MOV pulse_magnetron_voltage_adc_reading, W4
003406  780084     MOV W4, W1
003408  209540     MOV #0x954, W0
00340A  0701BA     RCALL ReturnPowerSupplyADCScaledVoltage
00340C  780200     MOV W0, W4
00340E  780F04     MOV W4, [W14]
666:                     break;
003410  370119     BRA 0x3644
667:                     
668:                   case RAM_READ_PREVIOUS_PULSE_MAGNETRON_CURRENT_ADC:
669:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, pulse_magnetron_current_adc_reading);
003412  804234     MOV pulse_magnetron_current_adc_reading, W4
003414  780084     MOV W4, W1
003416  209540     MOV #0x954, W0
003418  0701E9     RCALL ReturnPowerSupplyADCScaledCurrent
00341A  780200     MOV W0, W4
00341C  780F04     MOV W4, [W14]
670:                     break;
00341E  370112     BRA 0x3644
671:               
672:               
673:               
674:                     // Counter Data 
675:                   case RAM_READ_ARC_COUNTER_PERSISTENT_HIGH_WORD:
676:                     temp_long = arc_counter_persistent;
003420  80C564     MOV arc_counter_persistent, W4
003422  80C575     MOV 0x18AE, W5
003424  980714     MOV W4, [W14+2]
003426  980725     MOV W5, [W14+4]
677:                     temp_long = temp_long >> 16;
003428  90021E     MOV [W14+2], W4
00342A  9002AE     MOV [W14+4], W5
00342C  DE2A40     LSR W5, #0, W4
00342E  200005     MOV #0x0, W5
003430  980714     MOV W4, [W14+2]
003432  980725     MOV W5, [W14+4]
678:                     data_return = temp_long;
003434  90029E     MOV [W14+2], W5
003436  780F05     MOV W5, [W14]
679:                     break;
003438  370105     BRA 0x3644
680:                     
681:                   case RAM_READ_ARC_COUNTER_PERSISTENT_LOW_WORD:
682:                     temp_long = arc_counter_persistent;
00343A  80C568     MOV arc_counter_persistent, W8
00343C  80C579     MOV 0x18AE, W9
00343E  980718     MOV W8, [W14+2]
003440  980729     MOV W9, [W14+4]
683:                     data_return = temp_long;
003442  90049E     MOV [W14+2], W9
003444  780F09     MOV W9, [W14]
684:                     break;
003446  3700FE     BRA 0x3644
685:                     
686:                   case RAM_READ_ARC_COUNTER_THIS_HV_ON:
687:                     data_return = arc_counter_this_hv_on;
003448  80C5DA     MOV arc_counter_this_hv_on, W10
00344A  780F0A     MOV W10, [W14]
688:                     break;
00344C  3700FB     BRA 0x3644
689:                     
690:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_3_MSB:
691:                     temp_long_long = pulse_counter_persistent;
00344E  2189E4     MOV #0x189E, W4
003450  BE0434     MOV.D [W4++], W8
003452  BE0524     MOV.D [W4--], W10
003454  980738     MOV W8, [W14+6]
003456  980749     MOV W9, [W14+8]
003458  98075A     MOV W10, [W14+10]
00345A  98076B     MOV W11, [W14+12]
692:                     temp_long_long = temp_long_long >> 48;
00345C  90023E     MOV [W14+6], W4
00345E  9002CE     MOV [W14+8], W5
003460  90035E     MOV [W14+10], W6
003462  9003EE     MOV [W14+12], W7
003464  B83A61     MUL.UU W7, #1, W4
003466  B83360     MUL.UU W6, #0, W6
003468  980734     MOV W4, [W14+6]
00346A  980745     MOV W5, [W14+8]
00346C  980756     MOV W6, [W14+10]
00346E  980767     MOV W7, [W14+12]
693:                     data_return = temp_long_long;
003470  90053E     MOV [W14+6], W10
003472  780F0A     MOV W10, [W14]
694:                     break;
003474  3700E7     BRA 0x3644
695:                     
696:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_2:
697:                     temp_long_long = pulse_counter_persistent;
003476  2189E4     MOV #0x189E, W4
003478  BE0434     MOV.D [W4++], W8
00347A  BE0524     MOV.D [W4--], W10
00347C  980738     MOV W8, [W14+6]
00347E  980749     MOV W9, [W14+8]
003480  98075A     MOV W10, [W14+10]
003482  98076B     MOV W11, [W14+12]
698:                     temp_long_long = temp_long_long >> 32;
003484  90023E     MOV [W14+6], W4
003486  9002CE     MOV [W14+8], W5
003488  90035E     MOV [W14+10], W6
00348A  9003EE     MOV [W14+12], W7
00348C  BE0206     MOV.D W6, W4
00348E  B83360     MUL.UU W6, #0, W6
003490  980734     MOV W4, [W14+6]
003492  980745     MOV W5, [W14+8]
003494  980756     MOV W6, [W14+10]
003496  980767     MOV W7, [W14+12]
699:                     data_return = temp_long_long;
003498  90053E     MOV [W14+6], W10
00349A  780F0A     MOV W10, [W14]
700:                     break;
00349C  3700D3     BRA 0x3644
701:                     
702:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_1:
703:                     temp_long_long = pulse_counter_persistent;
00349E  2189E4     MOV #0x189E, W4
0034A0  BE0434     MOV.D [W4++], W8
0034A2  BE0524     MOV.D [W4--], W10
0034A4  980738     MOV W8, [W14+6]
0034A6  980749     MOV W9, [W14+8]
0034A8  98075A     MOV W10, [W14+10]
0034AA  98076B     MOV W11, [W14+12]
704:                     temp_long_long = temp_long_long >> 16;
0034AC  90023E     MOV [W14+6], W4
0034AE  9002CE     MOV [W14+8], W5
0034B0  90035E     MOV [W14+10], W6
0034B2  9003EE     MOV [W14+12], W7
0034B4  780205     MOV W5, W4
0034B6  780286     MOV W6, W5
0034B8  B83B61     MUL.UU W7, #1, W6
0034BA  980734     MOV W4, [W14+6]
0034BC  980745     MOV W5, [W14+8]
0034BE  980756     MOV W6, [W14+10]
0034C0  980767     MOV W7, [W14+12]
705:                     data_return = temp_long_long;
0034C2  90053E     MOV [W14+6], W10
0034C4  780F0A     MOV W10, [W14]
706:                     break;
0034C6  3700BE     BRA 0x3644
707:                     
708:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_0_LSB:
709:                     temp_long_long = pulse_counter_persistent;
0034C8  2189E4     MOV #0x189E, W4
0034CA  BE0434     MOV.D [W4++], W8
0034CC  BE0524     MOV.D [W4--], W10
0034CE  980738     MOV W8, [W14+6]
0034D0  980749     MOV W9, [W14+8]
0034D2  98075A     MOV W10, [W14+10]
0034D4  98076B     MOV W11, [W14+12]
710:                     data_return = temp_long_long;
0034D6  9004BE     MOV [W14+6], W9
0034D8  780F09     MOV W9, [W14]
711:                     break;
0034DA  3700B4     BRA 0x3644
712:                     
713:                   case RAM_READ_PULSE_COUNTER_THIS_HV_ON_HIGH_WORD:
714:                     temp_long = pulse_counter_this_hv_on;
0034DC  80C58A     MOV pulse_counter_this_hv_on, W10
0034DE  80C59B     MOV 0x18B2, W11
0034E0  98071A     MOV W10, [W14+2]
0034E2  98072B     MOV W11, [W14+4]
715:                     temp_long = temp_long >> 16;
0034E4  90021E     MOV [W14+2], W4
0034E6  9002AE     MOV [W14+4], W5
0034E8  DE2A40     LSR W5, #0, W4
0034EA  200005     MOV #0x0, W5
0034EC  980714     MOV W4, [W14+2]
0034EE  980725     MOV W5, [W14+4]
716:                     data_return = temp_long;
0034F0  90059E     MOV [W14+2], W11
0034F2  780F0B     MOV W11, [W14]
717:                     break;
0034F4  3700A7     BRA 0x3644
718:                     
719:                   case RAM_READ_PULSE_COUNTER_THIS_HV_ON_LOW_WORD:
720:                     temp_long = pulse_counter_this_hv_on;
0034F6  80C584     MOV pulse_counter_this_hv_on, W4
0034F8  80C595     MOV 0x18B2, W5
0034FA  980714     MOV W4, [W14+2]
0034FC  980725     MOV W5, [W14+4]
721:                     temp_long &= 0x0000FFFF;
0034FE  90031E     MOV [W14+2], W6
003500  9003AE     MOV [W14+4], W7
003502  2FFFF4     MOV #0xFFFF, W4
003504  200005     MOV #0x0, W5
003506  780006     MOV W6, W0
003508  780307     MOV W7, W6
00350A  780384     MOV W4, W7
00350C  780205     MOV W5, W4
00350E  600007     AND W0, W7, W0
003510  630204     AND W6, W4, W4
003512  200005     MOV #0x0, W5
003514  DD22C0     SL W4, #0, W5
003516  200004     MOV #0x0, W4
003518  BE0304     MOV.D W4, W6
00351A  B80261     MUL.UU W0, #1, W4
00351C  730304     IOR W6, W4, W6
00351E  738385     IOR W7, W5, W7
003520  980716     MOV W6, [W14+2]
003522  980727     MOV W7, [W14+4]
722:                     data_return = temp_long;
003524  90029E     MOV [W14+2], W5
003526  780F05     MOV W5, [W14]
723:                     break;
003528  37008D     BRA 0x3644
724:                     
725:               
726:                     // Power information
727:                   case RAM_READ_AVERAGE_PULSE_ENERGY:
728:                     data_return = average_energy_per_pulse_milli_joules;
00352A  804158     MOV average_energy_per_pulse_milli_joules, W8
00352C  780F08     MOV W8, [W14]
729:                     break;
00352E  37008A     BRA 0x3644
730:               
731:                   case RAM_READ_AVERAGE_PULSE_FREQUENCY:
732:                     data_return = average_pulse_repetition_frequency_deci_herz;
003530  804179     MOV average_pulse_repetition_frequency_deci_herz, W9
003532  780F09     MOV W9, [W14]
733:                     break;
003534  370087     BRA 0x3644
734:               
735:                   case RAM_READ_AVERAGE_MAGNETRON_INPUT_POWER:
736:                     data_return = average_output_power_watts;
003536  80416A     MOV average_output_power_watts, W10
003538  780F0A     MOV W10, [W14]
737:                     break;
00353A  370084     BRA 0x3644
738:               
739:                   case RAM_READ_HV_LAMBDA_VPEAK_ADC:
740:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_hv_lambda_mode_A, ps_hv_lambda_mode_A.v_adc_reading);
00353C  804854     MOV 0x90A, W4
00353E  780084     MOV W4, W1
003540  208FA0     MOV #0x8FA, W0
003542  07011E     RCALL ReturnPowerSupplyADCScaledVoltage
003544  780200     MOV W0, W4
003546  780F04     MOV W4, [W14]
741:                     break;
003548  37007D     BRA 0x3644
742:               
743:                   case RAM_READ_HV_LAMBDA_VMON_ADC:
744:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_hv_lambda_mode_B, ps_hv_lambda_mode_B.v_adc_reading);
00354A  804DF4     MOV 0x9BE, W4
00354C  780084     MOV W4, W1
00354E  209AE0     MOV #0x9AE, W0
003550  070117     RCALL ReturnPowerSupplyADCScaledVoltage
003552  780200     MOV W0, W4
003554  780F04     MOV W4, [W14]
745:                     break;
003556  370076     BRA 0x3644
746:               
747:                     // Fault information
748:                   case RAM_READ_DEBUG_STATUS_REG:
749:                     data_return = debug_status_register;
003558  80C2FB     MOV debug_status_register, W11
00355A  780F0B     MOV W11, [W14]
750:                     break;
00355C  370073     BRA 0x3644
751:               
752:                   case RAM_READ_FAULT_MAGNETRON_FAULT_REG:
753:                     data_return = faults_magnetron_fault_reg;
00355E  80C311     MOV faults_magnetron_fault_reg, W1
003560  780F01     MOV W1, [W14]
754:                     break;
003562  370070     BRA 0x3644
755:               
756:                   case RAM_READ_FAULT_MAGNETRON_STATUS_REG:
757:                     data_return = faults_magnetron_status_reg;
003564  80C304     MOV faults_magnetron_status_reg, W4
003566  780F04     MOV W4, [W14]
758:                     break;
003568  37006D     BRA 0x3644
759:               
760:                   case RAM_READ_FAULT_MAGNETRON_WARNING_REG:
761:                     data_return = faults_magnetron_warning_reg;
00356A  80C325     MOV faults_magnetron_warning_reg, W5
00356C  780F05     MOV W5, [W14]
762:                     break;
00356E  37006A     BRA 0x3644
763:               
764:                   case RAM_READ_FAULT_HIGH_VOLTAGE_FAULT_REG:
765:                     data_return = faults_high_voltage_fault_reg;
003570  80C348     MOV faults_high_voltage_fault_reg, W8
003572  780F08     MOV W8, [W14]
766:                     break;
003574  370067     BRA 0x3644
767:               
768:                   case RAM_READ_FAULT_HIGH_VOLTAGE_STATUS_REG:
769:                     data_return = faults_high_voltage_status_reg;
003576  80C339     MOV faults_high_voltage_status_reg, W9
003578  780F09     MOV W9, [W14]
770:                     break;
00357A  370064     BRA 0x3644
771:               
772:                   case RAM_READ_FAULT_HIGH_VOLTAGE_WARNING_REG:
773:                     data_return = faults_high_voltage_warning_reg;
00357C  80C35A     MOV faults_high_voltage_warning_reg, W10
00357E  780F0A     MOV W10, [W14]
774:                     break;
003580  370061     BRA 0x3644
775:               
776:                   case RAM_READ_FAULT_THYRATRON_FAULT_REG:
777:                     data_return = faults_thyratron_fault_reg;
003582  80C37B     MOV faults_thyratron_fault_reg, W11
003584  780F0B     MOV W11, [W14]
778:                     break;
003586  37005E     BRA 0x3644
779:               
780:                   case RAM_READ_FAULT_THYRATRON_STATUS_REG:
781:                     data_return = faults_thyratron_status_reg;
003588  80C361     MOV faults_thyratron_status_reg, W1
00358A  780F01     MOV W1, [W14]
782:                     break;
00358C  37005B     BRA 0x3644
783:               
784:                   case RAM_READ_FAULT_THYRATRON_WARNING_REG:
785:                     data_return = faults_thyratron_warning_reg;
00358E  80C384     MOV faults_thyratron_warning_reg, W4
003590  780F04     MOV W4, [W14]
786:                     break;
003592  370058     BRA 0x3644
787:               
788:                   case RAM_READ_FAULT_CONTROL_BOARD_FAULT_REG:
789:                     data_return = faults_control_board_fault_reg;
003594  80C3A5     MOV faults_control_board_fault_reg, W5
003596  780F05     MOV W5, [W14]
790:                     break;
003598  370055     BRA 0x3644
791:               
792:                   case RAM_READ_FAULT_CONTROL_BOARD_STATUS_REG:
793:                     data_return = faults_control_board_status_reg;
00359A  80C398     MOV faults_control_board_status_reg, W8
00359C  780F08     MOV W8, [W14]
794:                     break;
00359E  370052     BRA 0x3644
795:               
796:                   case RAM_READ_FAULT_CONTROL_BOARD_WARNING_REG:
797:                     data_return = faults_control_board_warning_reg;
0035A0  80C3B9     MOV faults_control_board_warning_reg, W9
0035A2  780F09     MOV W9, [W14]
798:                     break;
0035A4  37004F     BRA 0x3644
799:                     
800:                     
801:                     // Read Status
802:                   case RAM_READ_STATE:
803:                     data_return = control_state;
0035A6  208324     MOV #0x832, W4
0035A8  784214     MOV.B [W4], W4
0035AA  FB8204     ZE W4, W4
0035AC  780F04     MOV W4, [W14]
804:                     break;
0035AE  37004A     BRA 0x3644
805:                     
806:                   case RAM_READ_VERSION:
807:                     data_return = VERSION_NUMBER;
0035B0  202004     MOV #0x200, W4
0035B2  780F04     MOV W4, [W14]
808:                     break;
0035B4  370047     BRA 0x3644
809:               
810:                   case RAM_READ_LOCAL_REMOTE_MAGNET_CURRENT_CONTROL:
811:                     data_return = ram_config_set_magnetron_magnet_current_from_GUI;
0035B6  208224     MOV #0x822, W4
0035B8  784214     MOV.B [W4], W4
0035BA  FB8204     ZE W4, W4
0035BC  780F04     MOV W4, [W14]
812:                     break;
0035BE  370042     BRA 0x3644
813:                     
814:                   case RAM_READ_MAGNETRON_TYPE:
815:               #ifdef __MG7095
816:                     data_return = 7095;
0035C0  21BB74     MOV #0x1BB7, W4
0035C2  780F04     MOV W4, [W14]
817:               #else
818:                     data_return = 5193;
819:               #endif
820:                     break;
0035C4  37003F     BRA 0x3644
821:                  
822:                   case RAM_READ_CONTROL_BOARD_TYPE:
823:               #ifndef __A36760
824:                     data_return = 34760;
0035C6  287C84     MOV #0x87C8, W4
0035C8  780F04     MOV W4, [W14]
825:               #else
826:                     data_return = 36760;
827:               #endif
828:                     break;
0035CA  37003C     BRA 0x3644
829:                     
830:                     
831:                     // Read Bedug Counters
832:                     
833:                   case RAM_READ_COUNT_MAGNETRON_CURRENT_ADC_GLITCH:
834:                     data_return = global_debug_counter.magnetron_current_adc_glitch;
0035CC  80C24A     MOV global_debug_counter, W10
0035CE  780F0A     MOV W10, [W14]
835:                     break;
0035D0  370039     BRA 0x3644
836:                     
837:                   case RAM_READ_COUNT_MAGNETRON_VOLTAGE_ADC_GLITCH:
838:                     data_return = global_debug_counter.magnetron_voltage_adc_glitch;
0035D2  80C25B     MOV 0x184A, W11
0035D4  780F0B     MOV W11, [W14]
839:                     break;
0035D6  370036     BRA 0x3644
840:                     
841:                   case RAM_READ_COUNT_I2C_BUS_ERROR:
842:                     data_return = pac_2_adc_reading;
0035D8  8041B1     MOV pac_2_adc_reading, W1
0035DA  780F01     MOV W1, [W14]
843:                     break;
0035DC  370033     BRA 0x3644
844:                     
845:                   case RAM_READ_COUNT_SPI1_BUS_ERROR:
846:                     data_return = default_pac_2_adc_reading;
0035DE  804074     MOV default_pac_2_adc_reading, W4
0035E0  780F04     MOV W4, [W14]
847:                     break;
0035E2  370030     BRA 0x3644
848:                     
849:                   case RAM_READ_COUNT_SPI2_BUS_ERROR:
850:                     data_return = pac_1_adc_reading;
0035E4  8041A5     MOV pac_1_adc_reading, W5
0035E6  780F05     MOV W5, [W14]
851:                     break;
0035E8  37002D     BRA 0x3644
852:                     
853:                   case RAM_READ_COUNT_EXTERNAL_ADC_FALSE_TRIGGER:
854:                     data_return = global_debug_counter.external_adc_false_trigger;
0035EA  80C298     MOV 0x1852, W8
0035EC  780F08     MOV W8, [W14]
855:                     break;
0035EE  37002A     BRA 0x3644
856:               
857:                   case RAM_READ_COUNT_LTC2656_WRITE_ERROR:
858:                     data_return = global_debug_counter.LTC2656_write_error;
0035F0  80C2A9     MOV 0x1854, W9
0035F2  780F09     MOV W9, [W14]
859:                     break;
0035F4  370027     BRA 0x3644
860:                     
861:                   case RAM_READ_COUNT_SETPOINT_NOT_VALID:
862:                     data_return = global_debug_counter.setpoint_not_valid;
0035F6  80C2BA     MOV 0x1856, W10
0035F8  780F0A     MOV W10, [W14]
863:                     break;
0035FA  370024     BRA 0x3644
864:                     
865:                   case RAM_READ_COUNT_SCALE16BIT_SATURATION:
866:                     data_return = global_debug_counter.scale16bit_saturation;
0035FC  80C2CB     MOV 0x1858, W11
0035FE  780F0B     MOV W11, [W14]
867:                     break;
003600  370021     BRA 0x3644
868:               
869:                   case RAM_READ_LAST_OSCCON_BEFORE_CRASH:
870:                     data_return = last_osccon;
003602  80C5B1     MOV last_osccon, W1
003604  780F01     MOV W1, [W14]
871:                     break;
003606  37001E     BRA 0x3644
872:               
873:                   case RAM_READ_PULSE_LATCH_RESET_ERROR:
874:                     data_return = global_debug_counter.pulse_latch_reset_error;
003608  80C2E4     MOV 0x185C, W4
00360A  780F04     MOV W4, [W14]
875:                     break;
00360C  37001B     BRA 0x3644
876:               
877:                   case RAM_READ_COUNT_REVERSESCALE16BIT_SATURATION:
878:                     data_return = global_debug_counter.reversescale16bit_saturation;
00360E  80C2D5     MOV 0x185A, W5
003610  780F05     MOV W5, [W14]
879:                     break;
003612  370018     BRA 0x3644
880:               
881:                   case RAM_READ_COUNT_LVD_INTERRUPT:
882:                     data_return = lvdinterrupt_counter;
003614  80C488     MOV lvdinterrupt_counter, W8
003616  780F08     MOV W8, [W14]
883:                     break;
003618  370015     BRA 0x3644
884:               
885:                   case RAM_READ_LAST_ACTION_BEFORE_CRASH:
886:                     data_return = previous_last_action;
00361A  804129     MOV previous_last_action, W9
00361C  780F09     MOV W9, [W14]
887:                     break;
00361E  370012     BRA 0x3644
888:               
889:                   case RAM_READ_COUNT_PROCESSOR_CRASH:
890:                     data_return = processor_crash_count;
003620  80C5CA     MOV processor_crash_count, W10
003622  780F0A     MOV W10, [W14]
891:                     break;
003624  37000F     BRA 0x3644
892:                     
893:                   case RAM_READ_COUNT_TIMING_ERROR_INT1:
894:                     data_return = timing_error_int1_count;
003626  80C46B     MOV timing_error_int1_count, W11
003628  780F0B     MOV W11, [W14]
895:                     break;
00362A  37000C     BRA 0x3644
896:               
897:               
898:                   case RAM_READ_HIGH_TARGET_CURRENT_SET_POINT:
899:                     data_return = linac_high_energy_target_current_set_point;
00362C  804091     MOV linac_high_energy_target_current_set_point, W1
00362E  780F01     MOV W1, [W14]
900:                     break;
003630  370009     BRA 0x3644
901:               
902:                   case RAM_READ_LOW_TARGET_CURRENT_SET_POINT:
903:                     data_return = linac_low_energy_target_current_set_point;
003632  8040B4     MOV linac_low_energy_target_current_set_point, W4
003634  780F04     MOV W4, [W14]
904:                     break;
003636  370006     BRA 0x3644
905:               
906:                   case RAM_READ_HIGH_TARGET_CURRENT_READING:
907:                     data_return = linac_high_energy_target_current_adc_reading;
003638  804085     MOV linac_high_energy_target_current_adc_reading, W5
00363A  780F05     MOV W5, [W14]
908:                     break;
00363C  370003     BRA 0x3644
909:               
910:                   case RAM_READ_LOW_TARGET_CURRENT_READING:
911:                     data_return = linac_low_energy_target_current_adc_reading;
00363E  8040A8     MOV linac_low_energy_target_current_adc_reading, W8
003640  780F08     MOV W8, [W14]
912:                     break;
003642  000000     NOP
913:               
914:                     
915:                   }
916:                 
917:                 return data_return;
003644  78021E     MOV [W14], W4
918:               }
003646  780004     MOV W4, W0
003648  BE054F     MOV.D [--W15], W10
00364A  BE044F     MOV.D [--W15], W8
00364C  FA8000     ULNK
00364E  060000     RETURN
919:               
920:               
921:               unsigned int MakeCRC(unsigned char command_byte, unsigned char register_byte, unsigned int data_word) {
003650  FA0006     LNK #0x6
003652  984720     MOV.B W0, [W14+2]
003654  984731     MOV.B W1, [W14+3]
003656  980722     MOV W2, [W14+4]
922:                 unsigned int crc;
923:                 crc = SYNC_BYTE_1 + SYNC_BYTE_2 + SYNC_BYTE_3_SEND;
003658  202D74     MOV #0x2D7, W4
00365A  780F04     MOV W4, [W14]
924:                 crc += command_byte + register_byte;
00365C  90422E     MOV.B [W14+2], W4
00365E  FB8284     ZE W4, W5
003660  90423E     MOV.B [W14+3], W4
003662  FB8204     ZE W4, W4
003664  428204     ADD W5, W4, W4
003666  420F1E     ADD W4, [W14], [W14]
925:                 crc += (data_word >> 8);
003668  90022E     MOV [W14+4], W4
00366A  DE2248     LSR W4, #8, W4
00366C  420F1E     ADD W4, [W14], [W14]
926:                 crc += (data_word & 0x00FF);
00366E  9002AE     MOV [W14+4], W5
003670  200FF4     MOV #0xFF, W4
003672  628204     AND W5, W4, W4
003674  420F1E     ADD W4, [W14], [W14]
927:                 
928:                 return crc;
003676  78021E     MOV [W14], W4
929:                 // DPAKRER Make real CRC
930:               }
003678  780004     MOV W4, W0
00367A  FA8000     ULNK
00367C  060000     RETURN
931:               
932:               
933:               unsigned char CheckCRC(unsigned int crc) {
00367E  FA0004     LNK #0x4
003680  980710     MOV W0, [W14+2]
934:                 unsigned int crcCheck;
935:                 // At the moment the CRC is just a checksum
936:                 crcCheck = SYNC_BYTE_1 + SYNC_BYTE_2 + SYNC_BYTE_3_RECEIVE; 
003682  202D64     MOV #0x2D6, W4
003684  780F04     MOV W4, [W14]
937:                 crcCheck += command_string.command_byte + command_string.register_byte;
003686  218A64     MOV #0x18A6, W4
003688  784214     MOV.B [W4], W4
00368A  FB8284     ZE W4, W5
00368C  218A74     MOV #0x18A7, W4
00368E  784214     MOV.B [W4], W4
003690  FB8204     ZE W4, W4
003692  428204     ADD W5, W4, W4
003694  420F1E     ADD W4, [W14], [W14]
938:                 crcCheck += command_string.data_high_byte + command_string.data_low_byte;
003696  218A84     MOV #0x18A8, W4
003698  784214     MOV.B [W4], W4
00369A  FB8284     ZE W4, W5
00369C  218A94     MOV #0x18A9, W4
00369E  784214     MOV.B [W4], W4
0036A0  FB8204     ZE W4, W4
0036A2  428204     ADD W5, W4, W4
0036A4  420F1E     ADD W4, [W14], [W14]
939:                 if (crcCheck == crc) {
0036A6  90021E     MOV [W14+2], W4
0036A8  78029E     MOV [W14], W5
0036AA  528F84     SUB W5, W4, [W15]
0036AC  3A0002     BRA NZ, 0x36B2
940:                   return 1;
0036AE  B3C014     MOV #0x1, W4
0036B0  370001     BRA 0x36B4
941:                 } else {
942:                   return 0;
0036B2  EB4200     CLR.B W4
943:                 }
944:                 // DPARKER make Real CRC
945:               
946:               }
0036B4  784004     MOV.B W4, W0
0036B6  FA8000     ULNK
0036B8  060000     RETURN
947:               
948:               
949:               
950:               void _ISRNOPSV _U1RXInterrupt(void) {
0036BA  F80036     PUSH RCOUNT
0036BC  BE9F80     MOV.D W0, [W15++]
0036BE  BE9F82     MOV.D W2, [W15++]
0036C0  BE9F84     MOV.D W4, [W15++]
0036C2  BE9F86     MOV.D W6, [W15++]
0036C4  FA0000     LNK #0x0
951:                 _U1RXIF = 0;
0036C6  A92085     BCLR 0x85, #1
952:                 while (U1STAbits.URXDA) {
0036C8  370005     BRA 0x36D4
0036D4  801074     MOV U1STA, W4
0036D6  620261     AND W4, #0x1, W4
0036D8  520FE0     SUB W4, #0x0, [W15]
0036DA  3AFFF7     BRA NZ, 0x36CA
953:                   Buffer64WriteByte(&uart1_input_buffer, U1RXREG);
0036CA  801094     MOV U1RXREG, W4
0036CC  784204     MOV.B W4, W4
0036CE  784084     MOV.B W4, W1
0036D0  2085E0     MOV #0x85E, W0
0036D2  070ABB     RCALL Buffer64WriteByte
954:                 }
955:               }
0036DC  FA8000     ULNK
0036DE  BE034F     MOV.D [--W15], W6
0036E0  BE024F     MOV.D [--W15], W4
0036E2  BE014F     MOV.D [--W15], W2
0036E4  BE004F     MOV.D [--W15], W0
0036E6  F90036     POP RCOUNT
0036E8  064000     RETFIE
956:               
957:               
958:               
959:               void _ISRNOPSV _U1TXInterrupt(void) {
0036EA  F80036     PUSH RCOUNT
0036EC  BE9F80     MOV.D W0, [W15++]
0036EE  BE9F82     MOV.D W2, [W15++]
0036F0  BE9F84     MOV.D W4, [W15++]
0036F2  BE9F86     MOV.D W6, [W15++]
0036F4  FA0000     LNK #0x0
960:                 _U1TXIF = 0;
0036F6  A94085     BCLR 0x85, #2
961:                 while ((!U1STAbits.UTXBF) && (Buffer64BytesInBuffer(&uart1_output_buffer))) {
0036F8  370005     BRA 0x3704
003704  801075     MOV U1STA, W5
003706  202004     MOV #0x200, W4
003708  628204     AND W5, W4, W4
00370A  520FE0     SUB W4, #0x0, [W15]
00370C  3A0005     BRA NZ, 0x3718
00370E  208A00     MOV #0x8A0, W0
003710  070ADF     RCALL Buffer64BytesInBuffer
003712  784200     MOV.B W0, W4
003714  524FE0     SUB.B W4, #0x0, [W15]
003716  3AFFF1     BRA NZ, 0x36FA
962:                   /*
963:                     There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
964:                     Move a byte from the output buffer into the transmit buffer
965:                   */
966:                   U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
0036FA  208A00     MOV #0x8A0, W0
0036FC  070ACB     RCALL Buffer64ReadByte
0036FE  784200     MOV.B W0, W4
003700  FB8204     ZE W4, W4
003702  881084     MOV W4, U1TXREG
967:                 }
968:               }
003718  FA8000     ULNK
00371A  BE034F     MOV.D [--W15], W6
00371C  BE024F     MOV.D [--W15], W4
00371E  BE014F     MOV.D [--W15], W2
003720  BE004F     MOV.D [--W15], W0
003722  F90036     POP RCOUNT
003724  064000     RETFIE
969:               
970:               
971:               unsigned int GenerateMagnetronVprog(unsigned int iprog) {
003726  FA0002     LNK #0x2
003728  780F00     MOV W0, [W14]
972:                 return 42000;
00372A  2A4104     MOV #0xA410, W4
973:                 // DPARKER write this function
974:               }
00372C  780004     MOV W4, W0
00372E  FA8000     ULNK
003730  060000     RETURN
975:               
976:               
977:               
978:               unsigned int GenerateLambdaIprog(unsigned int vprog) {
003732  FA0002     LNK #0x2
003734  780F00     MOV W0, [W14]
979:                 return 0;
003736  EB0200     CLR W4
980:               }
003738  780004     MOV W4, W0
00373A  FA8000     ULNK
00373C  060000     RETURN
981:               
982:                
983:               unsigned int GenerateMagnetVprog(unsigned int iprog) {
00373E  FA0004     LNK #0x4
003740  980710     MOV W0, [W14+2]
984:                 unsigned int temp;
985:                 temp = Scale16Bit(iprog,10240); // temp = iprog*1.25
003742  228001     MOV #0x2800, W1
003744  90001E     MOV [W14+2], W0
003746  07F5BF     RCALL Scale16Bit
003748  780200     MOV W0, W4
00374A  780F04     MOV W4, [W14]
986:                 return temp;
00374C  78021E     MOV [W14], W4
987:               }
00374E  780004     MOV W4, W0
003750  FA8000     ULNK
003752  060000     RETURN
988:               
989:               
990:               unsigned int GenerateFilamentIprog(unsigned int vprog) {
003754  FA0004     LNK #0x4
003756  980710     MOV W0, [W14+2]
991:                 unsigned int temp;
992:                 temp = Scale16Bit(vprog, 5425);
003758  215311     MOV #0x1531, W1
00375A  90001E     MOV [W14+2], W0
00375C  07F5B4     RCALL Scale16Bit
00375E  780200     MOV W0, W4
003760  780F04     MOV W4, [W14]
993:                 return temp;
003762  78021E     MOV [W14], W4
994:               }
003764  780004     MOV W4, W0
003766  FA8000     ULNK
003768  060000     RETURN
995:               
996:               unsigned int GenerateFilamentVprog(unsigned int iprog) {
00376A  FA0004     LNK #0x4
00376C  980710     MOV W0, [W14+2]
997:                 unsigned int temp;
998:                 temp = Scale16Bit(iprog, 19363);
00376E  24BA31     MOV #0x4BA3, W1
003770  90001E     MOV [W14+2], W0
003772  07F5A9     RCALL Scale16Bit
003774  780200     MOV W0, W4
003776  780F04     MOV W4, [W14]
999:                 return temp;
003778  78021E     MOV [W14], W4
1000:              }
00377A  780004     MOV W4, W0
00377C  FA8000     ULNK
00377E  060000     RETURN
1001:              
1002:              
1003:              unsigned int ReturnPowerSupplyADCScaledVoltage(POWERSUPPLY* ptr, unsigned int value) {
003780  FA0004     LNK #0x4
003782  780F00     MOV W0, [W14]
003784  980711     MOV W1, [W14+2]
1004:                //value = value - ptr->v_adc_cal_offset;
1005:                if (ptr->v_adc_cal_offset > 0) {
003786  78021E     MOV [W14], W4
003788  900A34     MOV [W4+22], W4
00378A  520FE0     SUB W4, #0x0, [W15]
00378C  34000F     BRA LE, 0x37AC
1006:                  // the offset is positive
1007:                  // Check to make sure we do not overflow below 0x0000
1008:                  if (ptr->v_adc_cal_offset >= value) {
00378E  78021E     MOV [W14], W4
003790  900A34     MOV [W4+22], W4
003792  780284     MOV W4, W5
003794  90021E     MOV [W14+2], W4
003796  528F84     SUB W5, W4, [W15]
003798  390003     BRA NC, 0x37A0
1009:                    value = 0;
00379A  EB0200     CLR W4
00379C  980714     MOV W4, [W14+2]
00379E  370014     BRA 0x37C8
1010:                  } else {
1011:                    value = value - ptr->v_adc_cal_offset;
0037A0  78021E     MOV [W14], W4
0037A2  900A34     MOV [W4+22], W4
0037A4  90029E     MOV [W14+2], W5
0037A6  528204     SUB W5, W4, W4
0037A8  980714     MOV W4, [W14+2]
0037AA  37000E     BRA 0x37C8
1012:                  }
1013:                } else {
1014:                  // The offset is negative
1015:                  // Check to make sure we do not overflow above 0xFFFF
1016:                  if ((0xFFFF + ptr->v_adc_cal_offset) <= value) {
0037AC  78021E     MOV [W14], W4
0037AE  900A34     MOV [W4+22], W4
0037B0  E90284     DEC W4, W5
0037B2  90021E     MOV [W14+2], W4
0037B4  528F84     SUB W5, W4, [W15]
0037B6  3E0003     BRA GTU, 0x37BE
1017:                    value = 0xFFFF;
0037B8  EB8200     SETM W4
0037BA  980714     MOV W4, [W14+2]
0037BC  370005     BRA 0x37C8
1018:                  } else {
1019:                    value = value - ptr->v_adc_cal_offset;
0037BE  78021E     MOV [W14], W4
0037C0  900A34     MOV [W4+22], W4
0037C2  90029E     MOV [W14+2], W5
0037C4  528204     SUB W5, W4, W4
0037C6  980714     MOV W4, [W14+2]
1020:                  }
1021:                }
1022:                value = ReverseScale16Bit(value, ptr->v_adc_cal_gain);
0037C8  78021E     MOV [W14], W4
0037CA  900A24     MOV [W4+20], W4
0037CC  780084     MOV W4, W1
0037CE  90001E     MOV [W14+2], W0
0037D0  070043     RCALL ReverseScale16Bit
0037D2  780200     MOV W0, W4
0037D4  980714     MOV W4, [W14+2]
1023:                value = ReverseScale16Bit(value, ptr->v_adc_scale);
0037D6  78021E     MOV [W14], W4
0037D8  900A14     MOV [W4+18], W4
0037DA  780084     MOV W4, W1
0037DC  90001E     MOV [W14+2], W0
0037DE  07003C     RCALL ReverseScale16Bit
0037E0  780200     MOV W0, W4
0037E2  980714     MOV W4, [W14+2]
1024:                return value;
0037E4  90021E     MOV [W14+2], W4
1025:              }
0037E6  780004     MOV W4, W0
0037E8  FA8000     ULNK
0037EA  060000     RETURN
1026:              
1027:              unsigned int ReturnPowerSupplyADCScaledCurrent(POWERSUPPLY* ptr, unsigned int value) {
0037EC  FA0004     LNK #0x4
0037EE  780F00     MOV W0, [W14]
0037F0  980711     MOV W1, [W14+2]
1028:                if (ptr->i_adc_cal_offset > 0) {
0037F2  78021E     MOV [W14], W4
0037F4  902214     MOV [W4+66], W4
0037F6  520FE0     SUB W4, #0x0, [W15]
0037F8  34000F     BRA LE, 0x3818
1029:                  // Check to make sure we do not overflow below 0x0000
1030:                  // Our offset is 
1031:                  if (ptr->i_adc_cal_offset > value) {
0037FA  78021E     MOV [W14], W4
0037FC  902214     MOV [W4+66], W4
0037FE  780284     MOV W4, W5
003800  90021E     MOV [W14+2], W4
003802  528F84     SUB W5, W4, [W15]
003804  360003     BRA LEU, 0x380C
1032:                    value = 0;
003806  EB0200     CLR W4
003808  980714     MOV W4, [W14+2]
00380A  370014     BRA 0x3834
1033:                  } else {
1034:                    value = value - ptr->i_adc_cal_offset;
00380C  78021E     MOV [W14], W4
00380E  902214     MOV [W4+66], W4
003810  90029E     MOV [W14+2], W5
003812  528204     SUB W5, W4, W4
003814  980714     MOV W4, [W14+2]
003816  37000E     BRA 0x3834
1035:                  }
1036:                } else {
1037:                  // Check to make sure we do not overflow above 0xFFFF
1038:                  if ((0xFFFF + ptr->i_adc_cal_offset) < value) {
003818  78021E     MOV [W14], W4
00381A  902214     MOV [W4+66], W4
00381C  E90284     DEC W4, W5
00381E  90021E     MOV [W14+2], W4
003820  528F84     SUB W5, W4, [W15]
003822  310003     BRA C, 0x382A
1039:                    value = 0xFFFF;
003824  EB8200     SETM W4
003826  980714     MOV W4, [W14+2]
003828  370005     BRA 0x3834
1040:                  } else {
1041:                    value = value - ptr->i_adc_cal_offset;
00382A  78021E     MOV [W14], W4
00382C  902214     MOV [W4+66], W4
00382E  90029E     MOV [W14+2], W5
003830  528204     SUB W5, W4, W4
003832  980714     MOV W4, [W14+2]
1042:                  }
1043:                }
1044:                value = ReverseScale16Bit(value, ptr->i_adc_cal_gain);
003834  78021E     MOV [W14], W4
003836  902204     MOV [W4+64], W4
003838  780084     MOV W4, W1
00383A  90001E     MOV [W14+2], W0
00383C  07000D     RCALL ReverseScale16Bit
00383E  780200     MOV W0, W4
003840  980714     MOV W4, [W14+2]
1045:                value = ReverseScale16Bit(value, ptr->i_adc_scale);
003842  78021E     MOV [W14], W4
003844  901A74     MOV [W4+62], W4
003846  780084     MOV W4, W1
003848  90001E     MOV [W14+2], W0
00384A  070006     RCALL ReverseScale16Bit
00384C  780200     MOV W0, W4
00384E  980714     MOV W4, [W14+2]
1046:                return value;
003850  90021E     MOV [W14+2], W4
1047:              }
003852  780004     MOV W4, W0
003854  FA8000     ULNK
003856  060000     RETURN
1048:               
1049:              
1050:              unsigned int ReverseScale16Bit(unsigned int value, unsigned int scale) {
003858  FA0008     LNK #0x8
00385A  980720     MOV W0, [W14+4]
00385C  980731     MOV W1, [W14+6]
1051:                unsigned long temp;
1052:                temp = value;
00385E  90022E     MOV [W14+4], W4
003860  200005     MOV #0x0, W5
003862  BE8F04     MOV.D W4, [W14]
1053:                temp = temp << 13;
003864  BE031E     MOV.D [W14], W6
003866  DD3A4D     SL W7, #13, W4
003868  DE32C3     LSR W6, #3, W5
00386A  720285     IOR W4, W5, W5
00386C  DD324D     SL W6, #13, W4
00386E  BE8F04     MOV.D W4, [W14]
1054:                temp /= scale;
003870  90023E     MOV [W14+6], W4
003872  200005     MOV #0x0, W5
003874  BE0104     MOV.D W4, W2
003876  BE001E     MOV.D [W14], W0
003878  07E51E     RCALL ___udivsi3
00387A  BE0200     MOV.D W0, W4
00387C  BE8F04     MOV.D W4, [W14]
1055:                if (temp > 0x0000FFFF) {
00387E  2FFFF4     MOV #0xFFFF, W4
003880  200005     MOV #0x0, W5
003882  BE031E     MOV.D [W14], W6
003884  530F84     SUB W6, W4, [W15]
003886  5B8F85     SUBB W7, W5, [W15]
003888  360006     BRA LEU, 0x3896
1056:                  temp = 0x0000FFFF;
00388A  2FFFF4     MOV #0xFFFF, W4
00388C  200005     MOV #0x0, W5
00388E  BE8F04     MOV.D W4, [W14]
1057:                  global_debug_counter.reversescale16bit_saturation++;
003890  80C2D4     MOV 0x185A, W4
003892  E80204     INC W4, W4
003894  88C2D4     MOV W4, 0x185A
1058:                }
1059:                temp = temp & 0xFFFF;
003896  2FFFF4     MOV #0xFFFF, W4
003898  200005     MOV #0x0, W5
00389A  BE031E     MOV.D [W14], W6
00389C  780006     MOV W6, W0
00389E  780307     MOV W7, W6
0038A0  780384     MOV W4, W7
0038A2  780205     MOV W5, W4
0038A4  600007     AND W0, W7, W0
0038A6  630204     AND W6, W4, W4
0038A8  200005     MOV #0x0, W5
0038AA  DD22C0     SL W4, #0, W5
0038AC  200004     MOV #0x0, W4
0038AE  BE0304     MOV.D W4, W6
0038B0  B80261     MUL.UU W0, #1, W4
0038B2  730304     IOR W6, W4, W6
0038B4  738385     IOR W7, W5, W7
0038B6  BE8F06     MOV.D W6, [W14]
1060:                return temp;
0038B8  78021E     MOV [W14], W4
1061:              }
0038BA  780004     MOV W4, W0
0038BC  FA8000     ULNK
0038BE  060000     RETURN
---  C:/Users/dparker/Documents/GitHub/TestDan/Main.c  --------------------------------------------------
1:                 #include <p30F6014a.h>
2:                 #include <libpic30.h>
3:                 #include <adc12.h>
4:                 #include "A34760.h"
5:                 #include "A34760_PINS.h"
6:                 #include "IOPorts.h"
7:                 #include "LTC2656.h"
8:                 #include <i2c.h>
9:                 #include "MCP23017.h"
10:                #include "ETMSPI.h"
11:                #include <spi.h>
12:                #include "ETMdsp.h"
13:                #include "config.h"
14:                
15:                
16:                void ReadAllEEpromToRAM(void);
17:                
18:                _prog_addressT EE_address_ps_magnet_config_in_EEPROM;
19:                unsigned int _EEDATA(32) ps_magnet_config_in_EEPROM[] = PS_MAGNET_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
20:                signed int ps_magnet_config_ram_copy[16];
21:                
22:                _prog_addressT EE_address_ps_filament_config_in_EEPROM;
23:                unsigned int _EEDATA(32) ps_filament_config_in_EEPROM[] = PS_FILAMENT_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
24:                signed int ps_filament_config_ram_copy[16];
25:                
26:                _prog_addressT EE_address_ps_thyr_cathode_htr_config_in_EEPROM;
27:                unsigned int _EEDATA(32) ps_thyr_cathode_htr_config_in_EEPROM[] = PS_THYR_CATH_HTR_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
28:                signed int ps_thyr_cathode_htr_config_ram_copy[16];
29:                
30:                _prog_addressT EE_address_ps_thyr_reservoir_htr_config_in_EEPROM;
31:                unsigned int _EEDATA(32) ps_thyr_reservoir_htr_config_in_EEPROM[] = PS_THYR_RESER_HTR_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
32:                signed int ps_thyr_reservoir_htr_config_ram_copy[16];
33:                
34:                
35:                _prog_addressT EE_address_ps_hv_lambda_mode_A_config_in_EEPROM;
36:                unsigned int _EEDATA(32) ps_hv_lambda_mode_A_config_in_EEPROM[] = PS_HV_LAMBDA_MODE_A_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
37:                signed int ps_hv_lambda_mode_A_config_ram_copy[16];
38:                
39:                _prog_addressT EE_address_ps_hv_lambda_mode_B_config_in_EEPROM;
40:                unsigned int _EEDATA(32) ps_hv_lambda_mode_B_config_in_EEPROM[] = PS_HV_LAMBDA_MODE_B_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
41:                signed int ps_hv_lambda_mode_B_config_ram_copy[16];
42:                
43:                
44:                _prog_addressT EE_address_ps_magnetron_mode_A_config_in_EEPROM;
45:                unsigned int _EEDATA(32) ps_magnetron_mode_A_config_in_EEPROM[] = PS_MAGNETRON_MODE_A_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
46:                signed int ps_magnetron_mode_A_config_ram_copy[16];
47:                
48:                _prog_addressT EE_address_ps_magnetron_mode_B_config_in_EEPROM;
49:                unsigned int _EEDATA(32) ps_magnetron_mode_B_config_in_EEPROM[] = PS_MAGNETRON_MODE_B_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
50:                signed int ps_magnetron_mode_B_config_ram_copy[16];
51:                
52:                _prog_addressT EE_address_pulse_counter_repository_in_EEPROM;
53:                unsigned int _EEDATA(32) pulse_counter_repository_in_EEPROM[] = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};  // Create 16 word structure in EEPROM and load zeros
54:                signed int pulse_counter_repository_ram_copy[16];
55:                
56:                
57:                _prog_addressT EE_address_control_loop_cal_data_in_EEPROM;
58:                unsigned int _EEDATA(32) control_loop_cal_data_in_EEPROM[] = CONTROL_LOOP_CAL_DATA_DEFAULT_CONFIG; // Create 16 word structure in EEPROM and load default configuration values
59:                signed int control_loop_cal_data_ram_copy[16];
60:                
61:                
62:                /*
63:                  
64:                  
65:                 */
66:                
67:                
68:                
69:                /*
70:                  Pulse Counter Structure
71:                  pulse_counter_repository_ram_copy[0] = pulse_counter MSB
72:                  pulse_counter_repository_ram_copy[1] = pulse_counter 
73:                  pulse_counter_repository_ram_copy[2] = pulse_counter 
74:                  pulse_counter_repository_ram_copy[3] = pulse_counter LSB
75:                
76:                  pulse_counter_repository_ram_copy[4] = arc_counter MSB
77:                  pulse_counter_repository_ram_copy[5] = arc_counter LSB
78:                
79:                
80:                */
81:                
82:                
83:                
84:                /* Configuration Bit Settings */
85:                //_FOSC(LPRC & CSW_FSCM_OFF);
86:                _FOSC(ECIO & CSW_FSCM_OFF); // Primary Oscillator with PLL and Startup with User Selected Oscillator Source
87:                // DPARKER this is for use with 40MHz ext clock
88:                
89:                //_FOSC(FRC_PLL16 & CSW_FSCM_OFF); // Primary Oscillator with PLL and Startup with User Selected Oscillator Source
90:                                                 // External Oscillator is 7.3738MHz with 16x PLL and 4x Clocks per Instruction cycle
91:                                                 // This yields an Instruction Cycle Frequency of 29.4952 MHz
92:                                                 // This yields an Instruction Cycle Time of 33.904nS
93:                
94:                
95:                // Watchdog Timeout is 2 Millisconds with no pre scallers
96:                _FWDT(WDT_ON & WDTPSA_1 & WDTPSB_2);  // Watchdog Timer is enabled, 4ms TIMEOUT
97:                //_FWDT(WDT_ON & WDTPSA_1 & WDTPSB_16);  // Watchdog Timer is enabled, 32ms TIMEOUT
98:                //_FWDT(WDT_OFF & WDTPSA_1 & WDTPSB_16);  // Watchdog Timer is disnabled, 32ms TIMEOUT
99:                
100:               
101:               //_FBORPOR(PWRT_64 & BORV_27 & PBOR_ON & MCLR_EN); // Brown out and Power on Timer settings
102:               _FBORPOR(PWRT_OFF & BORV_45 & PBOR_OFF & MCLR_EN); // Brown out and Power on Timer settings
103:               
104:               // _FBS()  // No Boot Segment
105:               
106:               _FBS(WR_PROTECT_BOOT_OFF & NO_BOOT_CODE & NO_BOOT_EEPROM & NO_BOOT_RAM);
107:               
108:               _FSS(WR_PROT_SEC_OFF & NO_SEC_CODE & NO_SEC_EEPROM & NO_SEC_RAM);
109:               
110:               _FGS(CODE_PROT_OFF);
111:               
112:               _FICD(PGD);
113:               
114:               int main(void) {
004918  FA0000     LNK #0x0
115:               
116:                 TRIS_PIN_MAGNETRON_MAGNET_ENABLE = TRIS_OUTPUT_MODE;
00491A  A922D3     BCLR 0x2D3, #1
117:                 PIN_MAGNETRON_MAGNET_ENABLE = OLL_MAGNETRON_MAGNET_ENABLED;
00491C  A922D7     BCLR 0x2D7, #1
118:                 
119:                 PIN_MCU_CLOCK_OUT_TEST_POINT = 1;
00491E  A8E2D1     BSET 0x2D1, #7
120:                 TRIS_PIN_MCU_CLOCK_OUT_TEST_POINT = TRIS_OUTPUT_MODE;
004920  A9E2CD     BCLR 0x2CD, #7
121:               
122:               
123:                 control_state = STATE_START_UP;
004922  B3C044     MOV #0x4, W4
004924  784004     MOV.B W4, W0
004926  B7E832     MOV.B WREG, control_state
124:                 if ((PIN_FP_MODULATOR_ENABLE_INPUT == ILL_MODULATOR_ENABLED) && (PIN_FP_MODULATOR_HV_ON_INPUT == ILL_MODULATOR_HV_ON) && (PIN_FAST_RESTART_STORAGE_CAP_INPUT == ILL_DO_FAST_RESTART)) {
004928  801615     MOV PORTA, W5
00492A  240004     MOV #0x4000, W4
00492C  628204     AND W5, W4, W4
00492E  520FE0     SUB W4, #0x0, [W15]
004930  3A000D     BRA NZ, 0x494C
004932  801615     MOV PORTA, W5
004934  280004     MOV #0x8000, W4
004936  628204     AND W5, W4, W4
004938  520FE0     SUB W4, #0x0, [W15]
00493A  3A0008     BRA NZ, 0x494C
00493C  801615     MOV PORTA, W5
00493E  202004     MOV #0x200, W4
004940  628204     AND W5, W4, W4
004942  520FE0     SUB W4, #0x0, [W15]
004944  3A0003     BRA NZ, 0x494C
125:                   control_state = STATE_FAST_RECOVERY_START_UP;  // Execute fast startup straight to HV ON
004946  B3C064     MOV #0x6, W4
004948  784004     MOV.B W4, W0
00494A  B7E832     MOV.B WREG, control_state
126:                 }
127:                 
128:               
129:                 ReadAllEEpromToRAM();  // Ream all configuration from EEPROM into RAM
00494C  070005     RCALL ReadAllEEpromToRAM
130:               
131:                 ram_config_set_magnetron_magnet_current_from_GUI = 0;  // On processor rest, Magnet current is set from Mode A Voltage and not from the GUI
00494E  EB4200     CLR.B W4
004950  784004     MOV.B W4, W0
004952  B7E822     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
132:               
133:               
134:                 while (1) {
135:                   DoStateMachine();
004954  07DD00     RCALL DoStateMachine
136:                 }
004956  37FFFE     BRA 0x4954
137:               }
138:               
139:               
140:               
141:               void ReadAllEEpromToRAM(void) {
004958  FA0000     LNK #0x0
142:                 _init_prog_address(EE_address_ps_magnet_config_in_EEPROM, ps_magnet_config_in_EEPROM);
00495A  2F0004     MOV #0xF000, W4
00495C  2007F5     MOV #0x7F, W5
00495E  88B704     MOV W4, EE_address_ps_magnet_config_in_EEPROM
004960  88B715     MOV W5, 0x16E2
143:                 _memcpy_p2d16(ps_magnet_config_ram_copy, EE_address_ps_magnet_config_in_EEPROM, _EE_ROW);
004962  80B706     MOV EE_address_ps_magnet_config_in_EEPROM, W6
004964  80B717     MOV 0x16E2, W7
004966  EB0200     CLR W4
004968  200203     MOV #0x20, W3
00496A  216E42     MOV #0x16E4, W2
00496C  BE0006     MOV.D W6, W0
00496E  07DC79     RCALL __memcpy_helper
144:                 ClrWdt();
004970  FE6000     CLRWDT
145:               
146:                 _init_prog_address(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_in_EEPROM);
004972  2F0204     MOV #0xF020, W4
004974  2007F5     MOV #0x7F, W5
004976  88B824     MOV W4, EE_address_ps_filament_config_in_EEPROM
004978  88B835     MOV W5, 0x1706
147:                 _memcpy_p2d16(ps_filament_config_ram_copy, EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
00497A  80B826     MOV EE_address_ps_filament_config_in_EEPROM, W6
00497C  80B837     MOV 0x1706, W7
00497E  EB0200     CLR W4
004980  200203     MOV #0x20, W3
004982  217082     MOV #0x1708, W2
004984  BE0006     MOV.D W6, W0
004986  07DC6D     RCALL __memcpy_helper
148:                 ClrWdt();
004988  FE6000     CLRWDT
149:               
150:                 _init_prog_address(EE_address_ps_thyr_cathode_htr_config_in_EEPROM, ps_thyr_cathode_htr_config_in_EEPROM);
00498A  2F0404     MOV #0xF040, W4
00498C  2007F5     MOV #0x7F, W5
00498E  88B944     MOV W4, EE_address_ps_thyr_cathode_htr_config_in_EEPROM
004990  88B955     MOV W5, 0x172A
151:                 _memcpy_p2d16(ps_thyr_cathode_htr_config_ram_copy, EE_address_ps_thyr_cathode_htr_config_in_EEPROM, _EE_ROW);
004992  80B946     MOV EE_address_ps_thyr_cathode_htr_config_in_EEPROM, W6
004994  80B957     MOV 0x172A, W7
004996  EB0200     CLR W4
004998  200203     MOV #0x20, W3
00499A  2172C2     MOV #0x172C, W2
00499C  BE0006     MOV.D W6, W0
00499E  07DC61     RCALL __memcpy_helper
152:                 ClrWdt();
0049A0  FE6000     CLRWDT
153:               
154:                 _init_prog_address(EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, ps_thyr_reservoir_htr_config_in_EEPROM);
0049A2  2F0604     MOV #0xF060, W4
0049A4  2007F5     MOV #0x7F, W5
0049A6  88BA64     MOV W4, EE_address_ps_thyr_reservoir_htr_config_in_EEPROM
0049A8  88BA75     MOV W5, 0x174E
155:                 _memcpy_p2d16(ps_thyr_reservoir_htr_config_ram_copy, EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, _EE_ROW);
0049AA  80BA66     MOV EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, W6
0049AC  80BA77     MOV 0x174E, W7
0049AE  EB0200     CLR W4
0049B0  200203     MOV #0x20, W3
0049B2  217502     MOV #0x1750, W2
0049B4  BE0006     MOV.D W6, W0
0049B6  07DC55     RCALL __memcpy_helper
156:                 ClrWdt();
0049B8  FE6000     CLRWDT
157:               
158:                 _init_prog_address(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, ps_hv_lambda_mode_A_config_in_EEPROM);
0049BA  2F0804     MOV #0xF080, W4
0049BC  2007F5     MOV #0x7F, W5
0049BE  88BB84     MOV W4, EE_address_ps_hv_lambda_mode_A_config_in_EEPROM
0049C0  88BB95     MOV W5, 0x1772
159:                 _memcpy_p2d16(ps_hv_lambda_mode_A_config_ram_copy, EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, _EE_ROW);
0049C2  80BB86     MOV EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, W6
0049C4  80BB97     MOV 0x1772, W7
0049C6  EB0200     CLR W4
0049C8  200203     MOV #0x20, W3
0049CA  217742     MOV #0x1774, W2
0049CC  BE0006     MOV.D W6, W0
0049CE  07DC49     RCALL __memcpy_helper
160:                 ClrWdt();
0049D0  FE6000     CLRWDT
161:               
162:                 _init_prog_address(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, ps_hv_lambda_mode_B_config_in_EEPROM);
0049D2  2F0A04     MOV #0xF0A0, W4
0049D4  2007F5     MOV #0x7F, W5
0049D6  88BCA4     MOV W4, EE_address_ps_hv_lambda_mode_B_config_in_EEPROM
0049D8  88BCB5     MOV W5, 0x1796
163:                 _memcpy_p2d16(ps_hv_lambda_mode_B_config_ram_copy, EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, _EE_ROW);
0049DA  80BCA6     MOV EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, W6
0049DC  80BCB7     MOV 0x1796, W7
0049DE  EB0200     CLR W4
0049E0  200203     MOV #0x20, W3
0049E2  217982     MOV #0x1798, W2
0049E4  BE0006     MOV.D W6, W0
0049E6  07DC3D     RCALL __memcpy_helper
164:                 ClrWdt();
0049E8  FE6000     CLRWDT
165:               
166:                 _init_prog_address(EE_address_ps_magnetron_mode_A_config_in_EEPROM, ps_magnetron_mode_A_config_in_EEPROM);
0049EA  2F0C04     MOV #0xF0C0, W4
0049EC  2007F5     MOV #0x7F, W5
0049EE  88BDC4     MOV W4, EE_address_ps_magnetron_mode_A_config_in_EEPROM
0049F0  88BDD5     MOV W5, 0x17BA
167:                 _memcpy_p2d16(ps_magnetron_mode_A_config_ram_copy, EE_address_ps_magnetron_mode_A_config_in_EEPROM, _EE_ROW);
0049F2  80BDC6     MOV EE_address_ps_magnetron_mode_A_config_in_EEPROM, W6
0049F4  80BDD7     MOV 0x17BA, W7
0049F6  EB0200     CLR W4
0049F8  200203     MOV #0x20, W3
0049FA  217BC2     MOV #0x17BC, W2
0049FC  BE0006     MOV.D W6, W0
0049FE  07DC31     RCALL __memcpy_helper
168:                 ClrWdt();
004A00  FE6000     CLRWDT
169:               
170:                 _init_prog_address(EE_address_ps_magnetron_mode_B_config_in_EEPROM, ps_magnetron_mode_B_config_in_EEPROM);
004A02  2F0E04     MOV #0xF0E0, W4
004A04  2007F5     MOV #0x7F, W5
004A06  88BEE4     MOV W4, EE_address_ps_magnetron_mode_B_config_in_EEPROM
004A08  88BEF5     MOV W5, 0x17DE
171:                 _memcpy_p2d16(ps_magnetron_mode_B_config_ram_copy, EE_address_ps_magnetron_mode_B_config_in_EEPROM, _EE_ROW);
004A0A  80BEE6     MOV EE_address_ps_magnetron_mode_B_config_in_EEPROM, W6
004A0C  80BEF7     MOV 0x17DE, W7
004A0E  EB0200     CLR W4
004A10  200203     MOV #0x20, W3
004A12  217E02     MOV #0x17E0, W2
004A14  BE0006     MOV.D W6, W0
004A16  07DC25     RCALL __memcpy_helper
172:                 ClrWdt();
004A18  FE6000     CLRWDT
173:               
174:                 _init_prog_address(EE_address_pulse_counter_repository_in_EEPROM, pulse_counter_repository_in_EEPROM);
004A1A  2F1004     MOV #0xF100, W4
004A1C  2007F5     MOV #0x7F, W5
004A1E  88C004     MOV W4, EE_address_pulse_counter_repository_in_EEPROM
004A20  88C015     MOV W5, 0x1802
175:                 _memcpy_p2d16(pulse_counter_repository_ram_copy, EE_address_pulse_counter_repository_in_EEPROM, _EE_ROW);
004A22  80C006     MOV EE_address_pulse_counter_repository_in_EEPROM, W6
004A24  80C017     MOV 0x1802, W7
004A26  EB0200     CLR W4
004A28  200203     MOV #0x20, W3
004A2A  218042     MOV #0x1804, W2
004A2C  BE0006     MOV.D W6, W0
004A2E  07DC19     RCALL __memcpy_helper
176:                 ClrWdt();
004A30  FE6000     CLRWDT
177:               
178:                 _init_prog_address(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_in_EEPROM);
004A32  2F1204     MOV #0xF120, W4
004A34  2007F5     MOV #0x7F, W5
004A36  88C124     MOV W4, EE_address_control_loop_cal_data_in_EEPROM
004A38  88C135     MOV W5, 0x1826
179:                 _memcpy_p2d16(control_loop_cal_data_ram_copy, EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
004A3A  80C126     MOV EE_address_control_loop_cal_data_in_EEPROM, W6
004A3C  80C137     MOV 0x1826, W7
004A3E  EB0200     CLR W4
004A40  200203     MOV #0x20, W3
004A42  218282     MOV #0x1828, W2
004A44  BE0006     MOV.D W6, W0
004A46  07DC0D     RCALL __memcpy_helper
180:                 ClrWdt();
004A48  FE6000     CLRWDT
181:               }
004A4A  FA8000     ULNK
004A4C  060000     RETURN
---  C:/Users/dparker/Documents/GitHub/TestDan/MCP23017.c  ----------------------------------------------
1:                 #include "MCP23017.h"
2:                 #include "ETMI2C.h"
3:                 
4:                 unsigned int MCP23017WriteSingleByte(MCP23017* ptr_MCP23017, unsigned char MCP23017_register, unsigned char register_data) {
004B66  FA0006     LNK #0x6
004B68  980710     MOV W0, [W14+2]
004B6A  984741     MOV.B W1, [W14+4]
004B6C  984752     MOV.B W2, [W14+5]
5:                   unsigned int error_check;
6:                   
7:                   error_check = WaitForI2CBusIdle(ptr_MCP23017->i2c_port);                                                    // Wait for I2C Bus idle
004B6E  90021E     MOV [W14+2], W4
004B70  904274     MOV.B [W4+7], W4
004B72  784004     MOV.B W4, W0
004B74  07FDC2     RCALL WaitForI2CBusIdle
004B76  780200     MOV W0, W4
004B78  780F04     MOV W4, [W14]
8:                 
9:                   error_check |= GenerateI2CStart(ptr_MCP23017->i2c_port);                                                    // Generate start condition 
004B7A  90021E     MOV [W14+2], W4
004B7C  904274     MOV.B [W4+7], W4
004B7E  784004     MOV.B W4, W0
004B80  07FDE5     RCALL GenerateI2CStart
004B82  780200     MOV W0, W4
004B84  720F1E     IOR W4, [W14], [W14]
10:                
11:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_WRITE_CONTROL_BIT), ptr_MCP23017->i2c_port);  // Write the address to the bus in WRITE MODE
004B86  90021E     MOV [W14+2], W4
004B88  9042F4     MOV.B [W4+7], W5
004B8A  90021E     MOV [W14+2], W4
004B8C  904264     MOV.B [W4+6], W4
004B8E  784085     MOV.B W5, W1
004B90  784004     MOV.B W4, W0
004B92  07FE2C     RCALL WriteByteI2C
004B94  780200     MOV W0, W4
004B96  720F1E     IOR W4, [W14], [W14]
12:                  
13:                  error_check |= WriteByteI2C(MCP23017_register, ptr_MCP23017->i2c_port);                                     // Write the register location to the bus
004B98  90021E     MOV [W14+2], W4
004B9A  904274     MOV.B [W4+7], W4
004B9C  784084     MOV.B W4, W1
004B9E  90404E     MOV.B [W14+4], W0
004BA0  07FE25     RCALL WriteByteI2C
004BA2  780200     MOV W0, W4
004BA4  720F1E     IOR W4, [W14], [W14]
14:                
15:                  error_check |= WriteByteI2C(register_data, ptr_MCP23017->i2c_port);                                         // Write the data to the bus
004BA6  90021E     MOV [W14+2], W4
004BA8  904274     MOV.B [W4+7], W4
004BAA  784084     MOV.B W4, W1
004BAC  90405E     MOV.B [W14+5], W0
004BAE  07FE1E     RCALL WriteByteI2C
004BB0  780200     MOV W0, W4
004BB2  720F1E     IOR W4, [W14], [W14]
16:                  
17:                  error_check |= GenerateI2CStop(ptr_MCP23017->i2c_port);                                                     // Generate Stop Condition
004BB4  90021E     MOV [W14+2], W4
004BB6  904274     MOV.B [W4+7], W4
004BB8  784004     MOV.B W4, W0
004BBA  07FE86     RCALL GenerateI2CStop
004BBC  780200     MOV W0, W4
004BBE  720F1E     IOR W4, [W14], [W14]
18:                  
19:                  ClrWdt();
004BC0  FE6000     CLRWDT
20:                  return error_check;
004BC2  78021E     MOV [W14], W4
21:                }
004BC4  780004     MOV W4, W0
004BC6  FA8000     ULNK
004BC8  060000     RETURN
22:                
23:                unsigned int MCP23017ReadSingleByte(MCP23017* ptr_MCP23017, unsigned char MCP23017_register) {
004BCA  FA0006     LNK #0x6
004BCC  980710     MOV W0, [W14+2]
004BCE  984741     MOV.B W1, [W14+4]
24:                  unsigned int error_check;
25:                  
26:                  error_check = WaitForI2CBusIdle(ptr_MCP23017->i2c_port);                                                    // Wait for I2C Bus idle
004BD0  90021E     MOV [W14+2], W4
004BD2  904274     MOV.B [W4+7], W4
004BD4  784004     MOV.B W4, W0
004BD6  07FD91     RCALL WaitForI2CBusIdle
004BD8  780200     MOV W0, W4
004BDA  780F04     MOV W4, [W14]
27:                
28:                  error_check |= GenerateI2CStart(ptr_MCP23017->i2c_port);                                                    // Generate start condition 
004BDC  90021E     MOV [W14+2], W4
004BDE  904274     MOV.B [W4+7], W4
004BE0  784004     MOV.B W4, W0
004BE2  07FDB4     RCALL GenerateI2CStart
004BE4  780200     MOV W0, W4
004BE6  720F1E     IOR W4, [W14], [W14]
29:                
30:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_WRITE_CONTROL_BIT), ptr_MCP23017->i2c_port);  // Write the address to the bus in WRITE MODE
004BE8  90021E     MOV [W14+2], W4
004BEA  9042F4     MOV.B [W4+7], W5
004BEC  90021E     MOV [W14+2], W4
004BEE  904264     MOV.B [W4+6], W4
004BF0  784085     MOV.B W5, W1
004BF2  784004     MOV.B W4, W0
004BF4  07FDFB     RCALL WriteByteI2C
004BF6  780200     MOV W0, W4
004BF8  720F1E     IOR W4, [W14], [W14]
31:                
32:                  error_check |= WriteByteI2C(MCP23017_register, ptr_MCP23017->i2c_port);                                     // Write the register location to the bus
004BFA  90021E     MOV [W14+2], W4
004BFC  904274     MOV.B [W4+7], W4
004BFE  784084     MOV.B W4, W1
004C00  90404E     MOV.B [W14+4], W0
004C02  07FDF4     RCALL WriteByteI2C
004C04  780200     MOV W0, W4
004C06  720F1E     IOR W4, [W14], [W14]
33:                
34:                  error_check |= GenerateI2CRestart(ptr_MCP23017->i2c_port);                                                  // Generate re-start condition 
004C08  90021E     MOV [W14+2], W4
004C0A  904274     MOV.B [W4+7], W4
004C0C  784004     MOV.B W4, W0
004C0E  07FDC6     RCALL GenerateI2CRestart
004C10  780200     MOV W0, W4
004C12  720F1E     IOR W4, [W14], [W14]
35:                
36:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_READ_CONTROL_BIT), ptr_MCP23017->i2c_port);   // Write the address to the bus in READ MODE
004C14  90021E     MOV [W14+2], W4
004C16  9042F4     MOV.B [W4+7], W5
004C18  90021E     MOV [W14+2], W4
004C1A  904264     MOV.B [W4+6], W4
004C1C  A00404     BSET.B W4, #0
004C1E  784085     MOV.B W5, W1
004C20  784004     MOV.B W4, W0
004C22  07FDE4     RCALL WriteByteI2C
004C24  780200     MOV W0, W4
004C26  720F1E     IOR W4, [W14], [W14]
37:                
38:                  error_check |= ReadByteI2C(ptr_MCP23017->i2c_port);                                                         // Read a byte from the bus
004C28  90021E     MOV [W14+2], W4
004C2A  904274     MOV.B [W4+7], W4
004C2C  784004     MOV.B W4, W0
004C2E  07FE16     RCALL ReadByteI2C
004C30  780200     MOV W0, W4
004C32  720F1E     IOR W4, [W14], [W14]
39:                  
40:                  error_check |= GenerateI2CStop(ptr_MCP23017->i2c_port);                                                     // Generate Stop Condition
004C34  90021E     MOV [W14+2], W4
004C36  904274     MOV.B [W4+7], W4
004C38  784004     MOV.B W4, W0
004C3A  07FE46     RCALL GenerateI2CStop
004C3C  780200     MOV W0, W4
004C3E  720F1E     IOR W4, [W14], [W14]
41:                  
42:                  ClrWdt();
004C40  FE6000     CLRWDT
43:                  return error_check;
004C42  78021E     MOV [W14], W4
44:                }
004C44  780004     MOV W4, W0
004C46  FA8000     ULNK
004C48  060000     RETURN
45:                
46:                
47:                
48:                
49:                
---  C:/Users/dparker/Documents/GitHub/TestDan/LTC2656.c  -----------------------------------------------
1:                 #include "LTC2656.h"
2:                 
3:                 
4:                 void SetupLTC2656(LTC2656* ptr_LTC2656) {
004160  FA0002     LNK #0x2
004162  780F00     MOV W0, [W14]
5:                   // See h File For Documentation
6:                   
7:                   PinSetValue(ptr_LTC2656->pin_dac_clear, !LTC2656_CLEAR_OUTPUTS);
004164  78021E     MOV [W14], W4
004166  900214     MOV [W4+2], W4
004168  784204     MOV.B W4, W4
00416A  B3C011     MOV #0x1, W1
00416C  784004     MOV.B W4, W0
00416E  07021D     RCALL PinSetValue
8:                   PinSetValue(ptr_LTC2656->pin_load_dac, LTC2656_LOAD_DAC);
004170  78021E     MOV [W14], W4
004172  900224     MOV [W4+4], W4
004174  784204     MOV.B W4, W4
004176  EB4080     CLR.B W1
004178  784004     MOV.B W4, W0
00417A  070217     RCALL PinSetValue
9:                   PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
00417C  78021E     MOV [W14], W4
00417E  780214     MOV [W4], W4
004180  784204     MOV.B W4, W4
004182  B3C011     MOV #0x1, W1
004184  784004     MOV.B W4, W0
004186  070211     RCALL PinSetValue
10:                  PinSetValue(ptr_LTC2656->pin_por_select, ptr_LTC2656->por_select_value);
004188  78021E     MOV [W14], W4
00418A  900244     MOV [W4+8], W4
00418C  784284     MOV.B W4, W5
00418E  78021E     MOV [W14], W4
004190  900234     MOV [W4+6], W4
004192  784204     MOV.B W4, W4
004194  784085     MOV.B W5, W1
004196  784004     MOV.B W4, W0
004198  070208     RCALL PinSetValue
11:                  
12:                  PinSetTris(ptr_LTC2656->pin_cable_select, TRIS_DIGITAL_OUTPUT);
00419A  78021E     MOV [W14], W4
00419C  780214     MOV [W4], W4
00419E  784204     MOV.B W4, W4
0041A0  EB4080     CLR.B W1
0041A2  784004     MOV.B W4, W0
0041A4  07015A     RCALL PinSetTris
13:                  PinSetTris(ptr_LTC2656->pin_dac_clear, TRIS_DIGITAL_INPUT);
0041A6  78021E     MOV [W14], W4
0041A8  900214     MOV [W4+2], W4
0041AA  784204     MOV.B W4, W4
0041AC  B3C011     MOV #0x1, W1
0041AE  784004     MOV.B W4, W0
0041B0  070154     RCALL PinSetTris
14:                  PinSetTris(ptr_LTC2656->pin_load_dac, TRIS_DIGITAL_OUTPUT);
0041B2  78021E     MOV [W14], W4
0041B4  900224     MOV [W4+4], W4
0041B6  784204     MOV.B W4, W4
0041B8  EB4080     CLR.B W1
0041BA  784004     MOV.B W4, W0
0041BC  07014E     RCALL PinSetTris
15:                  PinSetTris(ptr_LTC2656->pin_por_select, TRIS_DIGITAL_OUTPUT);  
0041BE  78021E     MOV [W14], W4
0041C0  900234     MOV [W4+6], W4
0041C2  784204     MOV.B W4, W4
0041C4  EB4080     CLR.B W1
0041C6  784004     MOV.B W4, W0
0041C8  070148     RCALL PinSetTris
16:                }
0041CA  FA8000     ULNK
0041CC  060000     RETURN
17:                
18:                
19:                void ClearOutputsLTC2656(LTC2656* ptr_LTC2656) {
0041CE  FA0002     LNK #0x2
0041D0  780F00     MOV W0, [W14]
20:                  PinSetValue(ptr_LTC2656->pin_dac_clear, LTC2656_CLEAR_OUTPUTS);
0041D2  78021E     MOV [W14], W4
0041D4  900214     MOV [W4+2], W4
0041D6  784204     MOV.B W4, W4
0041D8  EB4080     CLR.B W1
0041DA  784004     MOV.B W4, W0
0041DC  0701E6     RCALL PinSetValue
21:                  PinSetValue(ptr_LTC2656->pin_dac_clear, !LTC2656_CLEAR_OUTPUTS);
0041DE  78021E     MOV [W14], W4
0041E0  900214     MOV [W4+2], W4
0041E2  784204     MOV.B W4, W4
0041E4  B3C011     MOV #0x1, W1
0041E6  784004     MOV.B W4, W0
0041E8  0701E0     RCALL PinSetValue
22:                }
0041EA  FA8000     ULNK
0041EC  060000     RETURN
23:                
24:                
25:                
26:                unsigned char WriteLTC2656(LTC2656* ptr_LTC2656, unsigned int command_word, unsigned int data_word) {
0041EE  FA0010     LNK #0x10
0041F0  980750     MOV W0, [W14+10]
0041F2  980761     MOV W1, [W14+12]
0041F4  980772     MOV W2, [W14+14]
27:                  // See h File For Documentation
28:                  
29:                  unsigned char spi_error;
30:                  unsigned int command_word_readback;
31:                  unsigned int data_word_readback;
32:                  unsigned long temp;
33:                  
34:                  spi_error = 0;
0041F6  EB4200     CLR.B W4
0041F8  784F04     MOV.B W4, [W14]
35:                
36:                  PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
0041FA  90025E     MOV [W14+10], W4
0041FC  780214     MOV [W4], W4
0041FE  784204     MOV.B W4, W4
004200  EB4080     CLR.B W1
004202  784004     MOV.B W4, W0
004204  0701D2     RCALL PinSetValue
37:                
38:                
39:                  temp = SendAndReceiveSPI(command_word, ptr_LTC2656->spi_port);
004206  90025E     MOV [W14+10], W4
004208  904A24     MOV.B [W4+10], W4
00420A  784084     MOV.B W4, W1
00420C  90006E     MOV [W14+12], W0
00420E  07041F     RCALL SendAndReceiveSPI
004210  BE0200     MOV.D W0, W4
004212  980734     MOV W4, [W14+6]
004214  980745     MOV W5, [W14+8]
40:                  if (temp == 0x11110000) {
004216  90033E     MOV [W14+6], W6
004218  9003CE     MOV [W14+8], W7
00421A  200004     MOV #0x0, W4
00421C  211115     MOV #0x1111, W5
00421E  530F84     SUB W6, W4, [W15]
004220  5B8F85     SUBB W7, W5, [W15]
004222  3A0002     BRA NZ, 0x4228
41:                    spi_error = 0b00000001;
004224  B3C014     MOV #0x1, W4
004226  784F04     MOV.B W4, [W14]
42:                  } 
43:                
44:                  if (spi_error == 0) { 
004228  78421E     MOV.B [W14], W4
00422A  524FE0     SUB.B W4, #0x0, [W15]
00422C  3A0010     BRA NZ, 0x424E
45:                    temp = SendAndReceiveSPI(data_word, ptr_LTC2656->spi_port);
00422E  90025E     MOV [W14+10], W4
004230  904A24     MOV.B [W4+10], W4
004232  784084     MOV.B W4, W1
004234  90007E     MOV [W14+14], W0
004236  07040B     RCALL SendAndReceiveSPI
004238  BE0200     MOV.D W0, W4
00423A  980734     MOV W4, [W14+6]
00423C  980745     MOV W5, [W14+8]
46:                    if (temp == 0x11110000) {
00423E  90033E     MOV [W14+6], W6
004240  9003CE     MOV [W14+8], W7
004242  200004     MOV #0x0, W4
004244  211115     MOV #0x1111, W5
004246  530F84     SUB W6, W4, [W15]
004248  5B8F85     SUBB W7, W5, [W15]
00424A  3A0001     BRA NZ, 0x424E
47:                      spi_error |= 0b00000010;
00424C  A0141E     BSET.B [W14], #1
48:                    } 
49:                  }
50:                 
51:                
52:                  PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
00424E  90025E     MOV [W14+10], W4
004250  780214     MOV [W4], W4
004252  784204     MOV.B W4, W4
004254  B3C011     MOV #0x1, W1
004256  784004     MOV.B W4, W0
004258  0701A8     RCALL PinSetValue
53:                 
54:                  Nop();
00425A  000000     NOP
55:                  
56:                  PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
00425C  90025E     MOV [W14+10], W4
00425E  780214     MOV [W4], W4
004260  784204     MOV.B W4, W4
004262  EB4080     CLR.B W1
004264  784004     MOV.B W4, W0
004266  0701A1     RCALL PinSetValue
57:                
58:                
59:                  if (spi_error == 0) { 
004268  78421E     MOV.B [W14], W4
00426A  524FE0     SUB.B W4, #0x0, [W15]
00426C  3A0012     BRA NZ, 0x4292
60:                    temp = SendAndReceiveSPI(LTC2656_CMD_NO_OPERATION, ptr_LTC2656->spi_port);
00426E  90025E     MOV [W14+10], W4
004270  904A24     MOV.B [W4+10], W4
004272  784084     MOV.B W4, W1
004274  200F00     MOV #0xF0, W0
004276  0703EB     RCALL SendAndReceiveSPI
004278  BE0200     MOV.D W0, W4
00427A  980734     MOV W4, [W14+6]
00427C  980745     MOV W5, [W14+8]
61:                    command_word_readback = temp & 0xFFFF;
00427E  90023E     MOV [W14+6], W4
004280  980714     MOV W4, [W14+2]
62:                    if (temp == 0x11110000) {
004282  90033E     MOV [W14+6], W6
004284  9003CE     MOV [W14+8], W7
004286  200004     MOV #0x0, W4
004288  211115     MOV #0x1111, W5
00428A  530F84     SUB W6, W4, [W15]
00428C  5B8F85     SUBB W7, W5, [W15]
00428E  3A0001     BRA NZ, 0x4292
63:                      spi_error |= 0b00000100;
004290  A0241E     BSET.B [W14], #2
64:                    } 
65:                  }
66:                
67:                  if (spi_error == 0) { 
004292  78421E     MOV.B [W14], W4
004294  524FE0     SUB.B W4, #0x0, [W15]
004296  3A0012     BRA NZ, 0x42BC
68:                    temp = SendAndReceiveSPI(0, ptr_LTC2656->spi_port);
004298  90025E     MOV [W14+10], W4
00429A  904A24     MOV.B [W4+10], W4
00429C  784084     MOV.B W4, W1
00429E  EB0000     CLR W0
0042A0  0703D6     RCALL SendAndReceiveSPI
0042A2  BE0200     MOV.D W0, W4
0042A4  980734     MOV W4, [W14+6]
0042A6  980745     MOV W5, [W14+8]
69:                    data_word_readback = temp & 0xFFFF;
0042A8  90023E     MOV [W14+6], W4
0042AA  980724     MOV W4, [W14+4]
70:                    if (temp == 0x11110000) {
0042AC  90033E     MOV [W14+6], W6
0042AE  9003CE     MOV [W14+8], W7
0042B0  200004     MOV #0x0, W4
0042B2  211115     MOV #0x1111, W5
0042B4  530F84     SUB W6, W4, [W15]
0042B6  5B8F85     SUBB W7, W5, [W15]
0042B8  3A0001     BRA NZ, 0x42BC
71:                      spi_error |= 0b00001000;
0042BA  A0341E     BSET.B [W14], #3
72:                    } 
73:                  }
74:                
75:                  PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
0042BC  90025E     MOV [W14+10], W4
0042BE  780214     MOV [W4], W4
0042C0  784204     MOV.B W4, W4
0042C2  B3C011     MOV #0x1, W1
0042C4  784004     MOV.B W4, W0
0042C6  070171     RCALL PinSetValue
76:                
77:                
78:                  if (command_word_readback != command_word) {
0042C8  90029E     MOV [W14+2], W5
0042CA  90026E     MOV [W14+12], W4
0042CC  528F84     SUB W5, W4, [W15]
0042CE  320001     BRA Z, 0x42D2
79:                    spi_error |= 0b00010000;
0042D0  A0441E     BSET.B [W14], #4
80:                  }
81:                  if (data_word_readback != data_word) {
0042D2  9002AE     MOV [W14+4], W5
0042D4  90027E     MOV [W14+14], W4
0042D6  528F84     SUB W5, W4, [W15]
0042D8  320002     BRA Z, 0x42DE
82:                    spi_error |= 0b00100000;
0042DA  B3C204     MOV #0x20, W4
0042DC  724F1E     IOR.B W4, [W14], [W14]
83:                  }
84:                  
85:                
86:                  return spi_error;
0042DE  78421E     MOV.B [W14], W4
87:                }
0042E0  784004     MOV.B W4, W0
0042E2  FA8000     ULNK
0042E4  060000     RETURN
88:                
89:                
90:                unsigned char WriteLTC2656AllDacChannels(LTC2656* ptr_LTC2656, unsigned int *dac_array) {
0042E6  FA0010     LNK #0x10
0042E8  980760     MOV W0, [W14+12]
0042EA  980771     MOV W1, [W14+14]
91:                  // See h File For Documentation
92:                  
93:                  unsigned char spi_error;
94:                  unsigned int command_word_readback;
95:                  unsigned int data_word_readback;
96:                  unsigned long temp;
97:                  unsigned char dac_number;
98:                
99:                  spi_error = 0;
0042EC  EB4200     CLR.B W4
0042EE  784F04     MOV.B W4, [W14]
100:                 dac_number = 0;
0042F0  EB4200     CLR.B W4
0042F2  984764     MOV.B W4, [W14+6]
101:                 
102:                 while ((spi_error == 0) && (dac_number < 8)) {
0042F4  370059     BRA 0x43A8
0043A8  78421E     MOV.B [W14], W4
0043AA  524FE0     SUB.B W4, #0x0, [W15]
0043AC  3A0003     BRA NZ, 0x43B4
0043AE  90426E     MOV.B [W14+6], W4
0043B0  524FE7     SUB.B W4, #0x7, [W15]
0043B2  36FFA1     BRA LEU, 0x42F6
103:                   // Send out two 16 bit words on the SPI BUS
104:               
105:                   PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
0042F6  90026E     MOV [W14+12], W4
0042F8  780214     MOV [W4], W4
0042FA  784204     MOV.B W4, W4
0042FC  EB4080     CLR.B W1
0042FE  784004     MOV.B W4, W0
004300  070154     RCALL PinSetValue
106:                   
107:                   temp = SendAndReceiveSPI(LTC2656_CMD_WRITE_AND_UPDATE_N | dac_number, ptr_LTC2656->spi_port);
004302  90026E     MOV [W14+12], W4
004304  904A24     MOV.B [W4+10], W4
004306  90436E     MOV.B [W14+6], W6
004308  B3C305     MOV #0x30, W5
00430A  734285     IOR.B W6, W5, W5
00430C  FB8285     ZE W5, W5
00430E  784084     MOV.B W4, W1
004310  780005     MOV W5, W0
004312  07039D     RCALL SendAndReceiveSPI
004314  BE0200     MOV.D W0, W4
004316  980744     MOV W4, [W14+8]
004318  980755     MOV W5, [W14+10]
108:                   command_word_readback = temp & 0xFFFF;
00431A  90024E     MOV [W14+8], W4
00431C  980714     MOV W4, [W14+2]
109:                   if (temp == 0x11110000) {
00431E  90034E     MOV [W14+8], W6
004320  9003DE     MOV [W14+10], W7
004322  200004     MOV #0x0, W4
004324  211115     MOV #0x1111, W5
004326  530F84     SUB W6, W4, [W15]
004328  5B8F85     SUBB W7, W5, [W15]
00432A  3A0002     BRA NZ, 0x4330
110:                     spi_error = 0b00000001;
00432C  B3C014     MOV #0x1, W4
00432E  784F04     MOV.B W4, [W14]
111:                   } 
112:                   
113:                   if (spi_error == 0) { 
004330  78421E     MOV.B [W14], W4
004332  524FE0     SUB.B W4, #0x0, [W15]
004334  3A0018     BRA NZ, 0x4366
114:                     temp = SendAndReceiveSPI(dac_array[dac_number], ptr_LTC2656->spi_port);
004336  90026E     MOV [W14+12], W4
004338  904A24     MOV.B [W4+10], W4
00433A  9042EE     MOV.B [W14+6], W5
00433C  FB8285     ZE W5, W5
00433E  428285     ADD W5, W5, W5
004340  90037E     MOV [W14+14], W6
004342  430285     ADD W6, W5, W5
004344  780295     MOV [W5], W5
004346  784084     MOV.B W4, W1
004348  780005     MOV W5, W0
00434A  070381     RCALL SendAndReceiveSPI
00434C  BE0200     MOV.D W0, W4
00434E  980744     MOV W4, [W14+8]
004350  980755     MOV W5, [W14+10]
115:                     data_word_readback = temp & 0xFFFF;
004352  90024E     MOV [W14+8], W4
004354  980724     MOV W4, [W14+4]
116:                     if (temp == 0x11110000) {
004356  90034E     MOV [W14+8], W6
004358  9003DE     MOV [W14+10], W7
00435A  200004     MOV #0x0, W4
00435C  211115     MOV #0x1111, W5
00435E  530F84     SUB W6, W4, [W15]
004360  5B8F85     SUBB W7, W5, [W15]
004362  3A0001     BRA NZ, 0x4366
117:               	spi_error |= 0b00000010;
004364  A0141E     BSET.B [W14], #1
118:                     } 
119:                   }
120:               
121:                   // Check that the command/data returned match the command/data sent out on the previous cycle
122:                   if (dac_number > 0) {
004366  90426E     MOV.B [W14+6], W4
004368  524FE0     SUB.B W4, #0x0, [W15]
00436A  320015     BRA Z, 0x4396
123:                     if (command_word_readback != (LTC2656_CMD_WRITE_AND_UPDATE_N | (dac_number - 1))) {
00436C  90426E     MOV.B [W14+6], W4
00436E  FB8204     ZE W4, W4
004370  E90284     DEC W4, W5
004372  200304     MOV #0x30, W4
004374  728204     IOR W5, W4, W4
004376  780284     MOV W4, W5
004378  90021E     MOV [W14+2], W4
00437A  528F84     SUB W5, W4, [W15]
00437C  320001     BRA Z, 0x4380
124:               	spi_error |= 0b00000100;
00437E  A0241E     BSET.B [W14], #2
125:                     }
126:                     if (data_word_readback != dac_array[dac_number-1]) {
004380  90426E     MOV.B [W14+6], W4
004382  FB8204     ZE W4, W4
004384  E90204     DEC W4, W4
004386  420204     ADD W4, W4, W4
004388  9002FE     MOV [W14+14], W5
00438A  428204     ADD W5, W4, W4
00438C  780294     MOV [W4], W5
00438E  90022E     MOV [W14+4], W4
004390  528F84     SUB W5, W4, [W15]
004392  320001     BRA Z, 0x4396
127:               	spi_error |= 0b00001000;
004394  A0341E     BSET.B [W14], #3
128:                     }   
129:                   }
130:                   
131:                   PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
004396  90026E     MOV [W14+12], W4
004398  780214     MOV [W4], W4
00439A  784204     MOV.B W4, W4
00439C  B3C011     MOV #0x1, W1
00439E  784004     MOV.B W4, W0
0043A0  070104     RCALL PinSetValue
132:                   
133:                   dac_number++;
0043A2  90426E     MOV.B [W14+6], W4
0043A4  E84204     INC.B W4, W4
0043A6  984764     MOV.B W4, [W14+6]
134:                 }
135:               
136:                 // Read back the error check from the last command/data string sent out
137:                 PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
0043B4  90026E     MOV [W14+12], W4
0043B6  780214     MOV [W4], W4
0043B8  784204     MOV.B W4, W4
0043BA  EB4080     CLR.B W1
0043BC  784004     MOV.B W4, W0
0043BE  0700F5     RCALL PinSetValue
138:               
139:                 if (spi_error == 0) { 
0043C0  78421E     MOV.B [W14], W4
0043C2  524FE0     SUB.B W4, #0x0, [W15]
0043C4  3A0012     BRA NZ, 0x43EA
140:                   temp = SendAndReceiveSPI(LTC2656_CMD_NO_OPERATION, ptr_LTC2656->spi_port);
0043C6  90026E     MOV [W14+12], W4
0043C8  904A24     MOV.B [W4+10], W4
0043CA  784084     MOV.B W4, W1
0043CC  200F00     MOV #0xF0, W0
0043CE  07033F     RCALL SendAndReceiveSPI
0043D0  BE0200     MOV.D W0, W4
0043D2  980744     MOV W4, [W14+8]
0043D4  980755     MOV W5, [W14+10]
141:                   command_word_readback = temp & 0xFFFF;
0043D6  90024E     MOV [W14+8], W4
0043D8  980714     MOV W4, [W14+2]
142:                   if (temp == 0x11110000) {
0043DA  90034E     MOV [W14+8], W6
0043DC  9003DE     MOV [W14+10], W7
0043DE  200004     MOV #0x0, W4
0043E0  211115     MOV #0x1111, W5
0043E2  530F84     SUB W6, W4, [W15]
0043E4  5B8F85     SUBB W7, W5, [W15]
0043E6  3A0001     BRA NZ, 0x43EA
143:                     spi_error |= 0b00000001;
0043E8  A0041E     BSET.B [W14], #0
144:                   } 
145:                 }
146:               
147:                 if (spi_error == 0) { 
0043EA  78421E     MOV.B [W14], W4
0043EC  524FE0     SUB.B W4, #0x0, [W15]
0043EE  3A0012     BRA NZ, 0x4414
148:                   temp = SendAndReceiveSPI(0, ptr_LTC2656->spi_port);
0043F0  90026E     MOV [W14+12], W4
0043F2  904A24     MOV.B [W4+10], W4
0043F4  784084     MOV.B W4, W1
0043F6  EB0000     CLR W0
0043F8  07032A     RCALL SendAndReceiveSPI
0043FA  BE0200     MOV.D W0, W4
0043FC  980744     MOV W4, [W14+8]
0043FE  980755     MOV W5, [W14+10]
149:                   data_word_readback = temp & 0xFFFF;
004400  90024E     MOV [W14+8], W4
004402  980724     MOV W4, [W14+4]
150:                   if (temp == 0x11110000) {
004404  90034E     MOV [W14+8], W6
004406  9003DE     MOV [W14+10], W7
004408  200004     MOV #0x0, W4
00440A  211115     MOV #0x1111, W5
00440C  530F84     SUB W6, W4, [W15]
00440E  5B8F85     SUBB W7, W5, [W15]
004410  3A0001     BRA NZ, 0x4414
151:                     spi_error |= 0b00000010;
004412  A0141E     BSET.B [W14], #1
152:                   } 
153:                 }
154:                 
155:                 PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
004414  90026E     MOV [W14+12], W4
004416  780214     MOV [W4], W4
004418  784204     MOV.B W4, W4
00441A  B3C011     MOV #0x1, W1
00441C  784004     MOV.B W4, W0
00441E  0700C5     RCALL PinSetValue
156:                 
157:                 
158:                 if (command_word_readback != (LTC2656_CMD_WRITE_AND_UPDATE_N | (dac_number - 1))) {
004420  90426E     MOV.B [W14+6], W4
004422  FB8204     ZE W4, W4
004424  E90284     DEC W4, W5
004426  200304     MOV #0x30, W4
004428  728204     IOR W5, W4, W4
00442A  780284     MOV W4, W5
00442C  90021E     MOV [W14+2], W4
00442E  528F84     SUB W5, W4, [W15]
004430  320001     BRA Z, 0x4434
159:                   spi_error |= 0b00010000;
004432  A0441E     BSET.B [W14], #4
160:                 }
161:                 if (data_word_readback != dac_array[dac_number-1]) {
004434  90426E     MOV.B [W14+6], W4
004436  FB8204     ZE W4, W4
004438  E90204     DEC W4, W4
00443A  420204     ADD W4, W4, W4
00443C  9002FE     MOV [W14+14], W5
00443E  428204     ADD W5, W4, W4
004440  780294     MOV [W4], W5
004442  90022E     MOV [W14+4], W4
004444  528F84     SUB W5, W4, [W15]
004446  320002     BRA Z, 0x444C
162:                   spi_error |= 0b00100000;
004448  B3C204     MOV #0x20, W4
00444A  724F1E     IOR.B W4, [W14], [W14]
163:                 }
164:               
165:               
166:                 Nop();
00444C  000000     NOP
167:                 Nop();
00444E  000000     NOP
168:                 Nop();
004450  000000     NOP
169:               
170:               
171:                 return spi_error;
004452  78421E     MOV.B [W14], W4
172:               }
004454  784004     MOV.B W4, W0
004456  FA8000     ULNK
004458  060000     RETURN
---  C:/Users/dparker/Documents/GitHub/TestDan/IOPorts.c  -----------------------------------------------
1:                 #include "IOPorts.h"
2:                 
3:                 
4:                 void PinSetTris(unsigned char pin, unsigned char tris_state) {
00445A  FA0004     LNK #0x4
00445C  984720     MOV.B W0, [W14+2]
00445E  984731     MOV.B W1, [W14+3]
5:                   /*
6:                     This is a very ineffecient way of setting the TRIS, but it is usefull because it 
7:                     1) Allows a framework for pins to passed to function
8:                     2) Is easy for others to use as a simple integer for the pin can be passed to functions
9:                   */
10:                  
11:                  unsigned char port;
12:                  unsigned char bit;
13:                  
14:                  port = pin & 0xF0;
004460  9042AE     MOV.B [W14+2], W5
004462  B3CF04     MOV #0xF0, W4
004464  62CF04     AND.B W5, W4, [W14]
15:                  bit = pin & 0x0F;
004466  90422E     MOV.B [W14+2], W4
004468  62426F     AND.B W4, #0xF, W4
00446A  984714     MOV.B W4, [W14+1]
16:                  
17:                  switch (port) {
00446C  78429E     MOV.B [W14], W5
00446E  FB8205     ZE W5, W4
004470  200B05     MOV #0xB0, W5
004472  520F85     SUB W4, W5, [W15]
004474  32002A     BRA Z, 0x44CA
004476  200B05     MOV #0xB0, W5
004478  520F85     SUB W4, W5, [W15]
00447A  3C0007     BRA GT, 0x448A
00447C  200905     MOV #0x90, W5
00447E  520F85     SUB W4, W5, [W15]
004480  32007C     BRA Z, 0x457A
004482  200A05     MOV #0xA0, W5
004484  520F85     SUB W4, W5, [W15]
004486  32000B     BRA Z, 0x449E
004488  37008E     BRA 0x45A6
00448A  200D05     MOV #0xD0, W5
00448C  520F85     SUB W4, W5, [W15]
00448E  320049     BRA Z, 0x4522
004490  200F05     MOV #0xF0, W5
004492  520F85     SUB W4, W5, [W15]
004494  32005C     BRA Z, 0x454E
004496  200C05     MOV #0xC0, W5
004498  520F85     SUB W4, W5, [W15]
00449A  32002D     BRA Z, 0x44F6
00449C  370084     BRA 0x45A6
18:                    
19:                #if defined(_PORTA)
20:                  case _PORT_PORTA:
21:                    if (tris_state) {
00449E  90423E     MOV.B [W14+3], W4
0044A0  524FE0     SUB.B W4, #0x0, [W15]
0044A2  320009     BRA Z, 0x44B6
22:                      TRISA = TRISA | (0x01 << bit);
0044A4  90421E     MOV.B [W14+1], W4
0044A6  FB8204     ZE W4, W4
0044A8  200015     MOV #0x1, W5
0044AA  DD2A04     SL W5, W4, W4
0044AC  780284     MOV W4, W5
0044AE  801604     MOV TRISA, W4
0044B0  728204     IOR W5, W4, W4
0044B2  881604     MOV W4, TRISA
23:                    } else {
24:                      TRISA = TRISA & (~(0x01 << bit));
0044B6  90421E     MOV.B [W14+1], W4
0044B8  FB8204     ZE W4, W4
0044BA  200015     MOV #0x1, W5
0044BC  DD2A04     SL W5, W4, W4
0044BE  EA8204     COM W4, W4
0044C0  780284     MOV W4, W5
0044C2  801604     MOV TRISA, W4
0044C4  628204     AND W5, W4, W4
0044C6  881604     MOV W4, TRISA
25:                    }
26:                    break;
0044B4  370078     BRA 0x45A6
0044C8  37006E     BRA 0x45A6
27:                #endif
28:                
29:                #if defined(_PORTB)
30:                  case _PORT_PORTB:
31:                    if (tris_state) {
0044CA  90423E     MOV.B [W14+3], W4
0044CC  524FE0     SUB.B W4, #0x0, [W15]
0044CE  320009     BRA Z, 0x44E2
32:                      TRISB = TRISB | (0x01 << bit);
0044D0  90421E     MOV.B [W14+1], W4
0044D2  FB8204     ZE W4, W4
0044D4  200015     MOV #0x1, W5
0044D6  DD2A04     SL W5, W4, W4
0044D8  780284     MOV W4, W5
0044DA  801634     MOV TRISB, W4
0044DC  728204     IOR W5, W4, W4
0044DE  881634     MOV W4, TRISB
33:                    } else {
34:                      TRISB = TRISB & (~(0x01 << bit));
0044E2  90421E     MOV.B [W14+1], W4
0044E4  FB8204     ZE W4, W4
0044E6  200015     MOV #0x1, W5
0044E8  DD2A04     SL W5, W4, W4
0044EA  EA8204     COM W4, W4
0044EC  780284     MOV W4, W5
0044EE  801634     MOV TRISB, W4
0044F0  628204     AND W5, W4, W4
0044F2  881634     MOV W4, TRISB
35:                    }
36:                    break;
0044E0  370062     BRA 0x45A6
0044F4  370058     BRA 0x45A6
37:                #endif
38:                    
39:                #if defined(_PORTC)
40:                  case _PORT_PORTC:
41:                    if (tris_state) {
0044F6  90423E     MOV.B [W14+3], W4
0044F8  524FE0     SUB.B W4, #0x0, [W15]
0044FA  320009     BRA Z, 0x450E
42:                      TRISC = TRISC | (0x01 << bit);
0044FC  90421E     MOV.B [W14+1], W4
0044FE  FB8204     ZE W4, W4
004500  200015     MOV #0x1, W5
004502  DD2A04     SL W5, W4, W4
004504  780284     MOV W4, W5
004506  801664     MOV TRISC, W4
004508  728204     IOR W5, W4, W4
00450A  881664     MOV W4, TRISC
43:                    } else {
44:                      TRISC = TRISC & (~(0x01 << bit));
00450E  90421E     MOV.B [W14+1], W4
004510  FB8204     ZE W4, W4
004512  200015     MOV #0x1, W5
004514  DD2A04     SL W5, W4, W4
004516  EA8204     COM W4, W4
004518  780284     MOV W4, W5
00451A  801664     MOV TRISC, W4
00451C  628204     AND W5, W4, W4
00451E  881664     MOV W4, TRISC
45:                    }
46:                    break;
00450C  37004C     BRA 0x45A6
004520  370042     BRA 0x45A6
47:                #endif
48:                
49:                #if defined(_PORTD)
50:                  case _PORT_PORTD:
51:                    if (tris_state) {
004522  90423E     MOV.B [W14+3], W4
004524  524FE0     SUB.B W4, #0x0, [W15]
004526  320009     BRA Z, 0x453A
52:                      TRISD = TRISD | (0x01 << bit);
004528  90421E     MOV.B [W14+1], W4
00452A  FB8204     ZE W4, W4
00452C  200015     MOV #0x1, W5
00452E  DD2A04     SL W5, W4, W4
004530  780284     MOV W4, W5
004532  801694     MOV TRISD, W4
004534  728204     IOR W5, W4, W4
004536  881694     MOV W4, TRISD
53:                    } else {
54:                      TRISD = TRISD & (~(0x01 << bit));
00453A  90421E     MOV.B [W14+1], W4
00453C  FB8204     ZE W4, W4
00453E  200015     MOV #0x1, W5
004540  DD2A04     SL W5, W4, W4
004542  EA8204     COM W4, W4
004544  780284     MOV W4, W5
004546  801694     MOV TRISD, W4
004548  628204     AND W5, W4, W4
00454A  881694     MOV W4, TRISD
55:                    }
56:                    break;
004538  370036     BRA 0x45A6
00454C  37002C     BRA 0x45A6
57:                #endif
58:                
59:                
60:                #if defined(_PORTE)    
61:                  case _PORT_PORTE:
62:                    if (tris_state) {
63:                      TRISE = TRISE | (0x01 << bit);
64:                    } else {
65:                      TRISE = TRISE & (~(0x01 << bit));
66:                    }
67:                    break;
68:                #endif
69:                
70:                #if defined(_PORTF)    
71:                  case _PORT_PORTF:
72:                    if (tris_state) {
00454E  90423E     MOV.B [W14+3], W4
004550  524FE0     SUB.B W4, #0x0, [W15]
004552  320009     BRA Z, 0x4566
73:                      TRISF = TRISF | (0x01 << bit);
004554  90421E     MOV.B [W14+1], W4
004556  FB8204     ZE W4, W4
004558  200015     MOV #0x1, W5
00455A  DD2A04     SL W5, W4, W4
00455C  780284     MOV W4, W5
00455E  8016F4     MOV TRISF, W4
004560  728204     IOR W5, W4, W4
004562  8816F4     MOV W4, TRISF
74:                    } else {
75:                      TRISF = TRISF & (~(0x01 << bit));
004566  90421E     MOV.B [W14+1], W4
004568  FB8204     ZE W4, W4
00456A  200015     MOV #0x1, W5
00456C  DD2A04     SL W5, W4, W4
00456E  EA8204     COM W4, W4
004570  780284     MOV W4, W5
004572  8016F4     MOV TRISF, W4
004574  628204     AND W5, W4, W4
004576  8816F4     MOV W4, TRISF
76:                    }
77:                    break;
004564  370020     BRA 0x45A6
004578  370016     BRA 0x45A6
78:                #endif
79:                    
80:                #if defined(_PORTG)
81:                  case _PORT_PORTG:
82:                    if (tris_state) {
00457A  90423E     MOV.B [W14+3], W4
00457C  524FE0     SUB.B W4, #0x0, [W15]
00457E  320009     BRA Z, 0x4592
83:                      TRISG = TRISG | (0x01 << bit);
004580  90421E     MOV.B [W14+1], W4
004582  FB8204     ZE W4, W4
004584  200015     MOV #0x1, W5
004586  DD2A04     SL W5, W4, W4
004588  780284     MOV W4, W5
00458A  801724     MOV TRISG, W4
00458C  728204     IOR W5, W4, W4
00458E  881724     MOV W4, TRISG
84:                    } else {
85:                      TRISG = TRISG & (~(0x01 << bit));
004592  90421E     MOV.B [W14+1], W4
004594  FB8204     ZE W4, W4
004596  200015     MOV #0x1, W5
004598  DD2A04     SL W5, W4, W4
00459A  EA8204     COM W4, W4
00459C  780284     MOV W4, W5
00459E  801724     MOV TRISG, W4
0045A0  628204     AND W5, W4, W4
0045A2  881724     MOV W4, TRISG
86:                    }
87:                    break;
004590  37000A     BRA 0x45A6
0045A4  000000     NOP
88:                #endif
89:                    
90:                  }
91:                }
0045A6  FA8000     ULNK
0045A8  060000     RETURN
92:                
93:                void PinSetValue(unsigned char pin, unsigned char pin_value) {
0045AA  FA0004     LNK #0x4
0045AC  984720     MOV.B W0, [W14+2]
0045AE  984731     MOV.B W1, [W14+3]
94:                  /*
95:                    This is a very ineffecient way of setting pins, but it is usefull because it 
96:                    1) Allows a framework for pins to passed to function
97:                    2) Is easy for others to use as a simple integer for the pin can be passed to functions
98:                    Note that is changes the LATCH registers not, the output registers.  DO NOT SET the output registers, use the Latches instead
99:                  */
100:                 
101:                 unsigned char port;
102:                 unsigned char bit;
103:                 
104:                 port = pin & 0xF0; 
0045B0  9042AE     MOV.B [W14+2], W5
0045B2  B3CF04     MOV #0xF0, W4
0045B4  62CF04     AND.B W5, W4, [W14]
105:                 bit = pin & 0x0F;
0045B6  90422E     MOV.B [W14+2], W4
0045B8  62426F     AND.B W4, #0xF, W4
0045BA  984714     MOV.B W4, [W14+1]
106:                 
107:                 switch (port) {
0045BC  78429E     MOV.B [W14], W5
0045BE  FB8205     ZE W5, W4
0045C0  200B05     MOV #0xB0, W5
0045C2  520F85     SUB W4, W5, [W15]
0045C4  32002A     BRA Z, 0x461A
0045C6  200B05     MOV #0xB0, W5
0045C8  520F85     SUB W4, W5, [W15]
0045CA  3C0007     BRA GT, 0x45DA
0045CC  200905     MOV #0x90, W5
0045CE  520F85     SUB W4, W5, [W15]
0045D0  32007C     BRA Z, 0x46CA
0045D2  200A05     MOV #0xA0, W5
0045D4  520F85     SUB W4, W5, [W15]
0045D6  32000B     BRA Z, 0x45EE
0045D8  37008E     BRA 0x46F6
0045DA  200D05     MOV #0xD0, W5
0045DC  520F85     SUB W4, W5, [W15]
0045DE  320049     BRA Z, 0x4672
0045E0  200F05     MOV #0xF0, W5
0045E2  520F85     SUB W4, W5, [W15]
0045E4  32005C     BRA Z, 0x469E
0045E6  200C05     MOV #0xC0, W5
0045E8  520F85     SUB W4, W5, [W15]
0045EA  32002D     BRA Z, 0x4646
0045EC  370084     BRA 0x46F6
108:                
109:               #if defined(_PORTA)
110:                 case _PORT_PORTA:
111:                   if (pin_value) {
0045EE  90423E     MOV.B [W14+3], W4
0045F0  524FE0     SUB.B W4, #0x0, [W15]
0045F2  320009     BRA Z, 0x4606
112:                     LATA = LATA | (0x01 << bit);
0045F4  90421E     MOV.B [W14+1], W4
0045F6  FB8204     ZE W4, W4
0045F8  200015     MOV #0x1, W5
0045FA  DD2A04     SL W5, W4, W4
0045FC  780284     MOV W4, W5
0045FE  801624     MOV LATA, W4
004600  728204     IOR W5, W4, W4
004602  881624     MOV W4, LATA
113:                   } else {
114:                     LATA = LATA & (~(0x01 << bit));
004606  90421E     MOV.B [W14+1], W4
004608  FB8204     ZE W4, W4
00460A  200015     MOV #0x1, W5
00460C  DD2A04     SL W5, W4, W4
00460E  EA8204     COM W4, W4
004610  780284     MOV W4, W5
004612  801624     MOV LATA, W4
004614  628204     AND W5, W4, W4
004616  881624     MOV W4, LATA
115:                   }
116:                   break;
004604  370078     BRA 0x46F6
004618  37006E     BRA 0x46F6
117:               #endif
118:               
119:               #if defined(_PORTB)
120:                 case _PORT_PORTB:
121:                   if (pin_value) {
00461A  90423E     MOV.B [W14+3], W4
00461C  524FE0     SUB.B W4, #0x0, [W15]
00461E  320009     BRA Z, 0x4632
122:                     LATB = LATB | (0x01 << bit);
004620  90421E     MOV.B [W14+1], W4
004622  FB8204     ZE W4, W4
004624  200015     MOV #0x1, W5
004626  DD2A04     SL W5, W4, W4
004628  780284     MOV W4, W5
00462A  801654     MOV LATB, W4
00462C  728204     IOR W5, W4, W4
00462E  881654     MOV W4, LATB
123:                   } else {
124:                     LATB = LATB & (~(0x01 << bit));
004632  90421E     MOV.B [W14+1], W4
004634  FB8204     ZE W4, W4
004636  200015     MOV #0x1, W5
004638  DD2A04     SL W5, W4, W4
00463A  EA8204     COM W4, W4
00463C  780284     MOV W4, W5
00463E  801654     MOV LATB, W4
004640  628204     AND W5, W4, W4
004642  881654     MOV W4, LATB
125:                   }
126:                   break;
004630  370062     BRA 0x46F6
004644  370058     BRA 0x46F6
127:               #endif
128:               
129:               #if defined(_PORTC)
130:                 case _PORT_PORTC:
131:                   if (pin_value) {
004646  90423E     MOV.B [W14+3], W4
004648  524FE0     SUB.B W4, #0x0, [W15]
00464A  320009     BRA Z, 0x465E
132:                     LATB = LATB | (0x01 << bit);
00464C  90421E     MOV.B [W14+1], W4
00464E  FB8204     ZE W4, W4
004650  200015     MOV #0x1, W5
004652  DD2A04     SL W5, W4, W4
004654  780284     MOV W4, W5
004656  801654     MOV LATB, W4
004658  728204     IOR W5, W4, W4
00465A  881654     MOV W4, LATB
133:                   } else {
134:                     LATB = LATB & (~(0x01 << bit));
00465E  90421E     MOV.B [W14+1], W4
004660  FB8204     ZE W4, W4
004662  200015     MOV #0x1, W5
004664  DD2A04     SL W5, W4, W4
004666  EA8204     COM W4, W4
004668  780284     MOV W4, W5
00466A  801654     MOV LATB, W4
00466C  628204     AND W5, W4, W4
00466E  881654     MOV W4, LATB
135:                   }
136:                   break;
00465C  37004C     BRA 0x46F6
004670  370042     BRA 0x46F6
137:               #endif
138:               
139:               #if defined(_PORTD)
140:                 case _PORT_PORTD:
141:                   if (pin_value) {
004672  90423E     MOV.B [W14+3], W4
004674  524FE0     SUB.B W4, #0x0, [W15]
004676  320009     BRA Z, 0x468A
142:                     LATD = LATD | (0x01 << bit);
004678  90421E     MOV.B [W14+1], W4
00467A  FB8204     ZE W4, W4
00467C  200015     MOV #0x1, W5
00467E  DD2A04     SL W5, W4, W4
004680  780284     MOV W4, W5
004682  8016B4     MOV LATD, W4
004684  728204     IOR W5, W4, W4
004686  8816B4     MOV W4, LATD
143:                   } else {
144:                     LATD = LATD & (~(0x01 << bit));
00468A  90421E     MOV.B [W14+1], W4
00468C  FB8204     ZE W4, W4
00468E  200015     MOV #0x1, W5
004690  DD2A04     SL W5, W4, W4
004692  EA8204     COM W4, W4
004694  780284     MOV W4, W5
004696  8016B4     MOV LATD, W4
004698  628204     AND W5, W4, W4
00469A  8816B4     MOV W4, LATD
145:                   }
146:                   break;
004688  370036     BRA 0x46F6
00469C  37002C     BRA 0x46F6
147:               #endif
148:               
149:               #if defined(_PORTE)
150:                 case _PORT_PORTE:
151:                   if (pin_value) {
152:                     LATE = LATE | (0x01 << bit);
153:                   } else {
154:                     LATE = LATE & (~(0x01 << bit));
155:                   }
156:                   break;
157:               #endif
158:               
159:               #if defined(_PORTF)
160:                 case _PORT_PORTF:
161:                   if (pin_value) {
00469E  90423E     MOV.B [W14+3], W4
0046A0  524FE0     SUB.B W4, #0x0, [W15]
0046A2  320009     BRA Z, 0x46B6
162:                     LATF = LATF | (0x01 << bit);
0046A4  90421E     MOV.B [W14+1], W4
0046A6  FB8204     ZE W4, W4
0046A8  200015     MOV #0x1, W5
0046AA  DD2A04     SL W5, W4, W4
0046AC  780284     MOV W4, W5
0046AE  801714     MOV LATF, W4
0046B0  728204     IOR W5, W4, W4
0046B2  881714     MOV W4, LATF
163:                   } else {
164:                     LATF = LATF & (~(0x01 << bit));
0046B6  90421E     MOV.B [W14+1], W4
0046B8  FB8204     ZE W4, W4
0046BA  200015     MOV #0x1, W5
0046BC  DD2A04     SL W5, W4, W4
0046BE  EA8204     COM W4, W4
0046C0  780284     MOV W4, W5
0046C2  801714     MOV LATF, W4
0046C4  628204     AND W5, W4, W4
0046C6  881714     MOV W4, LATF
165:                   }
166:                   break;
0046B4  370020     BRA 0x46F6
0046C8  370016     BRA 0x46F6
167:               #endif
168:               
169:               #if defined(_PORTG)
170:                 case _PORT_PORTG:
171:                   if (pin_value) {
0046CA  90423E     MOV.B [W14+3], W4
0046CC  524FE0     SUB.B W4, #0x0, [W15]
0046CE  320009     BRA Z, 0x46E2
172:                     LATG = LATG | (0x01 << bit);
0046D0  90421E     MOV.B [W14+1], W4
0046D2  FB8204     ZE W4, W4
0046D4  200015     MOV #0x1, W5
0046D6  DD2A04     SL W5, W4, W4
0046D8  780284     MOV W4, W5
0046DA  801744     MOV LATG, W4
0046DC  728204     IOR W5, W4, W4
0046DE  881744     MOV W4, LATG
173:                   } else {
174:                     LATG = LATG & (~(0x01 << bit));
0046E2  90421E     MOV.B [W14+1], W4
0046E4  FB8204     ZE W4, W4
0046E6  200015     MOV #0x1, W5
0046E8  DD2A04     SL W5, W4, W4
0046EA  EA8204     COM W4, W4
0046EC  780284     MOV W4, W5
0046EE  801744     MOV LATG, W4
0046F0  628204     AND W5, W4, W4
0046F2  881744     MOV W4, LATG
175:                   }
176:                   break;
0046E0  37000A     BRA 0x46F6
0046F4  000000     NOP
177:               #endif
178:               
179:                 }
180:               }
0046F6  FA8000     ULNK
0046F8  060000     RETURN
181:               
182:               
183:               
---  C:/Users/dparker/Documents/GitHub/TestDan/ETMdsp.s  ------------------------------------------------
                                                  1:     
                                                  2:     .ifdef __dsPIC30F
                                                  3:             .include "p30fxxxx.inc"
                                                  4:     .endif
                                                  5:     .ifdef __dsPIC33F
                                                  6:             .include "p33Fxxxx.inc"
                                                  7:     .endif
                                                  8:     
                                                  9:             .global  _AverageADC128
                                                  10:    
                                                  11:             .text
                                                  12:    _AverageADC128:
004D5A  780200     MOV W0, W4                     13:    		mov		W0, W4		; move source address
004D5C  C30112     CLR A                          14:    		CLR		A		; 0 40 bit Acc
                                                  15:    
004D5E  09007F     REPEAT #0x7F                   16:    ACC_S:	REPEAT	#127			; add em all up
004D60  C90234     ADD [W4++], #4, A              17:    		ADD		[W4++], #4, A ; signed 16 add to ACCA (right shift 4 bits)
                                                  18:    	                                      ; The data that we want is now stored in the 15 LSB of ACCAH and the 1 MSB of ACCAL
                                                  19:    	                                      ; If we shift the data left one bit and call SAC.R the data will be bashed because
                                                  20:    	                                      ; The accumulator will be signed.  There for we must work around this little problem 
004D62  CC0000     SAC A, W0                      21:    		SAC		A, W0	      ; Move ACCAH to W0
004D64  DD0041     SL W0, #1, W0                  22:    		SL		W0, #1, W0    ; Shift W0 left by one bit.  
004D66  C8007F     SFTAC A, #-1                   23:     		SFTAC           A, #-1        ; Shift Accumulator left by one bit.
004D68  CD0001     SAC.R A, W1                    24:    	        SAC.R           A, W1         ; Move ACCAH to W1
004D6A  B20011     AND #0x1, W1                   25:    		AND             #0x0001, W1   ; W1 &= 0x0001
004D6C  700001     IOR W0, W1, W0                 26:    	        IOR             W0, W1, W0    ; WO = WO | W1
004D6E  060000     RETURN                         27:    		return
                                                  28:    ;--------End of All Code Sections ---------------------------------------------
                                                  29:            .end                               ;End of program code in this file
                                                  30:    
                                                  31:    
                                                  32:    
---  C:/Users/dparker/Documents/GitHub/TestDan/ETMSPI.c  ------------------------------------------------
1:                 #include "ETMSPI.h"
2:                 
3:                 
4:                 unsigned long SendAndReceiveSPI(unsigned int data_word, unsigned char spi_port) {
004A4E  FA0008     LNK #0x8
004A50  980720     MOV W0, [W14+4]
004A52  984761     MOV.B W1, [W14+6]
5:                   unsigned char spi_bus_status;
6:                   unsigned int return_data;
7:                 
8:                   spi_bus_status = SPI_BUS_ACTIVE;
004A54  EB4200     CLR.B W4
004A56  784F04     MOV.B W4, [W14]
9:                   SPI_TIMER_REGISTER = 0;
004A58  EB0200     CLR W4
004A5A  8808A4     MOV W4, TMR4
10:                  SPI_TIMER_PERIOD = SPI_TIMEOUT_CYCLES;
004A5C  20FA04     MOV #0xFA0, W4
004A5E  8808D4     MOV W4, PR4
11:                  SPI_TIMER_INT_FLAG = 0;
004A60  A9A086     BCLR IFS1, #5
12:                  SPI_TIMER_CON_BITS.TON = 1;
004A62  A8E11F     BSET 0x11F, #7
13:                  SPI_TIMER_CON_BITS.TCKPS = SPI_TIMER_PRESCALE_1_1;
004A64  8008F4     MOV T4CON, W4
004A66  A14004     BCLR W4, #4
004A68  A15004     BCLR W4, #5
004A6A  8808F4     MOV W4, T4CON
14:                  
15:                
16:                #if defined(_SPIIF)
17:                  if ((spi_port == 0) || (spi_port == 1)) {
18:                    _SPIIF = 0;
19:                    SPIBUF = data_word;
20:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
21:                      if (SPI_TIMER_INT_FLAG) {
22:                	// There was a timeout of the data read, this is effectivly a fault
23:                	spi_bus_status = SPI_BUS_TIMEOUT;
24:                      }
25:                      if (SPISTATbits.SPIROV) {
26:                	// There was a data overflow in the buffer, this is a fault
27:                	spi_bus_status = SPI_BUS_OVERFLOW;
28:                      }
29:                      if (!SPISTATbits.SPITBF) {
30:                	spi_bus_status = SPI_DATA_SENT;
31:                      }
32:                    }
33:                    
34:                    while(spi_bus_status == SPI_DATA_SENT) {
35:                      if (SPI_TIMER_INT_FLAG) {
36:                	// There was a timeout of the data read, this is effectivly a fault
37:                	spi_bus_status = SPI_BUS_TIMEOUT;
38:                      }
39:                      if (SPISTATbits.SPIROV) {
40:                	// There was a data overflow in the buffer, this is a fault
41:                	spi_bus_status = SPI_BUS_OVERFLOW;
42:                      }
43:                      if (_SPIIF) {
44:                	// Data  been recieved in the buffer, read the data from the return buffer
45:                	spi_bus_status = SPI_DATA_RECEIVED;
46:                      }    
47:                    }
48:                    return_data = SPIBUF;
49:                  }
50:                #endif
51:                
52:                
53:                #if defined(_SPI1IF)
54:                  if (spi_port == 1) {
004A6C  90426E     MOV.B [W14+6], W4
004A6E  524FE1     SUB.B W4, #0x1, [W15]
004A70  3A0036     BRA NZ, 0x4ADE
55:                    _SPI1IF = 0;
004A72  A90085     BCLR 0x85, #0
56:                    SPI1BUF = data_word;
004A74  90022E     MOV [W14+4], W4
004A76  881124     MOV W4, SPI1BUF
57:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
004A78  370014     BRA 0x4AA2
004AA2  78421E     MOV.B [W14], W4
004AA4  524FE0     SUB.B W4, #0x0, [W15]
004AA6  32FFE9     BRA Z, 0x4A7A
58:                      if (SPI_TIMER_INT_FLAG) {
004A7A  800435     MOV IFS1, W5
004A7C  200204     MOV #0x20, W4
004A7E  628204     AND W5, W4, W4
004A80  520FE0     SUB W4, #0x0, [W15]
004A82  320002     BRA Z, 0x4A88
59:                	// There was a timeout of the data read, this is effectivly a fault
60:                	spi_bus_status = SPI_BUS_TIMEOUT;
004A84  B3C034     MOV #0x3, W4
004A86  784F04     MOV.B W4, [W14]
61:                      }
62:                      if (SPI1STATbits.SPIROV) {
004A88  801105     MOV SPI1STAT, W5
004A8A  200404     MOV #0x40, W4
004A8C  628204     AND W5, W4, W4
004A8E  520FE0     SUB W4, #0x0, [W15]
004A90  320002     BRA Z, 0x4A96
63:                	// There was a data overflow in the buffer, this is a fault
64:                	spi_bus_status = SPI_BUS_OVERFLOW;
004A92  B3C044     MOV #0x4, W4
004A94  784F04     MOV.B W4, [W14]
65:                      }
66:                      if (!SPI1STATbits.SPITBF) {
004A96  801104     MOV SPI1STAT, W4
004A98  620262     AND W4, #0x2, W4
004A9A  520FE0     SUB W4, #0x0, [W15]
004A9C  3A0002     BRA NZ, 0x4AA2
67:                	spi_bus_status = SPI_DATA_SENT;
004A9E  B3C014     MOV #0x1, W4
004AA0  784F04     MOV.B W4, [W14]
68:                      }
69:                    }
70:                    
71:                    while(spi_bus_status == SPI_DATA_SENT) {
004AA8  370015     BRA 0x4AD4
004AD4  78421E     MOV.B [W14], W4
004AD6  524FE1     SUB.B W4, #0x1, [W15]
004AD8  32FFE8     BRA Z, 0x4AAA
72:                      if (SPI_TIMER_INT_FLAG) {
004AAA  800435     MOV IFS1, W5
004AAC  200204     MOV #0x20, W4
004AAE  628204     AND W5, W4, W4
004AB0  520FE0     SUB W4, #0x0, [W15]
004AB2  320002     BRA Z, 0x4AB8
73:                	// There was a timeout of the data read, this is effectivly a fault
74:                	spi_bus_status = SPI_BUS_TIMEOUT;
004AB4  B3C034     MOV #0x3, W4
004AB6  784F04     MOV.B W4, [W14]
75:                      }
76:                      if (SPI1STATbits.SPIROV) {
004AB8  801105     MOV SPI1STAT, W5
004ABA  200404     MOV #0x40, W4
004ABC  628204     AND W5, W4, W4
004ABE  520FE0     SUB W4, #0x0, [W15]
004AC0  320002     BRA Z, 0x4AC6
77:                	// There was a data overflow in the buffer, this is a fault
78:                	spi_bus_status = SPI_BUS_OVERFLOW;
004AC2  B3C044     MOV #0x4, W4
004AC4  784F04     MOV.B W4, [W14]
79:                      }
80:                      //if (SPI1STATbits.SPIRBF) {
81:                      // A byte has been recieved in the buffer, read the data from the return buffer
82:                      if (_SPI1IF) {
004AC6  800425     MOV IFS0, W5
004AC8  201004     MOV #0x100, W4
004ACA  628204     AND W5, W4, W4
004ACC  520FE0     SUB W4, #0x0, [W15]
004ACE  320002     BRA Z, 0x4AD4
83:                	// Data  been recieved in the buffer, read the data from the return buffer
84:                	spi_bus_status = SPI_DATA_RECEIVED;
004AD0  B3C024     MOV #0x2, W4
004AD2  784F04     MOV.B W4, [W14]
85:                      }    
86:                    }
87:                    return_data = SPI1BUF;
004ADA  801124     MOV SPI1BUF, W4
004ADC  980714     MOV W4, [W14+2]
88:                  }
89:                #endif
90:                
91:                
92:                
93:                #if defined(_SPI2IF)
94:                  if (spi_port == 2) {
004ADE  90426E     MOV.B [W14+6], W4
004AE0  524FE2     SUB.B W4, #0x2, [W15]
004AE2  3A0036     BRA NZ, 0x4B50
95:                
96:                    _SPI2IF = 0;
004AE4  A94087     BCLR 0x87, #2
97:                    SPI2BUF = data_word;
004AE6  90022E     MOV [W14+4], W4
004AE8  881154     MOV W4, SPI2BUF
98:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
004AEA  370014     BRA 0x4B14
004B14  78421E     MOV.B [W14], W4
004B16  524FE0     SUB.B W4, #0x0, [W15]
004B18  32FFE9     BRA Z, 0x4AEC
99:                      if (SPI_TIMER_INT_FLAG) {
004AEC  800435     MOV IFS1, W5
004AEE  200204     MOV #0x20, W4
004AF0  628204     AND W5, W4, W4
004AF2  520FE0     SUB W4, #0x0, [W15]
004AF4  320002     BRA Z, 0x4AFA
100:               	// There was a timeout of the data read, this is effectivly a fault
101:               	spi_bus_status = SPI_BUS_TIMEOUT;
004AF6  B3C034     MOV #0x3, W4
004AF8  784F04     MOV.B W4, [W14]
102:                     }
103:                     if (SPI2STATbits.SPIROV) {
004AFA  801135     MOV SPI2STAT, W5
004AFC  200404     MOV #0x40, W4
004AFE  628204     AND W5, W4, W4
004B00  520FE0     SUB W4, #0x0, [W15]
004B02  320002     BRA Z, 0x4B08
104:               	// There was a data overflow in the buffer, this is a fault
105:               	spi_bus_status = SPI_BUS_OVERFLOW;
004B04  B3C044     MOV #0x4, W4
004B06  784F04     MOV.B W4, [W14]
106:                     }
107:                     if (!SPI2STATbits.SPITBF) {
004B08  801134     MOV SPI2STAT, W4
004B0A  620262     AND W4, #0x2, W4
004B0C  520FE0     SUB W4, #0x0, [W15]
004B0E  3A0002     BRA NZ, 0x4B14
108:               	spi_bus_status = SPI_DATA_SENT;  // Data has been moved into the shift register for sending out
004B10  B3C014     MOV #0x1, W4
004B12  784F04     MOV.B W4, [W14]
109:                     }
110:                   }
111:                   
112:                   while(spi_bus_status == SPI_DATA_SENT) {
004B1A  370015     BRA 0x4B46
004B46  78421E     MOV.B [W14], W4
004B48  524FE1     SUB.B W4, #0x1, [W15]
004B4A  32FFE8     BRA Z, 0x4B1C
113:                     if (SPI_TIMER_INT_FLAG) {
004B1C  800435     MOV IFS1, W5
004B1E  200204     MOV #0x20, W4
004B20  628204     AND W5, W4, W4
004B22  520FE0     SUB W4, #0x0, [W15]
004B24  320002     BRA Z, 0x4B2A
114:               	// There was a timeout of the data read, this is effectivly a fault
115:               	spi_bus_status = SPI_BUS_TIMEOUT;
004B26  B3C034     MOV #0x3, W4
004B28  784F04     MOV.B W4, [W14]
116:                     }
117:                     if (SPI2STATbits.SPIROV) {
004B2A  801135     MOV SPI2STAT, W5
004B2C  200404     MOV #0x40, W4
004B2E  628204     AND W5, W4, W4
004B30  520FE0     SUB W4, #0x0, [W15]
004B32  320002     BRA Z, 0x4B38
118:               	// There was a data overflow in the buffer, this is a fault
119:               	spi_bus_status = SPI_BUS_OVERFLOW;
004B34  B3C044     MOV #0x4, W4
004B36  784F04     MOV.B W4, [W14]
120:                     }
121:                     if (_SPI2IF) {
004B38  800435     MOV IFS1, W5
004B3A  204004     MOV #0x400, W4
004B3C  628204     AND W5, W4, W4
004B3E  520FE0     SUB W4, #0x0, [W15]
004B40  320002     BRA Z, 0x4B46
122:               	// Data  been recieved in the buffer, read the data from the return buffer
123:               	spi_bus_status = SPI_DATA_RECEIVED;
004B42  B3C024     MOV #0x2, W4
004B44  784F04     MOV.B W4, [W14]
124:                     }    
125:                   }
126:                   return_data = SPI2BUF;
004B4C  801154     MOV SPI2BUF, W4
004B4E  980714     MOV W4, [W14+2]
127:                 }
128:               #endif
129:                 
130:                 if (spi_bus_status == SPI_DATA_RECEIVED) {
004B50  78421E     MOV.B [W14], W4
004B52  524FE2     SUB.B W4, #0x2, [W15]
004B54  3A0003     BRA NZ, 0x4B5C
131:                   return (0x0000FFFF & return_data);
004B56  90021E     MOV [W14+2], W4
004B58  200005     MOV #0x0, W5
004B5A  370002     BRA 0x4B60
132:                 } else {
133:                   return (0x11110000);
004B5C  200004     MOV #0x0, W4
004B5E  211115     MOV #0x1111, W5
134:                 }
135:               }
004B60  BE0004     MOV.D W4, W0
004B62  FA8000     ULNK
004B64  060000     RETURN
---  C:/Users/dparker/Documents/GitHub/TestDan/ETMI2C.c  ------------------------------------------------
1:                 #include "ETMI2C.h"
2:                 
3:                 
4:                 unsigned int WaitForI2CBusIdle(unsigned char i2c_port) {
0046FA  FA0002     LNK #0x2
0046FC  784F00     MOV.B W0, [W14]
5:                   
6:                   I2C_TIMER_REGISTER = 0;
0046FE  EB0200     CLR W4
004700  8808A4     MOV W4, TMR4
7:                   I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004702  23E804     MOV #0x3E80, W4
004704  8808D4     MOV W4, PR4
8:                   I2C_TIMER_INT_FLAG = 0;
004706  A9A086     BCLR IFS1, #5
9:                   I2C_TIMER_CON_BITS.TON = 1;
004708  A8E11F     BSET 0x11F, #7
10:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
00470A  8008F4     MOV T4CON, W4
00470C  A14004     BCLR W4, #4
00470E  A15004     BCLR W4, #5
004710  8808F4     MOV W4, T4CON
11:                  
12:                #if defined(_I2CMD)
13:                  if ((i2c_port == 0) || (i2c_port == 1)) {
004712  78421E     MOV.B [W14], W4
004714  524FE0     SUB.B W4, #0x0, [W15]
004716  320004     BRA Z, 0x4720
004718  78421E     MOV.B [W14], W4
00471A  524FE1     SUB.B W4, #0x1, [W15]
00471C  3A000C     BRA NZ, 0x4736
14:                    while (I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
00471E  370001     BRA 0x4722
004720  000000     NOP
004722  801045     MOV I2CSTAT, W5
004724  240004     MOV #0x4000, W4
004726  628204     AND W5, W4, W4
004728  520FE0     SUB W4, #0x0, [W15]
00472A  320005     BRA Z, 0x4736
00472C  800435     MOV IFS1, W5
00472E  200204     MOV #0x20, W4
004730  628204     AND W5, W4, W4
004732  520FE0     SUB W4, #0x0, [W15]
004734  32FFF6     BRA Z, 0x4722
15:                  }
16:                #endif
17:                
18:                #if defined(_I2C1MD)
19:                  if (i2c_port == 1) {
20:                    while (I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
21:                  }
22:                #endif
23:                
24:                #if defined(_I2C2MD)
25:                  if (i2c_port == 2) {
26:                    while (I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
27:                  }
28:                #endif
29:                    
30:                  if (I2C_TIMER_INT_FLAG) {
004736  800435     MOV IFS1, W5
004738  200204     MOV #0x20, W4
00473A  628204     AND W5, W4, W4
00473C  520FE0     SUB W4, #0x0, [W15]
00473E  320002     BRA Z, 0x4744
31:                    return 0xFA00;
004740  2FA004     MOV #0xFA00, W4
004742  370001     BRA 0x4746
32:                  } else {
33:                    return 0x0000;
004744  EB0200     CLR W4
34:                  }
35:                }
004746  780004     MOV W4, W0
004748  FA8000     ULNK
00474A  060000     RETURN
36:                  
37:                
38:                
39:                
40:                
41:                unsigned int GenerateI2CStart(unsigned char i2c_port) {
00474C  FA0002     LNK #0x2
00474E  784F00     MOV.B W0, [W14]
42:                  I2C_TIMER_REGISTER = 0;
004750  EB0200     CLR W4
004752  8808A4     MOV W4, TMR4
43:                  I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004754  23E804     MOV #0x3E80, W4
004756  8808D4     MOV W4, PR4
44:                  I2C_TIMER_INT_FLAG = 0;
004758  A9A086     BCLR IFS1, #5
45:                  I2C_TIMER_CON_BITS.TON = 1;
00475A  A8E11F     BSET 0x11F, #7
46:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
00475C  8008F4     MOV T4CON, W4
00475E  A14004     BCLR W4, #4
004760  A15004     BCLR W4, #5
004762  8808F4     MOV W4, T4CON
47:                  
48:                #if defined(_I2CMD)
49:                  if ((i2c_port == 0) || (i2c_port == 1)) {
004764  78421E     MOV.B [W14], W4
004766  524FE0     SUB.B W4, #0x0, [W15]
004768  320003     BRA Z, 0x4770
00476A  78421E     MOV.B [W14], W4
00476C  524FE1     SUB.B W4, #0x1, [W15]
00476E  3A000B     BRA NZ, 0x4786
50:                    I2CCONbits.SEN = 1;		                         //Generate Start COndition
004770  A80206     BSET I2CCON, #0
51:                    while (I2CCONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
004772  000000     NOP
004774  801034     MOV I2CCON, W4
004776  620261     AND W4, #0x1, W4
004778  520FE0     SUB W4, #0x0, [W15]
00477A  320005     BRA Z, 0x4786
00477C  800435     MOV IFS1, W5
00477E  200204     MOV #0x20, W4
004780  628204     AND W5, W4, W4
004782  520FE0     SUB W4, #0x0, [W15]
004784  32FFF7     BRA Z, 0x4774
52:                  }
53:                #endif
54:                
55:                #if defined(_I2C1MD)
56:                  if (i2c_port == 1) {
57:                    I2C1CONbits.SEN = 1;		                         //Generate Start COndition
58:                    while (I2C1CONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
59:                  }
60:                #endif
61:                
62:                #if defined(_I2C2MD)
63:                  if (i2c_port == 2) {
64:                    I2C2CONbits.SEN = 1;		                         //Generate Start COndition
65:                    while (I2C2CONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
66:                  }
67:                #endif
68:                    
69:                  if (I2C_TIMER_INT_FLAG) {
004786  800435     MOV IFS1, W5
004788  200204     MOV #0x20, W4
00478A  628204     AND W5, W4, W4
00478C  520FE0     SUB W4, #0x0, [W15]
00478E  320002     BRA Z, 0x4794
70:                    return 0xFA00;
004790  2FA004     MOV #0xFA00, W4
004792  370001     BRA 0x4796
71:                  } else {
72:                    return 0x0000;
004794  EB0200     CLR W4
73:                  }
74:                }
004796  780004     MOV W4, W0
004798  FA8000     ULNK
00479A  060000     RETURN
75:                
76:                
77:                
78:                unsigned int GenerateI2CRestart(unsigned char i2c_port) {
00479C  FA0002     LNK #0x2
00479E  784F00     MOV.B W0, [W14]
79:                  I2C_TIMER_REGISTER = 0;
0047A0  EB0200     CLR W4
0047A2  8808A4     MOV W4, TMR4
80:                  I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
0047A4  23E804     MOV #0x3E80, W4
0047A6  8808D4     MOV W4, PR4
81:                  I2C_TIMER_INT_FLAG = 0;
0047A8  A9A086     BCLR IFS1, #5
82:                  I2C_TIMER_CON_BITS.TON = 1;
0047AA  A8E11F     BSET 0x11F, #7
83:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
0047AC  8008F4     MOV T4CON, W4
0047AE  A14004     BCLR W4, #4
0047B0  A15004     BCLR W4, #5
0047B2  8808F4     MOV W4, T4CON
84:                  
85:                #if defined(_I2CMD)
86:                  if ((i2c_port == 0) || (i2c_port == 1)) {
0047B4  78421E     MOV.B [W14], W4
0047B6  524FE0     SUB.B W4, #0x0, [W15]
0047B8  320003     BRA Z, 0x47C0
0047BA  78421E     MOV.B [W14], W4
0047BC  524FE1     SUB.B W4, #0x1, [W15]
0047BE  3A000B     BRA NZ, 0x47D6
87:                    I2CCONbits.RSEN = 1;	                         //Generate Re-Start COndition
0047C0  A82206     BSET I2CCON, #1
88:                    while (I2CCONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
0047C2  000000     NOP
0047C4  801034     MOV I2CCON, W4
0047C6  620262     AND W4, #0x2, W4
0047C8  520FE0     SUB W4, #0x0, [W15]
0047CA  320005     BRA Z, 0x47D6
0047CC  800435     MOV IFS1, W5
0047CE  200204     MOV #0x20, W4
0047D0  628204     AND W5, W4, W4
0047D2  520FE0     SUB W4, #0x0, [W15]
0047D4  32FFF7     BRA Z, 0x47C4
89:                  }
90:                #endif
91:                
92:                #if defined(_I2C1MD)
93:                  if (i2c_port == 1) {
94:                    I2C1CONbits.RSEN = 1;		                 //Generate Re-Start COndition
95:                    while (I2C1CONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
96:                  }
97:                #endif
98:                
99:                #if defined(_I2C2MD)
100:                 if (i2c_port == 2) {
101:                   I2C2CONbits.RSEN = 1;		                 //Generate Re-Start COndition
102:                   while (I2C2CONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
103:                 }
104:               #endif
105:                   
106:                 if (I2C_TIMER_INT_FLAG) {
0047D6  800435     MOV IFS1, W5
0047D8  200204     MOV #0x20, W4
0047DA  628204     AND W5, W4, W4
0047DC  520FE0     SUB W4, #0x0, [W15]
0047DE  320002     BRA Z, 0x47E4
107:                   return 0xFA00;
0047E0  2FA004     MOV #0xFA00, W4
0047E2  370001     BRA 0x47E6
108:                 } else {
109:                   return 0x0000;
0047E4  EB0200     CLR W4
110:                 }
111:               }
0047E6  780004     MOV W4, W0
0047E8  FA8000     ULNK
0047EA  060000     RETURN
112:               
113:               
114:               
115:               unsigned int WriteByteI2C(unsigned char data, unsigned char i2c_port) {
0047EC  FA0002     LNK #0x2
0047EE  784F00     MOV.B W0, [W14]
0047F0  984711     MOV.B W1, [W14+1]
116:                 I2C_TIMER_REGISTER = 0;
0047F2  EB0200     CLR W4
0047F4  8808A4     MOV W4, TMR4
117:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
0047F6  23E804     MOV #0x3E80, W4
0047F8  8808D4     MOV W4, PR4
118:                 I2C_TIMER_INT_FLAG = 0;
0047FA  A9A086     BCLR IFS1, #5
119:                 I2C_TIMER_CON_BITS.TON = 1;
0047FC  A8E11F     BSET 0x11F, #7
120:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
0047FE  8008F4     MOV T4CON, W4
004800  A14004     BCLR W4, #4
004802  A15004     BCLR W4, #5
004804  8808F4     MOV W4, T4CON
121:                 
122:               #if defined(_I2CMD)
123:                 if ((i2c_port == 0) || (i2c_port == 1)) {
004806  90421E     MOV.B [W14+1], W4
004808  524FE0     SUB.B W4, #0x0, [W15]
00480A  320003     BRA Z, 0x4812
00480C  90421E     MOV.B [W14+1], W4
00480E  524FE1     SUB.B W4, #0x1, [W15]
004810  3A001A     BRA NZ, 0x4846
124:                   I2CTRN = (data);                                            //Load data to the transmit buffer
004812  78429E     MOV.B [W14], W5
004814  FB8205     ZE W5, W4
004816  881014     MOV W4, I2CTRN
125:                   while (!I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);         //Set when transmit process starts
004818  000000     NOP
00481A  801045     MOV I2CSTAT, W5
00481C  240004     MOV #0x4000, W4
00481E  628204     AND W5, W4, W4
004820  520FE0     SUB W4, #0x0, [W15]
004822  3A0006     BRA NZ, 0x4830
004824  800435     MOV IFS1, W5
004826  200204     MOV #0x20, W4
004828  628204     AND W5, W4, W4
00482A  520FE0     SUB W4, #0x0, [W15]
00482C  32FFF6     BRA Z, 0x481A
126:                   while (I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);          //Cleared at end of Slave ACK
00482E  370001     BRA 0x4832
004830  000000     NOP
004832  801045     MOV I2CSTAT, W5
004834  240004     MOV #0x4000, W4
004836  628204     AND W5, W4, W4
004838  520FE0     SUB W4, #0x0, [W15]
00483A  320005     BRA Z, 0x4846
00483C  800435     MOV IFS1, W5
00483E  200204     MOV #0x20, W4
004840  628204     AND W5, W4, W4
004842  520FE0     SUB W4, #0x0, [W15]
004844  32FFF6     BRA Z, 0x4832
127:                 }
128:               #endif
129:               
130:               #if defined(_I2C1MD)
131:                 if (i2c_port == 1) {
132:                   I2C1TRN = (data);                                           //Load data to the transmit buffer
133:                   while (!I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);        //Set when transmit process starts
134:                   while (I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);	        //Cleared at end of Slave ACK
135:                 }
136:               #endif
137:               
138:               #if defined(_I2C2MD)
139:                 if (i2c_port == 2) {
140:                   I2C2TRN = (data);                                           //Load data to the transmit buffer
141:                   while (!I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);        //Set when transmit process starts
142:                   while (I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);	        //Cleared at end of Slave ACK
143:                 }
144:               #endif
145:                   
146:                 if (I2C_TIMER_INT_FLAG) {
004846  800435     MOV IFS1, W5
004848  200204     MOV #0x20, W4
00484A  628204     AND W5, W4, W4
00484C  520FE0     SUB W4, #0x0, [W15]
00484E  320002     BRA Z, 0x4854
147:                   return 0xFA00;
004850  2FA004     MOV #0xFA00, W4
004852  370001     BRA 0x4856
148:                 } else {
149:                   return 0x0000;
004854  EB0200     CLR W4
150:                 }
151:               }
004856  780004     MOV W4, W0
004858  FA8000     ULNK
00485A  060000     RETURN
152:               
153:               unsigned int ReadByteI2C(unsigned char i2c_port) {
00485C  FA0004     LNK #0x4
00485E  984720     MOV.B W0, [W14+2]
154:                 unsigned char return_data;
155:               
156:                 I2C_TIMER_REGISTER = 0;
004860  EB0200     CLR W4
004862  8808A4     MOV W4, TMR4
157:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004864  23E804     MOV #0x3E80, W4
004866  8808D4     MOV W4, PR4
158:                 I2C_TIMER_INT_FLAG = 0;
004868  A9A086     BCLR IFS1, #5
159:                 I2C_TIMER_CON_BITS.TON = 1;
00486A  A8E11F     BSET 0x11F, #7
160:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
00486C  8008F4     MOV T4CON, W4
00486E  A14004     BCLR W4, #4
004870  A15004     BCLR W4, #5
004872  8808F4     MOV W4, T4CON
161:                 
162:               #if defined(_I2CMD)
163:                 if ((i2c_port == 0) || (i2c_port == 1)) {
004874  90422E     MOV.B [W14+2], W4
004876  524FE0     SUB.B W4, #0x0, [W15]
004878  320003     BRA Z, 0x4880
00487A  90422E     MOV.B [W14+2], W4
00487C  524FE1     SUB.B W4, #0x1, [W15]
00487E  3A0018     BRA NZ, 0x48B0
164:                   I2CCONbits.RCEN = 1;			                 //Start Master receive
004880  A86206     BSET I2CCON, #3
165:                   while(I2CCONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
004882  000000     NOP
004884  801034     MOV I2CCON, W4
004886  620268     AND W4, #0x8, W4
004888  520FE0     SUB W4, #0x0, [W15]
00488A  320006     BRA Z, 0x4898
00488C  800435     MOV IFS1, W5
00488E  200204     MOV #0x20, W4
004890  628204     AND W5, W4, W4
004892  520FE0     SUB W4, #0x0, [W15]
004894  32FFF7     BRA Z, 0x4884
166:                   while(!I2CSTATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
004896  370001     BRA 0x489A
004898  000000     NOP
00489A  801044     MOV I2CSTAT, W4
00489C  620262     AND W4, #0x2, W4
00489E  520FE0     SUB W4, #0x0, [W15]
0048A0  3A0005     BRA NZ, 0x48AC
0048A2  800435     MOV IFS1, W5
0048A4  200204     MOV #0x20, W4
0048A6  628204     AND W5, W4, W4
0048A8  520FE0     SUB W4, #0x0, [W15]
0048AA  32FFF7     BRA Z, 0x489A
167:                   return_data = I2CRCV;
0048AC  801004     MOV I2CRCV, W4
0048AE  784F04     MOV.B W4, [W14]
168:                 }
169:               #endif
170:               
171:               #if defined(_I2C1MD)
172:                 if (i2c_port == 1) {
173:                   I2C1CONbits.RCEN = 1;			                 //Start Master receive
174:                   while(I2C1CONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
175:                   while(!I2C1STATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
176:                   return_data = I2C1RCV;
177:                 }
178:               #endif
179:               
180:               #if defined(_I2C2MD)
181:                 if (i2c_port == 2) {
182:                   I2C2CONbits.RCEN = 1;			                 //Start Master receive
183:                   while(I2C2CONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
184:                   while(!I2C2STATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
185:                   return_data = I2C2RCV;
186:                 }
187:               #endif
188:                   
189:                 if (I2C_TIMER_INT_FLAG) {
0048B0  800435     MOV IFS1, W5
0048B2  200204     MOV #0x20, W4
0048B4  628204     AND W5, W4, W4
0048B6  520FE0     SUB W4, #0x0, [W15]
0048B8  320002     BRA Z, 0x48BE
190:                   return 0xFA00;
0048BA  2FA004     MOV #0xFA00, W4
0048BC  370002     BRA 0x48C2
191:                 } else {
192:                   return (return_data & 0x00FF);
0048BE  78429E     MOV.B [W14], W5
0048C0  FB8205     ZE W5, W4
193:                 }
194:               }
0048C2  780004     MOV W4, W0
0048C4  FA8000     ULNK
0048C6  060000     RETURN
195:               
196:               
197:               
198:               unsigned int GenerateI2CStop(unsigned char i2c_port) {
0048C8  FA0002     LNK #0x2
0048CA  784F00     MOV.B W0, [W14]
199:                 I2C_TIMER_REGISTER = 0;
0048CC  EB0200     CLR W4
0048CE  8808A4     MOV W4, TMR4
200:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
0048D0  23E804     MOV #0x3E80, W4
0048D2  8808D4     MOV W4, PR4
201:                 I2C_TIMER_INT_FLAG = 0;
0048D4  A9A086     BCLR IFS1, #5
202:                 I2C_TIMER_CON_BITS.TON = 1;
0048D6  A8E11F     BSET 0x11F, #7
203:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
0048D8  8008F4     MOV T4CON, W4
0048DA  A14004     BCLR W4, #4
0048DC  A15004     BCLR W4, #5
0048DE  8808F4     MOV W4, T4CON
204:                 
205:               #if defined(_I2CMD)
206:                 if ((i2c_port == 0) || (i2c_port == 1)) {
0048E0  78421E     MOV.B [W14], W4
0048E2  524FE0     SUB.B W4, #0x0, [W15]
0048E4  320003     BRA Z, 0x48EC
0048E6  78421E     MOV.B [W14], W4
0048E8  524FE1     SUB.B W4, #0x1, [W15]
0048EA  3A000B     BRA NZ, 0x4902
207:                   I2CCONbits.PEN = 1;	                                 //Generate Stop COndition
0048EC  A84206     BSET I2CCON, #2
208:                   while (I2CCONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for Stop COndition
0048EE  000000     NOP
0048F0  801034     MOV I2CCON, W4
0048F2  620264     AND W4, #0x4, W4
0048F4  520FE0     SUB W4, #0x0, [W15]
0048F6  320005     BRA Z, 0x4902
0048F8  800435     MOV IFS1, W5
0048FA  200204     MOV #0x20, W4
0048FC  628204     AND W5, W4, W4
0048FE  520FE0     SUB W4, #0x0, [W15]
004900  32FFF7     BRA Z, 0x48F0
209:                 }
210:               #endif
211:               
212:               #if defined(_I2C1MD)
213:                 if (i2c_port == 1) {
214:                   I2C1CONbits.PEN = 1;		                 //Generate stop COndition
215:                   while (I2C1CONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for stop COndition
216:                 }
217:               #endif
218:               
219:               #if defined(_I2C2MD)
220:                 if (i2c_port == 2) {
221:                   I2C2CONbits.PEN = 1;		                 //Generate stop COndition
222:                   while (I2C2CONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for stop COndition
223:                 }
224:               #endif
225:                   
226:                 if (I2C_TIMER_INT_FLAG) {
004902  800435     MOV IFS1, W5
004904  200204     MOV #0x20, W4
004906  628204     AND W5, W4, W4
004908  520FE0     SUB W4, #0x0, [W15]
00490A  320002     BRA Z, 0x4910
227:                   return 0xFA00;
00490C  2FA004     MOV #0xFA00, W4
00490E  370001     BRA 0x4912
228:                 } else {
229:                   return 0x0000;
004910  EB0200     CLR W4
230:                 }
231:               }
004912  780004     MOV W4, W0
004914  FA8000     ULNK
004916  060000     RETURN
232:               
233:               
---  C:/Users/dparker/Documents/GitHub/TestDan/Buffer64.c  ----------------------------------------------
1:                 #include "Buffer64.h"
2:                 
3:                 void Buffer64WriteByte(BUFFER64BYTE* ptr, unsigned char value) {
004C4A  FA0004     LNK #0x4
004C4C  780F00     MOV W0, [W14]
004C4E  984721     MOV.B W1, [W14+2]
4:                   ptr->data[ptr->write_location] = value;
004C50  78021E     MOV [W14], W4
004C52  90C204     MOV.B [W4+64], W4
004C54  FB8204     ZE W4, W4
004C56  78029E     MOV [W14], W5
004C58  90432E     MOV.B [W14+2], W6
004C5A  7A7286     MOV.B W6, [W5+W4]
5:                   ptr->write_location += 1;
004C5C  78021E     MOV [W14], W4
004C5E  90C204     MOV.B [W4+64], W4
004C60  E84204     INC.B W4, W4
004C62  78029E     MOV [W14], W5
004C64  98C284     MOV.B W4, [W5+64]
6:                   ptr->write_location &= Buffer64Mask;
004C66  78021E     MOV [W14], W4
004C68  90C204     MOV.B [W4+64], W4
004C6A  B243F4     AND.B #0x3F, W4
004C6C  78029E     MOV [W14], W5
004C6E  98C284     MOV.B W4, [W5+64]
7:                   if (ptr->write_location == ptr->read_location) {
004C70  78021E     MOV [W14], W4
004C72  90C284     MOV.B [W4+64], W5
004C74  78021E     MOV [W14], W4
004C76  90C214     MOV.B [W4+65], W4
004C78  52CF84     SUB.B W5, W4, [W15]
004C7A  3A000A     BRA NZ, 0x4C90
8:                     ptr->read_location += 1;
004C7C  78021E     MOV [W14], W4
004C7E  90C214     MOV.B [W4+65], W4
004C80  E84204     INC.B W4, W4
004C82  78029E     MOV [W14], W5
004C84  98C294     MOV.B W4, [W5+65]
9:                     ptr->read_location &= Buffer64Mask;
004C86  78021E     MOV [W14], W4
004C88  90C214     MOV.B [W4+65], W4
004C8A  B243F4     AND.B #0x3F, W4
004C8C  78029E     MOV [W14], W5
004C8E  98C294     MOV.B W4, [W5+65]
10:                  }
11:                }
004C90  FA8000     ULNK
004C92  060000     RETURN
12:                
13:                unsigned char Buffer64ReadByte(BUFFER64BYTE* ptr) {
004C94  FA0004     LNK #0x4
004C96  980710     MOV W0, [W14+2]
14:                  unsigned char local_read_location;
15:                  unsigned char return_data;
16:                						
17:                  local_read_location = ptr->read_location;
004C98  90021E     MOV [W14+2], W4
004C9A  90C294     MOV.B [W4+65], W5
004C9C  984715     MOV.B W5, [W14+1]
18:                  if (local_read_location != ptr->write_location) {
004C9E  90021E     MOV [W14+2], W4
004CA0  90C284     MOV.B [W4+64], W5
004CA2  90421E     MOV.B [W14+1], W4
004CA4  52CF84     SUB.B W5, W4, [W15]
004CA6  32000E     BRA Z, 0x4CC4
19:                    // the buffer is not empty
20:                    return_data = ptr->data[local_read_location];
004CA8  90421E     MOV.B [W14+1], W4
004CAA  FB8204     ZE W4, W4
004CAC  90029E     MOV [W14+2], W5
004CAE  7A4F65     MOV.B [W5+W4], [W14]
21:                    local_read_location += 1;
004CB0  90421E     MOV.B [W14+1], W4
004CB2  E84204     INC.B W4, W4
004CB4  984714     MOV.B W4, [W14+1]
22:                    local_read_location &= Buffer64Mask; 
004CB6  90421E     MOV.B [W14+1], W4
004CB8  B243F4     AND.B #0x3F, W4
004CBA  984714     MOV.B W4, [W14+1]
23:                    ptr->read_location = local_read_location;
004CBC  90021E     MOV [W14+2], W4
004CBE  90429E     MOV.B [W14+1], W5
004CC0  98C215     MOV.B W5, [W4+65]
004CC2  370002     BRA 0x4CC8
24:                  } else {
25:                    // the buffer was empty
26:                    // return zero and do not increment the read_location
27:                    return_data = 0;
004CC4  EB4200     CLR.B W4
004CC6  784F04     MOV.B W4, [W14]
28:                  }
29:                  return return_data;
004CC8  78421E     MOV.B [W14], W4
30:                }
004CCA  784004     MOV.B W4, W0
004CCC  FA8000     ULNK
004CCE  060000     RETURN
31:                
32:                unsigned char Buffer64BytesInBuffer(BUFFER64BYTE* ptr) {
004CD0  FA0002     LNK #0x2
004CD2  780F00     MOV W0, [W14]
33:                  return ((ptr->write_location - ptr->read_location) & Buffer64Mask);
004CD4  78021E     MOV [W14], W4
004CD6  90C284     MOV.B [W4+64], W5
004CD8  78021E     MOV [W14], W4
004CDA  90C214     MOV.B [W4+65], W4
004CDC  52C204     SUB.B W5, W4, W4
004CDE  B243F4     AND.B #0x3F, W4
34:                }
004CE0  784004     MOV.B W4, W0
004CE2  FA8000     ULNK
004CE4  060000     RETURN
35:                
36:                unsigned char Buffer64IsNotEmpty(BUFFER64BYTE* ptr) {
004CE6  FA0002     LNK #0x2
004CE8  780F00     MOV W0, [W14]
37:                  if (ptr->write_location == ptr->read_location) {
004CEA  78021E     MOV [W14], W4
004CEC  90C284     MOV.B [W4+64], W5
004CEE  78021E     MOV [W14], W4
004CF0  90C214     MOV.B [W4+65], W4
004CF2  52CF84     SUB.B W5, W4, [W15]
004CF4  3A0002     BRA NZ, 0x4CFA
38:                    return 0;
004CF6  EB4200     CLR.B W4
004CF8  370001     BRA 0x4CFC
39:                  } else {
40:                    return 1;
004CFA  B3C014     MOV #0x1, W4
41:                  }
42:                }
004CFC  784004     MOV.B W4, W0
004CFE  FA8000     ULNK
004D00  060000     RETURN
43:                
44:                
45:                
---  C:/Users/dparker/Documents/GitHub/TestDan/A34760.c  ------------------------------------------------
1:                 #include "A34760.h"
2:                 #include "faults.h"
3:                 #include "Serial.h"
4:                 #include "A34760_PINS.h"
5:                 #include "Buffer64.h"
6:                 #include "LTC2656.h"
7:                 #include "IOPorts.h"
8:                 #include "MCP23017.h"
9:                 #include "faults.h"
10:                #include <libpic30.h>
11:                #include "ETMdsp.h"
12:                #include "Config.h"
13:                
14:                
15:                #define FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG7095 100,99,99,98,98,97,96,95,94,94,93,92,91,90,89,88,87,86,84,83,82,81,79,78,77,75,74,72,71,69,67,66,64,62,61,59,57,55,53,51,49,47,45,43,41,39,37,35,32,30,28,25,23,21,18,16,13,10,8,5,3,0,0,0
16:                
17:                #define FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG5193 100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,97,94,91,88,84,81,78,75,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
18:                
19:                #ifdef __MG7095
20:                const unsigned int FilamentLookUpTable[64] = {FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG7095};
21:                #else
22:                const unsigned int FilamentLookUpTable[64] = {FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG5193};
23:                #endif
24:                
25:                unsigned int arc_detected;
26:                
27:                
28:                unsigned int default_pac_2_adc_reading;
29:                
30:                
31:                signed int low_energy_target_current_startup_adjust_initital_value = 0;
32:                unsigned int low_energy_target_current_startup_adjust_decay_time_pulses = 100;
33:                
34:                
35:                unsigned int linac_high_energy_target_current_adc_reading;
36:                unsigned int linac_high_energy_target_current_set_point;
37:                
38:                unsigned int linac_low_energy_target_current_adc_reading;
39:                unsigned int linac_low_energy_target_current_set_point;
40:                
41:                signed int linac_high_energy_program_offset;
42:                signed int linac_low_energy_program_offset;
43:                unsigned char fast_ratio_mode;
44:                
45:                unsigned int pulse_counter_this_run;   // This counts the number of pulses in the current "run".  This will be reset to 0 if there are no triggers for 100mS or more.
46:                
47:                  
48:                
49:                unsigned int false_trigger;
50:                
51:                
52:                
53:                void ReadADCtoPACArray(void);
54:                
55:                volatile unsigned int timing_error_int1_count = 0;
56:                
57:                unsigned int software_skip_warmup = 0;
58:                
59:                unsigned char ram_config_set_magnetron_magnet_current_from_GUI;
60:                
61:                volatile unsigned int _PERSISTENT last_known_action;
62:                volatile unsigned int _PERSISTENT last_osccon;
63:                
64:                unsigned int _PERSISTENT processor_crash_count;
65:                
66:                unsigned int previous_last_action;
67:                
68:                volatile unsigned int lvdinterrupt_counter = 0;
69:                
70:                unsigned int MakeScale(unsigned int num, unsigned int den);
71:                
72:                unsigned int start_reset_process;
73:                
74:                void SavePulseCountersToEEPROM(void);
75:                
76:                void UpdateIOExpanderOutputs(void);
77:                
78:                unsigned char slow_down_thyratron_pid_counter;
79:                
80:                
81:                unsigned int average_energy_per_pulse_milli_joules;
82:                unsigned int average_output_power_watts;
83:                unsigned int average_pulse_repetition_frequency_deci_herz;
84:                unsigned int prf_pulse_counter;
85:                
86:                
87:                unsigned char control_state;
88:                
89:                unsigned int pac_1_adc_reading;
90:                unsigned int pac_2_adc_reading;
91:                
92:                
93:                unsigned int fast_reset_counter_persistent;
94:                unsigned long _PERSISTENT arc_counter_persistent;
95:                unsigned int arc_counter_consecutive;
96:                unsigned int _PERSISTENT arc_counter_this_hv_on;
97:                unsigned long _PERSISTENT pulse_counter_this_hv_on;
98:                unsigned long long _PERSISTENT pulse_counter_persistent;
99:                unsigned int arc_counter_fast;
100:               unsigned int arc_counter_slow;
101:               unsigned int pulse_counter_fast;
102:               unsigned int pulse_counter_slow;
103:               
104:               unsigned int led_pulse_count;
105:               
106:               
107:               
108:               unsigned int pulse_magnetron_current_adc_reading;
109:               unsigned int pulse_magnetron_voltage_adc_reading;
110:               
111:               
112:               // Control structers for the thyratron heater PID loops
113:               tPID thyratron_reservoir_heater_PID;
114:               fractional pid_thyratron_reservoir_heater_controlHistory[3] __attribute__ ((section (".ybss, bss, ymemory")));
115:               fractional pid_thyratron_reservoir_heater_abcCoefficient[3] __attribute__ ((section (".xbss, bss, xmemory")));
116:               fractional pid_thyratron_reservoir_heater_kCoeffs[] = {0,0,0};
117:               
118:               tPID thyratron_cathode_heater_PID;
119:               fractional pid_thyratron_cathode_heater_controlHistory[3] __attribute__ ((section (".ybss, bss, ymemory")));
120:               fractional pid_thyratron_cathode_heater_abcCoefficient[3] __attribute__ ((section (".xbss, bss, xmemory")));
121:               fractional pid_thyratron_cathode_heater_kCoeffs[] = {0,0,0};
122:               
123:               
124:               
125:               
126:               BUFFER64BYTE uart1_input_buffer;
127:               BUFFER64BYTE uart1_output_buffer;
128:               
129:               LTC2656 U44_LTC2656;
130:               MCP23017 U64_MCP23017;
131:               
132:               POWERSUPPLY ps_hv_lambda_mode_A;
133:               POWERSUPPLY ps_magnetron_mode_A;
134:               POWERSUPPLY ps_hv_lambda_mode_B;
135:               POWERSUPPLY ps_magnetron_mode_B;
136:               POWERSUPPLY ps_magnet;
137:               POWERSUPPLY ps_filament;
138:               POWERSUPPLY ps_thyr_cathode_htr;
139:               POWERSUPPLY ps_thyr_reservoir_htr;
140:               
141:               
142:               volatile unsigned char adc_result_index;
143:               
144:               unsigned int pfn_rev_current_array[128];
145:               
146:               unsigned int pac_1_array[128];
147:               unsigned int pac_2_array[128];
148:               
149:               unsigned int thyratron_cathode_heater_voltage_array[128];
150:               unsigned int thyratron_reservoir_heater_voltage_array[128];
151:               
152:               unsigned int magnetron_magnet_current_array[128];
153:               unsigned int magnetron_magnet_voltage_array[128];
154:               
155:               unsigned int magnetron_filament_current_array[128];
156:               unsigned int magnetron_filament_voltage_array[128];
157:               
158:               unsigned int lambda_vpeak_array[128];
159:               unsigned int lambda_vmon_array[128];
160:               
161:               
162:               volatile unsigned char global_run_post_pulse_process;
163:               volatile unsigned char global_adc_ignore_this_sample;
164:               
165:               
166:               
167:               unsigned char a_b_selected_mode;
168:               volatile unsigned char next_pulse_a_b_selected_mode;
169:               
170:               
171:               
172:               
173:               void DoA34760StartUpCommon(void);
174:               void DoA34760StartUpNormalProcess(void);
175:               void DoA34760StartUpFastProcess(void);
176:               void DoA34760StartUpCommonPostProcess(void);
177:               
178:               
179:               
180:               void CalcPowerSupplySettings(POWERSUPPLY* ptr_ps);
181:               void UpdateDacAll(void);
182:               void Do10msTicToc(void);
183:               void DoThyratronPIDs(void);
184:               void DoMagnetronFilamentAdjust(void);
185:               void ReadIsolatedAdcToRam(void);
186:               void FilterADCs(void);
187:               void FastReadAndFilterFeedbacks(void);
188:               void FastReadAndFilterPACInputs(void);
189:               void ExitHvOnState(void);
190:               void DoColdShutDown(void);
191:               void DoWarmShutDown(void);
192:               void StartWarmUp(void);
193:               
194:               void ScalePowerSupply(POWERSUPPLY* ptr_ps, unsigned int num, unsigned int den);
195:               
196:               void EnableMagnetronFilamentSupply(void);
197:               void DisableMagnetronFilamentSupply(void);
198:               void EnableMagnetronMagnetSupply(void);
199:               void DisableMagnetronMagnetSupply(void);
200:               void DisableHVLambdaSupply(void);
201:               void HVLambdaStartCharging(void);
202:               
203:               unsigned int CalculatePoly(unsigned int set_point);
204:               
205:               //unsigned int RCFilter256Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
206:               //unsigned int RCFilter64Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
207:               //unsigned int RCFilter16Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
208:               
209:               
210:               unsigned int mode_A_pulse_magnetron_current_adc_reading_filtered;
211:               unsigned int mode_B_pulse_magnetron_current_adc_reading_filtered;
212:               
213:               unsigned int mode_A_pulse_magnetron_voltage_adc_reading_filtered;
214:               unsigned int mode_B_pulse_magnetron_voltage_adc_reading_filtered;
215:               
216:               unsigned int mode_A_pulse_magnetron_current_adc_reading_max;
217:               unsigned int mode_A_pulse_magnetron_current_adc_reading_min;
218:               
219:               unsigned int mode_B_pulse_magnetron_current_adc_reading_max;
220:               unsigned int mode_B_pulse_magnetron_current_adc_reading_min;
221:               
222:               unsigned int mode_A_pulse_magnetron_voltage_adc_reading_filtered;
223:               unsigned int mode_B_pulse_magnetron_voltage_adc_reading_filtered;
224:               
225:               
226:               
227:               
228:               
229:               void DoStateMachine(void) {
000356  FA0010     LNK #0x10
230:                 unsigned int warmup_counter;
231:                 unsigned int lambda_supply_startup_counter;
232:                 unsigned long low_energy_target_current_set_point_derived; 
233:                 unsigned int vtemp;
234:                 
235:                 signed int low_energy_target_current_startup_adjust;
236:                 signed long temp_long;
237:               	  
238:               
239:               
240:                 switch(control_state) {
000358  208324     MOV #0x832, W4
00035A  784214     MOV.B [W4], W4
00035C  FB8204     ZE W4, W4
00035E  200345     MOV #0x34, W5
000360  520F85     SUB W4, W5, [W15]
000362  320114     BRA Z, 0x58C
000364  200345     MOV #0x34, W5
000366  520F85     SUB W4, W5, [W15]
000368  3C000D     BRA GT, 0x384
00036A  520FE6     SUB W4, #0x6, [W15]
00036C  32002E     BRA Z, 0x3CA
00036E  520FE6     SUB W4, #0x6, [W15]
000370  3C0003     BRA GT, 0x378
000372  520FE4     SUB W4, #0x4, [W15]
000374  32001B     BRA Z, 0x3AC
000376  37030D     BRA 0x992
000378  520FF4     SUB W4, #0x14, [W15]
00037A  320076     BRA Z, 0x468
00037C  200245     MOV #0x24, W5
00037E  520F85     SUB W4, W5, [W15]
000380  32008C     BRA Z, 0x49A
000382  370307     BRA 0x992
000384  200A05     MOV #0xA0, W5
000386  520F85     SUB W4, W5, [W15]
000388  320301     BRA Z, 0x98C
00038A  200A05     MOV #0xA0, W5
00038C  520F85     SUB W4, W5, [W15]
00038E  3C0007     BRA GT, 0x39E
000390  200355     MOV #0x35, W5
000392  520F85     SUB W4, W5, [W15]
000394  320136     BRA Z, 0x602
000396  200445     MOV #0x44, W5
000398  520F85     SUB W4, W5, [W15]
00039A  32017E     BRA Z, 0x698
00039C  3702FA     BRA 0x992
00039E  200A45     MOV #0xA4, W5
0003A0  520F85     SUB W4, W5, [W15]
0003A2  3202C1     BRA Z, 0x926
0003A4  200A85     MOV #0xA8, W5
0003A6  520F85     SUB W4, W5, [W15]
0003A8  3202CF     BRA Z, 0x948
0003AA  3702F3     BRA 0x992
241:                   
242:                 case STATE_START_UP:
243:                   DoA34760StartUpCommon();
0003AC  0702F8     RCALL DoA34760StartUpCommon
244:                   DoA34760StartUpNormalProcess();
0003AE  070742     RCALL DoA34760StartUpNormalProcess
245:                   DoA34760StartUpCommonPostProcess();
0003B0  07085F     RCALL DoA34760StartUpCommonPostProcess
246:                   
247:                   if (CheckStartupFailed()) {
0003B2  071E11     RCALL CheckStartupFailed
0003B4  780200     MOV W0, W4
0003B6  520FE0     SUB W4, #0x0, [W15]
0003B8  320004     BRA Z, 0x3C2
248:                     control_state = STATE_FAULT_MCU_CORE_FAULT;
0003BA  B3CA04     MOV #0xA0, W4
0003BC  784004     MOV.B W4, W0
0003BE  B7E832     MOV.B WREG, control_state
249:                   } else {
250:                     control_state = STATE_SYSTEM_COLD_READY;
0003C2  B3C144     MOV #0x14, W4
0003C4  784004     MOV.B W4, W0
0003C6  B7E832     MOV.B WREG, control_state
251:                   }
252:                   break;
0003C0  3702EC     BRA 0x99A
0003C8  3702E8     BRA 0x99A
253:                   
254:                 case STATE_FAST_RECOVERY_START_UP:
255:               
256:                   // It takes a 360uS to get to here (really just to read flash)
257:               
258:                   PIN_UART2_TX = !PIN_UART2_TX;
0003CA  801715     MOV LATF, W5
0003CC  200204     MOV #0x20, W4
0003CE  628204     AND W5, W4, W4
0003D0  A7F004     BTSC W4, #15
0003D2  EA0204     NEG W4, W4
0003D4  E90204     DEC W4, W4
0003D6  DE224F     LSR W4, #15, W4
0003D8  784204     MOV.B W4, W4
0003DA  FB8204     ZE W4, W4
0003DC  620261     AND W4, #0x1, W4
0003DE  DD2245     SL W4, #5, W4
0003E0  801716     MOV LATF, W6
0003E2  2FFDF5     MOV #0xFFDF, W5
0003E4  630285     AND W6, W5, W5
0003E6  728204     IOR W5, W4, W4
0003E8  881714     MOV W4, LATF
259:                   DoA34760StartUpCommon();  // This Takes 4.6ms (4.55 ms of this is loading and intialization of Power Supply Structures)
0003EA  0702D9     RCALL DoA34760StartUpCommon
260:                   PIN_UART2_TX = !PIN_UART2_TX;
0003EC  801715     MOV LATF, W5
0003EE  200204     MOV #0x20, W4
0003F0  628204     AND W5, W4, W4
0003F2  A7F004     BTSC W4, #15
0003F4  EA0204     NEG W4, W4
0003F6  E90204     DEC W4, W4
0003F8  DE224F     LSR W4, #15, W4
0003FA  784204     MOV.B W4, W4
0003FC  FB8204     ZE W4, W4
0003FE  620261     AND W4, #0x1, W4
000400  DD2245     SL W4, #5, W4
000402  801716     MOV LATF, W6
000404  2FFDF5     MOV #0xFFDF, W5
000406  630285     AND W6, W5, W5
000408  728204     IOR W5, W4, W4
00040A  881714     MOV W4, LATF
261:                   DoA34760StartUpFastProcess(); // This takes 4.3mS 
00040C  070781     RCALL DoA34760StartUpFastProcess
262:                   PIN_UART2_TX = !PIN_UART2_TX;
00040E  801715     MOV LATF, W5
000410  200204     MOV #0x20, W4
000412  628204     AND W5, W4, W4
000414  A7F004     BTSC W4, #15
000416  EA0204     NEG W4, W4
000418  E90204     DEC W4, W4
00041A  DE224F     LSR W4, #15, W4
00041C  784204     MOV.B W4, W4
00041E  FB8204     ZE W4, W4
000420  620261     AND W4, #0x1, W4
000422  DD2245     SL W4, #5, W4
000424  801716     MOV LATF, W6
000426  2FFDF5     MOV #0xFFDF, W5
000428  630285     AND W6, W5, W5
00042A  728204     IOR W5, W4, W4
00042C  881714     MOV W4, LATF
263:                   DoA34760StartUpCommonPostProcess(); // This takes 60uS
00042E  070820     RCALL DoA34760StartUpCommonPostProcess
264:                   PIN_UART2_TX = !PIN_UART2_TX;
000430  801715     MOV LATF, W5
000432  200204     MOV #0x20, W4
000434  628204     AND W5, W4, W4
000436  A7F004     BTSC W4, #15
000438  EA0204     NEG W4, W4
00043A  E90204     DEC W4, W4
00043C  DE224F     LSR W4, #15, W4
00043E  784204     MOV.B W4, W4
000440  FB8204     ZE W4, W4
000442  620261     AND W4, #0x1, W4
000444  DD2245     SL W4, #5, W4
000446  801716     MOV LATF, W6
000448  2FFDF5     MOV #0xFFDF, W5
00044A  630285     AND W6, W5, W5
00044C  728204     IOR W5, W4, W4
00044E  881714     MOV W4, LATF
265:                   
266:                   if (CheckStartupFailed()) {
000450  071DC2     RCALL CheckStartupFailed
000452  780200     MOV W0, W4
000454  520FE0     SUB W4, #0x0, [W15]
000456  320004     BRA Z, 0x460
267:                     control_state = STATE_FAULT_MCU_CORE_FAULT;
000458  B3CA04     MOV #0xA0, W4
00045A  784004     MOV.B W4, W0
00045C  B7E832     MOV.B WREG, control_state
268:                   } else {
269:                     control_state = STATE_HV_ON;
000460  B3C444     MOV #0x44, W4
000462  784004     MOV.B W4, W0
000464  B7E832     MOV.B WREG, control_state
270:                   }
271:               
272:                   break;
00045E  37029D     BRA 0x99A
000466  370299     BRA 0x99A
273:               
274:                   
275:               
276:                 case STATE_SYSTEM_COLD_READY:
277:                   DoColdShutDown();
000468  070DD6     RCALL DoColdShutDown
278:                   while (control_state == STATE_SYSTEM_COLD_READY) {
00046A  370012     BRA 0x490
000490  208324     MOV #0x832, W4
000492  784214     MOV.B [W4], W4
000494  524FF4     SUB.B W4, #0x14, [W15]
000496  32FFEA     BRA Z, 0x46C
279:                     Do10msTicToc();  // Execute 10mS timed functions if the 10ms Timer has rolled
00046C  0709D8     RCALL Do10msTicToc
280:                     DoSerialCommand();
00046E  071224     RCALL DoSerialCommand
281:                     if (CheckFaultActive()) {
000470  071DB7     RCALL CheckFaultActive
000472  780200     MOV W0, W4
000474  520FE0     SUB W4, #0x0, [W15]
000476  320004     BRA Z, 0x480
282:               	control_state = STATE_FAULT_COLD_FAULT;
000478  B3CA44     MOV #0xA4, W4
00047A  784004     MOV.B W4, W0
00047C  B7E832     MOV.B WREG, control_state
00047E  370008     BRA 0x490
283:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == ILL_MODULATOR_ENABLED) {
000480  801615     MOV PORTA, W5
000482  240004     MOV #0x4000, W4
000484  628204     AND W5, W4, W4
000486  520FE0     SUB W4, #0x0, [W15]
000488  3A0003     BRA NZ, 0x490
284:               	control_state = STATE_WARM_UP;
00048A  B3C244     MOV #0x24, W4
00048C  784004     MOV.B W4, W0
00048E  B7E832     MOV.B WREG, control_state
285:                     }
286:                   }
287:                   break;
000498  370280     BRA 0x99A
288:                   
289:                 case STATE_WARM_UP:
290:                   StartWarmUp();
00049A  070DEF     RCALL StartWarmUp
291:                   warmup_counter = 0;
00049C  EB0200     CLR W4
00049E  780F04     MOV W4, [W14]
292:                   software_skip_warmup = 0;
0004A0  EB0200     CLR W4
0004A2  88C474     MOV W4, software_skip_warmup
293:                   while (control_state == STATE_WARM_UP) {
0004A4  37006D     BRA 0x580
000580  208325     MOV #0x832, W5
000582  784295     MOV.B [W5], W5
000584  B3C244     MOV #0x24, W4
000586  52CF84     SUB.B W5, W4, [W15]
000588  32FF8E     BRA Z, 0x4A6
294:                     Do10msTicToc();
0004A6  0709BB     RCALL Do10msTicToc
295:                     DoSerialCommand();
0004A8  071207     RCALL DoSerialCommand
296:                     Nop();
0004AA  000000     NOP
297:                     Nop();
0004AC  000000     NOP
298:                     Nop();
0004AE  000000     NOP
299:                     if (_T2IF) {
0004B0  800425     MOV IFS0, W5
0004B2  200404     MOV #0x40, W4
0004B4  628204     AND W5, W4, W4
0004B6  520FE0     SUB W4, #0x0, [W15]
0004B8  32002F     BRA Z, 0x518
300:               	warmup_counter++;
0004BA  E80F1E     INC [W14], [W14]
301:               	_T2IF = 0;
0004BC  A9C084     BCLR IFS0, #6
302:               	if ((PIN_FP_FAST_RESTART == ILL_FAST_RESTART) || (software_skip_warmup == 1)) {
0004BE  801735     MOV PORTG, W5
0004C0  210004     MOV #0x1000, W4
0004C2  628204     AND W5, W4, W4
0004C4  520FE0     SUB W4, #0x0, [W15]
0004C6  320003     BRA Z, 0x4CE
0004C8  80C474     MOV software_skip_warmup, W4
0004CA  520FE1     SUB W4, #0x1, [W15]
0004CC  3A0011     BRA NZ, 0x4F0
303:               	  ScalePowerSupply(&ps_filament, warmup_counter, 10);
0004CE  2000A2     MOV #0xA, W2
0004D0  78009E     MOV [W14], W1
0004D2  20ABC0     MOV #0xABC, W0
0004D4  07081E     RCALL ScalePowerSupply
304:               	  ScalePowerSupply(&ps_magnet, warmup_counter, 10);
0004D6  2000A2     MOV #0xA, W2
0004D8  78009E     MOV [W14], W1
0004DA  20A620     MOV #0xA62, W0
0004DC  07081A     RCALL ScalePowerSupply
305:               	  ScalePowerSupply(&ps_thyr_cathode_htr, warmup_counter, 10);
0004DE  2000A2     MOV #0xA, W2
0004E0  78009E     MOV [W14], W1
0004E2  20B160     MOV #0xB16, W0
0004E4  070816     RCALL ScalePowerSupply
306:               	  ScalePowerSupply(&ps_thyr_reservoir_htr, warmup_counter, 10);
0004E6  2000A2     MOV #0xA, W2
0004E8  78009E     MOV [W14], W1
0004EA  20B700     MOV #0xB70, W0
0004EC  070812     RCALL ScalePowerSupply
0004EE  370014     BRA 0x518
307:               	} else {
308:               	  ScalePowerSupply(&ps_filament, warmup_counter, ps_filament.warmup_ramp_time);
0004F0  8055E4     MOV ps_filament, W4
0004F2  780104     MOV W4, W2
0004F4  78009E     MOV [W14], W1
0004F6  20ABC0     MOV #0xABC, W0
0004F8  07080C     RCALL ScalePowerSupply
309:               	  ScalePowerSupply(&ps_magnet, warmup_counter, ps_magnet.warmup_ramp_time);
0004FA  805314     MOV ps_magnet, W4
0004FC  780104     MOV W4, W2
0004FE  78009E     MOV [W14], W1
000500  20A620     MOV #0xA62, W0
000502  070807     RCALL ScalePowerSupply
310:               	  ScalePowerSupply(&ps_thyr_cathode_htr, warmup_counter, ps_thyr_cathode_htr.warmup_ramp_time);
000504  8058B4     MOV ps_thyr_cathode_htr, W4
000506  780104     MOV W4, W2
000508  78009E     MOV [W14], W1
00050A  20B160     MOV #0xB16, W0
00050C  070802     RCALL ScalePowerSupply
311:               	  ScalePowerSupply(&ps_thyr_reservoir_htr, warmup_counter, ps_thyr_reservoir_htr.warmup_ramp_time);
00050E  805B84     MOV ps_thyr_reservoir_htr, W4
000510  780104     MOV W4, W2
000512  78009E     MOV [W14], W1
000514  20B700     MOV #0xB70, W0
000516  0707FD     RCALL ScalePowerSupply
312:               	}
313:                     }
314:                     if (CheckFaultActive()) {
000518  071D63     RCALL CheckFaultActive
00051A  780200     MOV W0, W4
00051C  520FE0     SUB W4, #0x0, [W15]
00051E  320004     BRA Z, 0x528
315:               	control_state = STATE_FAULT_COLD_FAULT;
000520  B3CA44     MOV #0xA4, W4
000522  784004     MOV.B W4, W0
000524  B7E832     MOV.B WREG, control_state
000526  37002C     BRA 0x580
316:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000528  801615     MOV PORTA, W5
00052A  240004     MOV #0x4000, W4
00052C  628204     AND W5, W4, W4
00052E  520FE0     SUB W4, #0x0, [W15]
000530  320004     BRA Z, 0x53A
317:               	control_state = STATE_SYSTEM_COLD_READY;
000532  B3C144     MOV #0x14, W4
000534  784004     MOV.B W4, W0
000536  B7E832     MOV.B WREG, control_state
000538  370023     BRA 0x580
318:                     } else if (warmup_counter > SYSTEM_WARM_UP_TIME) {
00053A  207084     MOV #0x708, W4
00053C  78029E     MOV [W14], W5
00053E  528F84     SUB W5, W4, [W15]
000540  360007     BRA LEU, 0x550
319:               	ResetHWLatches();
000542  071AD4     RCALL ResetHWLatches
320:               	control_state = STATE_SYSTEM_WARM_READY;
000544  B3C344     MOV #0x34, W4
000546  784004     MOV.B W4, W0
000548  B7E832     MOV.B WREG, control_state
321:               	software_skip_warmup = 0;
00054A  EB0200     CLR W4
00054C  88C474     MOV W4, software_skip_warmup
00054E  370018     BRA 0x580
322:                     } else if ((PIN_FP_FAST_RESTART == ILL_FAST_RESTART) && (warmup_counter > 20)) {
000550  801735     MOV PORTG, W5
000552  210004     MOV #0x1000, W4
000554  628204     AND W5, W4, W4
000556  520FE0     SUB W4, #0x0, [W15]
000558  3A000A     BRA NZ, 0x56E
00055A  78021E     MOV [W14], W4
00055C  520FF4     SUB W4, #0x14, [W15]
00055E  360007     BRA LEU, 0x56E
323:               	ResetHWLatches();
000560  071AC5     RCALL ResetHWLatches
324:               	control_state = STATE_SYSTEM_WARM_READY;
000562  B3C344     MOV #0x34, W4
000564  784004     MOV.B W4, W0
000566  B7E832     MOV.B WREG, control_state
325:               	software_skip_warmup = 0;
000568  EB0200     CLR W4
00056A  88C474     MOV W4, software_skip_warmup
00056C  370009     BRA 0x580
326:                     } else if (software_skip_warmup == 1) {
00056E  80C474     MOV software_skip_warmup, W4
000570  520FE1     SUB W4, #0x1, [W15]
000572  3A0006     BRA NZ, 0x580
327:               	ResetHWLatches();
000574  071ABB     RCALL ResetHWLatches
328:               	control_state = STATE_SYSTEM_WARM_READY;
000576  B3C344     MOV #0x34, W4
000578  784004     MOV.B W4, W0
00057A  B7E832     MOV.B WREG, control_state
329:               	software_skip_warmup = 0;
00057C  EB0200     CLR W4
00057E  88C474     MOV W4, software_skip_warmup
330:                     }
331:                   }
332:                   break;
00058A  370207     BRA 0x99A
333:                   
334:                 case STATE_SYSTEM_WARM_READY:
335:                   // DPARKER SaveDataToEEPROM(); -- New Commands to deal with EEPROM access and storage
336:                   DoWarmShutDown();
00058C  070D6C     RCALL DoWarmShutDown
337:                   ScalePowerSupply(&ps_hv_lambda_mode_A,100,100);
00058E  200642     MOV #0x64, W2
000590  200641     MOV #0x64, W1
000592  208FA0     MOV #0x8FA, W0
000594  0707BE     RCALL ScalePowerSupply
338:                   ScalePowerSupply(&ps_hv_lambda_mode_B,100,100);
000596  200642     MOV #0x64, W2
000598  200641     MOV #0x64, W1
00059A  209AE0     MOV #0x9AE, W0
00059C  0707BA     RCALL ScalePowerSupply
339:                   ScalePowerSupply(&ps_filament,100,100);
00059E  200642     MOV #0x64, W2
0005A0  200641     MOV #0x64, W1
0005A2  20ABC0     MOV #0xABC, W0
0005A4  0707B6     RCALL ScalePowerSupply
340:                   ScalePowerSupply(&ps_magnet,100,100);
0005A6  200642     MOV #0x64, W2
0005A8  200641     MOV #0x64, W1
0005AA  20A620     MOV #0xA62, W0
0005AC  0707B2     RCALL ScalePowerSupply
341:                   ScalePowerSupply(&ps_thyr_reservoir_htr,100,100);
0005AE  200642     MOV #0x64, W2
0005B0  200641     MOV #0x64, W1
0005B2  20B700     MOV #0xB70, W0
0005B4  0707AE     RCALL ScalePowerSupply
342:                   ScalePowerSupply(&ps_thyr_cathode_htr,100,100);
0005B6  200642     MOV #0x64, W2
0005B8  200641     MOV #0x64, W1
0005BA  20B160     MOV #0xB16, W0
0005BC  0707AA     RCALL ScalePowerSupply
343:                   while (control_state == STATE_SYSTEM_WARM_READY) {
0005BE  37001B     BRA 0x5F6
0005F6  208325     MOV #0x832, W5
0005F8  784295     MOV.B [W5], W5
0005FA  B3C344     MOV #0x34, W4
0005FC  52CF84     SUB.B W5, W4, [W15]
0005FE  32FFE0     BRA Z, 0x5C0
344:                     Do10msTicToc();
0005C0  07092E     RCALL Do10msTicToc
345:                     DoSerialCommand();
0005C2  07117A     RCALL DoSerialCommand
346:                     if (CheckFaultActive()) {
0005C4  071D0D     RCALL CheckFaultActive
0005C6  780200     MOV W0, W4
0005C8  520FE0     SUB W4, #0x0, [W15]
0005CA  320004     BRA Z, 0x5D4
347:               	control_state = STATE_FAULT_WARM_FAULT;
0005CC  B3CA84     MOV #0xA8, W4
0005CE  784004     MOV.B W4, W0
0005D0  B7E832     MOV.B WREG, control_state
0005D2  370011     BRA 0x5F6
348:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
0005D4  801615     MOV PORTA, W5
0005D6  240004     MOV #0x4000, W4
0005D8  628204     AND W5, W4, W4
0005DA  520FE0     SUB W4, #0x0, [W15]
0005DC  320004     BRA Z, 0x5E6
349:               	control_state = STATE_SYSTEM_COLD_READY;
0005DE  B3C144     MOV #0x14, W4
0005E0  784004     MOV.B W4, W0
0005E2  B7E832     MOV.B WREG, control_state
0005E4  370008     BRA 0x5F6
350:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == ILL_MODULATOR_HV_ON) {
0005E6  801615     MOV PORTA, W5
0005E8  280004     MOV #0x8000, W4
0005EA  628204     AND W5, W4, W4
0005EC  520FE0     SUB W4, #0x0, [W15]
0005EE  3A0003     BRA NZ, 0x5F6
351:               	control_state = STATE_HV_STARTUP;
0005F0  B3C354     MOV #0x35, W4
0005F2  784004     MOV.B W4, W0
0005F4  B7E832     MOV.B WREG, control_state
352:                     }
353:                   }
354:                   break;
000600  3701CC     BRA 0x99A
355:                   
356:                 case STATE_HV_STARTUP:
357:                   // THIS STATE uses the same faults as STATE_SYSTEM_WARM_READY
358:               
359:               #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
360:                   
361:                   vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
000602  8041A4     MOV pac_1_adc_reading, W4
000604  20C351     MOV #0xC35, W1
000606  780004     MOV W4, W0
000608  070E5E     RCALL Scale16Bit
00060A  780200     MOV W0, W4
00060C  980744     MOV W4, [W14+8]
362:                   SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp , 0);
00060E  EB0100     CLR W2
000610  9000CE     MOV [W14+8], W1
000612  208FA0     MOV #0x8FA, W0
000614  07074C     RCALL SetPowerSupplyTarget
363:                   
364:                   vtemp = Scale16Bit(pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
000616  8041B4     MOV pac_2_adc_reading, W4
000618  20C351     MOV #0xC35, W1
00061A  780004     MOV W4, W0
00061C  070E54     RCALL Scale16Bit
00061E  780200     MOV W0, W4
000620  980744     MOV W4, [W14+8]
365:                   SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
000622  EB0100     CLR W2
000624  9000CE     MOV [W14+8], W1
000626  209AE0     MOV #0x9AE, W0
000628  070742     RCALL SetPowerSupplyTarget
366:               #endif
367:               
368:               
369:                   lambda_supply_startup_counter = 0;
00062A  EB0200     CLR W4
00062C  980714     MOV W4, [W14+2]
370:                   PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART;
00062E  A922C5     BCLR 0x2C5, #1
371:                   while (control_state == STATE_HV_STARTUP) {
000630  37002D     BRA 0x68C
00068C  208325     MOV #0x832, W5
00068E  784295     MOV.B [W5], W5
000690  B3C354     MOV #0x35, W4
000692  52CF84     SUB.B W5, W4, [W15]
000694  32FFCE     BRA Z, 0x632
372:                     Do10msTicToc();
000632  0708F5     RCALL Do10msTicToc
373:                     DoSerialCommand();
000634  071141     RCALL DoSerialCommand
374:                     if (_T2IF) {
000636  800425     MOV IFS0, W5
000638  200404     MOV #0x40, W4
00063A  628204     AND W5, W4, W4
00063C  520FE0     SUB W4, #0x0, [W15]
00063E  320004     BRA Z, 0x648
375:               	// 100ms Timer over flow 
376:               	_T2IF = 0;
000640  A9C084     BCLR IFS0, #6
377:               	lambda_supply_startup_counter++;
000642  90021E     MOV [W14+2], W4
000644  E80204     INC W4, W4
000646  980714     MOV W4, [W14+2]
378:                     }
379:                     if (CheckFaultActive()) {
000648  071CCB     RCALL CheckFaultActive
00064A  780200     MOV W0, W4
00064C  520FE0     SUB W4, #0x0, [W15]
00064E  320004     BRA Z, 0x658
380:               	control_state = STATE_FAULT_WARM_FAULT;
000650  B3CA84     MOV #0xA8, W4
000652  784004     MOV.B W4, W0
000654  B7E832     MOV.B WREG, control_state
000656  37001A     BRA 0x68C
381:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000658  801615     MOV PORTA, W5
00065A  240004     MOV #0x4000, W4
00065C  628204     AND W5, W4, W4
00065E  520FE0     SUB W4, #0x0, [W15]
000660  320004     BRA Z, 0x66A
382:               	control_state = STATE_SYSTEM_COLD_READY;
000662  B3C144     MOV #0x14, W4
000664  784004     MOV.B W4, W0
000666  B7E832     MOV.B WREG, control_state
000668  370011     BRA 0x68C
383:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == !ILL_MODULATOR_HV_ON) {
00066A  801615     MOV PORTA, W5
00066C  280004     MOV #0x8000, W4
00066E  628204     AND W5, W4, W4
000670  520FE0     SUB W4, #0x0, [W15]
000672  320004     BRA Z, 0x67C
384:               	control_state = STATE_SYSTEM_WARM_READY;
000674  B3C344     MOV #0x34, W4
000676  784004     MOV.B W4, W0
000678  B7E832     MOV.B WREG, control_state
00067A  370008     BRA 0x68C
385:                     } else if (lambda_supply_startup_counter >= LAMBDA_SUPPLY_STARTUP_DELAY) {
00067C  90029E     MOV [W14+2], W5
00067E  200314     MOV #0x31, W4
000680  528F84     SUB W5, W4, [W15]
000682  360004     BRA LEU, 0x68C
386:               	control_state = STATE_HV_ON;
000684  B3C444     MOV #0x44, W4
000686  784004     MOV.B W4, W0
000688  B7E832     MOV.B WREG, control_state
387:               	HVLambdaStartCharging();
00068A  070DC4     RCALL HVLambdaStartCharging
388:                     }
389:                   }
390:                   break;
000696  370181     BRA 0x99A
391:               
392:                   
393:                 case STATE_HV_ON:
394:                   arc_counter_consecutive = 0;
000698  EB0200     CLR W4
00069A  8841D4     MOV W4, arc_counter_consecutive
395:                   arc_counter_slow = 0;
00069C  EB0200     CLR W4
00069E  8841F4     MOV W4, arc_counter_slow
396:                   arc_counter_fast = 0;
0006A0  EB0200     CLR W4
0006A2  8841E4     MOV W4, arc_counter_fast
397:                   arc_counter_this_hv_on = 0;
0006A4  EB0200     CLR W4
0006A6  88C5D4     MOV W4, arc_counter_this_hv_on
398:                   pulse_counter_this_hv_on = 0;
0006A8  B82260     MUL.UU W4, #0, W4
0006AA  88C584     MOV W4, pulse_counter_this_hv_on
0006AC  88C595     MOV W5, 0x18B2
399:                   global_run_post_pulse_process = 0;
0006AE  EB4200     CLR.B W4
0006B0  784004     MOV.B W4, W0
0006B2  B7F6CC     MOV.B WREG, global_run_post_pulse_process
400:                   // PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART; // THIS is a redundent command and should be removed 
401:               
402:                   _T1IE = 1; // This is added for the fast restart process.  Normally _T1IE is set in HVLambdaStartCharging(), but the fast restart clears this bit temporarily
0006B4  A8608C     BSET IEC0, #3
403:                       
404:                   while (control_state == STATE_HV_ON) {
0006B6  370131     BRA 0x91A
00091A  208325     MOV #0x832, W5
00091C  784295     MOV.B [W5], W5
00091E  B3C444     MOV #0x44, W4
000920  52CF84     SUB.B W5, W4, [W15]
000922  32FECA     BRA Z, 0x6B8
405:                     last_known_action = LAST_ACTION_HV_ON_LOOP;
0006B8  2000C4     MOV #0xC, W4
0006BA  88C5A4     MOV W4, last_known_action
406:                     Do10msTicToc();
0006BC  0708B0     RCALL Do10msTicToc
407:                     DoSerialCommand();
0006BE  0710FC     RCALL DoSerialCommand
408:                     if (global_run_post_pulse_process) {
0006C0  216CC4     MOV #0x16CC, W4
0006C2  784214     MOV.B [W4], W4
0006C4  524FE0     SUB.B W4, #0x0, [W15]
0006C6  32010D     BRA Z, 0x8E2
409:               	if (false_trigger) {
0006C8  804104     MOV false_trigger, W4
0006CA  520FE0     SUB W4, #0x0, [W15]
0006CC  320002     BRA Z, 0x6D2
410:               	  RecordThisThyratronFault(FAULT_THYR_FALSE_TRIGGER);
0006CE  204000     MOV #0x400, W0
0006D0  071C45     RCALL RecordThisThyratronFault
411:               	}
412:               	last_known_action = LAST_ACTION_POST_PULSE_PROC;
0006D2  2000B4     MOV #0xB, W4
0006D4  88C5A4     MOV W4, last_known_action
413:               	// The Pulse Interrupt sets this Flag - And this sequence runs only once
414:               	// Update all the pulse data
415:               	if (pulse_counter_this_run <= 0xFF00) {
0006D6  8040F5     MOV pulse_counter_this_run, W5
0006D8  2FF004     MOV #0xFF00, W4
0006DA  528F84     SUB W5, W4, [W15]
0006DC  3E0003     BRA GTU, 0x6E4
416:               	  pulse_counter_this_run++;
0006DE  8040F4     MOV pulse_counter_this_run, W4
0006E0  E80204     INC W4, W4
0006E2  8840F4     MOV W4, pulse_counter_this_run
417:               	}
418:               	pulse_counter_this_hv_on++;
0006E4  80C584     MOV pulse_counter_this_hv_on, W4
0006E6  80C595     MOV 0x18B2, W5
0006E8  420261     ADD W4, #0x1, W4
0006EA  4A82E0     ADDC W5, #0x0, W5
0006EC  88C584     MOV W4, pulse_counter_this_hv_on
0006EE  88C595     MOV W5, 0x18B2
419:               	pulse_counter_persistent++;
0006F0  2189E4     MOV #0x189E, W4
0006F2  BE0034     MOV.D [W4++], W0
0006F4  BE0124     MOV.D [W4--], W2
0006F6  200014     MOV #0x1, W4
0006F8  200005     MOV #0x0, W5
0006FA  B83360     MUL.UU W6, #0, W6
0006FC  420200     ADD W4, W0, W4
0006FE  4A8281     ADDC W5, W1, W5
000700  4B0302     ADDC W6, W2, W6
000702  4B8383     ADDC W7, W3, W7
000704  2189E0     MOV #0x189E, W0
000706  BE9804     MOV.D W4, [W0++]
000708  BE9006     MOV.D W6, [W0--]
420:               	prf_pulse_counter++;
00070A  804184     MOV prf_pulse_counter, W4
00070C  E80204     INC W4, W4
00070E  884184     MOV W4, prf_pulse_counter
421:               
422:               	ReadIsolatedAdcToRam(); // Durring the pulse interrupt, the magnetron voltage and current was sampled.  Read back that data here
000710  070A1A     RCALL ReadIsolatedAdcToRam
423:               	UpdatePulseData(a_b_selected_mode);      // Run filtering/error detection on pulse data
000712  216CE4     MOV #0x16CE, W4
000714  784214     MOV.B [W4], W4
000716  784004     MOV.B W4, W0
000718  071A05     RCALL UpdatePulseData
424:               	a_b_selected_mode = next_pulse_a_b_selected_mode;
00071A  216CF4     MOV #0x16CF, W4
00071C  784214     MOV.B [W4], W4
00071E  784004     MOV.B W4, W0
000720  B7F6CE     MOV.B WREG, a_b_selected_mode
425:               	
426:               	// DPARKER impliment and test a current control PID LOOP
427:               	linac_low_energy_target_current_adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
000722  20ECC0     MOV #0xECC, W0
000724  07231A     RCALL _AverageADC128
000726  780200     MOV W0, W4
000728  8840A4     MOV W4, linac_low_energy_target_current_adc_reading
428:               	linac_high_energy_target_current_adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
00072A  20FCC0     MOV #0xFCC, W0
00072C  072316     RCALL _AverageADC128
00072E  780200     MOV W0, W4
000730  884084     MOV W4, linac_high_energy_target_current_adc_reading
429:               	//linac_low_energy_target_current_adc_reading = RCFilter64Tau(linac_low_energy_target_current_adc_reading, AverageADC128(thyratron_cathode_heater_voltage_array));
430:               	//linac_high_energy_target_current_adc_reading = RCFilter64Tau(linac_high_energy_target_current_adc_reading, AverageADC128(thyratron_reservoir_heater_voltage_array));
431:               
432:               	if (pulse_counter_this_run < 30) {
000732  8040F4     MOV pulse_counter_this_run, W4
000734  520FFD     SUB W4, #0x1D, [W15]
000736  3E0008     BRA GTU, 0x748
433:               	  linac_low_energy_program_offset = 0;
000738  EB0200     CLR W4
00073A  8840D4     MOV W4, linac_low_energy_program_offset
434:               	  linac_high_energy_program_offset = 0;
00073C  EB0200     CLR W4
00073E  8840C4     MOV W4, linac_high_energy_program_offset
435:               	  fast_ratio_mode = 1;
000740  B3C014     MOV #0x1, W4
000742  784004     MOV.B W4, W0
000744  B7E81C     MOV.B WREG, fast_ratio_mode
000746  3700A1     BRA 0x88A
436:               	} else {
437:               	  // There have been enough pulses for the sample and hold to return valid readins.  Start to close the loop around the measured target current
438:               	  // DPARKER - write the algorythim to take linac_target_current_high_energy_mode and linac_high_energy_target_current_set_point
439:               	
440:               
441:               	  low_energy_target_current_startup_adjust = 0;
000748  EB0200     CLR W4
00074A  980754     MOV W4, [W14+10]
442:               #ifdef __STARTUP_TARGET_CURRENT_ADJUST
443:               	  if (pulse_counter_this_run < low_energy_target_current_startup_adjust_decay_time_pulses) {
00074C  8040F5     MOV pulse_counter_this_run, W5
00074E  80C454     MOV low_energy_target_current_startup_adjust_decay_time_pulses, W4
000750  528F84     SUB W5, W4, [W15]
000752  310024     BRA C, 0x79C
444:               	    temp_long = low_energy_target_current_startup_adjust_initital_value;
000754  80C444     MOV low_energy_target_current_startup_adjust_initital_value, W4
000756  DEA2CF     ASR W4, #15, W5
000758  980764     MOV W4, [W14+12]
00075A  980775     MOV W5, [W14+14]
445:               	    temp_long *= (low_energy_target_current_startup_adjust_decay_time_pulses - pulse_counter_this_run);
00075C  80C455     MOV low_energy_target_current_startup_adjust_decay_time_pulses, W5
00075E  8040F4     MOV pulse_counter_this_run, W4
000760  528204     SUB W5, W4, W4
000762  200005     MOV #0x0, W5
000764  90037E     MOV [W14+14], W6
000766  B9B304     MUL.SS W6, W4, W6
000768  780306     MOV W6, W6
00076A  9003EE     MOV [W14+12], W7
00076C  B9B805     MUL.SS W7, W5, W0
00076E  780380     MOV W0, W7
000770  430307     ADD W6, W7, W6
000772  9003EE     MOV [W14+12], W7
000774  780204     MOV W4, W4
000776  B82207     MUL.UU W4, W7, W4
000778  430305     ADD W6, W5, W6
00077A  780286     MOV W6, W5
00077C  980764     MOV W4, [W14+12]
00077E  980775     MOV W5, [W14+14]
000780  980764     MOV W4, [W14+12]
000782  980775     MOV W5, [W14+14]
446:               	    temp_long /= low_energy_target_current_startup_adjust_decay_time_pulses;
000784  80C454     MOV low_energy_target_current_startup_adjust_decay_time_pulses, W4
000786  200005     MOV #0x0, W5
000788  BE0104     MOV.D W4, W2
00078A  90006E     MOV [W14+12], W0
00078C  9000FE     MOV [W14+14], W1
00078E  07FD84     RCALL ___divsi3
000790  BE0200     MOV.D W0, W4
000792  980764     MOV W4, [W14+12]
000794  980775     MOV W5, [W14+14]
447:               	    low_energy_target_current_startup_adjust = temp_long;
000796  90026E     MOV [W14+12], W4
000798  980754     MOV W4, [W14+10]
00079A  370002     BRA 0x7A0
448:               	  } else {
449:               	    low_energy_target_current_startup_adjust = 0;
00079C  EB0200     CLR W4
00079E  980754     MOV W4, [W14+10]
450:               	  }
451:               #endif
452:               	  
453:               
454:                 
455:               #ifdef __RATIO_CONTROL_MODE    
456:               	  
457:               	  low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point;
458:               	  low_energy_target_current_set_point_derived *= linac_high_energy_target_current_adc_reading;
459:               	  low_energy_target_current_set_point_derived /= linac_high_energy_target_current_set_point;
460:               	  
461:               
462:               	  if (fast_ratio_mode) {
463:               	    if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
464:               	      linac_low_energy_program_offset -= 3*LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
465:               	    } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
466:               	      linac_low_energy_program_offset += 3*LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
467:               	    } else {
468:               	      fast_ratio_mode = 0;
469:               	    }
470:               	  } else {
471:               	    if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
472:               	      linac_low_energy_program_offset -= LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
473:               	    } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
474:               	      linac_low_energy_program_offset += LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
475:               	    }
476:               	  }
477:               #else
478:               		  
479:               	  if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
0007A0  801735     MOV PORTG, W5
0007A2  240004     MOV #0x4000, W4
0007A4  628204     AND W5, W4, W4
0007A6  520FE0     SUB W4, #0x0, [W15]
0007A8  3A0007     BRA NZ, 0x7B8
480:               	    low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point + low_energy_target_current_startup_adjust;
0007AA  8040B5     MOV linac_low_energy_target_current_set_point, W5
0007AC  90025E     MOV [W14+10], W4
0007AE  428204     ADD W5, W4, W4
0007B0  200005     MOV #0x0, W5
0007B2  980724     MOV W4, [W14+4]
0007B4  980735     MOV W5, [W14+6]
0007B6  370021     BRA 0x7FA
481:               	  } else {
482:               	    low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point + low_energy_target_current_startup_adjust;
0007B8  8040B5     MOV linac_low_energy_target_current_set_point, W5
0007BA  90025E     MOV [W14+10], W4
0007BC  428204     ADD W5, W4, W4
0007BE  200005     MOV #0x0, W5
0007C0  980724     MOV W4, [W14+4]
0007C2  980735     MOV W5, [W14+6]
483:               	    low_energy_target_current_set_point_derived *= pac_2_adc_reading;
0007C4  8041B4     MOV pac_2_adc_reading, W4
0007C6  200005     MOV #0x0, W5
0007C8  90033E     MOV [W14+6], W6
0007CA  B9B304     MUL.SS W6, W4, W6
0007CC  780306     MOV W6, W6
0007CE  9003AE     MOV [W14+4], W7
0007D0  B9B805     MUL.SS W7, W5, W0
0007D2  780380     MOV W0, W7
0007D4  430307     ADD W6, W7, W6
0007D6  9003AE     MOV [W14+4], W7
0007D8  780204     MOV W4, W4
0007DA  B82207     MUL.UU W4, W7, W4
0007DC  430305     ADD W6, W5, W6
0007DE  780286     MOV W6, W5
0007E0  980724     MOV W4, [W14+4]
0007E2  980735     MOV W5, [W14+6]
0007E4  980724     MOV W4, [W14+4]
0007E6  980735     MOV W5, [W14+6]
484:               	    low_energy_target_current_set_point_derived /= default_pac_2_adc_reading;
0007E8  804074     MOV default_pac_2_adc_reading, W4
0007EA  200005     MOV #0x0, W5
0007EC  BE0104     MOV.D W4, W2
0007EE  90002E     MOV [W14+4], W0
0007F0  9000BE     MOV [W14+6], W1
0007F2  07FD61     RCALL ___udivsi3
0007F4  BE0200     MOV.D W0, W4
0007F6  980724     MOV W4, [W14+4]
0007F8  980735     MOV W5, [W14+6]
485:               	  }
486:               	  
487:               	  if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
0007FA  8040A4     MOV linac_low_energy_target_current_adc_reading, W4
0007FC  B82361     MUL.UU W4, #1, W6
0007FE  90022E     MOV [W14+4], W4
000800  9002BE     MOV [W14+6], W5
000802  B00324     ADD #0x32, W4
000804  B08005     ADDC #0x0, W5
000806  530F84     SUB W6, W4, [W15]
000808  5B8F85     SUBB W7, W5, [W15]
00080A  390004     BRA NC, 0x814
488:               	    linac_low_energy_program_offset -= LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
00080C  8040D4     MOV linac_low_energy_program_offset, W4
00080E  520263     SUB W4, #0x3, W4
000810  8840D4     MOV W4, linac_low_energy_program_offset
000812  37000E     BRA 0x830
489:               	  } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
000814  8040A4     MOV linac_low_energy_target_current_adc_reading, W4
000816  B82361     MUL.UU W4, #1, W6
000818  90002E     MOV [W14+4], W0
00081A  9000BE     MOV [W14+6], W1
00081C  2FFCE4     MOV #0xFFCE, W4
00081E  2FFFF5     MOV #0xFFFF, W5
000820  420200     ADD W4, W0, W4
000822  4A8281     ADDC W5, W1, W5
000824  530F84     SUB W6, W4, [W15]
000826  5B8F85     SUBB W7, W5, [W15]
000828  3E0003     BRA GTU, 0x830
490:               	    linac_low_energy_program_offset += LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
00082A  8040D4     MOV linac_low_energy_program_offset, W4
00082C  420263     ADD W4, #0x3, W4
00082E  8840D4     MOV W4, linac_low_energy_program_offset
491:               	  }
492:               
493:               	  if (linac_high_energy_target_current_adc_reading > (linac_high_energy_target_current_set_point + LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR)) {
000830  804094     MOV linac_high_energy_target_current_set_point, W4
000832  200325     MOV #0x32, W5
000834  428284     ADD W5, W4, W5
000836  804084     MOV linac_high_energy_target_current_adc_reading, W4
000838  528F84     SUB W5, W4, [W15]
00083A  310004     BRA C, 0x844
494:               	    linac_high_energy_program_offset -= LINAC_TARGET_CURRENT_HIGH_ENERGY_STEP_SIZE;
00083C  8040C4     MOV linac_high_energy_program_offset, W4
00083E  520263     SUB W4, #0x3, W4
000840  8840C4     MOV W4, linac_high_energy_program_offset
000842  370009     BRA 0x856
495:               	  } else if (linac_high_energy_target_current_adc_reading < (linac_high_energy_target_current_set_point - LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR)) {
000844  804094     MOV linac_high_energy_target_current_set_point, W4
000846  2FFCE5     MOV #0xFFCE, W5
000848  428284     ADD W5, W4, W5
00084A  804084     MOV linac_high_energy_target_current_adc_reading, W4
00084C  528F84     SUB W5, W4, [W15]
00084E  360003     BRA LEU, 0x856
496:               	    linac_high_energy_program_offset += LINAC_TARGET_CURRENT_HIGH_ENERGY_STEP_SIZE;
000850  8040C4     MOV linac_high_energy_program_offset, W4
000852  420263     ADD W4, #0x3, W4
000854  8840C4     MOV W4, linac_high_energy_program_offset
497:               	  }
498:               	  
499:               #endif
500:               	  
501:               	  if (linac_low_energy_program_offset > LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET) {
000856  8040D5     MOV linac_low_energy_program_offset, W5
000858  206404     MOV #0x640, W4
00085A  528F84     SUB W5, W4, [W15]
00085C  340003     BRA LE, 0x864
502:               	    linac_low_energy_program_offset = LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET;
00085E  206404     MOV #0x640, W4
000860  8840D4     MOV W4, linac_low_energy_program_offset
000862  370006     BRA 0x870
503:               	  } else if (linac_low_energy_program_offset < -LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET) {
000864  8040D5     MOV linac_low_energy_program_offset, W5
000866  2F9C04     MOV #0xF9C0, W4
000868  528F84     SUB W5, W4, [W15]
00086A  3D0002     BRA GE, 0x870
504:               	    linac_low_energy_program_offset = -LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET;
00086C  2F9C04     MOV #0xF9C0, W4
00086E  8840D4     MOV W4, linac_low_energy_program_offset
505:               	  }
506:               
507:               	  if (linac_high_energy_program_offset > LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET) {
000870  8040C5     MOV linac_high_energy_program_offset, W5
000872  202584     MOV #0x258, W4
000874  528F84     SUB W5, W4, [W15]
000876  340003     BRA LE, 0x87E
508:               	    linac_high_energy_program_offset = LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET;
000878  202584     MOV #0x258, W4
00087A  8840C4     MOV W4, linac_high_energy_program_offset
00087C  370006     BRA 0x88A
509:               	  } else if (linac_high_energy_program_offset < -LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET) {
00087E  8040C5     MOV linac_high_energy_program_offset, W5
000880  2FDA84     MOV #0xFDA8, W4
000882  528F84     SUB W5, W4, [W15]
000884  3D0002     BRA GE, 0x88A
510:               	    linac_high_energy_program_offset = -LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET;
000886  2FDA84     MOV #0xFDA8, W4
000888  8840C4     MOV W4, linac_high_energy_program_offset
511:               	  }
512:               	  	  
513:               	} 
514:               	
515:               #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
516:               	
517:               	vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
00088A  8041A4     MOV pac_1_adc_reading, W4
00088C  20C351     MOV #0xC35, W1
00088E  780004     MOV W4, W0
000890  070D1A     RCALL Scale16Bit
000892  780200     MOV W0, W4
000894  980744     MOV W4, [W14+8]
518:               	if (linac_high_energy_target_current_set_point >= 1000) {
000896  804095     MOV linac_high_energy_target_current_set_point, W5
000898  203E74     MOV #0x3E7, W4
00089A  528F84     SUB W5, W4, [W15]
00089C  360004     BRA LEU, 0x8A6
519:               	  vtemp += linac_high_energy_program_offset;
00089E  8040C4     MOV linac_high_energy_program_offset, W4
0008A0  9002CE     MOV [W14+8], W5
0008A2  428204     ADD W5, W4, W4
0008A4  980744     MOV W4, [W14+8]
520:               	}
521:               	SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp , 0);
0008A6  EB0100     CLR W2
0008A8  9000CE     MOV [W14+8], W1
0008AA  208FA0     MOV #0x8FA, W0
0008AC  070600     RCALL SetPowerSupplyTarget
522:               	
523:               	vtemp = Scale16Bit(default_pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
0008AE  804074     MOV default_pac_2_adc_reading, W4
0008B0  20C351     MOV #0xC35, W1
0008B2  780004     MOV W4, W0
0008B4  070D08     RCALL Scale16Bit
0008B6  780200     MOV W0, W4
0008B8  980744     MOV W4, [W14+8]
524:               	if (linac_low_energy_target_current_set_point >= 1000) {
0008BA  8040B5     MOV linac_low_energy_target_current_set_point, W5
0008BC  203E74     MOV #0x3E7, W4
0008BE  528F84     SUB W5, W4, [W15]
0008C0  360004     BRA LEU, 0x8CA
525:               	  vtemp += linac_low_energy_program_offset;
0008C2  8040D4     MOV linac_low_energy_program_offset, W4
0008C4  9002CE     MOV [W14+8], W5
0008C6  428204     ADD W5, W4, W4
0008C8  980744     MOV W4, [W14+8]
526:               	}
527:               	SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
0008CA  EB0100     CLR W2
0008CC  9000CE     MOV [W14+8], W1
0008CE  209AE0     MOV #0x9AE, W0
0008D0  0705EE     RCALL SetPowerSupplyTarget
528:               	
529:               #endif
530:               
531:               
532:               
533:               	
534:               	
535:               	UpdateDacAll();                          // We want to Execute DAC update after a pulse so that a pulse does not corrupt the SPI data
0008D2  070769     RCALL UpdateDacAll
536:               	//UpdateIOExpanderOutputs();               // DPAKRER is this needed here?  The io expander outputs should never change in state HV on!!!!
537:               	
538:               	// Set up the 100ms Timer that will roll if there is not another pulse in the next 100mS
539:               	TMR2 = 0;
0008D4  EB0200     CLR W4
0008D6  880834     MOV W4, TMR2
540:               	_T2IF = 0;          
0008D8  A9C084     BCLR IFS0, #6
541:               	global_run_post_pulse_process = 0;	
0008DA  EB4200     CLR.B W4
0008DC  784004     MOV.B W4, W0
0008DE  B7F6CC     MOV.B WREG, global_run_post_pulse_process
542:               	SendLoggingDataToUart();
0008E0  07104A     RCALL SendLoggingDataToUart
543:                     }
544:                     
545:                     // DPARKER need to write new timing diagram - should be simplier
546:                     
547:                     if (CheckFaultActive()) {
0008E2  071B7E     RCALL CheckFaultActive
0008E4  780200     MOV W0, W4
0008E6  520FE0     SUB W4, #0x0, [W15]
0008E8  320005     BRA Z, 0x8F4
548:               	ExitHvOnState();
0008EA  070B43     RCALL ExitHvOnState
549:               	control_state = STATE_FAULT_WARM_FAULT;
0008EC  B3CA84     MOV #0xA8, W4
0008EE  784004     MOV.B W4, W0
0008F0  B7E832     MOV.B WREG, control_state
0008F2  370013     BRA 0x91A
550:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
0008F4  801615     MOV PORTA, W5
0008F6  240004     MOV #0x4000, W4
0008F8  628204     AND W5, W4, W4
0008FA  520FE0     SUB W4, #0x0, [W15]
0008FC  320005     BRA Z, 0x908
551:               	ExitHvOnState();
0008FE  070B39     RCALL ExitHvOnState
552:               	control_state = STATE_SYSTEM_COLD_READY;
000900  B3C144     MOV #0x14, W4
000902  784004     MOV.B W4, W0
000904  B7E832     MOV.B WREG, control_state
000906  370009     BRA 0x91A
553:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == !ILL_MODULATOR_HV_ON) {
000908  801615     MOV PORTA, W5
00090A  280004     MOV #0x8000, W4
00090C  628204     AND W5, W4, W4
00090E  520FE0     SUB W4, #0x0, [W15]
000910  320004     BRA Z, 0x91A
554:               	ExitHvOnState();
000912  070B2F     RCALL ExitHvOnState
555:               	control_state = STATE_SYSTEM_WARM_READY;
000914  B3C344     MOV #0x34, W4
000916  784004     MOV.B W4, W0
000918  B7E832     MOV.B WREG, control_state
556:                     }
557:                   }
558:                   break;
000924  37003A     BRA 0x99A
559:                   
560:                 case STATE_FAULT_COLD_FAULT:
561:                   DoColdShutDown();
000926  070B77     RCALL DoColdShutDown
562:                   // SaveDataToEEPROM(); DPARKER use better functions
563:                   while (control_state == STATE_FAULT_COLD_FAULT) {
000928  370009     BRA 0x93C
00093C  208325     MOV #0x832, W5
00093E  784295     MOV.B [W5], W5
000940  B3CA44     MOV #0xA4, W4
000942  52CF84     SUB.B W5, W4, [W15]
000944  32FFF2     BRA Z, 0x92A
564:                     Do10msTicToc();
00092A  070779     RCALL Do10msTicToc
565:                     DoSerialCommand();
00092C  070FC5     RCALL DoSerialCommand
566:                     if (CheckFaultActive() == 0) {
00092E  071B58     RCALL CheckFaultActive
000930  780200     MOV W0, W4
000932  520FE0     SUB W4, #0x0, [W15]
000934  3A0003     BRA NZ, 0x93C
567:               	control_state = STATE_SYSTEM_COLD_READY;
000936  B3C144     MOV #0x14, W4
000938  784004     MOV.B W4, W0
00093A  B7E832     MOV.B WREG, control_state
568:                     }
569:                   }
570:                   break;
000946  370029     BRA 0x99A
571:                   
572:                 case STATE_FAULT_WARM_FAULT:
573:                   DoWarmShutDown();
000948  070B8E     RCALL DoWarmShutDown
574:                   // DPARKER SaveDataToEEPROM();
575:                   while (control_state == STATE_FAULT_WARM_FAULT) {
00094A  37001A     BRA 0x980
000980  208325     MOV #0x832, W5
000982  784295     MOV.B [W5], W5
000984  B3CA84     MOV #0xA8, W4
000986  52CF84     SUB.B W5, W4, [W15]
000988  32FFE1     BRA Z, 0x94C
576:                     Do10msTicToc();
00094C  070768     RCALL Do10msTicToc
577:                     DoSerialCommand();
00094E  070FB4     RCALL DoSerialCommand
578:                     if (CheckColdFaultActive()) {
000950  071B52     RCALL CheckColdFaultActive
000952  780200     MOV W0, W4
000954  520FE0     SUB W4, #0x0, [W15]
000956  320004     BRA Z, 0x960
579:               	control_state = STATE_FAULT_COLD_FAULT;
000958  B3CA44     MOV #0xA4, W4
00095A  784004     MOV.B W4, W0
00095C  B7E832     MOV.B WREG, control_state
00095E  370010     BRA 0x980
580:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000960  801615     MOV PORTA, W5
000962  240004     MOV #0x4000, W4
000964  628204     AND W5, W4, W4
000966  520FE0     SUB W4, #0x0, [W15]
000968  320004     BRA Z, 0x972
581:               	control_state = STATE_FAULT_COLD_FAULT;
00096A  B3CA44     MOV #0xA4, W4
00096C  784004     MOV.B W4, W0
00096E  B7E832     MOV.B WREG, control_state
000970  370007     BRA 0x980
582:                     } else if (CheckFaultActive() == 0) {
000972  071B36     RCALL CheckFaultActive
000974  780200     MOV W0, W4
000976  520FE0     SUB W4, #0x0, [W15]
000978  3A0003     BRA NZ, 0x980
583:               	control_state = STATE_SYSTEM_WARM_READY;
00097A  B3C344     MOV #0x34, W4
00097C  784004     MOV.B W4, W0
00097E  B7E832     MOV.B WREG, control_state
584:                     }
585:                   }
586:                   break;
00098A  370007     BRA 0x99A
587:                   
588:                 case STATE_FAULT_MCU_CORE_FAULT:
589:                   // DPARKER DO SOMETHING!!!!!!
590:                   // Maybe flash some LEDs, go home
591:                   // your're fracked.  Just hang out here till you get reset
592:                   while (1) {
593:                     Do10msTicToc();
00098C  070748     RCALL Do10msTicToc
594:                     DoSerialCommand();
00098E  070F94     RCALL DoSerialCommand
595:                   }
000990  37FFFD     BRA 0x98C
596:                   break;
597:               
598:                 default:
599:                   // DPARKER throw an ERROR
600:                   control_state = STATE_FAULT_MCU_CORE_FAULT;
000992  B3CA04     MOV #0xA0, W4
000994  784004     MOV.B W4, W0
000996  B7E832     MOV.B WREG, control_state
601:                   break;
000998  000000     NOP
602:                 }
603:               }
00099A  FA8000     ULNK
00099C  060000     RETURN
604:               
605:               void DoA34760StartUpCommon(void) {
00099E  FA0002     LNK #0x2
606:                 unsigned int *unsigned_int_ptr;  
607:               
608:                 // This is debugging info info  If the processor reset, a code that indicates the last major point that the processor entered should be held in RAM at last_known_action
609:                 previous_last_action = last_known_action;
0009A0  80C5A4     MOV last_known_action, W4
0009A2  884124     MOV W4, previous_last_action
610:                 last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
0009A4  EB0200     CLR W4
0009A6  88C5A4     MOV W4, last_known_action
611:               
612:                 // Figure out why the processor restarted and save to the debug status register
613:                 debug_status_register = 0;
0009A8  EB0200     CLR W4
0009AA  88C2F4     MOV W4, debug_status_register
614:                 if (_POR) {
0009AC  803A04     MOV RCON, W4
0009AE  620261     AND W4, #0x1, W4
0009B0  520FE0     SUB W4, #0x0, [W15]
0009B2  320003     BRA Z, 0x9BA
615:                   debug_status_register |= STATUS_POR_RESET;
0009B4  80C2F4     MOV debug_status_register, W4
0009B6  A04004     BSET W4, #4
0009B8  88C2F4     MOV W4, debug_status_register
616:                   // _POR = 0;
617:                 }
618:                 if (_EXTR) {
0009BA  803A05     MOV RCON, W5
0009BC  200804     MOV #0x80, W4
0009BE  628204     AND W5, W4, W4
0009C0  520FE0     SUB W4, #0x0, [W15]
0009C2  320004     BRA Z, 0x9CC
619:                   debug_status_register |= STATUS_EXTERNAL_RESET;
0009C4  80C2F5     MOV debug_status_register, W5
0009C6  200204     MOV #0x20, W4
0009C8  728204     IOR W5, W4, W4
0009CA  88C2F4     MOV W4, debug_status_register
620:                   //_EXTR = 0;
621:                 }
622:                 if (_SWR) {
0009CC  803A05     MOV RCON, W5
0009CE  200404     MOV #0x40, W4
0009D0  628204     AND W5, W4, W4
0009D2  520FE0     SUB W4, #0x0, [W15]
0009D4  320004     BRA Z, 0x9DE
623:                   debug_status_register |= STATUS_SOFTARE_RESET;
0009D6  80C2F5     MOV debug_status_register, W5
0009D8  200404     MOV #0x40, W4
0009DA  728204     IOR W5, W4, W4
0009DC  88C2F4     MOV W4, debug_status_register
624:                   //_SWR = 0;
625:                 }
626:                 if (_BOR) {
0009DE  803A04     MOV RCON, W4
0009E0  620262     AND W4, #0x2, W4
0009E2  520FE0     SUB W4, #0x0, [W15]
0009E4  320003     BRA Z, 0x9EC
627:                   debug_status_register |= STATUS_BOR_RESET;
0009E6  80C2F4     MOV debug_status_register, W4
0009E8  A00004     BSET W4, #0
0009EA  88C2F4     MOV W4, debug_status_register
628:                   //_BOR = 0;
629:                 }
630:                 if (_TRAPR) {
0009EC  803A05     MOV RCON, W5
0009EE  280004     MOV #0x8000, W4
0009F0  628204     AND W5, W4, W4
0009F2  520FE0     SUB W4, #0x0, [W15]
0009F4  320003     BRA Z, 0x9FC
631:                   debug_status_register |= STATUS_TRAPR_RESET;
0009F6  80C2F4     MOV debug_status_register, W4
0009F8  A01004     BSET W4, #1
0009FA  88C2F4     MOV W4, debug_status_register
632:                   //_TRAPR = 0;
633:                 }
634:                 if (_WDTO) {
0009FC  803A04     MOV RCON, W4
0009FE  620270     AND W4, #0x10, W4
000A00  520FE0     SUB W4, #0x0, [W15]
000A02  320003     BRA Z, 0xA0A
635:                   debug_status_register |= STATUS_WDT_RESET;
000A04  80C2F4     MOV debug_status_register, W4
000A06  A02004     BSET W4, #2
000A08  88C2F4     MOV W4, debug_status_register
636:                   // _WDTO = 0;
637:                 }
638:                 if (_IOPUWR) {
000A0A  803A05     MOV RCON, W5
000A0C  240004     MOV #0x4000, W4
000A0E  628204     AND W5, W4, W4
000A10  520FE0     SUB W4, #0x0, [W15]
000A12  320003     BRA Z, 0xA1A
639:                   debug_status_register |= STATUS_IOPUWR_RESET;
000A14  80C2F4     MOV debug_status_register, W4
000A16  A03004     BSET W4, #3
000A18  88C2F4     MOV W4, debug_status_register
640:                   //_IOPUWR = 0;
641:                 }
642:               
643:                 
644:                 // Debug Counter Initializations
645:                 global_debug_counter.magnetron_current_adc_glitch = 0;
000A1A  EB0200     CLR W4
000A1C  88C244     MOV W4, global_debug_counter
646:                 global_debug_counter.magnetron_voltage_adc_glitch = 0;
000A1E  EB0200     CLR W4
000A20  88C254     MOV W4, 0x184A
647:                 global_debug_counter.i2c_bus_error = 0;
000A22  EB0200     CLR W4
000A24  88C264     MOV W4, 0x184C
648:                 global_debug_counter.spi1_bus_error = 0;
000A26  EB0200     CLR W4
000A28  88C274     MOV W4, 0x184E
649:                 global_debug_counter.spi2_bus_error = 0;
000A2A  EB0200     CLR W4
000A2C  88C284     MOV W4, 0x1850
650:                 global_debug_counter.external_adc_false_trigger = 0;
000A2E  EB0200     CLR W4
000A30  88C294     MOV W4, 0x1852
651:                 global_debug_counter.LTC2656_write_error = 0;
000A32  EB0200     CLR W4
000A34  88C2A4     MOV W4, 0x1854
652:                 global_debug_counter.setpoint_not_valid = 0;
000A36  EB0200     CLR W4
000A38  88C2B4     MOV W4, 0x1856
653:                 global_debug_counter.scale16bit_saturation = 0;
000A3A  EB0200     CLR W4
000A3C  88C2C4     MOV W4, 0x1858
654:                 global_debug_counter.reversescale16bit_saturation = 0;
000A3E  EB0200     CLR W4
000A40  88C2D4     MOV W4, 0x185A
655:               
656:               
657:                 linac_high_energy_target_current_set_point = control_loop_cal_data_ram_copy[EEPROM_CNTRL_HIGH_ENERGY_TARGET];
000A42  80C174     MOV 0x182E, W4
000A44  884094     MOV W4, linac_high_energy_target_current_set_point
658:                 linac_low_energy_target_current_set_point = control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_TARGET];
000A46  80C184     MOV 0x1830, W4
000A48  8840B4     MOV W4, linac_low_energy_target_current_set_point
659:               
660:               
661:                 
662:                 /*
663:                   Initialize the thyratron heater PID structure
664:                   DPARKER add these values to H file
665:                 */
666:                 thyratron_cathode_heater_PID.abcCoefficients = &pid_thyratron_cathode_heater_abcCoefficient[0];    /*Set up pointer to derived coefficients */
000A4A  208064     MOV #0x806, W4
000A4C  8842A4     MOV W4, thyratron_cathode_heater_PID
667:                 
668:                 thyratron_cathode_heater_PID.controlHistory = &pid_thyratron_cathode_heater_controlHistory[0];     /*Set up pointer to controller history samples */
000A4E  21FFA4     MOV #0x1FFA, W4
000A50  8842B4     MOV W4, 0x856
669:                 PIDInit(&thyratron_cathode_heater_PID);                                                    /*Clear the controler history and the controller output */
000A52  208540     MOV #0x854, W0
000A54  07FBBB     RCALL _PIDInit
670:                 pid_thyratron_cathode_heater_kCoeffs[0] = Q15(0.02);
000A56  2028F4     MOV #0x28F, W4
000A58  88C4C4     MOV W4, pid_thyratron_cathode_heater_kCoeffs
671:                 pid_thyratron_cathode_heater_kCoeffs[1] = Q15(0.08);
000A5A  20A3D4     MOV #0xA3D, W4
000A5C  88C4D4     MOV W4, 0x189A
672:                 pid_thyratron_cathode_heater_kCoeffs[2] = Q15(0.08);
000A5E  20A3D4     MOV #0xA3D, W4
000A60  88C4E4     MOV W4, 0x189C
673:                 PIDCoeffCalc(&pid_thyratron_cathode_heater_kCoeffs[0], &thyratron_cathode_heater_PID);             /*Derive the a,b, & c coefficients from the Kp, Ki & Kd */
000A62  208541     MOV #0x854, W1
000A64  218980     MOV #0x1898, W0
000A66  07FBBD     RCALL _PIDCoeffCalc
674:                 
675:                 thyratron_reservoir_heater_PID.abcCoefficients = &pid_thyratron_reservoir_heater_abcCoefficient[0];    /*Set up pointer to derived coefficients */
000A68  208004     MOV #0x800, W4
000A6A  884254     MOV W4, thyratron_reservoir_heater_PID
676:                 thyratron_reservoir_heater_PID.controlHistory = &pid_thyratron_reservoir_heater_controlHistory[0];     /*Set up pointer to controller history samples */
000A6C  21FF44     MOV #0x1FF4, W4
000A6E  884264     MOV W4, 0x84C
677:                 PIDInit(&thyratron_reservoir_heater_PID);                                          /*Clear the controler history and the controller output */
000A70  2084A0     MOV #0x84A, W0
000A72  07FBAC     RCALL _PIDInit
678:                 pid_thyratron_reservoir_heater_kCoeffs[0] = Q15(0.02);
000A74  2028F4     MOV #0x28F, W4
000A76  88C494     MOV W4, pid_thyratron_reservoir_heater_kCoeffs
679:                 pid_thyratron_reservoir_heater_kCoeffs[1] = Q15(0.08);
000A78  20A3D4     MOV #0xA3D, W4
000A7A  88C4A4     MOV W4, 0x1894
680:                 pid_thyratron_reservoir_heater_kCoeffs[2] = Q15(0.08);
000A7C  20A3D4     MOV #0xA3D, W4
000A7E  88C4B4     MOV W4, 0x1896
681:                 PIDCoeffCalc(&pid_thyratron_reservoir_heater_kCoeffs[0], &thyratron_reservoir_heater_PID); /*Derive the a,b, & c coefficients from the Kp, Ki & Kd */
000A80  2084A1     MOV #0x84A, W1
000A82  218920     MOV #0x1892, W0
000A84  07FBAE     RCALL _PIDCoeffCalc
682:                 ClrWdt();
000A86  FE6000     CLRWDT
683:               
684:                 
685:                   
686:                 // --- ps_magnet initialization ---
687:               
688:                 ps_magnet.warmup_ramp_time     = MAGNET_SUPPLY_WARMUP_RAMP_TIME;
000A88  200644     MOV #0x64, W4
000A8A  885314     MOV W4, ps_magnet
689:                 
690:                 ps_magnet.v_max_set_point      = MAX_MAGNET_SUPPLY_VOLTAGE_SET_POINT;
000A8C  27D004     MOV #0x7D00, W4
000A8E  885344     MOV W4, 0xA68
691:                 
692:                 ps_magnet.v_dac_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
000A90  2A3271     MOV #0xA327, W1
000A92  EB8000     SETM W0
000A94  070BDD     RCALL MakeScale
000A96  780200     MOV W0, W4
000A98  885364     MOV W4, 0xA6C
693:                 ps_magnet.v_dac_cal_gain       = ps_magnet_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000A9A  80B734     MOV 0x16E6, W4
000A9C  885374     MOV W4, 0xA6E
694:                 ps_magnet.v_dac_cal_offset     = ps_magnet_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000A9E  80B744     MOV 0x16E8, W4
000AA0  885384     MOV W4, 0xA70
695:                 
696:                 ps_magnet.v_adc_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_VADC_INPUT_AT_0xFFFF);
000AA2  2AAE61     MOV #0xAAE6, W1
000AA4  EB8000     SETM W0
000AA6  070BD4     RCALL MakeScale
000AA8  780200     MOV W0, W4
000AAA  8853A4     MOV W4, 0xA74
697:                 ps_magnet.v_adc_cal_gain       = ps_magnet_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000AAC  80B754     MOV 0x16EA, W4
000AAE  8853B4     MOV W4, 0xA76
698:                 ps_magnet.v_adc_cal_offset     = ps_magnet_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000AB0  80B764     MOV 0x16EC, W4
000AB2  8853C4     MOV W4, 0xA78
699:                 ps_magnet.v_adc_over_abs       = Scale16Bit(MAGNET_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_magnet.v_adc_scale);
000AB4  8053A4     MOV 0xA74, W4
000AB6  780084     MOV W4, W1
000AB8  275300     MOV #0x7530, W0
000ABA  070C05     RCALL Scale16Bit
000ABC  780200     MOV W0, W4
000ABE  8853D4     MOV W4, 0xA7A
700:                 ps_magnet.v_adc_over_scale     = MakeScale(MAGNET_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000AC0  220001     MOV #0x2000, W1
000AC2  228000     MOV #0x2800, W0
000AC4  070BC5     RCALL MakeScale
000AC6  780200     MOV W0, W4
000AC8  885404     MOV W4, 0xA80
701:                 ps_magnet.v_adc_under_scale    = MakeScale(MAGNET_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000ACA  220001     MOV #0x2000, W1
000ACC  210000     MOV #0x1000, W0
000ACE  070BC0     RCALL MakeScale
000AD0  780200     MOV W0, W4
000AD2  885414     MOV W4, 0xA82
702:                 ps_magnet.v_adc_over_min_value = MAGNET_SUPPLY_VADC_MIN_OVER_VOLTAGE;
000AD4  203E84     MOV #0x3E8, W4
000AD6  885424     MOV W4, 0xA84
703:                 ps_magnet.v_adc_max_oor        = MAGNET_SUPPLY_VADC_MAX_OUT_OT_RANGE;
000AD8  200324     MOV #0x32, W4
000ADA  885434     MOV W4, 0xA86
704:                 
705:                 ps_magnet.i_max_set_point      = MAX_MAGNET_SUPPLY_CURRENT_SET_POINT;
000ADC  261A84     MOV #0x61A8, W4
000ADE  8854A4     MOV W4, 0xA94
706:                 
707:                 ps_magnet.i_dac_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
000AE0  2A3271     MOV #0xA327, W1
000AE2  EB8000     SETM W0
000AE4  070BB5     RCALL MakeScale
000AE6  780200     MOV W0, W4
000AE8  8854C4     MOV W4, 0xA98
708:                 ps_magnet.i_dac_cal_gain       = ps_magnet_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000AEA  80B784     MOV 0x16F0, W4
000AEC  8854D4     MOV W4, 0xA9A
709:                 ps_magnet.i_dac_cal_offset     = ps_magnet_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000AEE  80B794     MOV 0x16F2, W4
000AF0  8854E4     MOV W4, 0xA9C
710:                 
711:                 ps_magnet.i_adc_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_IADC_INPUT_AT_0xFFFF);
000AF2  2AAE61     MOV #0xAAE6, W1
000AF4  EB8000     SETM W0
000AF6  070BAC     RCALL MakeScale
000AF8  780200     MOV W0, W4
000AFA  885504     MOV W4, 0xAA0
712:                 ps_magnet.i_adc_cal_gain       = ps_magnet_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000AFC  80B7A4     MOV 0x16F4, W4
000AFE  885514     MOV W4, 0xAA2
713:                 ps_magnet.i_adc_cal_offset     = ps_magnet_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000B00  80B7B4     MOV 0x16F6, W4
000B02  885524     MOV W4, 0xAA4
714:                 ps_magnet.i_adc_over_abs       = Scale16Bit(MAGNET_SUPPLY_IADC_OVER_CURRENT_HARD, ps_magnet.i_adc_scale);
000B04  805504     MOV 0xAA0, W4
000B06  780084     MOV W4, W1
000B08  265900     MOV #0x6590, W0
000B0A  070BDD     RCALL Scale16Bit
000B0C  780200     MOV W0, W4
000B0E  885534     MOV W4, 0xAA6
715:                 ps_magnet.i_adc_over_scale     = MakeScale(MAGNET_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
000B10  220001     MOV #0x2000, W1
000B12  223330     MOV #0x2333, W0
000B14  070B9D     RCALL MakeScale
000B16  780200     MOV W0, W4
000B18  885564     MOV W4, 0xAAC
716:                 ps_magnet.i_adc_under_scale    = MakeScale(MAGNET_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000B1A  220001     MOV #0x2000, W1
000B1C  21CCC0     MOV #0x1CCC, W0
000B1E  070B98     RCALL MakeScale
000B20  780200     MOV W0, W4
000B22  885574     MOV W4, 0xAAE
717:                 ps_magnet.i_adc_over_min_value = MAGNET_SUPPLY_IADC_MIN_OVER_CURRENT;
000B24  20FA04     MOV #0xFA0, W4
000B26  885584     MOV W4, 0xAB0
718:                 ps_magnet.i_adc_max_oor        = MAGNET_SUPPLY_IADC_MAX_OUT_OT_RANGE;
000B28  200324     MOV #0x32, W4
000B2A  885594     MOV W4, 0xAB2
719:               
720:                 SetPowerSupplyTarget(&ps_magnet, ps_magnet_config_ram_copy[EEPROM_V_SET_POINT], ps_magnet_config_ram_copy[EEPROM_I_SET_POINT]);
000B2C  80B774     MOV 0x16EE, W4
000B2E  780284     MOV W4, W5
000B30  80B724     MOV ps_magnet_config_ram_copy, W4
000B32  780105     MOV W5, W2
000B34  780084     MOV W4, W1
000B36  20A620     MOV #0xA62, W0
000B38  0704BA     RCALL SetPowerSupplyTarget
721:                 
722:               
723:               
724:                 // --- ps_filament initialization ---
725:               
726:                 ps_filament.warmup_ramp_time     = FILAMENT_SUPPLY_WARMUP_RAMP_TIME;
000B3A  202584     MOV #0x258, W4
000B3C  8855E4     MOV W4, ps_filament
727:                 
728:                 ps_filament.v_max_set_point      = MAX_FILAMENT_SUPPLY_VOLTAGE_SET_POINT;
000B3E  25DC04     MOV #0x5DC0, W4
000B40  885614     MOV W4, 0xAC2
729:                 
730:                 ps_filament.v_dac_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
000B42  26EB21     MOV #0x6EB2, W1
000B44  EB8000     SETM W0
000B46  070B84     RCALL MakeScale
000B48  780200     MOV W0, W4
000B4A  885634     MOV W4, 0xAC6
731:                 ps_filament.v_dac_cal_gain       = ps_filament_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000B4C  80B854     MOV 0x170A, W4
000B4E  885644     MOV W4, 0xAC8
732:                 ps_filament.v_dac_cal_offset     = ps_filament_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000B50  80B864     MOV 0x170C, W4
000B52  885654     MOV W4, 0xACA
733:                 
734:                 ps_filament.v_adc_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_VADC_INPUT_AT_0xFFFF);
000B54  2AB0C1     MOV #0xAB0C, W1
000B56  EB8000     SETM W0
000B58  070B7B     RCALL MakeScale
000B5A  780200     MOV W0, W4
000B5C  885674     MOV W4, 0xACE
735:                 ps_filament.v_adc_cal_gain       = ps_filament_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000B5E  80B874     MOV 0x170E, W4
000B60  885684     MOV W4, 0xAD0
736:                 ps_filament.v_adc_cal_offset     = ps_filament_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000B62  80B884     MOV 0x1710, W4
000B64  885694     MOV W4, 0xAD2
737:                 ps_filament.v_adc_over_abs       = Scale16Bit(FILAMENT_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_filament.v_adc_scale);
000B66  805674     MOV 0xACE, W4
000B68  780084     MOV W4, W1
000B6A  261A80     MOV #0x61A8, W0
000B6C  070BAC     RCALL Scale16Bit
000B6E  780200     MOV W0, W4
000B70  8856A4     MOV W4, 0xAD4
738:                 ps_filament.v_adc_over_scale     = MakeScale(FILAMENT_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000B72  220001     MOV #0x2000, W1
000B74  228000     MOV #0x2800, W0
000B76  070B6C     RCALL MakeScale
000B78  780200     MOV W0, W4
000B7A  8856D4     MOV W4, 0xADA
739:                 ps_filament.v_adc_under_scale    = MakeScale(FILAMENT_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000B7C  220001     MOV #0x2000, W1
000B7E  218000     MOV #0x1800, W0
000B80  070B67     RCALL MakeScale
000B82  780200     MOV W0, W4
000B84  8856E4     MOV W4, 0xADC
740:                 ps_filament.v_adc_over_min_value = FILAMENT_SUPPLY_VADC_MIN_OVER_VOLTAGE;
000B86  20FA04     MOV #0xFA0, W4
000B88  8856F4     MOV W4, 0xADE
741:                 ps_filament.v_adc_max_oor        = FILAMENT_SUPPLY_VADC_MAX_OUT_OT_RANGE;
000B8A  200C84     MOV #0xC8, W4
000B8C  885704     MOV W4, 0xAE0
742:                 
743:                 ps_filament.i_max_set_point      = MAX_FILAMENT_SUPPLY_CURRENT_SET_POINT;
000B8E  25DC04     MOV #0x5DC0, W4
000B90  885774     MOV W4, 0xAEE
744:                 
745:                 ps_filament.i_dac_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
000B92  EB8080     SETM W1
000B94  EB8000     SETM W0
000B96  070B5C     RCALL MakeScale
000B98  780200     MOV W0, W4
000B9A  885794     MOV W4, 0xAF2
746:                 ps_filament.i_dac_cal_gain       = ps_filament_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000B9C  80B8A4     MOV 0x1714, W4
000B9E  8857A4     MOV W4, 0xAF4
747:                 ps_filament.i_dac_cal_offset     = ps_filament_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000BA0  80B8B4     MOV 0x1716, W4
000BA2  8857B4     MOV W4, 0xAF6
748:                 
749:                 ps_filament.i_adc_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_IADC_INPUT_AT_0xFFFF);
000BA4  2804C1     MOV #0x804C, W1
000BA6  EB8000     SETM W0
000BA8  070B53     RCALL MakeScale
000BAA  780200     MOV W0, W4
000BAC  8857D4     MOV W4, 0xAFA
750:                 ps_filament.i_adc_cal_gain       = ps_filament_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000BAE  80B8C4     MOV 0x1718, W4
000BB0  8857E4     MOV W4, 0xAFC
751:                 ps_filament.i_adc_cal_offset     = ps_filament_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000BB2  80B8D4     MOV 0x171A, W4
000BB4  8857F4     MOV W4, 0xAFE
752:                 ps_filament.i_adc_over_abs       = Scale16Bit(FILAMENT_SUPPLY_IADC_OVER_CURRENT_HARD, ps_filament.i_adc_scale);
000BB6  8057D4     MOV 0xAFA, W4
000BB8  780084     MOV W4, W1
000BBA  232C80     MOV #0x32C8, W0
000BBC  070B84     RCALL Scale16Bit
000BBE  780200     MOV W0, W4
000BC0  885804     MOV W4, 0xB00
753:                 ps_filament.i_adc_over_scale     = MakeScale(FILAMENT_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
000BC2  220001     MOV #0x2000, W1
000BC4  240000     MOV #0x4000, W0
000BC6  070B44     RCALL MakeScale
000BC8  780200     MOV W0, W4
000BCA  885834     MOV W4, 0xB06
754:                 ps_filament.i_adc_under_scale    = MakeScale(FILAMENT_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000BCC  220001     MOV #0x2000, W1
000BCE  210000     MOV #0x1000, W0
000BD0  070B3F     RCALL MakeScale
000BD2  780200     MOV W0, W4
000BD4  885844     MOV W4, 0xB08
755:                 ps_filament.i_adc_over_min_value = FILAMENT_SUPPLY_IADC_MIN_OVER_CURRENT;
000BD6  20FA04     MOV #0xFA0, W4
000BD8  885854     MOV W4, 0xB0A
756:                 ps_filament.i_adc_max_oor        = FILAMENT_SUPPLY_IADC_MAX_OUT_OT_RANGE;
000BDA  200C84     MOV #0xC8, W4
000BDC  885864     MOV W4, 0xB0C
757:               
758:                 SetPowerSupplyTarget(&ps_filament, ps_filament_config_ram_copy[EEPROM_V_SET_POINT], ps_filament_config_ram_copy[EEPROM_I_SET_POINT]);
000BDE  80B894     MOV 0x1712, W4
000BE0  780284     MOV W4, W5
000BE2  80B844     MOV ps_filament_config_ram_copy, W4
000BE4  780105     MOV W5, W2
000BE6  780084     MOV W4, W1
000BE8  20ABC0     MOV #0xABC, W0
000BEA  070461     RCALL SetPowerSupplyTarget
759:                 
760:               
761:               
762:                 // --- ps_thyr_cathode_htr initialization ---
763:               
764:                 ps_thyr_cathode_htr.warmup_ramp_time     = THYR_CATH_HTR_SUPPLY_WARMUP_RAMP_TIME;
000BEC  207084     MOV #0x708, W4
000BEE  8858B4     MOV W4, ps_thyr_cathode_htr
765:                 
766:                 ps_thyr_cathode_htr.v_max_set_point      = MAX_THYR_CATH_HTR_SUPPLY_VOLTAGE_SET_POINT;
000BF0  21A2C4     MOV #0x1A2C, W4
000BF2  8858E4     MOV W4, 0xB1C
767:                 
768:                 ps_thyr_cathode_htr.v_dac_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
000BF4  EB0080     CLR W1
000BF6  EB8000     SETM W0
000BF8  070B2B     RCALL MakeScale
000BFA  780200     MOV W0, W4
000BFC  885904     MOV W4, 0xB20
769:                 ps_thyr_cathode_htr.v_dac_cal_gain       = ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000BFE  80B974     MOV 0x172E, W4
000C00  885914     MOV W4, 0xB22
770:                 ps_thyr_cathode_htr.v_dac_cal_offset     = ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000C02  80B984     MOV 0x1730, W4
000C04  885924     MOV W4, 0xB24
771:                 
772:                 ps_thyr_cathode_htr.v_adc_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_VADC_INPUT_AT_0xFFFF);
000C06  295E21     MOV #0x95E2, W1
000C08  EB8000     SETM W0
000C0A  070B22     RCALL MakeScale
000C0C  780200     MOV W0, W4
000C0E  885944     MOV W4, 0xB28
773:                 ps_thyr_cathode_htr.v_adc_cal_gain       = ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000C10  80B994     MOV 0x1732, W4
000C12  885954     MOV W4, 0xB2A
774:                 ps_thyr_cathode_htr.v_adc_cal_offset     = ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000C14  80B9A4     MOV 0x1734, W4
000C16  885964     MOV W4, 0xB2C
775:                 ps_thyr_cathode_htr.v_adc_over_abs       = Scale16Bit(THYR_CATH_HTR_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_thyr_cathode_htr.v_adc_scale);
000C18  805944     MOV 0xB28, W4
000C1A  780084     MOV W4, W1
000C1C  21C200     MOV #0x1C20, W0
000C1E  070B53     RCALL Scale16Bit
000C20  780200     MOV W0, W4
000C22  885974     MOV W4, 0xB2E
776:                 ps_thyr_cathode_htr.v_adc_over_scale     = MakeScale(THYR_CATH_HTR_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000C24  220001     MOV #0x2000, W1
000C26  221990     MOV #0x2199, W0
000C28  070B13     RCALL MakeScale
000C2A  780200     MOV W0, W4
000C2C  8859A4     MOV W4, 0xB34
777:                 ps_thyr_cathode_htr.v_adc_under_scale    = MakeScale(THYR_CATH_HTR_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000C2E  220001     MOV #0x2000, W1
000C30  21E660     MOV #0x1E66, W0
000C32  070B0E     RCALL MakeScale
000C34  780200     MOV W0, W4
000C36  8859B4     MOV W4, 0xB36
778:                 ps_thyr_cathode_htr.v_adc_over_min_value = THYR_CATH_HTR_SUPPLY_VADC_MIN_OVER_VOLTAGE;
000C38  203E84     MOV #0x3E8, W4
000C3A  8859C4     MOV W4, 0xB38
779:                 ps_thyr_cathode_htr.v_adc_max_oor        = THYR_CATH_HTR_SUPPLY_VADC_MAX_OUT_OT_RANGE;
000C3C  201F44     MOV #0x1F4, W4
000C3E  8859D4     MOV W4, 0xB3A
780:                 
781:                 ps_thyr_cathode_htr.i_max_set_point      = MAX_THYR_CATH_HTR_SUPPLY_CURRENT_SET_POINT;
000C40  EB0200     CLR W4
000C42  885A44     MOV W4, 0xB48
782:                 
783:                 ps_thyr_cathode_htr.i_dac_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
000C44  EB0080     CLR W1
000C46  EB8000     SETM W0
000C48  070B03     RCALL MakeScale
000C4A  780200     MOV W0, W4
000C4C  885A64     MOV W4, 0xB4C
784:                 ps_thyr_cathode_htr.i_dac_cal_gain       = ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000C4E  80B9C4     MOV 0x1738, W4
000C50  885A74     MOV W4, 0xB4E
785:                 ps_thyr_cathode_htr.i_dac_cal_offset     = ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000C52  80B9D4     MOV 0x173A, W4
000C54  885A84     MOV W4, 0xB50
786:                 
787:                 ps_thyr_cathode_htr.i_adc_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_IADC_INPUT_AT_0xFFFF);
000C56  EB0080     CLR W1
000C58  EB8000     SETM W0
000C5A  070AFA     RCALL MakeScale
000C5C  780200     MOV W0, W4
000C5E  885AA4     MOV W4, 0xB54
788:                 ps_thyr_cathode_htr.i_adc_cal_gain       = ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000C60  80B9E4     MOV 0x173C, W4
000C62  885AB4     MOV W4, 0xB56
789:                 ps_thyr_cathode_htr.i_adc_cal_offset     = ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000C64  80B9F4     MOV 0x173E, W4
000C66  885AC4     MOV W4, 0xB58
790:                 ps_thyr_cathode_htr.i_adc_over_abs       = Scale16Bit(THYR_CATH_HTR_SUPPLY_IADC_OVER_CURRENT_HARD, ps_thyr_cathode_htr.i_adc_scale);
000C68  805AA4     MOV 0xB54, W4
000C6A  780084     MOV W4, W1
000C6C  EB0000     CLR W0
000C6E  070B2B     RCALL Scale16Bit
000C70  780200     MOV W0, W4
000C72  885AD4     MOV W4, 0xB5A
791:                 ps_thyr_cathode_htr.i_adc_over_scale     = MakeScale(THYR_CATH_HTR_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
000C74  220001     MOV #0x2000, W1
000C76  EB0000     CLR W0
000C78  070AEB     RCALL MakeScale
000C7A  780200     MOV W0, W4
000C7C  885B04     MOV W4, 0xB60
792:                 ps_thyr_cathode_htr.i_adc_under_scale    = MakeScale(THYR_CATH_HTR_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000C7E  220001     MOV #0x2000, W1
000C80  EB0000     CLR W0
000C82  070AE6     RCALL MakeScale
000C84  780200     MOV W0, W4
000C86  885B14     MOV W4, 0xB62
793:                 ps_thyr_cathode_htr.i_adc_over_min_value = THYR_CATH_HTR_SUPPLY_IADC_MIN_OVER_CURRENT;
000C88  EB0200     CLR W4
000C8A  885B24     MOV W4, 0xB64
794:                 ps_thyr_cathode_htr.i_adc_max_oor        = THYR_CATH_HTR_SUPPLY_IADC_MAX_OUT_OT_RANGE;
000C8C  EB0200     CLR W4
000C8E  885B34     MOV W4, 0xB66
795:               
796:                 SetPowerSupplyTarget(&ps_thyr_cathode_htr, ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_SET_POINT], ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_SET_POINT]);
000C90  80B9B4     MOV 0x1736, W4
000C92  780284     MOV W4, W5
000C94  80B964     MOV ps_thyr_cathode_htr_config_ram_copy, W4
000C96  780105     MOV W5, W2
000C98  780084     MOV W4, W1
000C9A  20B160     MOV #0xB16, W0
000C9C  070408     RCALL SetPowerSupplyTarget
797:                 
798:               
799:               
800:                 // --- ps_thyr_reservoir_htr initialization ---
801:               
802:                 ps_thyr_reservoir_htr.warmup_ramp_time     = THYR_RESER_HTR_SUPPLY_WARMUP_RAMP_TIME;
000C9E  207084     MOV #0x708, W4
000CA0  885B84     MOV W4, ps_thyr_reservoir_htr
803:                 
804:                 ps_thyr_reservoir_htr.v_max_set_point      = MAX_THYR_RESER_HTR_SUPPLY_VOLTAGE_SET_POINT;
000CA2  217704     MOV #0x1770, W4
000CA4  885BB4     MOV W4, 0xB76
805:                 
806:                 ps_thyr_reservoir_htr.v_dac_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
000CA6  EB0080     CLR W1
000CA8  EB8000     SETM W0
000CAA  070AD2     RCALL MakeScale
000CAC  780200     MOV W0, W4
000CAE  885BD4     MOV W4, 0xB7A
807:                 ps_thyr_reservoir_htr.v_dac_cal_gain       = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000CB0  80BA94     MOV 0x1752, W4
000CB2  885BE4     MOV W4, 0xB7C
808:                 ps_thyr_reservoir_htr.v_dac_cal_offset     = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000CB4  80BAA4     MOV 0x1754, W4
000CB6  885BF4     MOV W4, 0xB7E
809:                 
810:                 ps_thyr_reservoir_htr.v_adc_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_VADC_INPUT_AT_0xFFFF);
000CB8  295E21     MOV #0x95E2, W1
000CBA  EB8000     SETM W0
000CBC  070AC9     RCALL MakeScale
000CBE  780200     MOV W0, W4
000CC0  885C14     MOV W4, 0xB82
811:                 ps_thyr_reservoir_htr.v_adc_cal_gain       = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000CC2  80BAB4     MOV 0x1756, W4
000CC4  885C24     MOV W4, 0xB84
812:                 ps_thyr_reservoir_htr.v_adc_cal_offset     = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000CC6  80BAC4     MOV 0x1758, W4
000CC8  885C34     MOV W4, 0xB86
813:                 ps_thyr_reservoir_htr.v_adc_over_abs       = Scale16Bit(THYR_RESER_HTR_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_thyr_reservoir_htr.v_adc_scale);
000CCA  805C14     MOV 0xB82, W4
000CCC  780084     MOV W4, W1
000CCE  2186A0     MOV #0x186A, W0
000CD0  070AFA     RCALL Scale16Bit
000CD2  780200     MOV W0, W4
000CD4  885C44     MOV W4, 0xB88
814:                 ps_thyr_reservoir_htr.v_adc_over_scale     = MakeScale(THYR_RESER_HTR_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000CD6  220001     MOV #0x2000, W1
000CD8  221990     MOV #0x2199, W0
000CDA  070ABA     RCALL MakeScale
000CDC  780200     MOV W0, W4
000CDE  885C74     MOV W4, 0xB8E
815:                 ps_thyr_reservoir_htr.v_adc_under_scale    = MakeScale(THYR_RESER_HTR_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000CE0  220001     MOV #0x2000, W1
000CE2  21E660     MOV #0x1E66, W0
000CE4  070AB5     RCALL MakeScale
000CE6  780200     MOV W0, W4
000CE8  885C84     MOV W4, 0xB90
816:                 ps_thyr_reservoir_htr.v_adc_over_min_value = THYR_RESER_HTR_SUPPLY_VADC_MIN_OVER_VOLTAGE;
000CEA  203E84     MOV #0x3E8, W4
000CEC  885C94     MOV W4, 0xB92
817:                 ps_thyr_reservoir_htr.v_adc_max_oor        = THYR_RESER_HTR_SUPPLY_VADC_MAX_OUT_OT_RANGE;
000CEE  201F44     MOV #0x1F4, W4
000CF0  885CA4     MOV W4, 0xB94
818:                 
819:                 ps_thyr_reservoir_htr.i_max_set_point      = MAX_THYR_RESER_HTR_SUPPLY_CURRENT_SET_POINT;
000CF2  EB0200     CLR W4
000CF4  885D14     MOV W4, 0xBA2
820:                 
821:                 ps_thyr_reservoir_htr.i_dac_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
000CF6  EB0080     CLR W1
000CF8  EB8000     SETM W0
000CFA  070AAA     RCALL MakeScale
000CFC  780200     MOV W0, W4
000CFE  885D34     MOV W4, 0xBA6
822:                 ps_thyr_reservoir_htr.i_dac_cal_gain       = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000D00  80BAE4     MOV 0x175C, W4
000D02  885D44     MOV W4, 0xBA8
823:                 ps_thyr_reservoir_htr.i_dac_cal_offset     = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000D04  80BAF4     MOV 0x175E, W4
000D06  885D54     MOV W4, 0xBAA
824:                 
825:                 ps_thyr_reservoir_htr.i_adc_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_IADC_INPUT_AT_0xFFFF);
000D08  EB0080     CLR W1
000D0A  EB8000     SETM W0
000D0C  070AA1     RCALL MakeScale
000D0E  780200     MOV W0, W4
000D10  885D74     MOV W4, 0xBAE
826:                 ps_thyr_reservoir_htr.i_adc_cal_gain       = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000D12  80BB04     MOV 0x1760, W4
000D14  885D84     MOV W4, 0xBB0
827:                 ps_thyr_reservoir_htr.i_adc_cal_offset     = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000D16  80BB14     MOV 0x1762, W4
000D18  885D94     MOV W4, 0xBB2
828:                 ps_thyr_reservoir_htr.i_adc_over_abs       = Scale16Bit(THYR_RESER_HTR_SUPPLY_IADC_OVER_CURRENT_HARD, ps_thyr_reservoir_htr.i_adc_scale);
000D1A  805D74     MOV 0xBAE, W4
000D1C  780084     MOV W4, W1
000D1E  EB0000     CLR W0
000D20  070AD2     RCALL Scale16Bit
000D22  780200     MOV W0, W4
000D24  885DA4     MOV W4, 0xBB4
829:                 ps_thyr_reservoir_htr.i_adc_over_scale     = MakeScale(THYR_RESER_HTR_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
000D26  220001     MOV #0x2000, W1
000D28  EB0000     CLR W0
000D2A  070A92     RCALL MakeScale
000D2C  780200     MOV W0, W4
000D2E  885DD4     MOV W4, 0xBBA
830:                 ps_thyr_reservoir_htr.i_adc_under_scale    = MakeScale(THYR_RESER_HTR_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000D30  220001     MOV #0x2000, W1
000D32  EB0000     CLR W0
000D34  070A8D     RCALL MakeScale
000D36  780200     MOV W0, W4
000D38  885DE4     MOV W4, 0xBBC
831:                 ps_thyr_reservoir_htr.i_adc_over_min_value = THYR_RESER_HTR_SUPPLY_IADC_MIN_OVER_CURRENT;
000D3A  EB0200     CLR W4
000D3C  885DF4     MOV W4, 0xBBE
832:                 ps_thyr_reservoir_htr.i_adc_max_oor        = THYR_RESER_HTR_SUPPLY_IADC_MAX_OUT_OT_RANGE;
000D3E  EB0200     CLR W4
000D40  885E04     MOV W4, 0xBC0
833:               
834:                 SetPowerSupplyTarget(&ps_thyr_reservoir_htr, ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_SET_POINT], ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_SET_POINT]);
000D42  80BAD4     MOV 0x175A, W4
000D44  780284     MOV W4, W5
000D46  80BA84     MOV ps_thyr_reservoir_htr_config_ram_copy, W4
000D48  780105     MOV W5, W2
000D4A  780084     MOV W4, W1
000D4C  20B700     MOV #0xB70, W0
000D4E  0703AF     RCALL SetPowerSupplyTarget
835:                 
836:               
837:               
838:                 // --- ps_hv_lambda_mode_A initialization ---
839:               
840:                 ps_hv_lambda_mode_A.warmup_ramp_time     = HV_LAMBDA_MODE_A_WARMUP_RAMP_TIME;
000D50  EB0200     CLR W4
000D52  8847D4     MOV W4, ps_hv_lambda_mode_A
841:                 
842:                 ps_hv_lambda_mode_A.v_max_set_point      = MAX_HV_LAMBDA_MODE_A_VOLTAGE_SET_POINT;
000D54  24E204     MOV #0x4E20, W4
000D56  884804     MOV W4, 0x900
843:                 
844:                 ps_hv_lambda_mode_A.v_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_VDAC_OUTPUT_AT_0xFFFF);
000D58  257151     MOV #0x5715, W1
000D5A  EB8000     SETM W0
000D5C  070A79     RCALL MakeScale
000D5E  780200     MOV W0, W4
000D60  884824     MOV W4, 0x904
845:                 ps_hv_lambda_mode_A.v_dac_cal_gain       = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000D62  80BBB4     MOV 0x1776, W4
000D64  884834     MOV W4, 0x906
846:                 ps_hv_lambda_mode_A.v_dac_cal_offset     = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000D66  80BBC4     MOV 0x1778, W4
000D68  884844     MOV W4, 0x908
847:                 
848:                 ps_hv_lambda_mode_A.v_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_VADC_INPUT_AT_0xFFFF);
000D6A  261A81     MOV #0x61A8, W1
000D6C  EB8000     SETM W0
000D6E  070A70     RCALL MakeScale
000D70  780200     MOV W0, W4
000D72  884864     MOV W4, 0x90C
849:                 ps_hv_lambda_mode_A.v_adc_cal_gain       = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000D74  80BBD4     MOV 0x177A, W4
000D76  884874     MOV W4, 0x90E
850:                 ps_hv_lambda_mode_A.v_adc_cal_offset     = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000D78  80BBE4     MOV 0x177C, W4
000D7A  884884     MOV W4, 0x910
851:                 ps_hv_lambda_mode_A.v_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_A_VADC_OVER_VOLTAGE_HARD, ps_hv_lambda_mode_A.v_adc_scale);
000D7C  804864     MOV 0x90C, W4
000D7E  780084     MOV W4, W1
000D80  24C2C0     MOV #0x4C2C, W0
000D82  070AA1     RCALL Scale16Bit
000D84  780200     MOV W0, W4
000D86  884894     MOV W4, 0x912
852:                 ps_hv_lambda_mode_A.v_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_A_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000D88  220001     MOV #0x2000, W1
000D8A  EB0000     CLR W0
000D8C  070A61     RCALL MakeScale
000D8E  780200     MOV W0, W4
000D90  8848C4     MOV W4, 0x918
853:                 ps_hv_lambda_mode_A.v_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_A_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000D92  220001     MOV #0x2000, W1
000D94  EB0000     CLR W0
000D96  070A5C     RCALL MakeScale
000D98  780200     MOV W0, W4
000D9A  8848D4     MOV W4, 0x91A
854:                 ps_hv_lambda_mode_A.v_adc_over_min_value = HV_LAMBDA_MODE_A_VADC_MIN_OVER_VOLTAGE;
000D9C  EB0200     CLR W4
000D9E  8848E4     MOV W4, 0x91C
855:                 ps_hv_lambda_mode_A.v_adc_max_oor        = HV_LAMBDA_MODE_A_VADC_MAX_OUT_OT_RANGE;
000DA0  EB0200     CLR W4
000DA2  8848F4     MOV W4, 0x91E
856:                 
857:                 ps_hv_lambda_mode_A.i_max_set_point      = MAX_HV_LAMBDA_MODE_A_CURRENT_SET_POINT;
000DA4  EB0200     CLR W4
000DA6  884964     MOV W4, 0x92C
858:                 
859:                 ps_hv_lambda_mode_A.i_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_IDAC_OUTPUT_AT_0xFFFF);
000DA8  EB0080     CLR W1
000DAA  EB8000     SETM W0
000DAC  070A51     RCALL MakeScale
000DAE  780200     MOV W0, W4
000DB0  884984     MOV W4, 0x930
860:                 ps_hv_lambda_mode_A.i_dac_cal_gain       = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000DB2  80BC04     MOV 0x1780, W4
000DB4  884994     MOV W4, 0x932
861:                 ps_hv_lambda_mode_A.i_dac_cal_offset     = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000DB6  80BC14     MOV 0x1782, W4
000DB8  8849A4     MOV W4, 0x934
862:                 
863:                 ps_hv_lambda_mode_A.i_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_IADC_INPUT_AT_0xFFFF);
000DBA  EB0080     CLR W1
000DBC  EB8000     SETM W0
000DBE  070A48     RCALL MakeScale
000DC0  780200     MOV W0, W4
000DC2  8849C4     MOV W4, 0x938
864:                 ps_hv_lambda_mode_A.i_adc_cal_gain       = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000DC4  80BC24     MOV 0x1784, W4
000DC6  8849D4     MOV W4, 0x93A
865:                 ps_hv_lambda_mode_A.i_adc_cal_offset     = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000DC8  80BC34     MOV 0x1786, W4
000DCA  8849E4     MOV W4, 0x93C
866:                 ps_hv_lambda_mode_A.i_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_A_IADC_OVER_CURRENT_HARD, ps_hv_lambda_mode_A.i_adc_scale);
000DCC  8049C4     MOV 0x938, W4
000DCE  780084     MOV W4, W1
000DD0  EB0000     CLR W0
000DD2  070A79     RCALL Scale16Bit
000DD4  780200     MOV W0, W4
000DD6  8849F4     MOV W4, 0x93E
867:                 ps_hv_lambda_mode_A.i_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_A_IADC_OVER_CURRENT_SCALE*8192, 8192);
000DD8  220001     MOV #0x2000, W1
000DDA  EB0000     CLR W0
000DDC  070A39     RCALL MakeScale
000DDE  780200     MOV W0, W4
000DE0  884A24     MOV W4, 0x944
868:                 ps_hv_lambda_mode_A.i_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_A_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000DE2  220001     MOV #0x2000, W1
000DE4  EB0000     CLR W0
000DE6  070A34     RCALL MakeScale
000DE8  780200     MOV W0, W4
000DEA  884A34     MOV W4, 0x946
869:                 ps_hv_lambda_mode_A.i_adc_over_min_value = HV_LAMBDA_MODE_A_IADC_MIN_OVER_CURRENT;
000DEC  EB0200     CLR W4
000DEE  884A44     MOV W4, 0x948
870:                 ps_hv_lambda_mode_A.i_adc_max_oor        = HV_LAMBDA_MODE_A_IADC_MAX_OUT_OT_RANGE;
000DF0  EB0200     CLR W4
000DF2  884A54     MOV W4, 0x94A
871:               
872:                 SetPowerSupplyTarget(&ps_hv_lambda_mode_A, ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_SET_POINT], ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_SET_POINT]);
000DF4  80BBF4     MOV 0x177E, W4
000DF6  780284     MOV W4, W5
000DF8  80BBA4     MOV ps_hv_lambda_mode_A_config_ram_copy, W4
000DFA  780105     MOV W5, W2
000DFC  780084     MOV W4, W1
000DFE  208FA0     MOV #0x8FA, W0
000E00  070356     RCALL SetPowerSupplyTarget
873:                 
874:               
875:               
876:                 // --- ps_hv_lambda_mode_B initialization ---
877:               
878:                 ps_hv_lambda_mode_B.warmup_ramp_time     = HV_LAMBDA_MODE_B_WARMUP_RAMP_TIME;
000E02  EB0200     CLR W4
000E04  884D74     MOV W4, ps_hv_lambda_mode_B
879:                 
880:                 ps_hv_lambda_mode_B.v_max_set_point      = MAX_HV_LAMBDA_MODE_B_VOLTAGE_SET_POINT;
000E06  24E204     MOV #0x4E20, W4
000E08  884DA4     MOV W4, 0x9B4
881:                 
882:                 ps_hv_lambda_mode_B.v_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_VDAC_OUTPUT_AT_0xFFFF);
000E0A  257151     MOV #0x5715, W1
000E0C  EB8000     SETM W0
000E0E  070A20     RCALL MakeScale
000E10  780200     MOV W0, W4
000E12  884DC4     MOV W4, 0x9B8
883:                 ps_hv_lambda_mode_B.v_dac_cal_gain       = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000E14  80BCD4     MOV 0x179A, W4
000E16  884DD4     MOV W4, 0x9BA
884:                 ps_hv_lambda_mode_B.v_dac_cal_offset     = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000E18  80BCE4     MOV 0x179C, W4
000E1A  884DE4     MOV W4, 0x9BC
885:                 
886:                 ps_hv_lambda_mode_B.v_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_VADC_INPUT_AT_0xFFFF);
000E1C  261A81     MOV #0x61A8, W1
000E1E  EB8000     SETM W0
000E20  070A17     RCALL MakeScale
000E22  780200     MOV W0, W4
000E24  884E04     MOV W4, 0x9C0
887:                 ps_hv_lambda_mode_B.v_adc_cal_gain       = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000E26  80BCF4     MOV 0x179E, W4
000E28  884E14     MOV W4, 0x9C2
888:                 ps_hv_lambda_mode_B.v_adc_cal_offset     = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000E2A  80BD04     MOV 0x17A0, W4
000E2C  884E24     MOV W4, 0x9C4
889:                 ps_hv_lambda_mode_B.v_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_B_VADC_OVER_VOLTAGE_HARD, ps_hv_lambda_mode_B.v_adc_scale);
000E2E  804E04     MOV 0x9C0, W4
000E30  780084     MOV W4, W1
000E32  24C2C0     MOV #0x4C2C, W0
000E34  070A48     RCALL Scale16Bit
000E36  780200     MOV W0, W4
000E38  884E34     MOV W4, 0x9C6
890:                 ps_hv_lambda_mode_B.v_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_B_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000E3A  220001     MOV #0x2000, W1
000E3C  EB0000     CLR W0
000E3E  070A08     RCALL MakeScale
000E40  780200     MOV W0, W4
000E42  884E64     MOV W4, 0x9CC
891:                 ps_hv_lambda_mode_B.v_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_B_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000E44  220001     MOV #0x2000, W1
000E46  EB0000     CLR W0
000E48  070A03     RCALL MakeScale
000E4A  780200     MOV W0, W4
000E4C  884E74     MOV W4, 0x9CE
892:                 ps_hv_lambda_mode_B.v_adc_over_min_value = HV_LAMBDA_MODE_B_VADC_MIN_OVER_VOLTAGE;
000E4E  EB0200     CLR W4
000E50  884E84     MOV W4, 0x9D0
893:                 ps_hv_lambda_mode_B.v_adc_max_oor        = HV_LAMBDA_MODE_B_VADC_MAX_OUT_OT_RANGE;
000E52  EB0200     CLR W4
000E54  884E94     MOV W4, 0x9D2
894:                 
895:                 ps_hv_lambda_mode_B.i_max_set_point      = MAX_HV_LAMBDA_MODE_B_CURRENT_SET_POINT;
000E56  EB0200     CLR W4
000E58  884F04     MOV W4, 0x9E0
896:                 
897:                 ps_hv_lambda_mode_B.i_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_IDAC_OUTPUT_AT_0xFFFF);
000E5A  EB0080     CLR W1
000E5C  EB8000     SETM W0
000E5E  0709F8     RCALL MakeScale
000E60  780200     MOV W0, W4
000E62  884F24     MOV W4, 0x9E4
898:                 ps_hv_lambda_mode_B.i_dac_cal_gain       = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000E64  80BD24     MOV 0x17A4, W4
000E66  884F34     MOV W4, 0x9E6
899:                 ps_hv_lambda_mode_B.i_dac_cal_offset     = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000E68  80BD34     MOV 0x17A6, W4
000E6A  884F44     MOV W4, 0x9E8
900:                 
901:                 ps_hv_lambda_mode_B.i_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_IADC_INPUT_AT_0xFFFF);
000E6C  EB0080     CLR W1
000E6E  EB8000     SETM W0
000E70  0709EF     RCALL MakeScale
000E72  780200     MOV W0, W4
000E74  884F64     MOV W4, 0x9EC
902:                 ps_hv_lambda_mode_B.i_adc_cal_gain       = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000E76  80BD44     MOV 0x17A8, W4
000E78  884F74     MOV W4, 0x9EE
903:                 ps_hv_lambda_mode_B.i_adc_cal_offset     = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000E7A  80BD54     MOV 0x17AA, W4
000E7C  884F84     MOV W4, 0x9F0
904:                 ps_hv_lambda_mode_B.i_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_B_IADC_OVER_CURRENT_HARD, ps_hv_lambda_mode_B.i_adc_scale);
000E7E  804F64     MOV 0x9EC, W4
000E80  780084     MOV W4, W1
000E82  EB0000     CLR W0
000E84  070A20     RCALL Scale16Bit
000E86  780200     MOV W0, W4
000E88  884F94     MOV W4, 0x9F2
905:                 ps_hv_lambda_mode_B.i_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_B_IADC_OVER_CURRENT_SCALE*8192, 8192);
000E8A  220001     MOV #0x2000, W1
000E8C  EB0000     CLR W0
000E8E  0709E0     RCALL MakeScale
000E90  780200     MOV W0, W4
000E92  884FC4     MOV W4, 0x9F8
906:                 ps_hv_lambda_mode_B.i_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_B_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000E94  220001     MOV #0x2000, W1
000E96  EB0000     CLR W0
000E98  0709DB     RCALL MakeScale
000E9A  780200     MOV W0, W4
000E9C  884FD4     MOV W4, 0x9FA
907:                 ps_hv_lambda_mode_B.i_adc_over_min_value = HV_LAMBDA_MODE_B_IADC_MIN_OVER_CURRENT;
000E9E  EB0200     CLR W4
000EA0  884FE4     MOV W4, 0x9FC
908:                 ps_hv_lambda_mode_B.i_adc_max_oor        = HV_LAMBDA_MODE_B_IADC_MAX_OUT_OT_RANGE;
000EA2  EB0200     CLR W4
000EA4  884FF4     MOV W4, 0x9FE
909:               
910:               
911:                 SetPowerSupplyTarget(&ps_hv_lambda_mode_B, ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_SET_POINT], ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_SET_POINT]);
000EA6  80BD14     MOV 0x17A2, W4
000EA8  780284     MOV W4, W5
000EAA  80BCC4     MOV ps_hv_lambda_mode_B_config_ram_copy, W4
000EAC  780105     MOV W5, W2
000EAE  780084     MOV W4, W1
000EB0  209AE0     MOV #0x9AE, W0
000EB2  0702FD     RCALL SetPowerSupplyTarget
912:                 
913:               
914:               
915:                 // --- ps_magnetron_mode_A initialization ---
916:               
917:                 ps_magnetron_mode_A.warmup_ramp_time     = MAGNETRON_MODE_A_WARMUP_RAMP_TIME;
000EB4  EB0200     CLR W4
000EB6  884AA4     MOV W4, ps_magnetron_mode_A
918:                 
919:                 ps_magnetron_mode_A.v_max_set_point      = MAX_MAGNETRON_MODE_A_VOLTAGE_SET_POINT;
000EB8  2D6D84     MOV #0xD6D8, W4
000EBA  884AD4     MOV W4, 0x95A
920:                 
921:                 ps_magnetron_mode_A.v_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_VDAC_OUTPUT_AT_0xFFFF);
000EBC  EB0080     CLR W1
000EBE  EB8000     SETM W0
000EC0  0709C7     RCALL MakeScale
000EC2  780200     MOV W0, W4
000EC4  884AF4     MOV W4, 0x95E
922:                 ps_magnetron_mode_A.v_dac_cal_gain       = ps_magnetron_mode_A_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000EC6  80BDF4     MOV 0x17BE, W4
000EC8  884B04     MOV W4, 0x960
923:                 ps_magnetron_mode_A.v_dac_cal_offset     = ps_magnetron_mode_A_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000ECA  80BE04     MOV 0x17C0, W4
000ECC  884B14     MOV W4, 0x962
924:                 
925:                 ps_magnetron_mode_A.v_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_VADC_INPUT_AT_0xFFFF);
000ECE  2D8A11     MOV #0xD8A1, W1
000ED0  EB8000     SETM W0
000ED2  0709BE     RCALL MakeScale
000ED4  780200     MOV W0, W4
000ED6  884B34     MOV W4, 0x966
926:                 ps_magnetron_mode_A.v_adc_cal_gain       = ps_magnetron_mode_A_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000ED8  80BE14     MOV 0x17C2, W4
000EDA  884B44     MOV W4, 0x968
927:                 ps_magnetron_mode_A.v_adc_cal_offset     = ps_magnetron_mode_A_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000EDC  80BE24     MOV 0x17C4, W4
000EDE  884B54     MOV W4, 0x96A
928:                 ps_magnetron_mode_A.v_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_A_VADC_OVER_VOLTAGE_HARD, ps_magnetron_mode_A.v_adc_scale);
000EE0  804B34     MOV 0x966, W4
000EE2  780084     MOV W4, W1
000EE4  2CB200     MOV #0xCB20, W0
000EE6  0709EF     RCALL Scale16Bit
000EE8  780200     MOV W0, W4
000EEA  884B64     MOV W4, 0x96C
929:                 ps_magnetron_mode_A.v_adc_over_scale     = MakeScale(MAGNETRON_MODE_A_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000EEC  220001     MOV #0x2000, W1
000EEE  228000     MOV #0x2800, W0
000EF0  0709AF     RCALL MakeScale
000EF2  780200     MOV W0, W4
000EF4  884B94     MOV W4, 0x972
930:                 ps_magnetron_mode_A.v_adc_under_scale    = MakeScale(MAGNETRON_MODE_A_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000EF6  220001     MOV #0x2000, W1
000EF8  219990     MOV #0x1999, W0
000EFA  0709AA     RCALL MakeScale
000EFC  780200     MOV W0, W4
000EFE  884BA4     MOV W4, 0x974
931:                 ps_magnetron_mode_A.v_adc_over_min_value = MAGNETRON_MODE_A_VADC_MIN_OVER_VOLTAGE;
000F00  203E84     MOV #0x3E8, W4
000F02  884BB4     MOV W4, 0x976
932:                 ps_magnetron_mode_A.v_adc_max_oor        = MAGNETRON_MODE_A_VADC_MAX_OUT_OT_RANGE;
000F04  200144     MOV #0x14, W4
000F06  884BC4     MOV W4, 0x978
933:                 
934:                 ps_magnetron_mode_A.i_max_set_point      = MAX_MAGNETRON_MODE_A_CURRENT_SET_POINT;
000F08  22CEC4     MOV #0x2CEC, W4
000F0A  884C34     MOV W4, 0x986
935:                 
936:                 ps_magnetron_mode_A.i_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_IDAC_OUTPUT_AT_0xFFFF);
000F0C  EB0080     CLR W1
000F0E  EB8000     SETM W0
000F10  07099F     RCALL MakeScale
000F12  780200     MOV W0, W4
000F14  884C54     MOV W4, 0x98A
937:                 ps_magnetron_mode_A.i_dac_cal_gain       = ps_magnetron_mode_A_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000F16  80BE44     MOV 0x17C8, W4
000F18  884C64     MOV W4, 0x98C
938:                 ps_magnetron_mode_A.i_dac_cal_offset     = ps_magnetron_mode_A_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000F1A  80BE54     MOV 0x17CA, W4
000F1C  884C74     MOV W4, 0x98E
939:                 
940:                 ps_magnetron_mode_A.i_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_IADC_INPUT_AT_0xFFFF);
000F1E  2411B1     MOV #0x411B, W1
000F20  EB8000     SETM W0
000F22  070996     RCALL MakeScale
000F24  780200     MOV W0, W4
000F26  884C94     MOV W4, 0x992
941:                 ps_magnetron_mode_A.i_adc_cal_gain       = ps_magnetron_mode_A_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000F28  80BE64     MOV 0x17CC, W4
000F2A  884CA4     MOV W4, 0x994
942:                 ps_magnetron_mode_A.i_adc_cal_offset     = ps_magnetron_mode_A_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000F2C  80BE74     MOV 0x17CE, W4
000F2E  884CB4     MOV W4, 0x996
943:                 ps_magnetron_mode_A.i_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_A_IADC_OVER_CURRENT_HARD, ps_magnetron_mode_A.i_adc_scale);
000F30  804C94     MOV 0x992, W4
000F32  780084     MOV W4, W1
000F34  230D40     MOV #0x30D4, W0
000F36  0709C7     RCALL Scale16Bit
000F38  780200     MOV W0, W4
000F3A  884CC4     MOV W4, 0x998
944:                 ps_magnetron_mode_A.i_adc_over_scale     = MakeScale(MAGNETRON_MODE_A_IADC_OVER_CURRENT_SCALE*8192, 8192);
000F3C  220001     MOV #0x2000, W1
000F3E  221990     MOV #0x2199, W0
000F40  070987     RCALL MakeScale
000F42  780200     MOV W0, W4
000F44  884CF4     MOV W4, 0x99E
945:                 ps_magnetron_mode_A.i_adc_under_scale    = MakeScale(MAGNETRON_MODE_A_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000F46  220001     MOV #0x2000, W1
000F48  21E660     MOV #0x1E66, W0
000F4A  070982     RCALL MakeScale
000F4C  780200     MOV W0, W4
000F4E  884D04     MOV W4, 0x9A0
946:                 ps_magnetron_mode_A.i_adc_over_min_value = MAGNETRON_MODE_A_IADC_MIN_OVER_CURRENT;
000F50  203E84     MOV #0x3E8, W4
000F52  884D14     MOV W4, 0x9A2
947:                 ps_magnetron_mode_A.i_adc_max_oor        = MAGNETRON_MODE_A_IADC_MAX_OUT_OT_RANGE;
000F54  200144     MOV #0x14, W4
000F56  884D24     MOV W4, 0x9A4
948:               
949:                 ps_magnetron_mode_A.i_adc_max_reading    = 0;
000F58  EB0200     CLR W4
000F5A  884D54     MOV W4, 0x9AA
950:                 ps_magnetron_mode_A.i_adc_min_reading    = 0xFFFF;
000F5C  EB8200     SETM W4
000F5E  884D64     MOV W4, 0x9AC
951:                 ps_magnetron_mode_A.v_adc_max_reading    = 0;
000F60  EB0200     CLR W4
000F62  884BF4     MOV W4, 0x97E
952:                 ps_magnetron_mode_A.v_adc_min_reading    = 0xFFFF;
000F64  EB8200     SETM W4
000F66  884C04     MOV W4, 0x980
953:               
954:                 SetPowerSupplyTarget(&ps_magnetron_mode_A, ps_magnetron_mode_A_config_ram_copy[EEPROM_V_SET_POINT], ps_magnetron_mode_A_config_ram_copy[EEPROM_I_SET_POINT]);
000F68  80BE34     MOV 0x17C6, W4
000F6A  780284     MOV W4, W5
000F6C  80BDE4     MOV ps_magnetron_mode_A_config_ram_copy, W4
000F6E  780105     MOV W5, W2
000F70  780084     MOV W4, W1
000F72  209540     MOV #0x954, W0
000F74  07029C     RCALL SetPowerSupplyTarget
955:                 
956:               
957:               
958:                 // --- ps_magnetron_mode_B initialization ---
959:               
960:                 ps_magnetron_mode_B.warmup_ramp_time     = MAGNETRON_MODE_B_WARMUP_RAMP_TIME;
000F76  EB0200     CLR W4
000F78  885044     MOV W4, ps_magnetron_mode_B
961:                 
962:                 ps_magnetron_mode_B.v_max_set_point      = MAX_MAGNETRON_MODE_B_VOLTAGE_SET_POINT;
000F7A  2D6D84     MOV #0xD6D8, W4
000F7C  885074     MOV W4, 0xA0E
963:                 
964:                 ps_magnetron_mode_B.v_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_VDAC_OUTPUT_AT_0xFFFF);
000F7E  EB0080     CLR W1
000F80  EB8000     SETM W0
000F82  070966     RCALL MakeScale
000F84  780200     MOV W0, W4
000F86  885094     MOV W4, 0xA12
965:                 ps_magnetron_mode_B.v_dac_cal_gain       = ps_magnetron_mode_B_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000F88  80BF14     MOV 0x17E2, W4
000F8A  8850A4     MOV W4, 0xA14
966:                 ps_magnetron_mode_B.v_dac_cal_offset     = ps_magnetron_mode_B_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000F8C  80BF24     MOV 0x17E4, W4
000F8E  8850B4     MOV W4, 0xA16
967:                 
968:                 ps_magnetron_mode_B.v_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_VADC_INPUT_AT_0xFFFF);
000F90  2D8A11     MOV #0xD8A1, W1
000F92  EB8000     SETM W0
000F94  07095D     RCALL MakeScale
000F96  780200     MOV W0, W4
000F98  8850D4     MOV W4, 0xA1A
969:                 ps_magnetron_mode_B.v_adc_cal_gain       = ps_magnetron_mode_B_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000F9A  80BF34     MOV 0x17E6, W4
000F9C  8850E4     MOV W4, 0xA1C
970:                 ps_magnetron_mode_B.v_adc_cal_offset     = ps_magnetron_mode_B_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000F9E  80BF44     MOV 0x17E8, W4
000FA0  8850F4     MOV W4, 0xA1E
971:                 ps_magnetron_mode_B.v_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_B_VADC_OVER_VOLTAGE_HARD, ps_magnetron_mode_B.v_adc_scale);
000FA2  8050D4     MOV 0xA1A, W4
000FA4  780084     MOV W4, W1
000FA6  2CB200     MOV #0xCB20, W0
000FA8  07098E     RCALL Scale16Bit
000FAA  780200     MOV W0, W4
000FAC  885104     MOV W4, 0xA20
972:                 ps_magnetron_mode_B.v_adc_over_scale     = MakeScale(MAGNETRON_MODE_B_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000FAE  220001     MOV #0x2000, W1
000FB0  228000     MOV #0x2800, W0
000FB2  07094E     RCALL MakeScale
000FB4  780200     MOV W0, W4
000FB6  885134     MOV W4, 0xA26
973:                 ps_magnetron_mode_B.v_adc_under_scale    = MakeScale(MAGNETRON_MODE_B_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000FB8  220001     MOV #0x2000, W1
000FBA  219990     MOV #0x1999, W0
000FBC  070949     RCALL MakeScale
000FBE  780200     MOV W0, W4
000FC0  885144     MOV W4, 0xA28
974:                 ps_magnetron_mode_B.v_adc_over_min_value = MAGNETRON_MODE_B_VADC_MIN_OVER_VOLTAGE;
000FC2  203E84     MOV #0x3E8, W4
000FC4  885154     MOV W4, 0xA2A
975:                 ps_magnetron_mode_B.v_adc_max_oor        = MAGNETRON_MODE_B_VADC_MAX_OUT_OT_RANGE;
000FC6  200144     MOV #0x14, W4
000FC8  885164     MOV W4, 0xA2C
976:                 
977:                 ps_magnetron_mode_B.i_max_set_point      = MAX_MAGNETRON_MODE_B_CURRENT_SET_POINT;
000FCA  22CEC4     MOV #0x2CEC, W4
000FCC  8851D4     MOV W4, 0xA3A
978:                 
979:                 ps_magnetron_mode_B.i_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_IDAC_OUTPUT_AT_0xFFFF);
000FCE  EB0080     CLR W1
000FD0  EB8000     SETM W0
000FD2  07093E     RCALL MakeScale
000FD4  780200     MOV W0, W4
000FD6  8851F4     MOV W4, 0xA3E
980:                 ps_magnetron_mode_B.i_dac_cal_gain       = ps_magnetron_mode_B_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000FD8  80BF64     MOV 0x17EC, W4
000FDA  885204     MOV W4, 0xA40
981:                 ps_magnetron_mode_B.i_dac_cal_offset     = ps_magnetron_mode_B_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000FDC  80BF74     MOV 0x17EE, W4
000FDE  885214     MOV W4, 0xA42
982:                 
983:                 ps_magnetron_mode_B.i_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_IADC_INPUT_AT_0xFFFF);
000FE0  2411B1     MOV #0x411B, W1
000FE2  EB8000     SETM W0
000FE4  070935     RCALL MakeScale
000FE6  780200     MOV W0, W4
000FE8  885234     MOV W4, 0xA46
984:                 ps_magnetron_mode_B.i_adc_cal_gain       = ps_magnetron_mode_B_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000FEA  80BF84     MOV 0x17F0, W4
000FEC  885244     MOV W4, 0xA48
985:                 ps_magnetron_mode_B.i_adc_cal_offset     = ps_magnetron_mode_B_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000FEE  80BF94     MOV 0x17F2, W4
000FF0  885254     MOV W4, 0xA4A
986:                 ps_magnetron_mode_B.i_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_B_IADC_OVER_CURRENT_HARD, ps_magnetron_mode_B.i_adc_scale);
000FF2  805234     MOV 0xA46, W4
000FF4  780084     MOV W4, W1
000FF6  230D40     MOV #0x30D4, W0
000FF8  070966     RCALL Scale16Bit
000FFA  780200     MOV W0, W4
000FFC  885264     MOV W4, 0xA4C
987:                 ps_magnetron_mode_B.i_adc_over_scale     = MakeScale(MAGNETRON_MODE_B_IADC_OVER_CURRENT_SCALE*8192, 8192);
000FFE  220001     MOV #0x2000, W1
001000  221990     MOV #0x2199, W0
001002  070926     RCALL MakeScale
001004  780200     MOV W0, W4
001006  885294     MOV W4, 0xA52
988:                 ps_magnetron_mode_B.i_adc_under_scale    = MakeScale(MAGNETRON_MODE_B_IADC_UNDER_CURRENT_SCALE*8192, 8192);
001008  220001     MOV #0x2000, W1
00100A  21E660     MOV #0x1E66, W0
00100C  070921     RCALL MakeScale
00100E  780200     MOV W0, W4
001010  8852A4     MOV W4, 0xA54
989:                 ps_magnetron_mode_B.i_adc_over_min_value = MAGNETRON_MODE_B_IADC_MIN_OVER_CURRENT;
001012  203E84     MOV #0x3E8, W4
001014  8852B4     MOV W4, 0xA56
990:                 ps_magnetron_mode_B.i_adc_max_oor        = MAGNETRON_MODE_B_IADC_MAX_OUT_OT_RANGE;
001016  200144     MOV #0x14, W4
001018  8852C4     MOV W4, 0xA58
991:               
992:                 ps_magnetron_mode_B.i_adc_max_reading    = 0;
00101A  EB0200     CLR W4
00101C  8852F4     MOV W4, 0xA5E
993:                 ps_magnetron_mode_B.i_adc_min_reading    = 0xFFFF;
00101E  EB8200     SETM W4
001020  885304     MOV W4, 0xA60
994:                 ps_magnetron_mode_B.v_adc_max_reading    = 0;
001022  EB0200     CLR W4
001024  885194     MOV W4, 0xA32
995:                 ps_magnetron_mode_B.v_adc_min_reading    = 0xFFFF;
001026  EB8200     SETM W4
001028  8851A4     MOV W4, 0xA34
996:               
997:                 SetPowerSupplyTarget(&ps_magnetron_mode_B, ps_magnetron_mode_B_config_ram_copy[EEPROM_V_SET_POINT], ps_magnetron_mode_B_config_ram_copy[EEPROM_I_SET_POINT]);
00102A  80BF54     MOV 0x17EA, W4
00102C  780284     MOV W4, W5
00102E  80BF04     MOV ps_magnetron_mode_B_config_ram_copy, W4
001030  780105     MOV W5, W2
001032  780084     MOV W4, W1
001034  20A080     MOV #0xA08, W0
001036  07023B     RCALL SetPowerSupplyTarget
998:                 
999:               
1000:              
1001:                PIN_UART2_TX = !PIN_UART2_TX;
001038  801715     MOV LATF, W5
00103A  200204     MOV #0x20, W4
00103C  628204     AND W5, W4, W4
00103E  A7F004     BTSC W4, #15
001040  EA0204     NEG W4, W4
001042  E90204     DEC W4, W4
001044  DE224F     LSR W4, #15, W4
001046  784204     MOV.B W4, W4
001048  FB8204     ZE W4, W4
00104A  620261     AND W4, #0x1, W4
00104C  DD2245     SL W4, #5, W4
00104E  801716     MOV LATF, W6
001050  2FFDF5     MOV #0xFFDF, W5
001052  630285     AND W6, W5, W5
001054  728204     IOR W5, W4, W4
001056  881714     MOV W4, LATF
1002:              
1003:                // --------- BEGIN IO PIN CONFIGURATION ------------------
1004:                
1005:                
1006:                // Initialize Ouput Pin Latches BEFORE setting the pins to Output
1007:                PIN_HV_LAMBDA_ENABLE = !OLL_HV_LAMBDA_ENABLED;
001058  A962D7     BCLR 0x2D7, #3
1008:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;
00105A  A802D6     BSET LATD, #0
1009:              
1010:                //PIN_MAGNETRON_MAGNET_ENABLE = !OLL_MAGNETRON_MAGNET_ENABLED;
1011:                PIN_MAGNETRON_MAGNET_SO = OLL_MAGNETRON_MAGNET_OUTPUT_SHUT_OFF;
00105C  A942D7     BCLR 0x2D7, #2
1012:                PIN_MAGNETRON_FILAMENT_ENABLE = !OLL_MAGNETRON_FILAMENT_ENABLED;
00105E  A902D7     BCLR 0x2D7, #0
1013:                
1014:                PIN_SUM_FAULT_FIBER = !OLL_SUM_FAULT_FIBER_FAULT;
001060  A8E2C4     BSET LATA, #7
1015:                //DPARKER PIN REPURPOSED PIN_UART2_TX = !OLL_SPARE_OPTICAL_OUT_LIGHT_ON;
1016:                PIN_UART2_TX = !OLL_PIN_UART2_TX_LIGHT_ON;
001062  A9A2E2     BCLR LATF, #5
1017:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;
001064  A822C5     BSET 0x2C5, #1
1018:              
1019:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
001066  A9C2C4     BCLR LATA, #6
1020:                PIN_SUM_FAULT_COPPER = !OLL_SUM_FAULT_COPPER_FAULT;
001068  A842D0     BSET LATC, #2
1021:                PIN_LATCH_RESET = !OLL_RESET_LATCH;
00106A  A862D6     BSET LATD, #3
1022:                PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
00106C  A822E8     BSET LATG, #1
1023:                PIN_MAIN_CONTACTOR_CLOSE = !OLL_MAIN_CONTACTOR_CLOSED;
00106E  A902E2     BCLR LATF, #0
1024:                PIN_SAMPLE_PFN_IREV = !OLL_SAMPLE_PFN_IREV_TRIGGER;
001070  A942CA     BCLR LATB, #2
1025:                PIN_RS422_DE = OLL_RS422_DE_ENABLE_RS422_DRIVER;
001072  A802E8     BSET LATG, #0
1026:                // DPARKER PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
1027:                PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
001074  A9C2CB     BCLR 0x2CB, #6
1028:              
1029:              
1030:                // External 16 bit ADC control pins
1031:                PIN_PULSE_IMON_CS = !OLL_SELECT_PULSE_IMON_ADC;
001076  A8C2D6     BSET LATD, #6
1032:                PIN_PULSE_VMON_CS = !OLL_SELECT_PULSE_VMON_ADC;
001078  A8A2D6     BSET LATD, #5
1033:                PIN_PULSE_ADC_TRIGGER = !OLL_TRIGGER_PULSE_ADCS;
00107A  A922E2     BCLR LATF, #1
1034:              
1035:                
1036:                // HV Lambda IO Pins
1037:                TRIS_PIN_HV_LAMBDA_ENABLE = TRIS_OUTPUT_MODE;
00107C  A962D3     BCLR 0x2D3, #3
1038:                TRIS_PIN_HV_LAMBDA_INHIBIT = TRIS_OUTPUT_MODE;
00107E  A902D2     BCLR TRISD, #0
1039:              
1040:                TRIS_PIN_HV_LAMBDA_EOC_INPUT = TRIS_INPUT_MODE;
001080  A842D2     BSET TRISD, #2
1041:                TRIS_PIN_HV_LAMBDA_SUM_FAULT = TRIS_INPUT_MODE;
001082  A8C2CD     BSET 0x2CD, #6
1042:                TRIS_PIN_HV_LAMBDA_HV_ON_READBACK = TRIS_INPUT_MODE;
001084  A8A2CD     BSET 0x2CD, #5
1043:                TRIS_PIN_HV_LAMBDA_POWER_UP = TRIS_INPUT_MODE;
001086  A822D2     BSET TRISD, #1
1044:                
1045:              
1046:                // Magnetron Filament/Magnet Supply
1047:                TRIS_PIN_MAGNETRON_MAGNET_ENABLE = TRIS_OUTPUT_MODE;
001088  A922D3     BCLR 0x2D3, #1
1048:                TRIS_PIN_MAGNETRON_MAGNET_SO = TRIS_OUTPUT_MODE;
00108A  A942D3     BCLR 0x2D3, #2
1049:                TRIS_PIN_MAGNETRON_FILAMENT_ENABLE = TRIS_OUTPUT_MODE;
00108C  A902D3     BCLR 0x2D3, #0
1050:              
1051:              
1052:                // Optical Input Pins
1053:                TRIS_PIN_MODULATOR_DRIVE_INPUT = TRIS_INPUT_MODE;
00108E  A882C1     BSET 0x2C1, #4
1054:                TRIS_PIN_A_B_MODE_SELECT = TRIS_INPUT_MODE;
001090  A8A2C1     BSET 0x2C1, #5
1055:              
1056:                // Optical Output PIns
1057:                TRIS_PIN_SUM_FAULT_FIBER = TRIS_OUTPUT_MODE;
001092  A9E2C0     BCLR TRISA, #7
1058:                //DPARKER PIN REPURPOSED TRIS_PIN_SPARE_OPTICAL_OUT = TRIS_OUTPUT_MODE;
1059:                TRIS_PIN_UART2_TX = TRIS_OUTPUT_MODE;
001094  A9A2DE     BCLR TRISF, #5
1060:                TRIS_PIN_FAST_RESTART_STORAGE_CAP = TRIS_OUTPUT_MODE;
001096  A922C1     BCLR 0x2C1, #1
1061:              
1062:              
1063:                // Digital Control Input Pins
1064:                TRIS_FP_PIN_MODULATOR_ENABLE_INPUT = TRIS_INPUT_MODE;
001098  A8C2C1     BSET 0x2C1, #6
1065:                TRIS_FP_PIN_MODULATOR_HV_ON_INPUT = TRIS_INPUT_MODE;
00109A  A8E2C1     BSET 0x2C1, #7
1066:                TRIS_FP_PIN_MODULATOR_RESET = TRIS_INPUT_MODE;
00109C  A8A2E5     BSET 0x2E5, #5
1067:                TRIS_FP_PIN_FAST_RESTART = TRIS_INPUT_MODE;
00109E  A882E5     BSET 0x2E5, #4
1068:                TRIS_FP_PIN_SPARE_2_SAMPLE_VPROG_INPUT = TRIS_INPUT_MODE;
0010A0  A8C2E5     BSET 0x2E5, #6
1069:              
1070:              
1071:                // Analog Compartor/Latch Input Pins
1072:                TRIS_PIN_PULSE_OVER_CUR_LATCH = TRIS_INPUT_MODE;
0010A2  A882D2     BSET TRISD, #4
1073:                TRIS_PIN_PULSE_MIN_CUR_LATCH = TRIS_INPUT_MODE;
0010A4  A8E2D2     BSET TRISD, #7
1074:                TRIS_PIN_MAGNET_CURRENT_OOR_LATCH = TRIS_INPUT_MODE;
0010A6  A882D3     BSET 0x2D3, #4
1075:                TRIS_PIN_FILAMENT_OV_LATCH = TRIS_INPUT_MODE;
0010A8  A8A2D3     BSET 0x2D3, #5
1076:                
1077:                // Interlock Inputs
1078:                TRIS_PIN_INTERLOCK_1 = TRIS_INPUT_MODE;
0010AA  A862CC     BSET TRISC, #3
1079:                TRIS_PIN_INTERLOCK_2 = TRIS_INPUT_MODE;
0010AC  A882CC     BSET TRISC, #4
1080:                TRIS_PIN_INTERLOCK_3 = TRIS_INPUT_MODE;
0010AE  A802E5     BSET 0x2E5, #0
1081:                TRIS_PIN_INTERLOCK_4 = TRIS_INPUT_MODE;
0010B0  A822E5     BSET 0x2E5, #1
1082:                TRIS_PIN_4_20_DRVR_FLT = TRIS_INPUT_MODE;
0010B2  A842C1     BSET 0x2C1, #2
1083:              
1084:                // Digital Output Pins
1085:                TRIS_PIN_THYRATRON_TRIGGER_ENABLE = TRIS_OUTPUT_MODE;
0010B4  A9C2C0     BCLR TRISA, #6
1086:                TRIS_PIN_SUM_FAULT_COPPER = TRIS_OUTPUT_MODE;
0010B6  A942CC     BCLR TRISC, #2
1087:                TRIS_PIN_LATCH_RESET = TRIS_OUTPUT_MODE;
0010B8  A962D2     BCLR TRISD, #3
1088:                TRIS_PIN_PULSE_LATCH_RESET = TRIS_OUTPUT_MODE;
0010BA  A922E4     BCLR TRISG, #1
1089:                TRIS_PIN_MAIN_CONTACTOR_CLOSE = TRIS_OUTPUT_MODE;
0010BC  A902DE     BCLR TRISF, #0
1090:                TRIS_PIN_SAMPLE_PFN_IREV = TRIS_OUTPUT_MODE;
0010BE  A942C6     BCLR TRISB, #2
1091:                TRIS_PIN_RS422_DE = TRIS_OUTPUT_MODE;
0010C0  A902E4     BCLR TRISG, #0
1092:                TRIS_PIN_MCU_CLOCK_OUT_TEST_POINT = TRIS_OUTPUT_MODE;
0010C2  A9E2CD     BCLR 0x2CD, #7
1093:                TRIS_PIN_LAMBDA_VOLTAGE_SELECT = TRIS_OUTPUT_MODE;
0010C4  A9C2C7     BCLR 0x2C7, #6
1094:                TRIS_PIN_PULSE_IMON_CS = TRIS_OUTPUT_MODE;
0010C6  A9C2D2     BCLR TRISD, #6
1095:                TRIS_PIN_PULSE_VMON_CS = TRIS_OUTPUT_MODE;
0010C8  A9A2D2     BCLR TRISD, #5
1096:                TRIS_PIN_PULSE_ADC_TRIGGER = TRIS_OUTPUT_MODE;
0010CA  A922DE     BCLR TRISF, #1
1097:              
1098:              
1099:              
1100:                // ----------- Configure Interupts -------------- //
1101:              
1102:              
1103:                // Configure INT1 Interrupt
1104:                _INT1IE = 0; // Disable Interrupt
0010CC  A9008E     BCLR IEC1, #0
1105:                _INT1IF = 0; // Clear Interrupt Flag  
0010CE  A90086     BCLR IFS1, #0
1106:                _INT1IP = 6; // Highest Priority
0010D0  8004E4     MOV IPC4, W4
0010D2  A10004     BCLR W4, #0
0010D4  A01004     BSET W4, #1
0010D6  A02004     BSET W4, #2
0010D8  8804E4     MOV W4, IPC4
1107:                _INT1EP = 0; // Positive Transition Trigger
0010DA  A92082     BCLR INTCON2, #1
1108:              
1109:                // Configure T1 Interrupt
1110:                _T1IE = 0;  // Disable Interrupt
0010DC  A9608C     BCLR IEC0, #3
1111:                _T1IF = 0;  // Clear Interrupt Flag  
0010DE  A96084     BCLR IFS0, #3
1112:                _T1IP = 5;  // Lower Priority than INT1, Higher than everything else  
0010E0  8004A4     MOV IPC0, W4
0010E2  A0C004     BSET W4, #12
0010E4  A1D004     BCLR W4, #13
0010E6  A0E004     BSET W4, #14
0010E8  8804A4     MOV W4, IPC0
1113:              
1114:                // Configure ADC Interrupt
1115:                _ADIE = 0;
0010EA  A9608D     BCLR 0x8D, #3
1116:                _ADIF = 0;
0010EC  A96085     BCLR 0x85, #3
1117:                _ADIP = 3;
0010EE  8004C4     MOV IPC2, W4
0010F0  A0C004     BSET W4, #12
0010F2  A0D004     BSET W4, #13
0010F4  A1E004     BCLR W4, #14
0010F6  8804C4     MOV W4, IPC2
1118:              
1119:              
1120:                // Configure Change Notification Interrupt
1121:                _CNIF = 0;
0010F8  A9E085     BCLR 0x85, #7
1122:                _CN16IE = 1;  // Allow Change notification on CN16 (PULSE MINIMUM CURRENT LATCH)
0010FA  A800C2     BSET CNEN2, #0
1123:                _CNIE = 1;
0010FC  A8E08D     BSET 0x8D, #7
1124:                _CNIP = 4;
0010FE  8004D4     MOV IPC3, W4
001100  A1C004     BCLR W4, #12
001102  A1D004     BCLR W4, #13
001104  A0E004     BSET W4, #14
001106  8804D4     MOV W4, IPC3
1125:                
1126:              
1127:              
1128:                // Configure UART Interrupts
1129:                _U1RXIE = 0;
001108  A9208D     BCLR 0x8D, #1
1130:                _U1RXIP = 5;
00110A  8004C4     MOV IPC2, W4
00110C  A04004     BSET W4, #4
00110E  A15004     BCLR W4, #5
001110  A06004     BSET W4, #6
001112  8804C4     MOV W4, IPC2
1131:                
1132:                _U1TXIE = 0;
001114  A9408D     BCLR 0x8D, #2
1133:                _U1RXIP = 5;
001116  8004C4     MOV IPC2, W4
001118  A04004     BSET W4, #4
00111A  A15004     BCLR W4, #5
00111C  A06004     BSET W4, #6
00111E  8804C4     MOV W4, IPC2
1134:              
1135:              
1136:                // Configure LVD Interrupt
1137:                _LVDIF = 0;
001120  A94089     BCLR 0x89, #2
1138:                _LVDIE = 0;
001122  A94091     BCLR 0x91, #2
1139:                _LVDIP = 7;
001124  800544     MOV IPC10, W4
001126  A08004     BSET W4, #8
001128  A09004     BSET W4, #9
00112A  A0A004     BSET W4, #10
00112C  880544     MOV W4, IPC10
1140:                _LVDL = 0b1100;  //DPARKER LVDL should trigger at 4.1 Volts
00112E  803A04     MOV RCON, W4
001130  A18004     BCLR W4, #8
001132  A19004     BCLR W4, #9
001134  A0A004     BSET W4, #10
001136  A0B004     BSET W4, #11
001138  883A04     MOV W4, RCON
1141:              
1142:                
1143:              
1144:                // --------- CONFIGURATION FOR THE I2C BUS ---------------- //
1145:                I2CCON = I2CCON_SETUP;
00113A  2F00F4     MOV #0xF00F, W4
00113C  881034     MOV W4, I2CCON
1146:                I2CBRG = I2C_BAUD_RATE_GENERATOR;  // Configure I2C bus based on H file parameters
00113E  200614     MOV #0x61, W4
001140  881024     MOV W4, I2CBRG
1147:              
1148:              
1149:              
1150:                // --------- CONFIGURATION FOR THE SPI BUSSES ---------------- //
1151:                OpenSPI1((A34760_SPI1CON_VALUE & A34760_SPI1CON_CLOCK), A34760_SPI1STAT_VALUE);  // Configure SPI bus 1 based on H file parameters
001142  2DFBF1     MOV #0xDFBF, W1
001144  2B53B0     MOV #0xB53B, W0
001146  07F85F     RCALL _OpenSPI1
1152:                OpenSPI2((A34760_SPI2CON_VALUE & A34760_SPI2CON_CLOCK), A34760_SPI2STAT_VALUE);  // Configure SPI bus 2 based on H file parameters
001148  2DFBF1     MOV #0xDFBF, W1
00114A  2BF3A0     MOV #0xBF3A, W0
00114C  07F85F     RCALL _OpenSPI2
1153:                
1154:              
1155:                // ------ CONFIGURE the CAN Modules to be OFF -------------- //
1156:                C1CTRL = 0b0000000100000000;
00114E  201004     MOV #0x100, W4
001150  881C84     MOV W4, C1CTRL
1157:                C2CTRL = 0b0000000100000000;
001152  201004     MOV #0x100, W4
001154  882284     MOV W4, C2CTRL
1158:                
1159:              
1160:                // ----------------- UART #1 Setup and Data Buffer -------------------------//
1161:                // Setup the UART input and output buffers
1162:                uart1_input_buffer.write_location = 0;  
001156  EB4200     CLR.B W4
001158  784004     MOV.B W4, W0
00115A  B7E89E     MOV.B WREG, 0x89E
1163:                uart1_input_buffer.read_location = 0;
00115C  EB4200     CLR.B W4
00115E  784004     MOV.B W4, W0
001160  B7E89F     MOV.B WREG, 0x89F
1164:                uart1_output_buffer.write_location = 0;
001162  EB4200     CLR.B W4
001164  784004     MOV.B W4, W0
001166  B7E8E0     MOV.B WREG, 0x8E0
1165:                uart1_output_buffer.read_location = 0;
001168  EB4200     CLR.B W4
00116A  784004     MOV.B W4, W0
00116C  B7E8E1     MOV.B WREG, 0x8E1
1166:              
1167:                U1MODE = A34760_U1MODE_VALUE;
00116E  2FF004     MOV #0xFF00, W4
001170  881064     MOV W4, U1MODE
1168:                U1BRG = A34760_U1BRG_VALUE;
001172  200044     MOV #0x4, W4
001174  8810A4     MOV W4, U1BRG
1169:                U1STA = A34760_U1STA_VALUE;
001176  2775F4     MOV #0x775F, W4
001178  881074     MOV W4, U1STA
1170:                
1171:              
1172:              
1173:               // ---------- Configure Timers ----------------- //
1174:              
1175:              
1176:                // Configure TMR1
1177:                T1CON = A34760_T1CON_VALUE;
00117A  25FAD4     MOV #0x5FAD, W4
00117C  880824     MOV W4, T1CON
1178:              
1179:              
1180:                // Configure TMR2
1181:                T2CON = A34760_T2CON_VALUE;
00117E  25FA54     MOV #0x5FA5, W4
001180  880884     MOV W4, T2CON
1182:                PR2 = A34760_PR2_VALUE;  
001182  23D094     MOV #0x3D09, W4
001184  880864     MOV W4, PR2
1183:                TMR2 = 0;
001186  EB0200     CLR W4
001188  880834     MOV W4, TMR2
1184:                _T2IF = 0;
00118A  A9C084     BCLR IFS0, #6
1185:              
1186:              
1187:                // Configure TMR4
1188:                T4CON = A34760_T4CON_VALUE;
00118C  25F854     MOV #0x5F85, W4
00118E  8808F4     MOV W4, T4CON
1189:              
1190:              
1191:                // Configure TMR5
1192:                T5CON = A34760_T5CON_VALUE;
001190  25F9D4     MOV #0x5F9D, W4
001192  880904     MOV W4, T5CON
1193:                TMR5 = 0;
001194  EB0200     CLR W4
001196  8808C4     MOV W4, TMR5
1194:                _T5IF = 0;
001198  A9C086     BCLR IFS1, #6
1195:                PR5 = A34760_PR5_VALUE; 
00119A  230D44     MOV #0x30D4, W4
00119C  8808E4     MOV W4, PR5
1196:              
1197:              
1198:              
1199:              
1200:              
1201:                // --------------- Initialize U44 - LTC2656 ------------------------- //
1202:                U44_LTC2656.pin_cable_select = _PIN_RD15;
00119E  200DF4     MOV #0xDF, W4
0011A0  884714     MOV W4, U44_LTC2656
1203:                U44_LTC2656.pin_load_dac = _PIN_RD14;
0011A2  200DE4     MOV #0xDE, W4
0011A4  884734     MOV W4, 0x8E6
1204:                U44_LTC2656.pin_por_select = _PIN_NOT_CONNECTED;
0011A6  200204     MOV #0x20, W4
0011A8  884744     MOV W4, 0x8E8
1205:                U44_LTC2656.por_select_value = 0;
0011AA  EB0200     CLR W4
0011AC  884754     MOV W4, 0x8EA
1206:                U44_LTC2656.spi_port = SPI_PORT_1;
0011AE  B3C014     MOV #0x1, W4
0011B0  784004     MOV.B W4, W0
0011B2  B7E8EC     MOV.B WREG, 0x8EC
1207:              #ifndef __A36760
1208:                U44_LTC2656.pin_dac_clear = _PIN_RB15;
0011B4  200BF4     MOV #0xBF, W4
0011B6  884724     MOV W4, 0x8E4
1209:              #else
1210:                U44_LTC2656.pin_dac_clear = _PIN_NOT_CONNECTED;
1211:              #endif
1212:              
1213:              
1214:                SetupLTC2656(&U44_LTC2656);
0011B8  208E20     MOV #0x8E2, W0
0011BA  0717D2     RCALL SetupLTC2656
1215:                
1216:              
1217:                // ---------------- Initialize U64 - MCP23017 ----------------//
1218:              
1219:                U64_MCP23017.address = MCP23017_ADDRESS_0;
0011BC  B3C404     MOV #0x40, W4
0011BE  784004     MOV.B W4, W0
0011C0  B7E8F4     MOV.B WREG, 0x8F4
1220:                U64_MCP23017.i2c_port = I2C_PORT;
0011C2  EB4200     CLR.B W4
0011C4  784004     MOV.B W4, W0
0011C6  B7E8F5     MOV.B WREG, 0x8F5
1221:                U64_MCP23017.pin_reset = _PIN_NOT_CONNECTED;
0011C8  200204     MOV #0x20, W4
0011CA  884774     MOV W4, U64_MCP23017
1222:                U64_MCP23017.pin_int_a = _PIN_NOT_CONNECTED;
0011CC  200204     MOV #0x20, W4
0011CE  884784     MOV W4, 0x8F0
1223:                U64_MCP23017.pin_int_b = _PIN_NOT_CONNECTED;
0011D0  200204     MOV #0x20, W4
0011D2  884794     MOV W4, 0x8F2
1224:                U64_MCP23017.output_latch_a_in_ram = MCP23017_U64_LATA_INITIAL;
0011D4  EBC200     SETM.B W4
0011D6  784004     MOV.B W4, W0
0011D8  B7E8F6     MOV.B WREG, 0x8F6
1225:                U64_MCP23017.output_latch_b_in_ram = MCP23017_U64_LATB_INITIAL;
0011DA  EBC200     SETM.B W4
0011DC  784004     MOV.B W4, W0
0011DE  B7E8F7     MOV.B WREG, 0x8F7
1226:              
1227:              
1228:                ResetAllFaults();
0011E0  07148D     RCALL ResetAllFaults
1229:              
1230:              
1231:                // DPARKER - At some point want to recover the pulse and arc counter from RAM
1232:                // ------------ Load the pulse and arc counters ---------------- //
1233:                unsigned_int_ptr = &pulse_counter_persistent;              //unsigned_int_ptr now points to the Least Significant word of pulse_counter_persistent
0011E2  2189E4     MOV #0x189E, W4
0011E4  780F04     MOV W4, [W14]
1234:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[3];
0011E6  80C054     MOV 0x180A, W4
0011E8  780284     MOV W4, W5
0011EA  78021E     MOV [W14], W4
0011EC  780A05     MOV W5, [W4]
1235:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
0011EE  E88F1E     INC2 [W14], [W14]
1236:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[2];
0011F0  80C044     MOV 0x1808, W4
0011F2  780284     MOV W4, W5
0011F4  78021E     MOV [W14], W4
0011F6  780A05     MOV W5, [W4]
1237:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
0011F8  E88F1E     INC2 [W14], [W14]
1238:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[1];
0011FA  80C034     MOV 0x1806, W4
0011FC  780284     MOV W4, W5
0011FE  78021E     MOV [W14], W4
001200  780A05     MOV W5, [W4]
1239:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of pulse_counter_persistent
001202  E88F1E     INC2 [W14], [W14]
1240:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[0];
001204  80C024     MOV pulse_counter_repository_ram_copy, W4
001206  780284     MOV W4, W5
001208  78021E     MOV [W14], W4
00120A  780A05     MOV W5, [W4]
1241:              
1242:              
1243:                unsigned_int_ptr = &arc_counter_persistent;                //unsigned_int_ptr now points to the Least Significant word of arc_counter_persistent
00120C  218AC4     MOV #0x18AC, W4
00120E  780F04     MOV W4, [W14]
1244:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[5];
001210  80C074     MOV 0x180E, W4
001212  780284     MOV W4, W5
001214  78021E     MOV [W14], W4
001216  780A05     MOV W5, [W4]
1245:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of arc_counter_persistent
001218  E88F1E     INC2 [W14], [W14]
1246:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[4];
00121A  80C064     MOV 0x180C, W4
00121C  780284     MOV W4, W5
00121E  78021E     MOV [W14], W4
001220  780A05     MOV W5, [W4]
1247:                
1248:                arc_counter_this_hv_on = 0;
001222  EB0200     CLR W4
001224  88C5D4     MOV W4, arc_counter_this_hv_on
1249:                pulse_counter_this_hv_on = 0;
001226  B82260     MUL.UU W4, #0, W4
001228  88C584     MOV W4, pulse_counter_this_hv_on
00122A  88C595     MOV W5, 0x18B2
1250:               
1251:                fast_reset_counter_persistent = pulse_counter_repository_ram_copy[6];
00122C  80C084     MOV 0x1810, W4
00122E  8841C4     MOV W4, fast_reset_counter_persistent
1252:                
1253:                /*
1254:                  Check to See if this was a faulty processor Reset.
1255:                  If it was a faulty processor Reset, the following must occur
1256:                  * Durring warmup, if the Fast Restart Pin is set, the warmup will be truncated to 2 seconds
1257:                  
1258:                  * Read persistent RAM values and save to EEPROM as nessesary
1259:                  1) When the processor restarts, copy the persistent counters to a new RAM locations
1260:                  2) Load values from EEPROM
1261:                  3) The following statement *should* be true
1262:                  4) pulse_counter_persistent(from_before_arc) = pulse_counter_persistent(stored_in_EEPROM) + pulse_counter_this_hv_on(from_before_arc)
1263:                  4a) If that math works out, save the pulse information.  If that math does not work out, throw away pre-arc data and just reload from EEPROM
1264:                */
1265:                /*
1266:                pulse_counter_persistent_store = pulse_counter_persistent;
1267:                pulse_counter_this_hv_on_store = pulse_counter_this_hv_on;
1268:                arc_counter_persistent_store = arc_counter_persistent;
1269:                arc_counter_this_hv_on_store = arc_counter_this_hv_on;
1270:              
1271:              
1272:                if (PIN_FP_FAST_RESTART == ILL_FAST_RESTART) {
1273:                  if (pulse_counter_persistent_store > 5) {
1274:                    pulse_counter_persistent_store -= 5;
1275:                  }
1276:                  if ((pulse_counter_persistent + pulse_counter_this_hv_on_store) > pulse_counter_persistent_store) {
1277:                    if ((pulse_counter_persistent + pulse_counter_this_hv_on_store) < (pulse_counter_persistent_store + 10)) {
1278:              	pulse_counter_persistent = pulse_counter_persistent_store + 5;
1279:                    }
1280:                  }
1281:                  
1282:                  if (arc_counter_persistent_store > 5) {
1283:                    arc_counter_persistent_store -= 5;
1284:                  }
1285:                  if ((arc_counter_persistent + arc_counter_this_hv_on_store) > arc_counter_persistent_store) {
1286:                    if ((arc_counter_persistent + arc_counter_this_hv_on_store) < (arc_counter_persistent_store + 10)) {
1287:              	arc_counter_persistent = arc_counter_persistent_store + 5;
1288:                    }
1289:                  }
1290:                  
1291:                  SavePulseCountersToEEPROM();
1292:                  }
1293:                */   
1294:              
1295:              
1296:               
1297:              }
001230  FA8000     ULNK
001232  060000     RETURN
1298:              
1299:              
1300:              
1301:              void DoA34760StartUpNormalProcess(void) {
001234  FA0002     LNK #0x2
1302:                unsigned int i2c_test = 0;
001236  EB0200     CLR W4
001238  780F04     MOV W4, [W14]
1303:              
1304:                // This was a not a reset from a fast crash so clear the reset data
1305:                debug_status_register = 0;
00123A  EB0200     CLR W4
00123C  88C2F4     MOV W4, debug_status_register
1306:                _POR = 0;
00123E  A90740     BCLR RCON, #0
1307:                _EXTR = 0;
001240  A9E740     BCLR RCON, #7
1308:                _SWR = 0;
001242  A9C740     BCLR RCON, #6
1309:                _BOR = 0;
001244  A92740     BCLR RCON, #1
1310:                _TRAPR = 0;
001246  A9E741     BCLR 0x741, #7
1311:                _WDTO = 0;
001248  A98740     BCLR RCON, #4
1312:                _IOPUWR = 0;
00124A  A9C741     BCLR 0x741, #6
1313:                last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
00124C  EB0200     CLR W4
00124E  88C5A4     MOV W4, last_known_action
1314:                processor_crash_count = 0;
001250  EB0200     CLR W4
001252  88C5C4     MOV W4, processor_crash_count
1315:                
1316:                ClearOutputsLTC2656(&U44_LTC2656);
001254  208E20     MOV #0x8E2, W0
001256  0717BB     RCALL ClearOutputsLTC2656
1317:                
1318:                // Test U64 - MCP23017
1319:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
001258  EB4100     CLR.B W2
00125A  B3C0A1     MOV #0xA, W1
00125C  208EE0     MOV #0x8EE, W0
00125E  071C83     RCALL MCP23017WriteSingleByte
001260  780200     MOV W0, W4
001262  720F1E     IOR W4, [W14], [W14]
1320:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
001264  EB4100     CLR.B W2
001266  B3C0A1     MOV #0xA, W1
001268  208EE0     MOV #0x8EE, W0
00126A  071C7D     RCALL MCP23017WriteSingleByte
00126C  780200     MOV W0, W4
00126E  720F1E     IOR W4, [W14], [W14]
1321:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
001270  EB4100     CLR.B W2
001272  B3C0A1     MOV #0xA, W1
001274  208EE0     MOV #0x8EE, W0
001276  071C77     RCALL MCP23017WriteSingleByte
001278  780200     MOV W0, W4
00127A  720F1E     IOR W4, [W14], [W14]
1322:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATA, U64_MCP23017.output_latch_a_in_ram);
00127C  208F64     MOV #0x8F6, W4
00127E  784214     MOV.B [W4], W4
001280  784104     MOV.B W4, W2
001282  B3C141     MOV #0x14, W1
001284  208EE0     MOV #0x8EE, W0
001286  071C6F     RCALL MCP23017WriteSingleByte
001288  780200     MOV W0, W4
00128A  720F1E     IOR W4, [W14], [W14]
1323:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATB, U64_MCP23017.output_latch_b_in_ram);
00128C  208F74     MOV #0x8F7, W4
00128E  784214     MOV.B [W4], W4
001290  784104     MOV.B W4, W2
001292  B3C151     MOV #0x15, W1
001294  208EE0     MOV #0x8EE, W0
001296  071C67     RCALL MCP23017WriteSingleByte
001298  780200     MOV W0, W4
00129A  720F1E     IOR W4, [W14], [W14]
1324:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRA, MCP23017_U64_IODIRA_VALUE);
00129C  B3CF82     MOV #0xF8, W2
00129E  EB4080     CLR.B W1
0012A0  208EE0     MOV #0x8EE, W0
0012A2  071C61     RCALL MCP23017WriteSingleByte
0012A4  780200     MOV W0, W4
0012A6  720F1E     IOR W4, [W14], [W14]
1325:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRB, MCP23017_U64_IODIRB_VALUE);
0012A8  EB4100     CLR.B W2
0012AA  B3C011     MOV #0x1, W1
0012AC  208EE0     MOV #0x8EE, W0
0012AE  071C5B     RCALL MCP23017WriteSingleByte
0012B0  780200     MOV W0, W4
0012B2  720F1E     IOR W4, [W14], [W14]
1326:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IPOLA, MCP23017_U64_IPOLA_VALUE);
0012B4  EB4100     CLR.B W2
0012B6  B3C021     MOV #0x2, W1
0012B8  208EE0     MOV #0x8EE, W0
0012BA  071C55     RCALL MCP23017WriteSingleByte
0012BC  780200     MOV W0, W4
0012BE  720F1E     IOR W4, [W14], [W14]
1327:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IPOLB, MCP23017_U64_IPOLB_VALUE);
0012C0  EB4100     CLR.B W2
0012C2  B3C031     MOV #0x3, W1
0012C4  208EE0     MOV #0x8EE, W0
0012C6  071C4F     RCALL MCP23017WriteSingleByte
0012C8  780200     MOV W0, W4
0012CA  720F1E     IOR W4, [W14], [W14]
1328:                  
1329:                if ((i2c_test & 0xFF00) == 0xFA00) {
0012CC  2FF004     MOV #0xFF00, W4
0012CE  62029E     AND W4, [W14], W5
0012D0  2FA004     MOV #0xFA00, W4
0012D2  528F84     SUB W5, W4, [W15]
0012D4  3A0007     BRA NZ, 0x12E4
1330:                  // There was a fault on the i2c bus, the MCP23017 did not initialize properly
1331:                  debug_status_register |= STATUS_DIGITAL_IO_EXP_ERROR;
0012D6  80C2F5     MOV debug_status_register, W5
0012D8  200804     MOV #0x80, W4
0012DA  728204     IOR W5, W4, W4
0012DC  88C2F4     MOV W4, debug_status_register
1332:                  global_debug_counter.i2c_bus_error++;
0012DE  80C264     MOV 0x184C, W4
0012E0  E80204     INC W4, W4
0012E2  88C264     MOV W4, 0x184C
1333:                }
1334:                
1335:                i2c_test = MCP23017ReadSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRA);
0012E4  EB4080     CLR.B W1
0012E6  208EE0     MOV #0x8EE, W0
0012E8  071C70     RCALL MCP23017ReadSingleByte
0012EA  780200     MOV W0, W4
0012EC  780F04     MOV W4, [W14]
1336:                if ((i2c_test & 0x00FF) != MCP23017_U64_IODIRA_VALUE) {
0012EE  200FF4     MOV #0xFF, W4
0012F0  62029E     AND W4, [W14], W5
0012F2  200F84     MOV #0xF8, W4
0012F4  528F84     SUB W5, W4, [W15]
0012F6  320007     BRA Z, 0x1306
1337:                  // The MCP Write/Read operation failed
1338:                  debug_status_register |= STATUS_DIGITAL_IO_EXP_ERROR;
0012F8  80C2F5     MOV debug_status_register, W5
0012FA  200804     MOV #0x80, W4
0012FC  728204     IOR W5, W4, W4
0012FE  88C2F4     MOV W4, debug_status_register
1339:                  global_debug_counter.i2c_bus_error++;
001300  80C264     MOV 0x184C, W4
001302  E80204     INC W4, W4
001304  88C264     MOV W4, 0x184C
1340:                }
1341:               
1342:                DisableMagnetronFilamentSupply();
001306  0706D9     RCALL DisableMagnetronFilamentSupply
1343:                DisableMagnetronMagnetSupply();
001308  0706E0     RCALL DisableMagnetronMagnetSupply
1344:                DisableHVLambdaSupply();
00130A  0706E3     RCALL DisableHVLambdaSupply
1345:              }
00130C  FA8000     ULNK
00130E  060000     RETURN
1346:              
1347:              
1348:              
1349:              
1350:              
1351:              
1352:              void DoA34760StartUpFastProcess(void) {
001310  FA0006     LNK #0x6
1353:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
1354:                unsigned int vtemp;
1355:              #endif
1356:                
1357:                unsigned int vtemp_2;
1358:                unsigned int itemp_2;
1359:              
1360:                processor_crash_count++;
001312  80C5C4     MOV processor_crash_count, W4
001314  E80204     INC W4, W4
001316  88C5C4     MOV W4, processor_crash_count
1361:              
1362:                fast_reset_counter_persistent++;
001318  8041C4     MOV fast_reset_counter_persistent, W4
00131A  E80204     INC W4, W4
00131C  8841C4     MOV W4, fast_reset_counter_persistent
1363:                pulse_counter_repository_ram_copy[6] = fast_reset_counter_persistent;
00131E  8041C4     MOV fast_reset_counter_persistent, W4
001320  88C084     MOV W4, 0x1810
1364:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART;
001322  A922C5     BCLR 0x2C5, #1
1365:              
1366:                // Taken from StartWarmUp(); & the start of State Warm Ready
1367:                PIDInit(&thyratron_reservoir_heater_PID);
001324  2084A0     MOV #0x84A, W0
001326  07F752     RCALL _PIDInit
1368:                PIDInit(&thyratron_cathode_heater_PID);
001328  208540     MOV #0x854, W0
00132A  07F750     RCALL _PIDInit
1369:              
1370:                // DPARKER, there are a lot more power supply configuration calls going on here than are needed, that is a lot of wasted CPU cycles as these are complex math operations
1371:                ScalePowerSupply(&ps_hv_lambda_mode_A,100,100);   // DPARKER this may be re-adjusted below
00132C  200642     MOV #0x64, W2
00132E  200641     MOV #0x64, W1
001330  208FA0     MOV #0x8FA, W0
001332  0700EF     RCALL ScalePowerSupply
1372:                ScalePowerSupply(&ps_hv_lambda_mode_B,100,100);   // DPARKER this may be re-adjusted below
001334  200642     MOV #0x64, W2
001336  200641     MOV #0x64, W1
001338  209AE0     MOV #0x9AE, W0
00133A  0700EB     RCALL ScalePowerSupply
1373:                ScalePowerSupply(&ps_filament,100,100);           // DPARKER this may be re-adjusted below
00133C  200642     MOV #0x64, W2
00133E  200641     MOV #0x64, W1
001340  20ABC0     MOV #0xABC, W0
001342  0700E7     RCALL ScalePowerSupply
1374:                ScalePowerSupply(&ps_magnet,100,100);             // DPARKER this may be re-adjusted below
001344  200642     MOV #0x64, W2
001346  200641     MOV #0x64, W1
001348  20A620     MOV #0xA62, W0
00134A  0700E3     RCALL ScalePowerSupply
1375:                ScalePowerSupply(&ps_thyr_reservoir_htr,100,100); // DPARKER this is not actually being used
00134C  200642     MOV #0x64, W2
00134E  200641     MOV #0x64, W1
001350  20B700     MOV #0xB70, W0
001352  0700DF     RCALL ScalePowerSupply
1376:                ScalePowerSupply(&ps_thyr_cathode_htr,100,100);   // DPARKER this is not actually being used
001354  200642     MOV #0x64, W2
001356  200641     MOV #0x64, W1
001358  20B160     MOV #0xB16, W0
00135A  0700DB     RCALL ScalePowerSupply
1377:              
1378:                EnableMagnetronMagnetSupply();
00135C  0706B2     RCALL EnableMagnetronMagnetSupply
1379:                EnableMagnetronFilamentSupply();
00135E  0706A9     RCALL EnableMagnetronFilamentSupply
1380:                HVLambdaStartCharging();  // DPARKER TMR1 and TMR2 must be initialized and ready to go before this call. DPARKER T1 Interrupt must also be ready to go
001360  070759     RCALL HVLambdaStartCharging
1381:                _T1IE = 0;  // We don't want to enter the interrupt until we get to STATE_HV_ON
001362  A9608C     BCLR IEC0, #3
1382:              
1383:                PIN_UART2_TX = !PIN_UART2_TX;
001364  801715     MOV LATF, W5
001366  200204     MOV #0x20, W4
001368  628204     AND W5, W4, W4
00136A  A7F004     BTSC W4, #15
00136C  EA0204     NEG W4, W4
00136E  E90204     DEC W4, W4
001370  DE224F     LSR W4, #15, W4
001372  784204     MOV.B W4, W4
001374  FB8204     ZE W4, W4
001376  620261     AND W4, #0x1, W4
001378  DD2245     SL W4, #5, W4
00137A  801716     MOV LATF, W6
00137C  2FFDF5     MOV #0xFFDF, W5
00137E  630285     AND W6, W5, W5
001380  728204     IOR W5, W4, W4
001382  881714     MOV W4, LATF
1384:                // Setup the ADC to read PAC and save to RAM as appropriate
1385:                FastReadAndFilterPACInputs();
001384  07054C     RCALL FastReadAndFilterPACInputs
1386:                PIN_UART2_TX = !PIN_UART2_TX;
001386  801715     MOV LATF, W5
001388  200204     MOV #0x20, W4
00138A  628204     AND W5, W4, W4
00138C  A7F004     BTSC W4, #15
00138E  EA0204     NEG W4, W4
001390  E90204     DEC W4, W4
001392  DE224F     LSR W4, #15, W4
001394  784204     MOV.B W4, W4
001396  FB8204     ZE W4, W4
001398  620261     AND W4, #0x1, W4
00139A  DD2245     SL W4, #5, W4
00139C  801716     MOV LATF, W6
00139E  2FFDF5     MOV #0xFFDF, W5
0013A0  630285     AND W6, W5, W5
0013A2  728204     IOR W5, W4, W4
0013A4  881714     MOV W4, LATF
1387:              
1388:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
1389:                if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
0013A6  801735     MOV PORTG, W5
0013A8  240004     MOV #0x4000, W4
0013AA  628204     AND W5, W4, W4
0013AC  520FE0     SUB W4, #0x0, [W15]
0013AE  3A0014     BRA NZ, 0x13D8
1390:                  vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
0013B0  8041A4     MOV pac_1_adc_reading, W4
0013B2  20C351     MOV #0xC35, W1
0013B4  780004     MOV W4, W0
0013B6  070787     RCALL Scale16Bit
0013B8  780200     MOV W0, W4
0013BA  780F04     MOV W4, [W14]
1391:                  SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp, 0);
0013BC  EB0100     CLR W2
0013BE  78009E     MOV [W14], W1
0013C0  208FA0     MOV #0x8FA, W0
0013C2  070075     RCALL SetPowerSupplyTarget
1392:                  
1393:                  vtemp = Scale16Bit(pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
0013C4  8041B4     MOV pac_2_adc_reading, W4
0013C6  20C351     MOV #0xC35, W1
0013C8  780004     MOV W4, W0
0013CA  07077D     RCALL Scale16Bit
0013CC  780200     MOV W0, W4
0013CE  780F04     MOV W4, [W14]
1394:                  SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
0013D0  EB0100     CLR W2
0013D2  78009E     MOV [W14], W1
0013D4  209AE0     MOV #0x9AE, W0
0013D6  07006B     RCALL SetPowerSupplyTarget
1395:                }
1396:              #endif
1397:                
1398:                if (!ram_config_set_magnetron_magnet_current_from_GUI) {
0013D8  208224     MOV #0x822, W4
0013DA  784214     MOV.B [W4], W4
0013DC  524FE0     SUB.B W4, #0x0, [W15]
0013DE  3A000D     BRA NZ, 0x13FA
1399:                  // The Magnet Current is calculated from Mode A program voltage
1400:                  itemp_2 = CalculatePoly(ps_hv_lambda_mode_A.v_command_set_point);
0013E0  8047E4     MOV 0x8FC, W4
0013E2  780004     MOV W4, W0
0013E4  0709FF     RCALL CalculatePoly
0013E6  780200     MOV W0, W4
0013E8  980714     MOV W4, [W14+2]
1401:                  vtemp_2 = GenerateMagnetVprog(itemp_2);
0013EA  90001E     MOV [W14+2], W0
0013EC  0711A8     RCALL GenerateMagnetVprog
0013EE  780200     MOV W0, W4
0013F0  980724     MOV W4, [W14+4]
1402:                  SetPowerSupplyTarget(&ps_magnet, vtemp_2, itemp_2);
0013F2  90011E     MOV [W14+2], W2
0013F4  9000AE     MOV [W14+4], W1
0013F6  20A620     MOV #0xA62, W0
0013F8  07005A     RCALL SetPowerSupplyTarget
1403:                }
1404:                  
1405:                // DPARKER Calculate and Setup Magnetron Filament Power
1406:                // DoMagnetronFilamentAdjust();  
1407:                PIN_UART2_TX = !PIN_UART2_TX;
0013FA  801715     MOV LATF, W5
0013FC  200204     MOV #0x20, W4
0013FE  628204     AND W5, W4, W4
001400  A7F004     BTSC W4, #15
001402  EA0204     NEG W4, W4
001404  E90204     DEC W4, W4
001406  DE224F     LSR W4, #15, W4
001408  784204     MOV.B W4, W4
00140A  FB8204     ZE W4, W4
00140C  620261     AND W4, #0x1, W4
00140E  DD2245     SL W4, #5, W4
001410  801716     MOV LATF, W6
001412  2FFDF5     MOV #0xFFDF, W5
001414  630285     AND W6, W5, W5
001416  728204     IOR W5, W4, W4
001418  881714     MOV W4, LATF
1408:                UpdateDacAll();
00141A  0701C5     RCALL UpdateDacAll
1409:              
1410:              
1411:                PIN_UART2_TX = !PIN_UART2_TX;
00141C  801715     MOV LATF, W5
00141E  200204     MOV #0x20, W4
001420  628204     AND W5, W4, W4
001422  A7F004     BTSC W4, #15
001424  EA0204     NEG W4, W4
001426  E90204     DEC W4, W4
001428  DE224F     LSR W4, #15, W4
00142A  784204     MOV.B W4, W4
00142C  FB8204     ZE W4, W4
00142E  620261     AND W4, #0x1, W4
001430  DD2245     SL W4, #5, W4
001432  801716     MOV LATF, W6
001434  2FFDF5     MOV #0xFFDF, W5
001436  630285     AND W6, W5, W5
001438  728204     IOR W5, W4, W4
00143A  881714     MOV W4, LATF
1412:                FastReadAndFilterFeedbacks(); // DPARKER - Move this to as late as possible (want time to feedbacks to get as stable as possible before reading)
00143C  070428     RCALL FastReadAndFilterFeedbacks
1413:                PIN_UART2_TX = !PIN_UART2_TX;
00143E  801715     MOV LATF, W5
001440  200204     MOV #0x20, W4
001442  628204     AND W5, W4, W4
001444  A7F004     BTSC W4, #15
001446  EA0204     NEG W4, W4
001448  E90204     DEC W4, W4
00144A  DE224F     LSR W4, #15, W4
00144C  784204     MOV.B W4, W4
00144E  FB8204     ZE W4, W4
001450  620261     AND W4, #0x1, W4
001452  DD2245     SL W4, #5, W4
001454  801716     MOV LATF, W6
001456  2FFDF5     MOV #0xFFDF, W5
001458  630285     AND W6, W5, W5
00145A  728204     IOR W5, W4, W4
00145C  881714     MOV W4, LATF
1414:              
1415:                // DPARKER - convert filament voltage readback to the program that will the exact same value.  Scale the filament to that value.  Do all this before you program the DAC
1416:              
1417:                control_state = STATE_HV_ON;  //  Want to check the faults based on STATE_HV_ON
00145E  B3C444     MOV #0x44, W4
001460  784004     MOV.B W4, W0
001462  B7E832     MOV.B WREG, control_state
1418:                UpdateFaults();
001464  07122D     RCALL UpdateFaults
1419:                control_state = STATE_FAST_RECOVERY_START_UP;
001466  B3C064     MOV #0x6, W4
001468  784004     MOV.B W4, W0
00146A  B7E832     MOV.B WREG, control_state
1420:                
1421:                // DPARKER - NO CONFIG/CHANGES to the I/O Expander for NOW
1422:              }
00146C  FA8000     ULNK
00146E  060000     RETURN
1423:              
1424:              
1425:              
1426:              
1427:              void DoA34760StartUpCommonPostProcess(void) {
001470  FA0000     LNK #0x0
1428:                
1429:                T2CONbits.TON = 1;
001472  A8E111     BSET 0x111, #7
1430:                T5CONbits.TON = 1;
001474  A8E121     BSET 0x121, #7
1431:                
1432:                // ---- Configure the dsPIC ADC Module ------------ //
1433:                ADCON1 = A34760_ADCON1_VALUE;             // Configure the high speed ADC module based on H file parameters
001476  27CFF4     MOV #0x7CFF, W4
001478  881504     MOV W4, ADCON1
1434:                ADCON2 = A34760_ADCON2_VALUE;             // Configure the high speed ADC module based on H file parameters
00147A  20FE84     MOV #0xFE8, W4
00147C  881514     MOV W4, ADCON2
1435:                ADCON3 = A34760_ADCON3_VALUE;             // Configure the high speed ADC module based on H file parameters
00147E  2E3464     MOV #0xE346, W4
001480  881524     MOV W4, ADCON3
1436:                ADCHS  = A34760_ADCHS_VALUE;              // Configure the high speed ADC module based on H file parameters
001482  2EFE34     MOV #0xEFE3, W4
001484  881534     MOV W4, ADCHS
1437:              
1438:                ADPCFG = A34760_ADPCFG_VALUE;             // Set which pins are analog and which are digital I/O
001486  2C0074     MOV #0xC007, W4
001488  881544     MOV W4, ADPCFG
1439:                ADCSSL = A34760_ADCSSL_VALUE;             // Set which analog pins are scanned
00148A  23FF84     MOV #0x3FF8, W4
00148C  881554     MOV W4, ADCSSL
1440:                ADCON1bits.ADON = 1;
00148E  A8E2A1     BSET 0x2A1, #7
1441:                _ADIF = 0;
001490  A96085     BCLR 0x85, #3
1442:                _ADIE = 1;
001492  A8608D     BSET 0x8D, #3
1443:               
1444:                
1445:                // Begin UART operation
1446:                _U1TXIF = 0;	// Clear the Transmit Interrupt Flag
001494  A94085     BCLR 0x85, #2
1447:                _U1TXIE = 1;	// Enable Transmit Interrupts
001496  A8408D     BSET 0x8D, #2
1448:                _U1RXIF = 0;	// Clear the Recieve Interrupt Flag
001498  A92085     BCLR 0x85, #1
1449:                _U1RXIE = 1;	// Enable Recieve Interrupts
00149A  A8208D     BSET 0x8D, #1
1450:                
1451:                U1MODEbits.UARTEN = 1;	// And turn the peripheral on
00149C  A8E20D     BSET 0x20D, #7
1452:                PIN_RS422_DE = OLL_RS422_DE_ENABLE_RS422_DRIVER;  // Enable the U69-RS422 Driver output (The reciever is always enabled)
00149E  A802E8     BSET LATG, #0
1453:                command_string.data_state = COMMAND_BUFFER_EMPTY;  // The command buffer is empty
0014A0  EB4200     CLR.B W4
0014A2  784004     MOV.B W4, W0
0014A4  B7F8AA     MOV.B WREG, 0x18AA
1454:               
1455:                ResetHWLatches();
0014A6  071322     RCALL ResetHWLatches
1456:                ClrWdt();
0014A8  FE6000     CLRWDT
1457:                // PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;  DPARKER THIS DOES NOT BELONG HERE
1458:              
1459:              }
0014AA  FA8000     ULNK
0014AC  060000     RETURN
1460:              
1461:              
1462:              
1463:              
1464:              
1465:              void SetPowerSupplyTarget(POWERSUPPLY* ptr_ps, unsigned int v_command, unsigned int i_command) {
0014AE  FA0006     LNK #0x6
0014B0  780F00     MOV W0, [W14]
0014B2  980711     MOV W1, [W14+2]
0014B4  980722     MOV W2, [W14+4]
1466:                /*
1467:                  ptr_ps - Pointer to the power supply that is having it's set point updated
1468:                  v_command - the new voltage command Set point
1469:                  i_command - the new current command set point
1470:                */
1471:              
1472:                
1473:                if (v_command > ptr_ps->v_max_set_point) {
0014B6  78021E     MOV [W14], W4
0014B8  9002B4     MOV [W4+6], W5
0014BA  90021E     MOV [W14+2], W4
0014BC  528F84     SUB W5, W4, [W15]
0014BE  310008     BRA C, 0x14D0
1474:                  ptr_ps->v_command_set_point = ptr_ps->v_max_set_point;
0014C0  78021E     MOV [W14], W4
0014C2  9002B4     MOV [W4+6], W5
0014C4  78021E     MOV [W14], W4
0014C6  980215     MOV W5, [W4+2]
1475:                  global_debug_counter.setpoint_not_valid++;
0014C8  80C2B4     MOV 0x1856, W4
0014CA  E80204     INC W4, W4
0014CC  88C2B4     MOV W4, 0x1856
0014CE  370003     BRA 0x14D6
1476:                } else {
1477:                  ptr_ps->v_command_set_point = v_command;
0014D0  78021E     MOV [W14], W4
0014D2  90029E     MOV [W14+2], W5
0014D4  980215     MOV W5, [W4+2]
1478:                }
1479:                
1480:                if (i_command > ptr_ps->i_max_set_point) {
0014D6  78021E     MOV [W14], W4
0014D8  901A94     MOV [W4+50], W5
0014DA  90022E     MOV [W14+4], W4
0014DC  528F84     SUB W5, W4, [W15]
0014DE  310008     BRA C, 0x14F0
1481:                  ptr_ps->i_command_set_point = ptr_ps->i_max_set_point;
0014E0  78021E     MOV [W14], W4
0014E2  901A94     MOV [W4+50], W5
0014E4  78021E     MOV [W14], W4
0014E6  981275     MOV W5, [W4+46]
1482:                  global_debug_counter.setpoint_not_valid++;
0014E8  80C2B4     MOV 0x1856, W4
0014EA  E80204     INC W4, W4
0014EC  88C2B4     MOV W4, 0x1856
0014EE  370003     BRA 0x14F6
1483:                } else {
1484:                  ptr_ps->i_command_set_point = i_command;
0014F0  78021E     MOV [W14], W4
0014F2  9002AE     MOV [W14+4], W5
0014F4  981275     MOV W5, [W4+46]
1485:                }
1486:                
1487:                if (control_state != STATE_WARM_UP) {
0014F6  208325     MOV #0x832, W5
0014F8  784295     MOV.B [W5], W5
0014FA  B3C244     MOV #0x24, W4
0014FC  52CF84     SUB.B W5, W4, [W15]
0014FE  320004     BRA Z, 0x1508
1488:                  ScalePowerSupply(ptr_ps,100,100);
001500  200642     MOV #0x64, W2
001502  200641     MOV #0x64, W1
001504  78001E     MOV [W14], W0
001506  070005     RCALL ScalePowerSupply
1489:                }
1490:                CalcPowerSupplySettings(ptr_ps);  // DPARKER is this call redundant since ScalePowerSupply also calls ScalePowerSupply
001508  78001E     MOV [W14], W0
00150A  070054     RCALL CalcPowerSupplySettings
1491:              
1492:                ClrWdt();
00150C  FE6000     CLRWDT
1493:              
1494:                // DPARKER need to figure out how to combine ScalePowerSupply & SetPowerSupplyTarget & CalcPowerSupplySettings
1495:                
1496:                
1497:                // DPARKER Record Saturation Errors for each supply???
1498:              }
00150E  FA8000     ULNK
001510  060000     RETURN
1499:              
1500:              
1501:              
1502:              void ScalePowerSupply(POWERSUPPLY* ptr_ps, unsigned int num, unsigned int den) {
001512  FA000A     LNK #0xA
001514  980720     MOV W0, [W14+4]
001516  980731     MOV W1, [W14+6]
001518  980742     MOV W2, [W14+8]
1503:              
1504:                unsigned long temp_32_bit;
1505:              
1506:                if (num >= den) {
00151A  9002BE     MOV [W14+6], W5
00151C  90024E     MOV [W14+8], W4
00151E  528F84     SUB W5, W4, [W15]
001520  390009     BRA NC, 0x1534
1507:                  // Power supply can not be scalled above the set point.
1508:                  // Set the scaled_set_point to the command_set_point
1509:                  ptr_ps->v_scaled_set_point = ptr_ps->v_command_set_point;
001522  90022E     MOV [W14+4], W4
001524  900294     MOV [W4+2], W5
001526  90022E     MOV [W14+4], W4
001528  980225     MOV W5, [W4+4]
1510:                  ptr_ps->i_scaled_set_point = ptr_ps->i_command_set_point;
00152A  90022E     MOV [W14+4], W4
00152C  9012F4     MOV [W4+46], W5
00152E  90022E     MOV [W14+4], W4
001530  981A05     MOV W5, [W4+48]
001532  37003C     BRA 0x15AC
1511:                } else {
1512:                  // Scale v_set_point by num/den
1513:                  temp_32_bit = ptr_ps->v_command_set_point;
001534  90022E     MOV [W14+4], W4
001536  900214     MOV [W4+2], W4
001538  200005     MOV #0x0, W5
00153A  BE8F04     MOV.D W4, [W14]
1514:                  temp_32_bit *= num;
00153C  90023E     MOV [W14+6], W4
00153E  200005     MOV #0x0, W5
001540  90031E     MOV [W14+2], W6
001542  B9B304     MUL.SS W6, W4, W6
001544  780306     MOV W6, W6
001546  78039E     MOV [W14], W7
001548  B9B805     MUL.SS W7, W5, W0
00154A  780380     MOV W0, W7
00154C  430307     ADD W6, W7, W6
00154E  78039E     MOV [W14], W7
001550  780204     MOV W4, W4
001552  B82207     MUL.UU W4, W7, W4
001554  430305     ADD W6, W5, W6
001556  780286     MOV W6, W5
001558  BE8F04     MOV.D W4, [W14]
00155A  BE8F04     MOV.D W4, [W14]
1515:                  temp_32_bit /= den;
00155C  90024E     MOV [W14+8], W4
00155E  200005     MOV #0x0, W5
001560  BE0104     MOV.D W4, W2
001562  BE001E     MOV.D [W14], W0
001564  07F6A8     RCALL ___udivsi3
001566  BE0200     MOV.D W0, W4
001568  BE8F04     MOV.D W4, [W14]
1516:                  ptr_ps->v_scaled_set_point = temp_32_bit & 0x0000FFFF;
00156A  78029E     MOV [W14], W5
00156C  90022E     MOV [W14+4], W4
00156E  980225     MOV W5, [W4+4]
1517:                  
1518:                  // Scale i_set_point by num/den
1519:                  temp_32_bit = ptr_ps->i_command_set_point;
001570  90022E     MOV [W14+4], W4
001572  901274     MOV [W4+46], W4
001574  200005     MOV #0x0, W5
001576  BE8F04     MOV.D W4, [W14]
1520:                  temp_32_bit *= num;
001578  90023E     MOV [W14+6], W4
00157A  200005     MOV #0x0, W5
00157C  90031E     MOV [W14+2], W6
00157E  B9B304     MUL.SS W6, W4, W6
001580  780306     MOV W6, W6
001582  78039E     MOV [W14], W7
001584  B9B805     MUL.SS W7, W5, W0
001586  780380     MOV W0, W7
001588  430307     ADD W6, W7, W6
00158A  78039E     MOV [W14], W7
00158C  780204     MOV W4, W4
00158E  B82207     MUL.UU W4, W7, W4
001590  430305     ADD W6, W5, W6
001592  780286     MOV W6, W5
001594  BE8F04     MOV.D W4, [W14]
001596  BE8F04     MOV.D W4, [W14]
1521:                  temp_32_bit /= den;
001598  90024E     MOV [W14+8], W4
00159A  200005     MOV #0x0, W5
00159C  BE0104     MOV.D W4, W2
00159E  BE001E     MOV.D [W14], W0
0015A0  07F68A     RCALL ___udivsi3
0015A2  BE0200     MOV.D W0, W4
0015A4  BE8F04     MOV.D W4, [W14]
1522:                  ptr_ps->i_scaled_set_point = temp_32_bit & 0x0000FFFF;
0015A6  78029E     MOV [W14], W5
0015A8  90022E     MOV [W14+4], W4
0015AA  981A05     MOV W5, [W4+48]
1523:              
1524:                }
1525:                // Send these scaled values to the DAC and Under/Over setting registers
1526:                CalcPowerSupplySettings(ptr_ps);
0015AC  90002E     MOV [W14+4], W0
0015AE  070002     RCALL CalcPowerSupplySettings
1527:              }
0015B0  FA8000     ULNK
0015B2  060000     RETURN
1528:              
1529:              
1530:              
1531:              void CalcPowerSupplySettings(POWERSUPPLY* ptr_ps) {
0015B4  FA0006     LNK #0x6
0015B6  980720     MOV W0, [W14+4]
1532:                unsigned int v_temp;
1533:                unsigned int i_temp;
1534:                // This function generates DAC settings and ADC trip points based on the passed voltage and current set point
1535:                
1536:                // Generate the DAC Values associated with the set points
1537:                v_temp = Scale16Bit(ptr_ps->v_scaled_set_point, ptr_ps->v_dac_scale);
0015B8  90022E     MOV [W14+4], W4
0015BA  9002D4     MOV [W4+10], W5
0015BC  90022E     MOV [W14+4], W4
0015BE  900224     MOV [W4+4], W4
0015C0  780085     MOV W5, W1
0015C2  780004     MOV W4, W0
0015C4  070680     RCALL Scale16Bit
0015C6  780200     MOV W0, W4
0015C8  780F04     MOV W4, [W14]
1538:                v_temp = Scale16Bit(v_temp, ptr_ps->v_dac_cal_gain);
0015CA  90022E     MOV [W14+4], W4
0015CC  900264     MOV [W4+12], W4
0015CE  780084     MOV W4, W1
0015D0  78001E     MOV [W14], W0
0015D2  070679     RCALL Scale16Bit
0015D4  780200     MOV W0, W4
0015D6  780F04     MOV W4, [W14]
1539:                if (ptr_ps->v_dac_cal_offset > 0) {
0015D8  90022E     MOV [W14+4], W4
0015DA  900274     MOV [W4+14], W4
0015DC  520FE0     SUB W4, #0x0, [W15]
0015DE  34000C     BRA LE, 0x15F8
1540:                  // the offset is positive check for overflow above 0xFFFF
1541:                  if ((0xFFFF-ptr_ps->v_dac_cal_offset) < v_temp) {
0015E0  90022E     MOV [W14+4], W4
0015E2  900274     MOV [W4+14], W4
0015E4  EA8204     COM W4, W4
0015E6  520F9E     SUB W4, [W14], [W15]
0015E8  310003     BRA C, 0x15F0
1542:                    v_temp = 0xFFFF;
0015EA  EB8200     SETM W4
0015EC  780F04     MOV W4, [W14]
0015EE  37000F     BRA 0x160E
1543:                  } else {
1544:                    v_temp = v_temp + ptr_ps->v_dac_cal_offset;
0015F0  90022E     MOV [W14+4], W4
0015F2  900274     MOV [W4+14], W4
0015F4  420F1E     ADD W4, [W14], [W14]
0015F6  37000B     BRA 0x160E
1545:                  }
1546:                } else {
1547:                  // the offset is negative check for overflow below 0x0000
1548:                  if ((0-ptr_ps->v_dac_cal_offset) > v_temp) {
0015F8  90022E     MOV [W14+4], W4
0015FA  900274     MOV [W4+14], W4
0015FC  EA0204     NEG W4, W4
0015FE  520F9E     SUB W4, [W14], [W15]
001600  360003     BRA LEU, 0x1608
1549:                    v_temp = 0x0000;
001602  EB0200     CLR W4
001604  780F04     MOV W4, [W14]
001606  370003     BRA 0x160E
1550:                  } else {
1551:                    v_temp = v_temp + ptr_ps->v_dac_cal_offset;
001608  90022E     MOV [W14+4], W4
00160A  900274     MOV [W4+14], W4
00160C  420F1E     ADD W4, [W14], [W14]
1552:                  }
1553:                }
1554:                ptr_ps->v_dac_set_point = v_temp;
00160E  90022E     MOV [W14+4], W4
001610  78029E     MOV [W14], W5
001612  980245     MOV W5, [W4+8]
1555:                
1556:                i_temp = Scale16Bit(ptr_ps->i_scaled_set_point, ptr_ps->i_dac_scale);
001614  90022E     MOV [W14+4], W4
001616  901AB4     MOV [W4+54], W5
001618  90022E     MOV [W14+4], W4
00161A  901A04     MOV [W4+48], W4
00161C  780085     MOV W5, W1
00161E  780004     MOV W4, W0
001620  070652     RCALL Scale16Bit
001622  780200     MOV W0, W4
001624  980714     MOV W4, [W14+2]
1557:                i_temp = Scale16Bit(i_temp, ptr_ps->i_dac_cal_gain);
001626  90022E     MOV [W14+4], W4
001628  901A44     MOV [W4+56], W4
00162A  780084     MOV W4, W1
00162C  90001E     MOV [W14+2], W0
00162E  07064B     RCALL Scale16Bit
001630  780200     MOV W0, W4
001632  980714     MOV W4, [W14+2]
1558:                if (ptr_ps->i_dac_cal_offset > 0) {
001634  90022E     MOV [W14+4], W4
001636  901A54     MOV [W4+58], W4
001638  520FE0     SUB W4, #0x0, [W15]
00163A  34000F     BRA LE, 0x165A
1559:                  // the offset is positive check for overflow above 0xFFFF
1560:                  if ((0xFFFF-ptr_ps->i_dac_cal_offset) < i_temp) {
00163C  90022E     MOV [W14+4], W4
00163E  901A54     MOV [W4+58], W4
001640  EA8284     COM W4, W5
001642  90021E     MOV [W14+2], W4
001644  528F84     SUB W5, W4, [W15]
001646  310003     BRA C, 0x164E
1561:                    i_temp = 0xFFFF;
001648  EB8200     SETM W4
00164A  980714     MOV W4, [W14+2]
00164C  370015     BRA 0x1678
1562:                  } else {
1563:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
00164E  90022E     MOV [W14+4], W4
001650  901A54     MOV [W4+58], W4
001652  90029E     MOV [W14+2], W5
001654  428204     ADD W5, W4, W4
001656  980714     MOV W4, [W14+2]
001658  37000F     BRA 0x1678
1564:                  }
1565:                } else {
1566:                  // the offset is negative check for overflow below 0x0000
1567:                  if ((0-ptr_ps->i_dac_cal_offset) > i_temp) {
00165A  90022E     MOV [W14+4], W4
00165C  901A54     MOV [W4+58], W4
00165E  EA0204     NEG W4, W4
001660  780284     MOV W4, W5
001662  90021E     MOV [W14+2], W4
001664  528F84     SUB W5, W4, [W15]
001666  360003     BRA LEU, 0x166E
1568:                    i_temp = 0x0000;
001668  EB0200     CLR W4
00166A  980714     MOV W4, [W14+2]
00166C  370005     BRA 0x1678
1569:                  } else {
1570:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
00166E  90022E     MOV [W14+4], W4
001670  901A54     MOV [W4+58], W4
001672  90029E     MOV [W14+2], W5
001674  428204     ADD W5, W4, W4
001676  980714     MOV W4, [W14+2]
1571:                  }
1572:                }
1573:                ptr_ps->i_dac_set_point = i_temp;
001678  90022E     MOV [W14+4], W4
00167A  90029E     MOV [W14+2], W5
00167C  981A25     MOV W5, [W4+52]
1574:                
1575:                
1576:                // Set all of the over/under trip points based on the set point
1577:                v_temp = Scale16Bit(ptr_ps->v_scaled_set_point, ptr_ps->v_adc_scale);
00167E  90022E     MOV [W14+4], W4
001680  900A94     MOV [W4+18], W5
001682  90022E     MOV [W14+4], W4
001684  900224     MOV [W4+4], W4
001686  780085     MOV W5, W1
001688  780004     MOV W4, W0
00168A  07061D     RCALL Scale16Bit
00168C  780200     MOV W0, W4
00168E  780F04     MOV W4, [W14]
1578:                v_temp = Scale16Bit(v_temp, ptr_ps->v_adc_cal_gain);
001690  90022E     MOV [W14+4], W4
001692  900A24     MOV [W4+20], W4
001694  780084     MOV W4, W1
001696  78001E     MOV [W14], W0
001698  070616     RCALL Scale16Bit
00169A  780200     MOV W0, W4
00169C  780F04     MOV W4, [W14]
1579:                if (ptr_ps->v_adc_cal_offset > 0) {
00169E  90022E     MOV [W14+4], W4
0016A0  900A34     MOV [W4+22], W4
0016A2  520FE0     SUB W4, #0x0, [W15]
0016A4  34000C     BRA LE, 0x16BE
1580:                  // the offset is positive check for overflow above 0xFFFF
1581:                  if ((0xFFFF-ptr_ps->v_adc_cal_offset) < v_temp) {
0016A6  90022E     MOV [W14+4], W4
0016A8  900A34     MOV [W4+22], W4
0016AA  EA8204     COM W4, W4
0016AC  520F9E     SUB W4, [W14], [W15]
0016AE  310003     BRA C, 0x16B6
1582:                    v_temp = 0xFFFF;
0016B0  EB8200     SETM W4
0016B2  780F04     MOV W4, [W14]
0016B4  37000F     BRA 0x16D4
1583:                  } else {
1584:                    v_temp = v_temp + ptr_ps->v_adc_cal_offset;
0016B6  90022E     MOV [W14+4], W4
0016B8  900A34     MOV [W4+22], W4
0016BA  420F1E     ADD W4, [W14], [W14]
0016BC  37000B     BRA 0x16D4
1585:                  }
1586:                } else {
1587:                  // the offset is negative check for overflow below 0x0000
1588:                  if ((0-ptr_ps->v_adc_cal_offset) > v_temp) {
0016BE  90022E     MOV [W14+4], W4
0016C0  900A34     MOV [W4+22], W4
0016C2  EA0204     NEG W4, W4
0016C4  520F9E     SUB W4, [W14], [W15]
0016C6  360003     BRA LEU, 0x16CE
1589:                    v_temp = 0x0000;
0016C8  EB0200     CLR W4
0016CA  780F04     MOV W4, [W14]
0016CC  370003     BRA 0x16D4
1590:                  } else {
1591:                    v_temp = v_temp + ptr_ps->v_adc_cal_offset;
0016CE  90022E     MOV [W14+4], W4
0016D0  900A34     MOV [W4+22], W4
0016D2  420F1E     ADD W4, [W14], [W14]
1592:                  }
1593:                }
1594:              
1595:                ptr_ps->v_adc_over_rel = Scale16Bit(v_temp, ptr_ps->v_adc_over_scale);
0016D4  90022E     MOV [W14+4], W4
0016D6  900A74     MOV [W4+30], W4
0016D8  780084     MOV W4, W1
0016DA  78001E     MOV [W14], W0
0016DC  0705F4     RCALL Scale16Bit
0016DE  780200     MOV W0, W4
0016E0  9002AE     MOV [W14+4], W5
0016E2  980AD4     MOV W4, [W5+26]
1596:                ptr_ps->v_adc_under_rel = Scale16Bit(v_temp,ptr_ps-> v_adc_under_scale);
0016E4  90022E     MOV [W14+4], W4
0016E6  901204     MOV [W4+32], W4
0016E8  780084     MOV W4, W1
0016EA  78001E     MOV [W14], W0
0016EC  0705EC     RCALL Scale16Bit
0016EE  780200     MOV W0, W4
0016F0  9002AE     MOV [W14+4], W5
0016F2  980AE4     MOV W4, [W5+28]
1597:                if (ptr_ps->v_adc_over_rel < ptr_ps->v_adc_over_min_value) {
0016F4  90022E     MOV [W14+4], W4
0016F6  900AD4     MOV [W4+26], W5
0016F8  90022E     MOV [W14+4], W4
0016FA  901214     MOV [W4+34], W4
0016FC  528F84     SUB W5, W4, [W15]
0016FE  310004     BRA C, 0x1708
1598:                  ptr_ps->v_adc_over_rel = ptr_ps->v_adc_over_min_value;
001700  90022E     MOV [W14+4], W4
001702  901294     MOV [W4+34], W5
001704  90022E     MOV [W14+4], W4
001706  980A55     MOV W5, [W4+26]
1599:                }
1600:                
1601:                i_temp = Scale16Bit(ptr_ps->i_scaled_set_point, ptr_ps->i_adc_scale);
001708  90022E     MOV [W14+4], W4
00170A  901AF4     MOV [W4+62], W5
00170C  90022E     MOV [W14+4], W4
00170E  901A04     MOV [W4+48], W4
001710  780085     MOV W5, W1
001712  780004     MOV W4, W0
001714  0705D8     RCALL Scale16Bit
001716  780200     MOV W0, W4
001718  980714     MOV W4, [W14+2]
1602:                i_temp = Scale16Bit(i_temp, ptr_ps->i_adc_cal_gain);
00171A  90022E     MOV [W14+4], W4
00171C  902204     MOV [W4+64], W4
00171E  780084     MOV W4, W1
001720  90001E     MOV [W14+2], W0
001722  0705D1     RCALL Scale16Bit
001724  780200     MOV W0, W4
001726  980714     MOV W4, [W14+2]
1603:                if (ptr_ps->i_adc_cal_offset > 0) {
001728  90022E     MOV [W14+4], W4
00172A  902214     MOV [W4+66], W4
00172C  520FE0     SUB W4, #0x0, [W15]
00172E  34000F     BRA LE, 0x174E
1604:                  // the offset is positive check for overflow above 0xFFFF
1605:                  if ((0xFFFF-ptr_ps->i_adc_cal_offset) < i_temp) {
001730  90022E     MOV [W14+4], W4
001732  902214     MOV [W4+66], W4
001734  EA8284     COM W4, W5
001736  90021E     MOV [W14+2], W4
001738  528F84     SUB W5, W4, [W15]
00173A  310003     BRA C, 0x1742
1606:                    i_temp = 0xFFFF;
00173C  EB8200     SETM W4
00173E  980714     MOV W4, [W14+2]
001740  370015     BRA 0x176C
1607:                  } else {
1608:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
001742  90022E     MOV [W14+4], W4
001744  901A54     MOV [W4+58], W4
001746  90029E     MOV [W14+2], W5
001748  428204     ADD W5, W4, W4
00174A  980714     MOV W4, [W14+2]
00174C  37000F     BRA 0x176C
1609:                  }
1610:                } else {
1611:                  // the offset is negative check for overflow below 0x0000
1612:                  if ((0-ptr_ps->i_adc_cal_offset) > i_temp) {
00174E  90022E     MOV [W14+4], W4
001750  902214     MOV [W4+66], W4
001752  EA0204     NEG W4, W4
001754  780284     MOV W4, W5
001756  90021E     MOV [W14+2], W4
001758  528F84     SUB W5, W4, [W15]
00175A  360003     BRA LEU, 0x1762
1613:                    i_temp = 0x0000;
00175C  EB0200     CLR W4
00175E  980714     MOV W4, [W14+2]
001760  370005     BRA 0x176C
1614:                  } else {
1615:                    i_temp = i_temp + ptr_ps->i_adc_cal_offset;
001762  90022E     MOV [W14+4], W4
001764  902214     MOV [W4+66], W4
001766  90029E     MOV [W14+2], W5
001768  428204     ADD W5, W4, W4
00176A  980714     MOV W4, [W14+2]
1616:                  }
1617:                }
1618:              
1619:                /*
1620:                //  DPARKER NEED TO ADJUST THE OVER/UNDER SCALE SUCH THAT IT IS SET TO X Percent of MAX VALUE.  NOT PROGRAMED VALUE
1621:                //  This will overwrite the values calculated above
1622:                
1623:                
1624:                #define DPARKER_SCALE_5_PERCENT (410)  // This will be 5%
1625:                dan_temp = Scale16Bit(ptr_ps->v_max_set_point, DPARKER_SCALE_5_PERCENT);
1626:                
1627:                ptr_ps->v_adc_over_rel = v_temp + dan_temp;
1628:              
1629:                if (v_temp > dan_temp) {
1630:                  ptr_ps->v_adc_under_rel = v_temp - dan_temp;
1631:                } else {
1632:                  ptr_ps->v_adc_under_rel = 0;
1633:                }
1634:                
1635:              					       
1636:                // End New code to adjust the over scaling
1637:              
1638:                */
1639:              
1640:              
1641:              
1642:              
1643:                
1644:                ptr_ps->i_adc_over_rel = Scale16Bit(i_temp, ptr_ps->i_adc_over_scale);
00176C  90022E     MOV [W14+4], W4
00176E  902254     MOV [W4+74], W4
001770  780084     MOV W4, W1
001772  90001E     MOV [W14+2], W0
001774  0705A8     RCALL Scale16Bit
001776  780200     MOV W0, W4
001778  9002AE     MOV [W14+4], W5
00177A  9822B4     MOV W4, [W5+70]
1645:                ptr_ps->i_adc_under_rel = Scale16Bit(i_temp, ptr_ps->i_adc_under_scale);
00177C  90022E     MOV [W14+4], W4
00177E  902264     MOV [W4+76], W4
001780  780084     MOV W4, W1
001782  90001E     MOV [W14+2], W0
001784  0705A0     RCALL Scale16Bit
001786  780200     MOV W0, W4
001788  9002AE     MOV [W14+4], W5
00178A  9822C4     MOV W4, [W5+72]
1646:                if (ptr_ps->i_adc_over_rel < ptr_ps->i_adc_over_min_value) {
00178C  90022E     MOV [W14+4], W4
00178E  9022B4     MOV [W4+70], W5
001790  90022E     MOV [W14+4], W4
001792  902274     MOV [W4+78], W4
001794  528F84     SUB W5, W4, [W15]
001796  310004     BRA C, 0x17A0
1647:                  ptr_ps->i_adc_over_rel = ptr_ps->i_adc_over_min_value;
001798  90022E     MOV [W14+4], W4
00179A  9022F4     MOV [W4+78], W5
00179C  90022E     MOV [W14+4], W4
00179E  982235     MOV W5, [W4+70]
1648:                }
1649:                ClrWdt();
0017A0  FE6000     CLRWDT
1650:              }
0017A2  FA8000     ULNK
0017A4  060000     RETURN
1651:              
1652:              
1653:              
1654:              
1655:              void UpdateDacAll(void) {
0017A6  FA0012     LNK #0x12
1656:                unsigned int dac_value_array[8];
1657:                unsigned char dac_write_failed;
1658:                unsigned char number_tries;
1659:              
1660:                last_known_action = LAST_ACTION_UPDATE_DAC_ALL;
0017A8  2000A4     MOV #0xA, W4
0017AA  88C5A4     MOV W4, last_known_action
1661:              
1662:                dac_value_array[0] = ps_thyr_reservoir_htr.v_dac_set_point;
0017AC  805BC4     MOV 0xB78, W4
0017AE  980714     MOV W4, [W14+2]
1663:                dac_value_array[1] = ps_thyr_cathode_htr.v_dac_set_point;
0017B0  8058F4     MOV 0xB1E, W4
0017B2  980724     MOV W4, [W14+4]
1664:                dac_value_array[2] = ps_magnet.v_dac_set_point;
0017B4  805354     MOV 0xA6A, W4
0017B6  980734     MOV W4, [W14+6]
1665:                dac_value_array[3] = ps_magnet.i_dac_set_point;
0017B8  8054B4     MOV 0xA96, W4
0017BA  980744     MOV W4, [W14+8]
1666:                dac_value_array[4] = ps_filament.v_dac_set_point;
0017BC  805624     MOV 0xAC4, W4
0017BE  980754     MOV W4, [W14+10]
1667:                dac_value_array[5] = ps_filament.i_dac_set_point;
0017C0  805784     MOV 0xAF0, W4
0017C2  980764     MOV W4, [W14+12]
1668:                dac_value_array[6] = ps_hv_lambda_mode_A.v_dac_set_point;
0017C4  804814     MOV 0x902, W4
0017C6  980774     MOV W4, [W14+14]
1669:                dac_value_array[7] = ps_hv_lambda_mode_B.v_dac_set_point;
0017C8  804DB4     MOV 0x9B6, W4
0017CA  980F04     MOV W4, [W14+16]
1670:              
1671:                dac_write_failed = 1;
0017CC  B3C014     MOV #0x1, W4
0017CE  784F04     MOV.B W4, [W14]
1672:                number_tries = 0;
0017D0  EB4200     CLR.B W4
0017D2  984714     MOV.B W4, [W14+1]
1673:                while ((dac_write_failed != 0) & (number_tries < 20)) {
0017D4  370010     BRA 0x17F6
0017F6  78429E     MOV.B [W14], W5
0017F8  FB8205     ZE W5, W4
0017FA  EA0204     NEG W4, W4
0017FC  DE224F     LSR W4, #15, W4
0017FE  784284     MOV.B W4, W5
001800  B3C014     MOV #0x1, W4
001802  90431E     MOV.B [W14+1], W6
001804  534FF3     SUB.B W6, #0x13, [W15]
001806  360001     BRA LEU, 0x180A
001808  EB4200     CLR.B W4
00180A  62C204     AND.B W5, W4, W4
00180C  524FE0     SUB.B W4, #0x0, [W15]
00180E  3AFFE3     BRA NZ, 0x17D6
1674:                  dac_write_failed = WriteLTC2656AllDacChannels(&U44_LTC2656, dac_value_array);
0017D6  E8820E     INC2 W14, W4
0017D8  780084     MOV W4, W1
0017DA  208E20     MOV #0x8E2, W0
0017DC  071584     RCALL WriteLTC2656AllDacChannels
0017DE  784200     MOV.B W0, W4
0017E0  784F04     MOV.B W4, [W14]
1675:                  number_tries++;
0017E2  90421E     MOV.B [W14+1], W4
0017E4  E84204     INC.B W4, W4
0017E6  984714     MOV.B W4, [W14+1]
1676:                  if (dac_write_failed) {
0017E8  78421E     MOV.B [W14], W4
0017EA  524FE0     SUB.B W4, #0x0, [W15]
0017EC  320003     BRA Z, 0x17F4
1677:                    global_debug_counter.LTC2656_write_error++;
0017EE  80C2A4     MOV 0x1854, W4
0017F0  E80204     INC W4, W4
0017F2  88C2A4     MOV W4, 0x1854
1678:                  }
1679:                  ClrWdt();
0017F4  FE6000     CLRWDT
1680:                }
1681:                if (number_tries >= 20) {
001810  90421E     MOV.B [W14+1], W4
001812  524FF3     SUB.B W4, #0x13, [W15]
001814  360002     BRA LEU, 0x181A
1682:                  RecordThisControlBoardFault(FAULT_CB_SPI_UNRECOVERABLE_ERROR);
001816  200200     MOV #0x20, W0
001818  0713BD     RCALL RecordThisControlBoardFault
1683:                }
1684:              }
00181A  FA8000     ULNK
00181C  060000     RETURN
1685:              
1686:              
1687:              
1688:              
1689:              void Do10msTicToc(void) {
00181E  FA0004     LNK #0x4
1690:                /*
1691:                  Certain functions need to happen at regular interval for the system to work
1692:              
1693:                  Thyratron PIDs - The gain and phase of the PID control loop is a function of it's execution frequency therefor it must be updated at a regular interval
1694:                  Analog Filters - The filter response is function of the execution frequency so they must be executed at a regular interval
1695:              
1696:                  DAC updates - The DAC must be regularly.  Durring HV ON this should happen AFTER a pulse so that the SPI bus is not corrupted by EMI
1697:                  If the state is not in HV_ON or the system is pulsing at a very low freqeuncy, DAC updates must be handeled by this function.
1698:                  
1699:                  Calculating the PRF
1700:              
1701:                  Other timing functions like flashing LEDs
1702:                */
1703:              
1704:                unsigned int vtemp;
1705:                unsigned int itemp;
1706:              
1707:              
1708:                last_known_action = LAST_ACTION_DO_10MS;
001820  200094     MOV #0x9, W4
001822  88C5A4     MOV W4, last_known_action
1709:                
1710:                if (_POR) {
001824  803A04     MOV RCON, W4
001826  620261     AND W4, #0x1, W4
001828  520FE0     SUB W4, #0x0, [W15]
00182A  320003     BRA Z, 0x1832
1711:                  debug_status_register |= STATUS_POR_RESET;
00182C  80C2F4     MOV debug_status_register, W4
00182E  A04004     BSET W4, #4
001830  88C2F4     MOV W4, debug_status_register
1712:                  // _POR = 0;
1713:                }
1714:                if (_EXTR) {
001832  803A05     MOV RCON, W5
001834  200804     MOV #0x80, W4
001836  628204     AND W5, W4, W4
001838  520FE0     SUB W4, #0x0, [W15]
00183A  320004     BRA Z, 0x1844
1715:                  debug_status_register |= STATUS_EXTERNAL_RESET;
00183C  80C2F5     MOV debug_status_register, W5
00183E  200204     MOV #0x20, W4
001840  728204     IOR W5, W4, W4
001842  88C2F4     MOV W4, debug_status_register
1716:                  //_EXTR = 0;
1717:                }
1718:                if (_SWR) {
001844  803A05     MOV RCON, W5
001846  200404     MOV #0x40, W4
001848  628204     AND W5, W4, W4
00184A  520FE0     SUB W4, #0x0, [W15]
00184C  320004     BRA Z, 0x1856
1719:                  debug_status_register |= STATUS_SOFTARE_RESET;
00184E  80C2F5     MOV debug_status_register, W5
001850  200404     MOV #0x40, W4
001852  728204     IOR W5, W4, W4
001854  88C2F4     MOV W4, debug_status_register
1720:                  //_SWR = 0;
1721:                }
1722:                if (_BOR) {
001856  803A04     MOV RCON, W4
001858  620262     AND W4, #0x2, W4
00185A  520FE0     SUB W4, #0x0, [W15]
00185C  320003     BRA Z, 0x1864
1723:                  debug_status_register |= STATUS_BOR_RESET;
00185E  80C2F4     MOV debug_status_register, W4
001860  A00004     BSET W4, #0
001862  88C2F4     MOV W4, debug_status_register
1724:                  //_BOR = 0;
1725:                }
1726:                if (_TRAPR) {
001864  803A05     MOV RCON, W5
001866  280004     MOV #0x8000, W4
001868  628204     AND W5, W4, W4
00186A  520FE0     SUB W4, #0x0, [W15]
00186C  320003     BRA Z, 0x1874
1727:                  debug_status_register |= STATUS_TRAPR_RESET;
00186E  80C2F4     MOV debug_status_register, W4
001870  A01004     BSET W4, #1
001872  88C2F4     MOV W4, debug_status_register
1728:                  //_TRAPR = 0;
1729:                }
1730:                if (_WDTO) {
001874  803A04     MOV RCON, W4
001876  620270     AND W4, #0x10, W4
001878  520FE0     SUB W4, #0x0, [W15]
00187A  320003     BRA Z, 0x1882
1731:                  debug_status_register |= STATUS_WDT_RESET;
00187C  80C2F4     MOV debug_status_register, W4
00187E  A02004     BSET W4, #2
001880  88C2F4     MOV W4, debug_status_register
1732:                  // _WDTO = 0;
1733:                }
1734:                if (_IOPUWR) {
001882  803A05     MOV RCON, W5
001884  240004     MOV #0x4000, W4
001886  628204     AND W5, W4, W4
001888  520FE0     SUB W4, #0x0, [W15]
00188A  320003     BRA Z, 0x1892
1735:                  debug_status_register |= STATUS_IOPUWR_RESET;
00188C  80C2F4     MOV debug_status_register, W4
00188E  A03004     BSET W4, #3
001890  88C2F4     MOV W4, debug_status_register
1736:                  //_IOPUWR = 0;
1737:                }
1738:              
1739:              
1740:                ClrWdt();
001892  FE6000     CLRWDT
1741:                if (_T5IF) {
001894  800435     MOV IFS1, W5
001896  200404     MOV #0x40, W4
001898  628204     AND W5, W4, W4
00189A  520FE0     SUB W4, #0x0, [W15]
00189C  32008C     BRA Z, 0x19B6
1742:                  _T5IF = 0;
00189E  A9C086     BCLR IFS1, #6
1743:                  //10ms roll has occured
1744:                  
1745:                  led_pulse_count = ((led_pulse_count + 1) & 0b00001111);
0018A0  804224     MOV led_pulse_count, W4
0018A2  E80204     INC W4, W4
0018A4  62026F     AND W4, #0xF, W4
0018A6  884224     MOV W4, led_pulse_count
1746:                  if (led_pulse_count == 0) {
0018A8  804224     MOV led_pulse_count, W4
0018AA  520FE0     SUB W4, #0x0, [W15]
0018AC  3A0014     BRA NZ, 0x18D6
1747:                    // 10ms * 16 counter has ocurred
1748:                    // Flash the LED - NOTE "PIN_MAIN_CONTACTOR_CLOSE = !PIN_MAIN_CONTACTOR_CLOSE" was causing any changes made in Port F durring interrupt to be overwritten
1749:                    if (PIN_MAIN_CONTACTOR_CLOSE) {
0018AE  801714     MOV LATF, W4
0018B0  620261     AND W4, #0x1, W4
0018B2  520FE0     SUB W4, #0x0, [W15]
0018B4  320002     BRA Z, 0x18BA
1750:              	PIN_MAIN_CONTACTOR_CLOSE = 0;
0018B6  A902E2     BCLR LATF, #0
0018B8  370001     BRA 0x18BC
1751:                    } else {
1752:              	PIN_MAIN_CONTACTOR_CLOSE = 1;
0018BA  A802E2     BSET LATF, #0
1753:                    }  
1754:                    
1755:                    average_pulse_repetition_frequency_deci_herz = RCFilter16Tau(average_pulse_repetition_frequency_deci_herz, ((prf_pulse_counter*125)>>1));
0018BC  804185     MOV prf_pulse_counter, W5
0018BE  2007D4     MOV #0x7D, W4
0018C0  B9AA04     MUL.SS W5, W4, W4
0018C2  780204     MOV W4, W4
0018C4  D10284     LSR W4, W5
0018C6  804174     MOV average_pulse_repetition_frequency_deci_herz, W4
0018C8  780085     MOV W5, W1
0018CA  780004     MOV W4, W0
0018CC  0705A2     RCALL RCFilter16Tau
0018CE  780200     MOV W0, W4
0018D0  884174     MOV W4, average_pulse_repetition_frequency_deci_herz
1756:                    prf_pulse_counter = 0;  
0018D2  EB0200     CLR W4
0018D4  884184     MOV W4, prf_pulse_counter
1757:                  }
1758:                  
1759:                  
1760:                  if ((PIN_FP_MODULATOR_RESET == !ILL_MODULATOR_RESET) && (start_reset_process)) {
0018D6  801735     MOV PORTG, W5
0018D8  220004     MOV #0x2000, W4
0018DA  628204     AND W5, W4, W4
0018DC  520FE0     SUB W4, #0x0, [W15]
0018DE  320006     BRA Z, 0x18EC
0018E0  804134     MOV start_reset_process, W4
0018E2  520FE0     SUB W4, #0x0, [W15]
0018E4  320003     BRA Z, 0x18EC
1761:                    ResetAllFaults();
0018E6  07110A     RCALL ResetAllFaults
1762:                    ResetHWLatches(); // Clear the hardware Latches
0018E8  071101     RCALL ResetHWLatches
1763:                    ResetPulseLatches();
0018EA  0710F8     RCALL ResetPulseLatches
1764:                  }
1765:                  
1766:                  if (PIN_FP_MODULATOR_RESET == ILL_MODULATOR_RESET) {
0018EC  801735     MOV PORTG, W5
0018EE  220004     MOV #0x2000, W4
0018F0  628204     AND W5, W4, W4
0018F2  520FE0     SUB W4, #0x0, [W15]
0018F4  3A0003     BRA NZ, 0x18FC
1767:                    // Start the Reset Process
1768:                    start_reset_process = 1;
0018F6  200014     MOV #0x1, W4
0018F8  884134     MOV W4, start_reset_process
0018FA  370002     BRA 0x1900
1769:                  } else {
1770:                    start_reset_process = 0;
0018FC  EB0200     CLR W4
0018FE  884134     MOV W4, start_reset_process
1771:                  }
1772:                      
1773:                  // ResetSPI1(); // ResetSPI(2) // DPARKER - This may be requried to fix bit errors in the SPI bus
1774:                  
1775:                  
1776:                  FilterADCs();  // Read Data from the DAC arrays, average, and filter
001900  07016A     RCALL FilterADCs
1777:                  
1778:                  // If the magnet current is based on mode A program voltage (instead of from GUI), set the magnet current based on mode A program voltage
1779:                  if (!ram_config_set_magnetron_magnet_current_from_GUI) {
001902  208224     MOV #0x822, W4
001904  784214     MOV.B [W4], W4
001906  524FE0     SUB.B W4, #0x0, [W15]
001908  3A000D     BRA NZ, 0x1924
1780:                    // The Magnet Current is calculated from Mode A program voltage
1781:                    itemp = CalculatePoly(ps_hv_lambda_mode_A.v_command_set_point);
00190A  8047E4     MOV 0x8FC, W4
00190C  780004     MOV W4, W0
00190E  07076A     RCALL CalculatePoly
001910  780200     MOV W0, W4
001912  780F04     MOV W4, [W14]
1782:                    vtemp = GenerateMagnetVprog(itemp);
001914  78001E     MOV [W14], W0
001916  070F13     RCALL GenerateMagnetVprog
001918  780200     MOV W0, W4
00191A  980714     MOV W4, [W14+2]
1783:                    SetPowerSupplyTarget(&ps_magnet, vtemp, itemp);
00191C  78011E     MOV [W14], W2
00191E  90009E     MOV [W14+2], W1
001920  20A620     MOV #0xA62, W0
001922  07FDC5     RCALL SetPowerSupplyTarget
1784:                  }
1785:                
1786:                  if ((control_state == STATE_SYSTEM_COLD_READY) || (control_state == STATE_FAULT_COLD_FAULT)) {
001924  208324     MOV #0x832, W4
001926  784214     MOV.B [W4], W4
001928  524FF4     SUB.B W4, #0x14, [W15]
00192A  320005     BRA Z, 0x1936
00192C  208325     MOV #0x832, W5
00192E  784295     MOV.B [W5], W5
001930  B3CA44     MOV #0xA4, W4
001932  52CF84     SUB.B W5, W4, [W15]
001934  3A0018     BRA NZ, 0x1966
1787:                    ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
001936  200642     MOV #0x64, W2
001938  EB0080     CLR W1
00193A  208FA0     MOV #0x8FA, W0
00193C  07FDEA     RCALL ScalePowerSupply
1788:                    ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
00193E  200642     MOV #0x64, W2
001940  EB0080     CLR W1
001942  208FA0     MOV #0x8FA, W0
001944  07FDE6     RCALL ScalePowerSupply
1789:                    ScalePowerSupply(&ps_filament,0,100);
001946  200642     MOV #0x64, W2
001948  EB0080     CLR W1
00194A  20ABC0     MOV #0xABC, W0
00194C  07FDE2     RCALL ScalePowerSupply
1790:                    ScalePowerSupply(&ps_magnet,0,100);
00194E  200642     MOV #0x64, W2
001950  EB0080     CLR W1
001952  20A620     MOV #0xA62, W0
001954  07FDDE     RCALL ScalePowerSupply
1791:                    ScalePowerSupply(&ps_thyr_reservoir_htr,0,100);
001956  200642     MOV #0x64, W2
001958  EB0080     CLR W1
00195A  20B700     MOV #0xB70, W0
00195C  07FDDA     RCALL ScalePowerSupply
1792:                    ScalePowerSupply(&ps_thyr_cathode_htr,0,100);
00195E  200642     MOV #0x64, W2
001960  EB0080     CLR W1
001962  20B160     MOV #0xB16, W0
001964  07FDD6     RCALL ScalePowerSupply
1793:                  }
1794:              
1795:              
1796:              
1797:              
1798:                  UpdateFaults();  // Update all the fault registers.  Note this must only happen once every 10ms because some faults are timed
001966  070FAC     RCALL UpdateFaults
1799:                  //  DPARKER figure out some better way to timer certain faults
1800:                
1801:                  // Update the sum fault outputs (copper and fiber)
1802:                  if (CheckFaultActive()) {
001968  07133B     RCALL CheckFaultActive
00196A  780200     MOV W0, W4
00196C  520FE0     SUB W4, #0x0, [W15]
00196E  320003     BRA Z, 0x1976
1803:                    PIN_SUM_FAULT_FIBER = OLL_SUM_FAULT_FIBER_FAULT;
001970  A9E2C4     BCLR LATA, #7
1804:                    PIN_SUM_FAULT_COPPER = OLL_SUM_FAULT_COPPER_FAULT;
001972  A942D0     BCLR LATC, #2
001974  370002     BRA 0x197A
1805:                  } else {
1806:                    PIN_SUM_FAULT_FIBER = !OLL_SUM_FAULT_FIBER_FAULT;
001976  A8E2C4     BSET LATA, #7
1807:                    PIN_SUM_FAULT_COPPER = !OLL_SUM_FAULT_COPPER_FAULT;
001978  A842D0     BSET LATC, #2
1808:                  }
1809:                  
1810:                  slow_down_thyratron_pid_counter++;
00197A  208284     MOV #0x828, W4
00197C  784214     MOV.B [W4], W4
00197E  E84204     INC.B W4, W4
001980  784004     MOV.B W4, W0
001982  B7E828     MOV.B WREG, slow_down_thyratron_pid_counter
1811:                  slow_down_thyratron_pid_counter &= 0b00001111;
001984  208284     MOV #0x828, W4
001986  784214     MOV.B [W4], W4
001988  62426F     AND.B W4, #0xF, W4
00198A  784004     MOV.B W4, W0
00198C  B7E828     MOV.B WREG, slow_down_thyratron_pid_counter
1812:                  if (slow_down_thyratron_pid_counter == 0) {
00198E  208284     MOV #0x828, W4
001990  784214     MOV.B [W4], W4
001992  524FE0     SUB.B W4, #0x0, [W15]
001994  3A0001     BRA NZ, 0x1998
1813:                    //execute PID loop once every 160ms
1814:                    DoThyratronPIDs();
001996  070011     RCALL DoThyratronPIDs
1815:                  }
1816:                  
1817:              
1818:                  // The system is configured to adjust the filament power based on magnetron power.  Otherwise the filament power will be maxed at all times
1819:                  DoMagnetronFilamentAdjust();
001998  070073     RCALL DoMagnetronFilamentAdjust
1820:              
1821:                  if ((control_state != STATE_HV_ON) || (_T2IF)) {
00199A  208325     MOV #0x832, W5
00199C  784295     MOV.B [W5], W5
00199E  B3C444     MOV #0x44, W4
0019A0  52CF84     SUB.B W5, W4, [W15]
0019A2  3A0005     BRA NZ, 0x19AE
0019A4  800425     MOV IFS0, W5
0019A6  200404     MOV #0x40, W4
0019A8  628204     AND W5, W4, W4
0019AA  520FE0     SUB W4, #0x0, [W15]
0019AC  320004     BRA Z, 0x19B6
1822:                    // Do10msTicToc needs to be responsible for updating the DAC
1823:                    UpdateDacAll();
0019AE  07FEFB     RCALL UpdateDacAll
1824:                    UpdateIOExpanderOutputs();
0019B0  070395     RCALL UpdateIOExpanderOutputs
1825:                    pulse_counter_this_run = 0;
0019B2  EB0200     CLR W4
0019B4  8840F4     MOV W4, pulse_counter_this_run
1826:                  } 
1827:                } 
1828:              }
0019B6  FA8000     ULNK
0019B8  060000     RETURN
1829:              
1830:              
1831:              
1832:              
1833:              
1834:              void DoThyratronPIDs(void) {
0019BA  FA0002     LNK #0x2
1835:                /*
1836:                  The pid functions provided by dsp.h use Q15 fractional data.
1837:                  This represents fractional inputs/outputs from -1 to 1.
1838:                  Our inputs to the PID come from an unipolar ADC.
1839:                  The control output of the PID goes directly to a DAC.
1840:                  In order for the PID control to work with our unsigned 16 bit data two changed must be made.
1841:                  (1) Measured output must be converted from 16 bit data to Q(15).  This is easily done by shifting one bit to the right.
1842:                      From to PIDs point of view we are just decreasing our resolution by 1 bit, not a problem here.
1843:                  (2) Control output must be convereted so that it can iterface to our DAC.
1844:                      The control output ranges from -1 to 1.  so perform the following logic.
1845:              	If (control_output < 0) then (control_output = 0).
1846:              	Multiply control_output by 2 (shift left 1 bit) to use the full range of the DAC.
1847:              	NOTE: You must perform the math like this we because the PID will set the output to Zero at start.
1848:              	If you shift the entire 16 bits to unsinged interger, 0 will become 0x7FFF and your control_output will start at 50%, not zero!!!!
1849:                  (3) In order to set the DAC the control output "is moved" to v_dac_set_point register by setting v_dac_scale to zero, v_dac_cal_gain to zero
1850:                      and setting v_dac_cal_offset to 0x1000 "zero level" + the output of the PID loop (which ranges from zero to 0xFFFF)
1851:                  (4) If the DAC setting exceeds an output program of 2V (32000 or 0x7D00) , then we have saturated the output.  Throw some faults
1852:                */
1853:              
1854:                unsigned int temp;
1855:              
1856:                last_known_action = LAST_ACTION_DO_THYRATRON_PID;
0019BC  200084     MOV #0x8, W4
0019BE  88C5A4     MOV W4, last_known_action
1857:              
1858:                // Run the Thyratron Heaters PID loops on the latest data
1859:                // bit shift the data 1 bit to the right because the PID loop is expecting Q15
1860:                temp = Scale16Bit(ps_thyr_reservoir_htr.v_scaled_set_point, ps_thyr_reservoir_htr.v_adc_scale);
0019C0  805C15     MOV 0xB82, W5
0019C2  805BA4     MOV 0xB74, W4
0019C4  780085     MOV W5, W1
0019C6  780004     MOV W4, W0
0019C8  07047E     RCALL Scale16Bit
0019CA  780200     MOV W0, W4
0019CC  780F04     MOV W4, [W14]
1861:                temp = Scale16Bit(temp, ps_thyr_reservoir_htr.v_adc_cal_gain);
0019CE  805C24     MOV 0xB84, W4
0019D0  780084     MOV W4, W1
0019D2  78001E     MOV [W14], W0
0019D4  070478     RCALL Scale16Bit
0019D6  780200     MOV W0, W4
0019D8  780F04     MOV W4, [W14]
1862:                temp = temp + ps_thyr_reservoir_htr.v_adc_cal_offset;
0019DA  805C34     MOV 0xB86, W4
0019DC  420F1E     ADD W4, [W14], [W14]
1863:                thyratron_reservoir_heater_PID.controlReference = (temp >> 1);
0019DE  78021E     MOV [W14], W4
0019E0  D10204     LSR W4, W4
0019E2  884294     MOV W4, 0x852
1864:                thyratron_reservoir_heater_PID.measuredOutput = (ps_thyr_reservoir_htr.v_adc_reading >> 1);
0019E4  805C04     MOV 0xB80, W4
0019E6  D10204     LSR W4, W4
0019E8  884284     MOV W4, 0x850
1865:                PID(&thyratron_reservoir_heater_PID);
0019EA  2084A0     MOV #0x84A, W0
0019EC  07F3D3     RCALL _PID
1866:              
1867:              
1868:                temp = Scale16Bit(ps_thyr_cathode_htr.v_scaled_set_point, ps_thyr_cathode_htr.v_adc_scale);
0019EE  805945     MOV 0xB28, W5
0019F0  8058D4     MOV 0xB1A, W4
0019F2  780085     MOV W5, W1
0019F4  780004     MOV W4, W0
0019F6  070467     RCALL Scale16Bit
0019F8  780200     MOV W0, W4
0019FA  780F04     MOV W4, [W14]
1869:                temp = Scale16Bit(temp, ps_thyr_cathode_htr.v_adc_cal_gain);
0019FC  805954     MOV 0xB2A, W4
0019FE  780084     MOV W4, W1
001A00  78001E     MOV [W14], W0
001A02  070461     RCALL Scale16Bit
001A04  780200     MOV W0, W4
001A06  780F04     MOV W4, [W14]
1870:                temp = temp + ps_thyr_cathode_htr.v_adc_cal_offset;
001A08  805964     MOV 0xB2C, W4
001A0A  420F1E     ADD W4, [W14], [W14]
1871:                thyratron_cathode_heater_PID.controlReference = (temp >> 1);
001A0C  78021E     MOV [W14], W4
001A0E  D10204     LSR W4, W4
001A10  8842E4     MOV W4, 0x85C
1872:                thyratron_cathode_heater_PID.measuredOutput = (ps_thyr_cathode_htr.v_adc_reading >> 1);
001A12  805934     MOV 0xB26, W4
001A14  D10204     LSR W4, W4
001A16  8842D4     MOV W4, 0x85A
1873:                PID(&thyratron_cathode_heater_PID);
001A18  208540     MOV #0x854, W0
001A1A  07F3BC     RCALL _PID
1874:                
1875:              
1876:                // Update the DAC setting for the Reservoir Heater
1877:                // The output of the PID is Q15, convert to 16 bit unsigned for the DAC
1878:                temp = thyratron_reservoir_heater_PID.controlOutput;
001A1C  804274     MOV 0x84E, W4
001A1E  780F04     MOV W4, [W14]
1879:                if (temp & 0x8000) {
001A20  78021E     MOV [W14], W4
001A22  520FE0     SUB W4, #0x0, [W15]
001A24  3D0002     BRA GE, 0x1A2A
1880:                  temp = 0x0000;
001A26  EB0200     CLR W4
001A28  780F04     MOV W4, [W14]
1881:                }
1882:                temp = temp << 1;
001A2A  78021E     MOV [W14], W4
001A2C  420204     ADD W4, W4, W4
001A2E  780F04     MOV W4, [W14]
1883:                temp += 0;
1884:                if (temp > THYRATRON_DAC_SATURATED) {
001A30  27D004     MOV #0x7D00, W4
001A32  78029E     MOV [W14], W5
001A34  528F84     SUB W5, W4, [W15]
001A36  360002     BRA LEU, 0x1A3C
1885:                  // The dac output will exceed 2V (20mA from the 4-20mA driver).  Limit the output to 0x7D00
1886:                  temp = THYRATRON_DAC_SATURATED;
001A38  27D004     MOV #0x7D00, W4
001A3A  780F04     MOV W4, [W14]
1887:                }
1888:                ps_thyr_reservoir_htr.v_dac_cal_gain = 0;
001A3C  EB0200     CLR W4
001A3E  885BE4     MOV W4, 0xB7C
1889:                ps_thyr_reservoir_htr.v_dac_scale = 0;
001A40  EB0200     CLR W4
001A42  885BD4     MOV W4, 0xB7A
1890:                ps_thyr_reservoir_htr.v_dac_cal_offset = temp;
001A44  78021E     MOV [W14], W4
001A46  885BF4     MOV W4, 0xB7E
1891:                
1892:                
1893:                // Update the DAC setting for the Cathode Heater
1894:                // The output of the PID is Q15, convert to 16 bit unsigned for the DAC
1895:                temp = thyratron_cathode_heater_PID.controlOutput;
001A48  8042C4     MOV 0x858, W4
001A4A  780F04     MOV W4, [W14]
1896:                if (temp & 0x8000) {
001A4C  78021E     MOV [W14], W4
001A4E  520FE0     SUB W4, #0x0, [W15]
001A50  3D0002     BRA GE, 0x1A56
1897:                  temp = 0x0000;
001A52  EB0200     CLR W4
001A54  780F04     MOV W4, [W14]
1898:                }
1899:                temp = temp << 1;
001A56  78021E     MOV [W14], W4
001A58  420204     ADD W4, W4, W4
001A5A  780F04     MOV W4, [W14]
1900:                temp += 0; 
1901:                if (temp > THYRATRON_DAC_SATURATED) {
001A5C  27D004     MOV #0x7D00, W4
001A5E  78029E     MOV [W14], W5
001A60  528F84     SUB W5, W4, [W15]
001A62  360002     BRA LEU, 0x1A68
1902:                  // The dac output will exceed 2V (20mA from the 4-20mA driver).  Limit the output to 0x7D00
1903:                  // DPARKER how are thyratron dac saturations detected in faults.c - confirm this works
1904:                  temp = THYRATRON_DAC_SATURATED;
001A64  27D004     MOV #0x7D00, W4
001A66  780F04     MOV W4, [W14]
1905:                }
1906:                ps_thyr_cathode_htr.v_dac_cal_gain = 0;
001A68  EB0200     CLR W4
001A6A  885914     MOV W4, 0xB22
1907:                ps_thyr_cathode_htr.v_dac_scale = 0;
001A6C  EB0200     CLR W4
001A6E  885904     MOV W4, 0xB20
1908:                ps_thyr_cathode_htr.v_dac_cal_offset = temp;
001A70  78021E     MOV [W14], W4
001A72  885924     MOV W4, 0xB24
1909:              
1910:                CalcPowerSupplySettings(&ps_thyr_cathode_htr);
001A74  20B160     MOV #0xB16, W0
001A76  07FD9E     RCALL CalcPowerSupplySettings
1911:                CalcPowerSupplySettings(&ps_thyr_reservoir_htr);
001A78  20B700     MOV #0xB70, W0
001A7A  07FD9C     RCALL CalcPowerSupplySettings
1912:              }
001A7C  FA8000     ULNK
001A7E  060000     RETURN
1913:              
1914:              
1915:              void DoMagnetronFilamentAdjust(void) {
001A80  FA0008     LNK #0x8
1916:                unsigned long temp32;
1917:                unsigned int look_up_position;
1918:                unsigned int filament_scale;
1919:                
1920:                temp32 = average_energy_per_pulse_milli_joules;
001A82  804154     MOV average_energy_per_pulse_milli_joules, W4
001A84  200005     MOV #0x0, W5
001A86  BE8F04     MOV.D W4, [W14]
1921:                temp32 *= average_pulse_repetition_frequency_deci_herz;
001A88  804174     MOV average_pulse_repetition_frequency_deci_herz, W4
001A8A  200005     MOV #0x0, W5
001A8C  90031E     MOV [W14+2], W6
001A8E  B9B304     MUL.SS W6, W4, W6
001A90  780306     MOV W6, W6
001A92  78039E     MOV [W14], W7
001A94  B9B805     MUL.SS W7, W5, W0
001A96  780380     MOV W0, W7
001A98  430307     ADD W6, W7, W6
001A9A  78039E     MOV [W14], W7
001A9C  780204     MOV W4, W4
001A9E  B82207     MUL.UU W4, W7, W4
001AA0  430305     ADD W6, W5, W6
001AA2  780286     MOV W6, W5
001AA4  BE8F04     MOV.D W4, [W14]
001AA6  BE8F04     MOV.D W4, [W14]
1922:                temp32 >>= 6;
001AA8  BE021E     MOV.D [W14], W4
001AAA  DD2B4A     SL W5, #10, W6
001AAC  DE2246     LSR W4, #6, W4
001AAE  730204     IOR W6, W4, W4
001AB0  DE2AC6     LSR W5, #6, W5
001AB2  BE8F04     MOV.D W4, [W14]
1923:                temp32 *= 13;
001AB4  90021E     MOV [W14+2], W4
001AB6  B9226D     MUL.SU W4, #13, W4
001AB8  780304     MOV W4, W6
001ABA  78021E     MOV [W14], W4
001ABC  B92260     MUL.SU W4, #0, W4
001ABE  780204     MOV W4, W4
001AC0  430304     ADD W6, W4, W6
001AC2  78029E     MOV [W14], W5
001AC4  2000D4     MOV #0xD, W4
001AC6  B82A04     MUL.UU W5, W4, W4
001AC8  430305     ADD W6, W5, W6
001ACA  780286     MOV W6, W5
001ACC  BE8F04     MOV.D W4, [W14]
001ACE  BE8F04     MOV.D W4, [W14]
1924:                temp32 >>= 11;
001AD0  BE021E     MOV.D [W14], W4
001AD2  DD2B45     SL W5, #5, W6
001AD4  DE224B     LSR W4, #11, W4
001AD6  730204     IOR W6, W4, W4
001AD8  DE2ACB     LSR W5, #11, W5
001ADA  BE8F04     MOV.D W4, [W14]
1925:              
1926:                // DPARKER this will not work at powers greater than 6.5KW because the apparent power will roll around.  This is very bad
1927:                // Need to truncate for (average output power watts) and properly handel look up position.
1928:                if (temp32 >= 0xFFFF) {
001ADC  2FFFE4     MOV #0xFFFE, W4
001ADE  200005     MOV #0x0, W5
001AE0  BE031E     MOV.D [W14], W6
001AE2  530F84     SUB W6, W4, [W15]
001AE4  5B8F85     SUBB W7, W5, [W15]
001AE6  360003     BRA LEU, 0x1AEE
1929:                  average_output_power_watts = 0xFFFF;
001AE8  EB8200     SETM W4
001AEA  884164     MOV W4, average_output_power_watts
001AEC  370002     BRA 0x1AF2
1930:                } else {
1931:                  average_output_power_watts = (temp32 & 0xFFFF);
001AEE  78021E     MOV [W14], W4
001AF0  884164     MOV W4, average_output_power_watts
1932:                }
1933:                temp32 >>= 7;
001AF2  BE021E     MOV.D [W14], W4
001AF4  DD2B49     SL W5, #9, W6
001AF6  DE2247     LSR W4, #7, W4
001AF8  730204     IOR W6, W4, W4
001AFA  DE2AC7     LSR W5, #7, W5
001AFC  BE8F04     MOV.D W4, [W14]
1934:                look_up_position = (temp32 & 0b01111111);
001AFE  78029E     MOV [W14], W5
001B00  2007F4     MOV #0x7F, W4
001B02  628204     AND W5, W4, W4
001B04  980724     MOV W4, [W14+4]
1935:                if ((control_state == STATE_HV_ON) || (control_state == STATE_SYSTEM_WARM_READY)  || (control_state == STATE_HV_STARTUP) || (control_state == STATE_FAULT_WARM_FAULT)) {
001B06  208325     MOV #0x832, W5
001B08  784295     MOV.B [W5], W5
001B0A  B3C444     MOV #0x44, W4
001B0C  52CF84     SUB.B W5, W4, [W15]
001B0E  32000F     BRA Z, 0x1B2E
001B10  208325     MOV #0x832, W5
001B12  784295     MOV.B [W5], W5
001B14  B3C344     MOV #0x34, W4
001B16  52CF84     SUB.B W5, W4, [W15]
001B18  32000A     BRA Z, 0x1B2E
001B1A  208325     MOV #0x832, W5
001B1C  784295     MOV.B [W5], W5
001B1E  B3C354     MOV #0x35, W4
001B20  52CF84     SUB.B W5, W4, [W15]
001B22  320005     BRA Z, 0x1B2E
001B24  208325     MOV #0x832, W5
001B26  784295     MOV.B [W5], W5
001B28  B3CA84     MOV #0xA8, W4
001B2A  52CF84     SUB.B W5, W4, [W15]
001B2C  3A000A     BRA NZ, 0x1B42
1936:                  filament_scale = FilamentLookUpTable[look_up_position];
001B2E  90022E     MOV [W14+4], W4
001B30  420284     ADD W4, W4, W5
001B32  282D64     MOV #0x82D6, W4
001B34  428204     ADD W5, W4, W4
001B36  780294     MOV [W4], W5
001B38  980735     MOV W5, [W14+6]
1937:                  ScalePowerSupply(&ps_filament,filament_scale,100);
001B3A  200642     MOV #0x64, W2
001B3C  9000BE     MOV [W14+6], W1
001B3E  20ABC0     MOV #0xABC, W0
001B40  07FCE8     RCALL ScalePowerSupply
1938:                }  
1939:              }
001B42  FA8000     ULNK
001B44  060000     RETURN
1940:              
1941:              
1942:              
1943:              void ReadIsolatedAdcToRam(void) {
001B46  FA0004     LNK #0x4
1944:                /*
1945:                  This function reads back data from the external AD7686.
1946:                  When this function is called, the data has already been sampled, and the conversion is complete.
1947:                  The convert pin to the two AD7686 should be active
1948:              
1949:                  DO NOT COPY THIS FUNCTION TO OTHER APPLICATIONS - IT WILL NOT WORK BECAUSE THIS DOES NOT INCLUDE TO CODE TO SAMPLE THE INPUTS
1950:                */
1951:              
1952:                // reads data into global variable 
1953:                unsigned long adc_read;
1954:              
1955:              
1956:                last_known_action = LAST_ACTION_READ_ISOLATED_ADC;
001B48  200074     MOV #0x7, W4
001B4A  88C5A4     MOV W4, last_known_action
1957:              
1958:                if (PIN_PULSE_ADC_TRIGGER == OLL_TRIGGER_PULSE_ADCS) {
001B4C  801714     MOV LATF, W4
001B4E  620262     AND W4, #0x2, W4
001B50  520FE0     SUB W4, #0x0, [W15]
001B52  320037     BRA Z, 0x1BC2
1959:                  // The convert signal is asserted like it should be
1960:              
1961:              
1962:                  // ----------  READ BACK THE CURRENT ADC CONVERSION ------------------------- //
1963:                  PIN_PULSE_IMON_CS = OLL_SELECT_PULSE_IMON_ADC;   // Select the Current Monitor ADC
001B54  A9C2D6     BCLR LATD, #6
1964:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
001B56  200C80     MOV #0xC8, W0
001B58  200001     MOV #0x0, W1
001B5A  0718F1     RCALL ___delay32
1965:                  adc_read = SendAndReceiveSPI(0, SPI_PORT_2);     // ReadData 16 bit value off of the Current Monitor ADC
001B5C  B3C021     MOV #0x2, W1
001B5E  EB0000     CLR W0
001B60  071776     RCALL SendAndReceiveSPI
001B62  BE0200     MOV.D W0, W4
001B64  BE8F04     MOV.D W4, [W14]
1966:                  if (adc_read == 0x11110000) {
001B66  200004     MOV #0x0, W4
001B68  211115     MOV #0x1111, W5
001B6A  BE031E     MOV.D [W14], W6
001B6C  530F84     SUB W6, W4, [W15]
001B6E  5B8F85     SUBB W7, W5, [W15]
001B70  3A0006     BRA NZ, 0x1B7E
1967:                    // THERE WAS an SPI ERROR
1968:                    pulse_magnetron_current_adc_reading = 0;
001B72  EB0200     CLR W4
001B74  884234     MOV W4, pulse_magnetron_current_adc_reading
1969:                    global_debug_counter.spi2_bus_error++;
001B76  80C284     MOV 0x1850, W4
001B78  E80204     INC W4, W4
001B7A  88C284     MOV W4, 0x1850
001B7C  370002     BRA 0x1B82
1970:                  } else {
1971:                    pulse_magnetron_current_adc_reading = adc_read & 0xFFFF;
001B7E  78021E     MOV [W14], W4
001B80  884234     MOV W4, pulse_magnetron_current_adc_reading
1972:                  }
1973:                  PIN_PULSE_IMON_CS = !OLL_SELECT_PULSE_IMON_ADC;  // De - Select the Current Monitor ADC  
001B82  A8C2D6     BSET LATD, #6
1974:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
001B84  200C80     MOV #0xC8, W0
001B86  200001     MOV #0x0, W1
001B88  0718DA     RCALL ___delay32
1975:                  
1976:                  
1977:              
1978:                  // ----------  READ BACK THE VOLTAGE ADC CONVERSION ------------------------- //
1979:                  PIN_PULSE_VMON_CS = OLL_SELECT_PULSE_VMON_ADC;   // Select the Voltage Monitor ADC
001B8A  A9A2D6     BCLR LATD, #5
1980:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);      // Wait for the cable select signal to propagate
001B8C  200C80     MOV #0xC8, W0
001B8E  200001     MOV #0x0, W1
001B90  0718D6     RCALL ___delay32
1981:                  adc_read = SendAndReceiveSPI(0, SPI_PORT_2);     // ReadData 16 bit value off of the Voltage Monitor ADC
001B92  B3C021     MOV #0x2, W1
001B94  EB0000     CLR W0
001B96  07175B     RCALL SendAndReceiveSPI
001B98  BE0200     MOV.D W0, W4
001B9A  BE8F04     MOV.D W4, [W14]
1982:                  if (adc_read == 0x11110000) {
001B9C  200004     MOV #0x0, W4
001B9E  211115     MOV #0x1111, W5
001BA0  BE031E     MOV.D [W14], W6
001BA2  530F84     SUB W6, W4, [W15]
001BA4  5B8F85     SUBB W7, W5, [W15]
001BA6  3A0006     BRA NZ, 0x1BB4
1983:                    // THERE WAS an SPI ERROR
1984:                    pulse_magnetron_voltage_adc_reading = 0;
001BA8  EB0200     CLR W4
001BAA  884244     MOV W4, pulse_magnetron_voltage_adc_reading
1985:                    global_debug_counter.spi2_bus_error++;
001BAC  80C284     MOV 0x1850, W4
001BAE  E80204     INC W4, W4
001BB0  88C284     MOV W4, 0x1850
001BB2  370002     BRA 0x1BB8
1986:                  } else {
1987:                    pulse_magnetron_voltage_adc_reading = adc_read & 0xFFFF;
001BB4  78021E     MOV [W14], W4
001BB6  884244     MOV W4, pulse_magnetron_voltage_adc_reading
1988:                  }
1989:                  PIN_PULSE_VMON_CS = !OLL_SELECT_PULSE_VMON_ADC;  // De - Select the Current Monitor ADC  
001BB8  A8A2D6     BSET LATD, #5
1990:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
001BBA  200C80     MOV #0xC8, W0
001BBC  200001     MOV #0x0, W1
001BBE  0718BF     RCALL ___delay32
001BC0  370007     BRA 0x1BD0
1991:                
1992:                } else {
1993:                  // This function was called when the ADC convert signal was not asserted.  Something very bad happened 
1994:                  pulse_magnetron_voltage_adc_reading = 0;
001BC2  EB0200     CLR W4
001BC4  884244     MOV W4, pulse_magnetron_voltage_adc_reading
1995:                  pulse_magnetron_current_adc_reading = 0;
001BC6  EB0200     CLR W4
001BC8  884234     MOV W4, pulse_magnetron_current_adc_reading
1996:                  global_debug_counter.external_adc_false_trigger++;
001BCA  80C294     MOV 0x1852, W4
001BCC  E80204     INC W4, W4
001BCE  88C294     MOV W4, 0x1852
1997:                }
1998:                PIN_PULSE_ADC_TRIGGER = !OLL_TRIGGER_PULSE_ADCS;   // Clear the convert trigger signal
001BD0  A922E2     BCLR LATF, #1
1999:              } 
001BD2  FA8000     ULNK
001BD4  060000     RETURN
2000:              
2001:              
2002:              
2003:              
2004:              void FilterADCs(void) {
001BD6  FA0002     LNK #0x2
2005:                /*
2006:                  This function should be called once every 10mS from Do10msTicToc()
2007:                  The ADC value array is averaged and the the result of that average is low pass filtered.
2008:              
2009:                  From Internal DAC
2010:                  AN3 -  PFN Rev Current           - Only sampled after a pulse
2011:               
2012:                  AN4 - pac_#1                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2013:                  AN5 - pac_#2                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2014:              
2015:                  AN6 - Thyratron Cathode Heater   - 160mS tau - Analog Input Bandwidth = 10 Hz
2016:                  AN7 - Thyratron Reservoir Heater - 160mS tau - Analog Input Bandwidth = 10 Hz
2017:              
2018:                  AN8  - magnet_current            - 160mS tau - Analog Input Bandwidth = 200 Hz
2019:                  AN9  - magnet_voltage            - 160mS tau - Analog Input Bandwidth = 200 Hz
2020:               
2021:                  AN10 - filament_voltage          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2022:                  AN11 - filament_current          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2023:               
2024:                  AN12 - lambda_vpeak              - 640mS tau - Analog Input Bandwidth = 200 Hz
2025:                  AN13 - lambda_vmon               - Only Sampled at EOC
2026:                */
2027:                
2028:                unsigned int adc_reading;
2029:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
2030:                unsigned int vtemp;
2031:              #endif
2032:              
2033:                last_known_action = LAST_ACTION_FILTER_ADC;
001BD8  200064     MOV #0x6, W4
001BDA  88C5A4     MOV W4, last_known_action
2034:              
2035:                // AN3 -  PFN Rev Current           - Only Sampled after a pulse
2036:                // PFN Rev Current is read after a pulse
2037:              
2038:                //AN4 - pac_#1                     - 256 samples/tau - Analog Input Bandwidth = 200 Hz  
2039:                adc_reading = AverageADC128(pac_1_array);
001BDC  20CCC0     MOV #0xCCC, W0
001BDE  0718BD     RCALL _AverageADC128
001BE0  780200     MOV W0, W4
001BE2  780F04     MOV W4, [W14]
2040:                pac_1_adc_reading = RCFilter16Tau(pac_1_adc_reading, adc_reading);
001BE4  8041A4     MOV pac_1_adc_reading, W4
001BE6  78009E     MOV [W14], W1
001BE8  780004     MOV W4, W0
001BEA  070413     RCALL RCFilter16Tau
001BEC  780200     MOV W0, W4
001BEE  8841A4     MOV W4, pac_1_adc_reading
2041:              
2042:              
2043:                //AN5 - pac_#2                     - 256 samples/tau - Analog Input Bandwidth = 200 Hz
2044:                adc_reading = AverageADC128(pac_2_array);
001BF0  20DCC0     MOV #0xDCC, W0
001BF2  0718B3     RCALL _AverageADC128
001BF4  780200     MOV W0, W4
001BF6  780F04     MOV W4, [W14]
2045:                pac_2_adc_reading = RCFilter16Tau(pac_2_adc_reading, adc_reading);
001BF8  8041B4     MOV pac_2_adc_reading, W4
001BFA  78009E     MOV [W14], W1
001BFC  780004     MOV W4, W0
001BFE  070409     RCALL RCFilter16Tau
001C00  780200     MOV W0, W4
001C02  8841B4     MOV W4, pac_2_adc_reading
2046:                
2047:              
2048:                if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
001C04  801735     MOV PORTG, W5
001C06  240004     MOV #0x4000, W4
001C08  628204     AND W5, W4, W4
001C0A  520FE0     SUB W4, #0x0, [W15]
001C0C  3A0002     BRA NZ, 0x1C12
2049:                  default_pac_2_adc_reading = pac_2_adc_reading;
001C0E  8041B4     MOV pac_2_adc_reading, W4
001C10  884074     MOV W4, default_pac_2_adc_reading
2050:                }
2051:              
2052:              
2053:                //AN6 - Thyratron Cathode Heater   - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2054:                //adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
2055:                //ps_thyr_cathode_htr.v_adc_reading = RCFilter16Tau(ps_thyr_cathode_htr.v_adc_reading, adc_reading);
2056:              
2057:              
2058:                //AN7 - Thyratron Reservoir Heater - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2059:                //adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
2060:                //ps_thyr_reservoir_htr.v_adc_reading = RCFilter16Tau(ps_thyr_reservoir_htr.v_adc_reading, adc_reading);
2061:              
2062:              
2063:                //AN8  - magnet_current            - 16 samples/tau - Analog Input Bandwidth = 200 Hz  
2064:                adc_reading = AverageADC128(magnetron_magnet_current_array);
001C12  210CC0     MOV #0x10CC, W0
001C14  0718A2     RCALL _AverageADC128
001C16  780200     MOV W0, W4
001C18  780F04     MOV W4, [W14]
2065:                ps_magnet.i_adc_reading = RCFilter16Tau(ps_magnet.i_adc_reading, adc_reading);
001C1A  8054F4     MOV 0xA9E, W4
001C1C  78009E     MOV [W14], W1
001C1E  780004     MOV W4, W0
001C20  0703F8     RCALL RCFilter16Tau
001C22  780200     MOV W0, W4
001C24  8854F4     MOV W4, 0xA9E
2066:              
2067:                //AN9  - magnet_voltage            - 16 samples/tau - Analog Input Bandwidth = 200 Hz
2068:                adc_reading = AverageADC128(magnetron_magnet_voltage_array);
001C26  211CC0     MOV #0x11CC, W0
001C28  071898     RCALL _AverageADC128
001C2A  780200     MOV W0, W4
001C2C  780F04     MOV W4, [W14]
2069:                ps_magnet.v_adc_reading = RCFilter16Tau(ps_magnet.v_adc_reading, adc_reading);
001C2E  805394     MOV 0xA72, W4
001C30  78009E     MOV [W14], W1
001C32  780004     MOV W4, W0
001C34  0703EE     RCALL RCFilter16Tau
001C36  780200     MOV W0, W4
001C38  885394     MOV W4, 0xA72
2070:               
2071:                //AN10 - filament_voltage          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2072:                adc_reading = AverageADC128(magnetron_filament_voltage_array);
001C3A  213CC0     MOV #0x13CC, W0
001C3C  07188E     RCALL _AverageADC128
001C3E  780200     MOV W0, W4
001C40  780F04     MOV W4, [W14]
2073:                ps_filament.v_adc_reading = RCFilter16Tau(ps_filament.v_adc_reading, adc_reading);
001C42  805664     MOV 0xACC, W4
001C44  78009E     MOV [W14], W1
001C46  780004     MOV W4, W0
001C48  0703E4     RCALL RCFilter16Tau
001C4A  780200     MOV W0, W4
001C4C  885664     MOV W4, 0xACC
2074:              
2075:                //AN11 - filament_current          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2076:                adc_reading = AverageADC128(magnetron_filament_current_array);
001C4E  212CC0     MOV #0x12CC, W0
001C50  071884     RCALL _AverageADC128
001C52  780200     MOV W0, W4
001C54  780F04     MOV W4, [W14]
2077:                ps_filament.i_adc_reading = RCFilter16Tau(ps_filament.i_adc_reading, adc_reading);
001C56  8057C4     MOV 0xAF8, W4
001C58  78009E     MOV [W14], W1
001C5A  780004     MOV W4, W0
001C5C  0703DA     RCALL RCFilter16Tau
001C5E  780200     MOV W0, W4
001C60  8857C4     MOV W4, 0xAF8
2078:              
2079:                //AN12 - lambda_vpeak              - 64 samples/tau - Analog Input Bandwidth = 200 Hz
2080:                adc_reading = AverageADC128(lambda_vpeak_array);
001C62  214CC0     MOV #0x14CC, W0
001C64  07187A     RCALL _AverageADC128
001C66  780200     MOV W0, W4
001C68  780F04     MOV W4, [W14]
2081:                ps_hv_lambda_mode_A.v_adc_reading = RCFilter16Tau(ps_hv_lambda_mode_A.v_adc_reading, adc_reading);
001C6A  804854     MOV 0x90A, W4
001C6C  78009E     MOV [W14], W1
001C6E  780004     MOV W4, W0
001C70  0703D0     RCALL RCFilter16Tau
001C72  780200     MOV W0, W4
001C74  884854     MOV W4, 0x90A
2082:              
2083:                //AN13 - lambda_vmon               - not averaged / filtered  - Analog Input Bandwidth = 200 Hz
2084:                adc_reading = AverageADC128(lambda_vmon_array);
001C76  215CC0     MOV #0x15CC, W0
001C78  071870     RCALL _AverageADC128
001C7A  780200     MOV W0, W4
001C7C  780F04     MOV W4, [W14]
2085:                ps_hv_lambda_mode_B.v_adc_reading = RCFilter16Tau(ps_hv_lambda_mode_B.v_adc_reading, adc_reading);
001C7E  804DF4     MOV 0x9BE, W4
001C80  78009E     MOV [W14], W1
001C82  780004     MOV W4, W0
001C84  0703C6     RCALL RCFilter16Tau
001C86  780200     MOV W0, W4
001C88  884DF4     MOV W4, 0x9BE
2086:                // lambda_vmon is read at EOC
2087:                
2088:              }
001C8A  FA8000     ULNK
001C8C  060000     RETURN
2089:              
2090:              
2091:              
2092:              
2093:              
2094:              void FastReadAndFilterFeedbacks(void) {
001C8E  FA0006     LNK #0x6
2095:                /*
2096:                  This function should be called once durring fast restart.
2097:                  The ADC value array is populated, averaged and the the result of that average used to set initial condition for RC Filter.
2098:              
2099:                  From Internal DAC
2100:                  AN3 -  PFN Rev Current           - Only sampled after a pulse 
2101:               
2102:                  AN4 - pac_#1                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2103:                  AN5 - pac_#2                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2104:              
2105:                  AN6 - Thyratron Cathode Heater   - 160mS tau - Analog Input Bandwidth = 10 Hz
2106:                  AN7 - Thyratron Reservoir Heater - 160mS tau - Analog Input Bandwidth = 10 Hz
2107:              
2108:                  AN8  - magnet_current            - 160mS tau - Analog Input Bandwidth = 200 Hz
2109:                  AN9  - magnet_voltage            - 160mS tau - Analog Input Bandwidth = 200 Hz
2110:               
2111:                  AN10 - filament_voltage          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2112:                  AN11 - filament_current          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2113:               
2114:                  AN12 - lambda_vpeak              - 640mS tau - Analog Input Bandwidth = 200 Hz
2115:                  AN13 - lambda_vmon               - Only Sampled at EOC
2116:                */
2117:              
2118:              
2119:                unsigned int index;
2120:                unsigned int n;
2121:                unsigned int adc_reading;
2122:                
2123:                // Configure ADC for this particular operation
2124:                ADCON1 = A34760_ADCON1_VALUE;
001C90  27CFF4     MOV #0x7CFF, W4
001C92  881504     MOV W4, ADCON1
2125:                ADCON2 = (ADC_VREF_AVDD_AVSS & ADC_SCAN_ON & ADC_SAMPLES_PER_INT_8 & ADC_ALT_BUF_ON & ADC_ALT_INPUT_OFF);
001C94  20FDE4     MOV #0xFDE, W4
001C96  881514     MOV W4, ADCON2
2126:                ADCON3 = A34760_ADCON3_VALUE;
001C98  2E3464     MOV #0xE346, W4
001C9A  881524     MOV W4, ADCON3
2127:                ADCHS  = A34760_ADCHS_VALUE;
001C9C  2EFE34     MOV #0xEFE3, W4
001C9E  881534     MOV W4, ADCHS
2128:                ADPCFG = A34760_ADPCFG_VALUE;
001CA0  2C0074     MOV #0xC007, W4
001CA2  881544     MOV W4, ADPCFG
2129:                ADCSSL = (SKIP_SCAN_AN0 & SKIP_SCAN_AN1 & SKIP_SCAN_AN2 & SKIP_SCAN_AN3 & SKIP_SCAN_AN4 & SKIP_SCAN_AN5 & SKIP_SCAN_AN14 & SKIP_SCAN_AN15);
001CA4  23FC04     MOV #0x3FC0, W4
001CA6  881554     MOV W4, ADCSSL
2130:                ADCON1bits.ADON = 1;
001CA8  A8E2A1     BSET 0x2A1, #7
2131:              
2132:                index = 0;
001CAA  EB0200     CLR W4
001CAC  780F04     MOV W4, [W14]
2133:                while (index < 128) {
001CAE  370080     BRA 0x1DB0
001DB0  2007F4     MOV #0x7F, W4
001DB2  78029E     MOV [W14], W5
001DB4  528F84     SUB W5, W4, [W15]
001DB6  36FF7C     BRA LEU, 0x1CB0
2134:                  while(!_BUFS);
001CB0  000000     NOP
001CB2  801515     MOV ADCON2, W5
001CB4  200804     MOV #0x80, W4
001CB6  628204     AND W5, W4, W4
001CB8  520FE0     SUB W4, #0x0, [W15]
001CBA  32FFFB     BRA Z, 0x1CB2
2135:                  // Copy each reading into 8 data readings 
2136:                  for (n = 0; n < 8; n++) {
001CBC  EB0200     CLR W4
001CBE  980714     MOV W4, [W14+2]
001CC0  370034     BRA 0x1D2A
001D24  90021E     MOV [W14+2], W4
001D26  E80204     INC W4, W4
001D28  980714     MOV W4, [W14+2]
001D2A  90021E     MOV [W14+2], W4
001D2C  520FE7     SUB W4, #0x7, [W15]
001D2E  36FFC9     BRA LEU, 0x1CC2
2137:                    thyratron_cathode_heater_voltage_array[index] = ADCBUF0;
001CC2  801405     MOV ADCBUF0, W5
001CC4  78021E     MOV [W14], W4
001CC6  420304     ADD W4, W4, W6
001CC8  20ECC4     MOV #0xECC, W4
001CCA  430204     ADD W6, W4, W4
001CCC  780A05     MOV W5, [W4]
2138:                    thyratron_reservoir_heater_voltage_array[index] = ADCBUF1;
001CCE  801415     MOV ADCBUF1, W5
001CD0  78021E     MOV [W14], W4
001CD2  420304     ADD W4, W4, W6
001CD4  20FCC4     MOV #0xFCC, W4
001CD6  430204     ADD W6, W4, W4
001CD8  780A05     MOV W5, [W4]
2139:                    magnetron_magnet_current_array[index] = ADCBUF2;
001CDA  801425     MOV ADCBUF2, W5
001CDC  78021E     MOV [W14], W4
001CDE  420304     ADD W4, W4, W6
001CE0  210CC4     MOV #0x10CC, W4
001CE2  430204     ADD W6, W4, W4
001CE4  780A05     MOV W5, [W4]
2140:                    magnetron_magnet_voltage_array[index] = ADCBUF3;
001CE6  801435     MOV ADCBUF3, W5
001CE8  78021E     MOV [W14], W4
001CEA  420304     ADD W4, W4, W6
001CEC  211CC4     MOV #0x11CC, W4
001CEE  430204     ADD W6, W4, W4
001CF0  780A05     MOV W5, [W4]
2141:                    magnetron_filament_current_array[index] = ADCBUF4;
001CF2  801445     MOV ADCBUF4, W5
001CF4  78021E     MOV [W14], W4
001CF6  420304     ADD W4, W4, W6
001CF8  212CC4     MOV #0x12CC, W4
001CFA  430204     ADD W6, W4, W4
001CFC  780A05     MOV W5, [W4]
2142:                    magnetron_filament_voltage_array[index] = ADCBUF5;
001CFE  801455     MOV ADCBUF5, W5
001D00  78021E     MOV [W14], W4
001D02  420304     ADD W4, W4, W6
001D04  213CC4     MOV #0x13CC, W4
001D06  430204     ADD W6, W4, W4
001D08  780A05     MOV W5, [W4]
2143:                    lambda_vpeak_array[index] = ADCBUF6;
001D0A  801465     MOV ADCBUF6, W5
001D0C  78021E     MOV [W14], W4
001D0E  420304     ADD W4, W4, W6
001D10  214CC4     MOV #0x14CC, W4
001D12  430204     ADD W6, W4, W4
001D14  780A05     MOV W5, [W4]
2144:                    lambda_vmon_array[index++] = ADCBUF7;
001D16  801475     MOV ADCBUF7, W5
001D18  78021E     MOV [W14], W4
001D1A  420304     ADD W4, W4, W6
001D1C  215CC4     MOV #0x15CC, W4
001D1E  430204     ADD W6, W4, W4
001D20  780A05     MOV W5, [W4]
001D22  E80F1E     INC [W14], [W14]
2145:                  }
2146:                  while(_BUFS);
001D30  000000     NOP
001D32  801515     MOV ADCON2, W5
001D34  200804     MOV #0x80, W4
001D36  628204     AND W5, W4, W4
001D38  520FE0     SUB W4, #0x0, [W15]
001D3A  3AFFFB     BRA NZ, 0x1D32
2147:                  // Copy each reading into 8 data readings 
2148:                  for (n = 0; n < 8; n++) {
001D3C  EB0200     CLR W4
001D3E  980714     MOV W4, [W14+2]
001D40  370034     BRA 0x1DAA
001DA4  90021E     MOV [W14+2], W4
001DA6  E80204     INC W4, W4
001DA8  980714     MOV W4, [W14+2]
001DAA  90021E     MOV [W14+2], W4
001DAC  520FE7     SUB W4, #0x7, [W15]
001DAE  36FFC9     BRA LEU, 0x1D42
2149:                    thyratron_cathode_heater_voltage_array[index] = ADCBUF8;
001D42  801485     MOV ADCBUF8, W5
001D44  78021E     MOV [W14], W4
001D46  420304     ADD W4, W4, W6
001D48  20ECC4     MOV #0xECC, W4
001D4A  430204     ADD W6, W4, W4
001D4C  780A05     MOV W5, [W4]
2150:                    thyratron_reservoir_heater_voltage_array[index] = ADCBUF9;
001D4E  801495     MOV ADCBUF9, W5
001D50  78021E     MOV [W14], W4
001D52  420304     ADD W4, W4, W6
001D54  20FCC4     MOV #0xFCC, W4
001D56  430204     ADD W6, W4, W4
001D58  780A05     MOV W5, [W4]
2151:                    magnetron_magnet_current_array[index] = ADCBUFA;
001D5A  8014A5     MOV ADCBUFA, W5
001D5C  78021E     MOV [W14], W4
001D5E  420304     ADD W4, W4, W6
001D60  210CC4     MOV #0x10CC, W4
001D62  430204     ADD W6, W4, W4
001D64  780A05     MOV W5, [W4]
2152:                    magnetron_magnet_voltage_array[index] = ADCBUFB;
001D66  8014B5     MOV ADCBUFB, W5
001D68  78021E     MOV [W14], W4
001D6A  420304     ADD W4, W4, W6
001D6C  211CC4     MOV #0x11CC, W4
001D6E  430204     ADD W6, W4, W4
001D70  780A05     MOV W5, [W4]
2153:                    magnetron_filament_current_array[index] = ADCBUFC;
001D72  8014C5     MOV ADCBUFC, W5
001D74  78021E     MOV [W14], W4
001D76  420304     ADD W4, W4, W6
001D78  212CC4     MOV #0x12CC, W4
001D7A  430204     ADD W6, W4, W4
001D7C  780A05     MOV W5, [W4]
2154:                    magnetron_filament_voltage_array[index] = ADCBUFD;
001D7E  8014D5     MOV ADCBUFD, W5
001D80  78021E     MOV [W14], W4
001D82  420304     ADD W4, W4, W6
001D84  213CC4     MOV #0x13CC, W4
001D86  430204     ADD W6, W4, W4
001D88  780A05     MOV W5, [W4]
2155:                    lambda_vpeak_array[index] = ADCBUFE;
001D8A  8014E5     MOV ADCBUFE, W5
001D8C  78021E     MOV [W14], W4
001D8E  420304     ADD W4, W4, W6
001D90  214CC4     MOV #0x14CC, W4
001D92  430204     ADD W6, W4, W4
001D94  780A05     MOV W5, [W4]
2156:                    lambda_vmon_array[index++] = ADCBUFF;
001D96  8014F5     MOV ADCBUFF, W5
001D98  78021E     MOV [W14], W4
001D9A  420304     ADD W4, W4, W6
001D9C  215CC4     MOV #0x15CC, W4
001D9E  430204     ADD W6, W4, W4
001DA0  780A05     MOV W5, [W4]
001DA2  E80F1E     INC [W14], [W14]
2157:                  }
2158:                }
2159:                ADCON1bits.ADON = 0;
001DB8  A9E2A1     BCLR 0x2A1, #7
2160:              
2161:                //AN6 - Thyratron Cathode Heater   - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2162:                adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
001DBA  20ECC0     MOV #0xECC, W0
001DBC  0717CE     RCALL _AverageADC128
001DBE  780200     MOV W0, W4
001DC0  980724     MOV W4, [W14+4]
2163:                ps_thyr_cathode_htr.v_adc_reading = adc_reading;
001DC2  90022E     MOV [W14+4], W4
001DC4  885934     MOV W4, 0xB26
2164:              
2165:                //AN7 - Thyratron Reservoir Heater - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2166:                adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
001DC6  20FCC0     MOV #0xFCC, W0
001DC8  0717C8     RCALL _AverageADC128
001DCA  780200     MOV W0, W4
001DCC  980724     MOV W4, [W14+4]
2167:                ps_thyr_reservoir_htr.v_adc_reading = adc_reading;
001DCE  90022E     MOV [W14+4], W4
001DD0  885C04     MOV W4, 0xB80
2168:              
2169:                //AN8  - magnet_current            - 16 samples/tau - Analog Input Bandwidth = 200 Hz  
2170:                adc_reading = AverageADC128(magnetron_magnet_current_array);
001DD2  210CC0     MOV #0x10CC, W0
001DD4  0717C2     RCALL _AverageADC128
001DD6  780200     MOV W0, W4
001DD8  980724     MOV W4, [W14+4]
2171:                ps_magnet.i_adc_reading = adc_reading;
001DDA  90022E     MOV [W14+4], W4
001DDC  8854F4     MOV W4, 0xA9E
2172:              
2173:                //AN9  - magnet_voltage            - 16 samples/tau - Analog Input Bandwidth = 200 Hz
2174:                adc_reading = AverageADC128(magnetron_magnet_voltage_array);
001DDE  211CC0     MOV #0x11CC, W0
001DE0  0717BC     RCALL _AverageADC128
001DE2  780200     MOV W0, W4
001DE4  980724     MOV W4, [W14+4]
2175:                ps_magnet.v_adc_reading = adc_reading;
001DE6  90022E     MOV [W14+4], W4
001DE8  885394     MOV W4, 0xA72
2176:               
2177:                //AN10 - filament_voltage          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2178:                adc_reading = AverageADC128(magnetron_filament_voltage_array);
001DEA  213CC0     MOV #0x13CC, W0
001DEC  0717B6     RCALL _AverageADC128
001DEE  780200     MOV W0, W4
001DF0  980724     MOV W4, [W14+4]
2179:                ps_filament.v_adc_reading = adc_reading;
001DF2  90022E     MOV [W14+4], W4
001DF4  885664     MOV W4, 0xACC
2180:              
2181:                //AN11 - filament_current          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2182:                adc_reading = AverageADC128(magnetron_filament_current_array);
001DF6  212CC0     MOV #0x12CC, W0
001DF8  0717B0     RCALL _AverageADC128
001DFA  780200     MOV W0, W4
001DFC  980724     MOV W4, [W14+4]
2183:                ps_filament.i_adc_reading = adc_reading;
001DFE  90022E     MOV [W14+4], W4
001E00  8857C4     MOV W4, 0xAF8
2184:              
2185:                //AN12 - lambda_vpeak              - 64 samples/tau - Analog Input Bandwidth = 200 Hz
2186:                adc_reading = AverageADC128(lambda_vpeak_array);
001E02  214CC0     MOV #0x14CC, W0
001E04  0717AA     RCALL _AverageADC128
001E06  780200     MOV W0, W4
001E08  980724     MOV W4, [W14+4]
2187:                ps_hv_lambda_mode_A.v_adc_reading = adc_reading;
001E0A  90022E     MOV [W14+4], W4
001E0C  884854     MOV W4, 0x90A
2188:              
2189:                //AN13 - lambda_vmon               - not averaged / filtered  - Analog Input Bandwidth = 200 Hz
2190:                adc_reading = AverageADC128(lambda_vmon_array);
001E0E  215CC0     MOV #0x15CC, W0
001E10  0717A4     RCALL _AverageADC128
001E12  780200     MOV W0, W4
001E14  980724     MOV W4, [W14+4]
2191:                ps_hv_lambda_mode_B.v_adc_reading = adc_reading;
001E16  90022E     MOV [W14+4], W4
001E18  884DF4     MOV W4, 0x9BE
2192:              
2193:              }
001E1A  FA8000     ULNK
001E1C  060000     RETURN
2194:              
2195:              
2196:              
2197:              
2198:              void FastReadAndFilterPACInputs(void) {
001E1E  FA0006     LNK #0x6
2199:                unsigned int index;
2200:                unsigned int n;
2201:                unsigned int adc_reading;
2202:                
2203:                // Configure ADC for this particular operation
2204:                ADCON1 = A34760_ADCON1_VALUE;
001E20  27CFF4     MOV #0x7CFF, W4
001E22  881504     MOV W4, ADCON1
2205:                ADCON2 = (ADC_VREF_AVDD_AVSS & ADC_SCAN_ON & ADC_SAMPLES_PER_INT_8 & ADC_ALT_BUF_ON & ADC_ALT_INPUT_OFF);
001E24  20FDE4     MOV #0xFDE, W4
001E26  881514     MOV W4, ADCON2
2206:                ADCON3 = A34760_ADCON3_VALUE;
001E28  2E3464     MOV #0xE346, W4
001E2A  881524     MOV W4, ADCON3
2207:                ADCHS  = A34760_ADCHS_VALUE;
001E2C  2EFE34     MOV #0xEFE3, W4
001E2E  881534     MOV W4, ADCHS
2208:                ADPCFG = A34760_ADPCFG_VALUE;
001E30  2C0074     MOV #0xC007, W4
001E32  881544     MOV W4, ADPCFG
2209:                ADCSSL = (SKIP_SCAN_AN0 & SKIP_SCAN_AN1 & SKIP_SCAN_AN2 & SKIP_SCAN_AN3 & SKIP_SCAN_AN6 & SKIP_SCAN_AN7 & SKIP_SCAN_AN8 & SKIP_SCAN_AN9 & SKIP_SCAN_AN10 & SKIP_SCAN_AN11 & SKIP_SCAN_AN12 & SKIP_SCAN_AN13 & SKIP_SCAN_AN14 & SKIP_SCAN_AN15);
001E34  200304     MOV #0x30, W4
001E36  881554     MOV W4, ADCSSL
2210:                ADCON1bits.ADON = 1;
001E38  A8E2A1     BSET 0x2A1, #7
2211:              
2212:                
2213:                // Repeate the sample sequence until we have filled up the pac arrays
2214:                index = 0;
001E3A  EB0200     CLR W4
001E3C  780F04     MOV W4, [W14]
2215:                while (index < 128) {
001E3E  370086     BRA 0x1F4C
001F4C  2007F4     MOV #0x7F, W4
001F4E  78029E     MOV [W14], W5
001F50  528F84     SUB W5, W4, [W15]
001F52  36FF76     BRA LEU, 0x1E40
2216:                  // wait for buffer 0-8 to fill up
2217:                  while(!_BUFS);
001E40  000000     NOP
001E42  801515     MOV ADCON2, W5
001E44  200804     MOV #0x80, W4
001E46  628204     AND W5, W4, W4
001E48  520FE0     SUB W4, #0x0, [W15]
001E4A  32FFFB     BRA Z, 0x1E42
2218:                  for (n = 0; n < 4; n++) {
001E4C  EB0200     CLR W4
001E4E  980714     MOV W4, [W14+2]
001E50  370037     BRA 0x1EC0
001EBA  90021E     MOV [W14+2], W4
001EBC  E80204     INC W4, W4
001EBE  980714     MOV W4, [W14+2]
001EC0  90021E     MOV [W14+2], W4
001EC2  520FE3     SUB W4, #0x3, [W15]
001EC4  36FFC6     BRA LEU, 0x1E52
2219:                    pac_1_array[index] = ADCBUF0;
001E52  801405     MOV ADCBUF0, W5
001E54  78021E     MOV [W14], W4
001E56  420304     ADD W4, W4, W6
001E58  20CCC4     MOV #0xCCC, W4
001E5A  430204     ADD W6, W4, W4
001E5C  780A05     MOV W5, [W4]
2220:                    pac_2_array[index++] = ADCBUF1;
001E5E  801415     MOV ADCBUF1, W5
001E60  78021E     MOV [W14], W4
001E62  420304     ADD W4, W4, W6
001E64  20DCC4     MOV #0xDCC, W4
001E66  430204     ADD W6, W4, W4
001E68  780A05     MOV W5, [W4]
001E6A  E80F1E     INC [W14], [W14]
2221:                    pac_1_array[index] = ADCBUF2;
001E6C  801425     MOV ADCBUF2, W5
001E6E  78021E     MOV [W14], W4
001E70  420304     ADD W4, W4, W6
001E72  20CCC4     MOV #0xCCC, W4
001E74  430204     ADD W6, W4, W4
001E76  780A05     MOV W5, [W4]
2222:                    pac_2_array[index++] = ADCBUF3;
001E78  801435     MOV ADCBUF3, W5
001E7A  78021E     MOV [W14], W4
001E7C  420304     ADD W4, W4, W6
001E7E  20DCC4     MOV #0xDCC, W4
001E80  430204     ADD W6, W4, W4
001E82  780A05     MOV W5, [W4]
001E84  E80F1E     INC [W14], [W14]
2223:                    pac_1_array[index] = ADCBUF4;
001E86  801445     MOV ADCBUF4, W5
001E88  78021E     MOV [W14], W4
001E8A  420304     ADD W4, W4, W6
001E8C  20CCC4     MOV #0xCCC, W4
001E8E  430204     ADD W6, W4, W4
001E90  780A05     MOV W5, [W4]
2224:                    pac_2_array[index++] = ADCBUF5;
001E92  801455     MOV ADCBUF5, W5
001E94  78021E     MOV [W14], W4
001E96  420304     ADD W4, W4, W6
001E98  20DCC4     MOV #0xDCC, W4
001E9A  430204     ADD W6, W4, W4
001E9C  780A05     MOV W5, [W4]
001E9E  E80F1E     INC [W14], [W14]
2225:                    pac_1_array[index] = ADCBUF6;
001EA0  801465     MOV ADCBUF6, W5
001EA2  78021E     MOV [W14], W4
001EA4  420304     ADD W4, W4, W6
001EA6  20CCC4     MOV #0xCCC, W4
001EA8  430204     ADD W6, W4, W4
001EAA  780A05     MOV W5, [W4]
2226:                    pac_2_array[index++] = ADCBUF7;  
001EAC  801475     MOV ADCBUF7, W5
001EAE  78021E     MOV [W14], W4
001EB0  420304     ADD W4, W4, W6
001EB2  20DCC4     MOV #0xDCC, W4
001EB4  430204     ADD W6, W4, W4
001EB6  780A05     MOV W5, [W4]
001EB8  E80F1E     INC [W14], [W14]
2227:                  }
2228:                  
2229:                  // wait for buffers 9-F to fill up
2230:                  while(_BUFS);
001EC6  000000     NOP
001EC8  801515     MOV ADCON2, W5
001ECA  200804     MOV #0x80, W4
001ECC  628204     AND W5, W4, W4
001ECE  520FE0     SUB W4, #0x0, [W15]
001ED0  3AFFFB     BRA NZ, 0x1EC8
2231:                  for (n = 0; n < 4; n++) {
001ED2  EB0200     CLR W4
001ED4  980714     MOV W4, [W14+2]
001ED6  370037     BRA 0x1F46
001F40  90021E     MOV [W14+2], W4
001F42  E80204     INC W4, W4
001F44  980714     MOV W4, [W14+2]
001F46  90021E     MOV [W14+2], W4
001F48  520FE3     SUB W4, #0x3, [W15]
001F4A  36FFC6     BRA LEU, 0x1ED8
2232:                    pac_1_array[index] = ADCBUF8;
001ED8  801485     MOV ADCBUF8, W5
001EDA  78021E     MOV [W14], W4
001EDC  420304     ADD W4, W4, W6
001EDE  20CCC4     MOV #0xCCC, W4
001EE0  430204     ADD W6, W4, W4
001EE2  780A05     MOV W5, [W4]
2233:                    pac_2_array[index++] = ADCBUF9;
001EE4  801495     MOV ADCBUF9, W5
001EE6  78021E     MOV [W14], W4
001EE8  420304     ADD W4, W4, W6
001EEA  20DCC4     MOV #0xDCC, W4
001EEC  430204     ADD W6, W4, W4
001EEE  780A05     MOV W5, [W4]
001EF0  E80F1E     INC [W14], [W14]
2234:                    pac_1_array[index] = ADCBUFA;
001EF2  8014A5     MOV ADCBUFA, W5
001EF4  78021E     MOV [W14], W4
001EF6  420304     ADD W4, W4, W6
001EF8  20CCC4     MOV #0xCCC, W4
001EFA  430204     ADD W6, W4, W4
001EFC  780A05     MOV W5, [W4]
2235:                    pac_2_array[index++] = ADCBUFB;
001EFE  8014B5     MOV ADCBUFB, W5
001F00  78021E     MOV [W14], W4
001F02  420304     ADD W4, W4, W6
001F04  20DCC4     MOV #0xDCC, W4
001F06  430204     ADD W6, W4, W4
001F08  780A05     MOV W5, [W4]
001F0A  E80F1E     INC [W14], [W14]
2236:                    pac_1_array[index] = ADCBUFC;
001F0C  8014C5     MOV ADCBUFC, W5
001F0E  78021E     MOV [W14], W4
001F10  420304     ADD W4, W4, W6
001F12  20CCC4     MOV #0xCCC, W4
001F14  430204     ADD W6, W4, W4
001F16  780A05     MOV W5, [W4]
2237:                    pac_2_array[index++] = ADCBUFD;
001F18  8014D5     MOV ADCBUFD, W5
001F1A  78021E     MOV [W14], W4
001F1C  420304     ADD W4, W4, W6
001F1E  20DCC4     MOV #0xDCC, W4
001F20  430204     ADD W6, W4, W4
001F22  780A05     MOV W5, [W4]
001F24  E80F1E     INC [W14], [W14]
2238:                    pac_1_array[index] = ADCBUFE;
001F26  8014E5     MOV ADCBUFE, W5
001F28  78021E     MOV [W14], W4
001F2A  420304     ADD W4, W4, W6
001F2C  20CCC4     MOV #0xCCC, W4
001F2E  430204     ADD W6, W4, W4
001F30  780A05     MOV W5, [W4]
2239:                    pac_2_array[index++] = ADCBUFF;  
001F32  8014F5     MOV ADCBUFF, W5
001F34  78021E     MOV [W14], W4
001F36  420304     ADD W4, W4, W6
001F38  20DCC4     MOV #0xDCC, W4
001F3A  430204     ADD W6, W4, W4
001F3C  780A05     MOV W5, [W4]
001F3E  E80F1E     INC [W14], [W14]
2240:                  }    
2241:                }
2242:                ADCON1bits.ADON = 0;
001F54  A9E2A1     BCLR 0x2A1, #7
2243:                
2244:              
2245:                // Average Pac Array and Populte the RC Filter
2246:                // This is just copied from Filter ADCs
2247:                adc_reading = AverageADC128(pac_1_array);
001F56  20CCC0     MOV #0xCCC, W0
001F58  071700     RCALL _AverageADC128
001F5A  780200     MOV W0, W4
001F5C  980724     MOV W4, [W14+4]
2248:                pac_1_adc_reading = adc_reading;
001F5E  90022E     MOV [W14+4], W4
001F60  8841A4     MOV W4, pac_1_adc_reading
2249:                
2250:                adc_reading = AverageADC128(pac_2_array);
001F62  20DCC0     MOV #0xDCC, W0
001F64  0716FA     RCALL _AverageADC128
001F66  780200     MOV W0, W4
001F68  980724     MOV W4, [W14+4]
2251:                pac_2_adc_reading = adc_reading;
001F6A  90022E     MOV [W14+4], W4
001F6C  8841B4     MOV W4, pac_2_adc_reading
2252:              }
001F6E  FA8000     ULNK
001F70  060000     RETURN
2253:              
2254:              
2255:              
2256:              
2257:              
2258:              
2259:              void ExitHvOnState(void) {
001F72  FA0004     LNK #0x4
2260:                // this subroutine is called to properly shut down the HV on state
2261:                // This required interrupts to be disabled/cleared/ect
2262:                
2263:                SET_CPU_IPL(7); // Disable all interrupts
001F74  800294     MOV DISICNT, W4
001F76  780F04     MOV W4, [W14]
001F78  FC3FFF     DISI #0x3FFF
001F7A  800214     MOV SR, W4
001F7C  A05004     BSET W4, #5
001F7E  A06004     BSET W4, #6
001F80  A07004     BSET W4, #7
001F82  880214     MOV W4, SR
001F84  78021E     MOV [W14], W4
001F86  880294     MOV W4, DISICNT
001F88  880000     MOV W0, WREG0
2264:                Nop();
001F8A  000000     NOP
2265:                Nop();
001F8C  000000     NOP
2266:                Nop();
001F8E  000000     NOP
2267:                Nop();
001F90  000000     NOP
2268:                _T1IE = 0;      // Disable the T1 interrupt.  The T1 interrupt enables INT1 Interrupt
001F92  A9608C     BCLR IEC0, #3
2269:                _INT1IE = 0;    // Disable the INT1 Interrupt.  INT1 enables T1 Interrupt.
001F94  A9008E     BCLR IEC1, #0
2270:                SET_CPU_IPL(0); // Enable all interrupts
001F96  800294     MOV DISICNT, W4
001F98  980714     MOV W4, [W14+2]
001F9A  FC3FFF     DISI #0x3FFF
001F9C  800214     MOV SR, W4
001F9E  A15004     BCLR W4, #5
001FA0  A16004     BCLR W4, #6
001FA2  A17004     BCLR W4, #7
001FA4  880214     MOV W4, SR
001FA6  90021E     MOV [W14+2], W4
001FA8  880294     MOV W4, DISICNT
001FAA  880000     MOV W0, WREG0
2271:                SavePulseCountersToEEPROM();
001FAC  070003     RCALL SavePulseCountersToEEPROM
2272:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;
001FAE  A822C5     BSET 0x2C5, #1
2273:              }
001FB0  FA8000     ULNK
001FB2  060000     RETURN
2274:              
2275:              void SavePulseCountersToEEPROM(void) {
001FB4  FA0002     LNK #0x2
2276:                unsigned int *unsigned_int_ptr;
2277:                unsigned_int_ptr = &pulse_counter_persistent;              //unsigned_int_ptr now points to the Least Significant word of pulse_counter_persistent
001FB6  2189E4     MOV #0x189E, W4
001FB8  780F04     MOV W4, [W14]
2278:                pulse_counter_repository_ram_copy[3] = *unsigned_int_ptr; 
001FBA  78021E     MOV [W14], W4
001FBC  780214     MOV [W4], W4
001FBE  88C054     MOV W4, 0x180A
2279:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
001FC0  E88F1E     INC2 [W14], [W14]
2280:                pulse_counter_repository_ram_copy[2] = *unsigned_int_ptr;
001FC2  78021E     MOV [W14], W4
001FC4  780214     MOV [W4], W4
001FC6  88C044     MOV W4, 0x1808
2281:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
001FC8  E88F1E     INC2 [W14], [W14]
2282:                pulse_counter_repository_ram_copy[1] = *unsigned_int_ptr;
001FCA  78021E     MOV [W14], W4
001FCC  780214     MOV [W4], W4
001FCE  88C034     MOV W4, 0x1806
2283:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of pulse_counter_persistent
001FD0  E88F1E     INC2 [W14], [W14]
2284:                pulse_counter_repository_ram_copy[0] = *unsigned_int_ptr;
001FD2  78021E     MOV [W14], W4
001FD4  780214     MOV [W4], W4
001FD6  88C024     MOV W4, pulse_counter_repository_ram_copy
2285:                
2286:                
2287:                unsigned_int_ptr = &arc_counter_persistent;                //unsigned_int_ptr now points to the Least Significant word of arc_counter_persistent
001FD8  218AC4     MOV #0x18AC, W4
001FDA  780F04     MOV W4, [W14]
2288:                pulse_counter_repository_ram_copy[5] = *unsigned_int_ptr;
001FDC  78021E     MOV [W14], W4
001FDE  780214     MOV [W4], W4
001FE0  88C074     MOV W4, 0x180E
2289:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of arc_counter_persistent
001FE2  E88F1E     INC2 [W14], [W14]
2290:                pulse_counter_repository_ram_copy[4] = *unsigned_int_ptr;
001FE4  78021E     MOV [W14], W4
001FE6  780214     MOV [W4], W4
001FE8  88C064     MOV W4, 0x180C
2291:              
2292:                // The values have now been saved to the array in RAM.  Save the RAM data to EEPROM
2293:                _wait_eedata();
001FEA  803B05     MOV NVMCON, W5
001FEC  280004     MOV #0x8000, W4
001FEE  628204     AND W5, W4, W4
001FF0  520FE0     SUB W4, #0x0, [W15]
001FF2  3AFFFB     BRA NZ, 0x1FEA
2294:                _erase_eedata(EE_address_pulse_counter_repository_in_EEPROM, _EE_ROW);
001FF4  80C004     MOV EE_address_pulse_counter_repository_in_EEPROM, W4
001FF6  80C015     MOV 0x1802, W5
001FF8  200202     MOV #0x20, W2
001FFA  BE0004     MOV.D W4, W0
001FFC  07F10A     RCALL __eedata_helper1
2295:                _wait_eedata();
001FFE  803B05     MOV NVMCON, W5
002000  280004     MOV #0x8000, W4
002002  628204     AND W5, W4, W4
002004  520FE0     SUB W4, #0x0, [W15]
002006  3AFFFB     BRA NZ, 0x1FFE
2296:                _write_eedata_row(EE_address_pulse_counter_repository_in_EEPROM, pulse_counter_repository_ram_copy);
002008  80C004     MOV EE_address_pulse_counter_repository_in_EEPROM, W4
00200A  80C015     MOV 0x1802, W5
00200C  218042     MOV #0x1804, W2
00200E  BE0004     MOV.D W4, W0
002010  07F11F     RCALL __eedata_helper4
2297:              }
002012  FA8000     ULNK
002014  060000     RETURN
2298:              
2299:              
2300:              void DoColdShutDown(void) {
002016  FA0000     LNK #0x0
2301:                /*
2302:                  This is a function to safely move from any state to cold state
2303:              
2304:                  The following actions occur
2305:                  * The HV Lambda is disabled
2306:                  * The Filament supply is disabled
2307:                  * The magnet supply is disabled
2308:                  * The thyratron DACs are set to Zero //DPARKER how to do with without PID taking over
2309:                  
2310:                  // DPARKER when do we write values from EEPROM to RAM
2311:                  */
2312:                DisableHVLambdaSupply();
002018  07005C     RCALL DisableHVLambdaSupply
2313:                DisableMagnetronFilamentSupply();
00201A  07004F     RCALL DisableMagnetronFilamentSupply
2314:                DisableMagnetronMagnetSupply();
00201C  070056     RCALL DisableMagnetronMagnetSupply
2315:                ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
00201E  200642     MOV #0x64, W2
002020  EB0080     CLR W1
002022  208FA0     MOV #0x8FA, W0
002024  07FA76     RCALL ScalePowerSupply
2316:                ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
002026  200642     MOV #0x64, W2
002028  EB0080     CLR W1
00202A  208FA0     MOV #0x8FA, W0
00202C  07FA72     RCALL ScalePowerSupply
2317:                ScalePowerSupply(&ps_filament,0,100);
00202E  200642     MOV #0x64, W2
002030  EB0080     CLR W1
002032  20ABC0     MOV #0xABC, W0
002034  07FA6E     RCALL ScalePowerSupply
2318:                ScalePowerSupply(&ps_magnet,0,100);
002036  200642     MOV #0x64, W2
002038  EB0080     CLR W1
00203A  20A620     MOV #0xA62, W0
00203C  07FA6A     RCALL ScalePowerSupply
2319:                ScalePowerSupply(&ps_thyr_reservoir_htr,0,100);
00203E  200642     MOV #0x64, W2
002040  EB0080     CLR W1
002042  20B700     MOV #0xB70, W0
002044  07FA66     RCALL ScalePowerSupply
2320:                ScalePowerSupply(&ps_thyr_cathode_htr,0,100);
002046  200642     MOV #0x64, W2
002048  EB0080     CLR W1
00204A  20B160     MOV #0xB16, W0
00204C  07FA62     RCALL ScalePowerSupply
2321:              
2322:                //DPARKER need to do more to shut down the PID loops
2323:                PIDInit(&thyratron_reservoir_heater_PID);
00204E  2084A0     MOV #0x84A, W0
002050  07F0BD     RCALL _PIDInit
2324:                PIDInit(&thyratron_cathode_heater_PID);
002052  208540     MOV #0x854, W0
002054  07F0BB     RCALL _PIDInit
2325:              
2326:                T1CONbits.TON = 0;
002056  A9E105     BCLR 0x105, #7
2327:                _INT1IE = 0;
002058  A9008E     BCLR IEC1, #0
2328:                _T1IE = 0;
00205A  A9608C     BCLR IEC0, #3
2329:                _INT1IF = 0;
00205C  A90086     BCLR IFS1, #0
2330:                _T1IF = 0;
00205E  A96084     BCLR IFS0, #3
2331:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
002060  A9C2C4     BCLR LATA, #6
2332:              }
002062  FA8000     ULNK
002064  060000     RETURN
2333:              
2334:              
2335:              void DoWarmShutDown(void) {
002066  FA0000     LNK #0x0
2336:                /*
2337:                  This function is called to safely move from any warm/HV on state to, warm state
2338:              
2339:                  The Following Actions occur
2340:                  * The HV Lambda is disabled
2341:                  * Clean up Interupts associated with pulsing
2342:                  
2343:                  // DPARKER when do we write values from EEPROM TO RAM???
2344:                  */
2345:                DisableHVLambdaSupply();
002068  070034     RCALL DisableHVLambdaSupply
2346:                T1CONbits.TON = 0;
00206A  A9E105     BCLR 0x105, #7
2347:                _INT1IE = 0;
00206C  A9008E     BCLR IEC1, #0
2348:                _T1IE = 0;
00206E  A9608C     BCLR IEC0, #3
2349:                _INT1IF = 0;
002070  A90086     BCLR IFS1, #0
2350:                _T1IF = 0;
002072  A96084     BCLR IFS0, #3
2351:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
002074  A9C2C4     BCLR LATA, #6
2352:              }
002076  FA8000     ULNK
002078  060000     RETURN
2353:              
2354:              
2355:              
2356:              
2357:              void StartWarmUp(void) {
00207A  FA0000     LNK #0x0
2358:                /*
2359:                  This subroutine is called at the start of the warmup process.
2360:                  It enables the heater and magnet supplies at zero and starts the ramp process
2361:                  
2362:                  + Set all outputs to Zero
2363:                  + Setup TMR2 for 100ms Intervals
2364:                */  
2365:              
2366:                PIDInit(&thyratron_reservoir_heater_PID);
00207C  2084A0     MOV #0x84A, W0
00207E  07F0A6     RCALL _PIDInit
2367:                PIDInit(&thyratron_cathode_heater_PID);
002080  208540     MOV #0x854, W0
002082  07F0A4     RCALL _PIDInit
2368:              
2369:                ScalePowerSupply(&ps_magnet, 0, 100);
002084  200642     MOV #0x64, W2
002086  EB0080     CLR W1
002088  20A620     MOV #0xA62, W0
00208A  07FA43     RCALL ScalePowerSupply
2370:                ScalePowerSupply(&ps_filament, 0, 100);
00208C  200642     MOV #0x64, W2
00208E  EB0080     CLR W1
002090  20ABC0     MOV #0xABC, W0
002092  07FA3F     RCALL ScalePowerSupply
2371:                ScalePowerSupply(&ps_thyr_cathode_htr, 0, 100);
002094  200642     MOV #0x64, W2
002096  EB0080     CLR W1
002098  20B160     MOV #0xB16, W0
00209A  07FA3B     RCALL ScalePowerSupply
2372:                ScalePowerSupply(&ps_thyr_reservoir_htr, 0, 100);
00209C  200642     MOV #0x64, W2
00209E  EB0080     CLR W1
0020A0  20B700     MOV #0xB70, W0
0020A2  07FA37     RCALL ScalePowerSupply
2373:              
2374:                EnableMagnetronMagnetSupply();
0020A4  07000E     RCALL EnableMagnetronMagnetSupply
2375:                EnableMagnetronFilamentSupply();
0020A6  070005     RCALL EnableMagnetronFilamentSupply
2376:              
2377:                TMR2 = 0;
0020A8  EB0200     CLR W4
0020AA  880834     MOV W4, TMR2
2378:                _T2IF = 0;
0020AC  A9C084     BCLR IFS0, #6
2379:              }
0020AE  FA8000     ULNK
0020B0  060000     RETURN
2380:              
2381:              
2382:              
2383:              
2384:              void EnableMagnetronFilamentSupply(void) {
0020B2  FA0000     LNK #0x0
2385:                PIN_MAGNETRON_FILAMENT_ENABLE = OLL_MAGNETRON_FILAMENT_ENABLED;
0020B4  A802D7     BSET 0x2D7, #0
2386:              }
0020B6  FA8000     ULNK
0020B8  060000     RETURN
2387:              
2388:              void DisableMagnetronFilamentSupply(void) {
0020BA  FA0000     LNK #0x0
2389:                PIN_MAGNETRON_FILAMENT_ENABLE = !OLL_MAGNETRON_FILAMENT_ENABLED;
0020BC  A902D7     BCLR 0x2D7, #0
2390:              }
0020BE  FA8000     ULNK
0020C0  060000     RETURN
2391:              
2392:              void EnableMagnetronMagnetSupply(void) {
0020C2  FA0000     LNK #0x0
2393:                PIN_MAGNETRON_MAGNET_ENABLE = OLL_MAGNETRON_MAGNET_ENABLED;
0020C4  A922D7     BCLR 0x2D7, #1
2394:              }
0020C6  FA8000     ULNK
0020C8  060000     RETURN
2395:              
2396:              void DisableMagnetronMagnetSupply(void) {
0020CA  FA0000     LNK #0x0
2397:                PIN_MAGNETRON_MAGNET_ENABLE = !OLL_MAGNETRON_MAGNET_ENABLED;
0020CC  A822D7     BSET 0x2D7, #1
2398:              }
0020CE  FA8000     ULNK
0020D0  060000     RETURN
2399:              
2400:              
2401:              void DisableHVLambdaSupply(void) {
0020D2  FA0000     LNK #0x0
2402:                PIN_HV_LAMBDA_ENABLE = !OLL_HV_LAMBDA_ENABLED;
0020D4  A962D7     BCLR 0x2D7, #3
2403:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;
0020D6  A802D6     BSET LATD, #0
2404:              }
0020D8  FA8000     ULNK
0020DA  060000     RETURN
2405:              
2406:              
2407:              void UpdateIOExpanderOutputs(void) {
0020DC  FA0004     LNK #0x4
2408:                // This updates all of the LED/Digital Outputs From the Control Board
2409:                // See 34-34357 for the configuration of the output polarities
2410:              
2411:                // All of the outputs are "Active Low"
2412:                // For Faults - The Fault state is "NOT ACTIVE" or a "high output"
2413:                // FOr HV ON - HV On is the "Not Active" state or "high otuput"
2414:              
2415:                unsigned int temp_lat_a;
2416:                unsigned int temp_lat_b;
2417:                
2418:                temp_lat_a = 0x00;
0020DE  EB0200     CLR W4
0020E0  780F04     MOV W4, [W14]
2419:                temp_lat_b = 0x00;
0020E2  EB0200     CLR W4
0020E4  980714     MOV W4, [W14+2]
2420:              
2421:                last_known_action = LAST_ACTION_UPDATE_IO_EXPANDER;
0020E6  200054     MOV #0x5, W4
0020E8  88C5A4     MOV W4, last_known_action
2422:                
2423:                if ((control_state == STATE_SYSTEM_WARM_READY) || (control_state == STATE_HV_ON) || (control_state == STATE_FAULT_WARM_FAULT) || (control_state == STATE_HV_STARTUP)) {
0020EA  208325     MOV #0x832, W5
0020EC  784295     MOV.B [W5], W5
0020EE  B3C344     MOV #0x34, W4
0020F0  52CF84     SUB.B W5, W4, [W15]
0020F2  32000F     BRA Z, 0x2112
0020F4  208325     MOV #0x832, W5
0020F6  784295     MOV.B [W5], W5
0020F8  B3C444     MOV #0x44, W4
0020FA  52CF84     SUB.B W5, W4, [W15]
0020FC  32000A     BRA Z, 0x2112
0020FE  208325     MOV #0x832, W5
002100  784295     MOV.B [W5], W5
002102  B3CA84     MOV #0xA8, W4
002104  52CF84     SUB.B W5, W4, [W15]
002106  320005     BRA Z, 0x2112
002108  208325     MOV #0x832, W5
00210A  784295     MOV.B [W5], W5
00210C  B3C354     MOV #0x35, W4
00210E  52CF84     SUB.B W5, W4, [W15]
002110  3A0005     BRA NZ, 0x211C
2424:                  // warmup_done bit is active.  Clear this bit
2425:                  temp_lat_b &= ~BIT_OUTPUT_MODULATOR_WARMUP_DONE;
002112  90029E     MOV [W14+2], W5
002114  2FF7F4     MOV #0xFF7F, W4
002116  628204     AND W5, W4, W4
002118  980714     MOV W4, [W14+2]
00211A  370004     BRA 0x2124
2426:                } else {
2427:                  temp_lat_b |= BIT_OUTPUT_MODULATOR_WARMUP_DONE;
00211C  90029E     MOV [W14+2], W5
00211E  200804     MOV #0x80, W4
002120  728204     IOR W5, W4, W4
002122  980714     MOV W4, [W14+2]
2428:                }
2429:              
2430:                if (faults_control_board_fault_reg) {
002124  80C3A4     MOV faults_control_board_fault_reg, W4
002126  520FE0     SUB W4, #0x0, [W15]
002128  320004     BRA Z, 0x2132
2431:                  temp_lat_b |= BIT_OUTPUT_CONTROL_BOARD_FAULT;   
00212A  90021E     MOV [W14+2], W4
00212C  A00004     BSET W4, #0
00212E  980714     MOV W4, [W14+2]
002130  370004     BRA 0x213A
2432:                } else {
2433:                  temp_lat_b &= ~BIT_OUTPUT_CONTROL_BOARD_FAULT;
002132  90029E     MOV [W14+2], W5
002134  2FFFE4     MOV #0xFFFE, W4
002136  628204     AND W5, W4, W4
002138  980714     MOV W4, [W14+2]
2434:                }
2435:                
2436:                if (faults_thyratron_fault_reg) {
00213A  80C374     MOV faults_thyratron_fault_reg, W4
00213C  520FE0     SUB W4, #0x0, [W15]
00213E  320002     BRA Z, 0x2144
2437:                  // a thyratron fault is active - Set this bit
2438:                  temp_lat_a |= BIT_OUTPUT_THYRATRON_FAULT;
002140  A0201E     BSET [W14], #2
002142  370002     BRA 0x2148
2439:                } else {
2440:                  temp_lat_a &= ~BIT_OUTPUT_THYRATRON_FAULT;
002144  2FFFB4     MOV #0xFFFB, W4
002146  620F1E     AND W4, [W14], [W14]
2441:                }
2442:                
2443:                if (faults_magnetron_fault_reg & 0xFF00) {
002148  80C315     MOV faults_magnetron_fault_reg, W5
00214A  2FF004     MOV #0xFF00, W4
00214C  628204     AND W5, W4, W4
00214E  520FE0     SUB W4, #0x0, [W15]
002150  320004     BRA Z, 0x215A
2444:                  // an electromagnet fault is active - Set this bit
2445:                  temp_lat_b |= BIT_OUTPUT_ELECTROMAGNET_FAULT;
002152  90021E     MOV [W14+2], W4
002154  A04004     BSET W4, #4
002156  980714     MOV W4, [W14+2]
002158  370004     BRA 0x2162
2446:                } else {
2447:                  temp_lat_b &= ~BIT_OUTPUT_ELECTROMAGNET_FAULT;
00215A  90029E     MOV [W14+2], W5
00215C  2FFEF4     MOV #0xFFEF, W4
00215E  628204     AND W5, W4, W4
002160  980714     MOV W4, [W14+2]
2448:                }
2449:              
2450:                if (faults_magnetron_fault_reg & 0x00FF) {
002162  80C315     MOV faults_magnetron_fault_reg, W5
002164  200FF4     MOV #0xFF, W4
002166  628204     AND W5, W4, W4
002168  520FE0     SUB W4, #0x0, [W15]
00216A  320004     BRA Z, 0x2174
2451:                  // an magnetron filament fault is active - Set this bit
2452:                  temp_lat_b |= BIT_OUTPUT_FILAMENT_FAULT;
00216C  90021E     MOV [W14+2], W4
00216E  A01004     BSET W4, #1
002170  980714     MOV W4, [W14+2]
002172  370004     BRA 0x217C
2453:                } else {
2454:                  temp_lat_b &= ~BIT_OUTPUT_FILAMENT_FAULT;
002174  90029E     MOV [W14+2], W5
002176  2FFFD4     MOV #0xFFFD, W4
002178  628204     AND W5, W4, W4
00217A  980714     MOV W4, [W14+2]
2455:                }
2456:              
2457:                if (faults_high_voltage_fault_reg & 0xFF00) {
00217C  80C345     MOV faults_high_voltage_fault_reg, W5
00217E  2FF004     MOV #0xFF00, W4
002180  628204     AND W5, W4, W4
002182  520FE0     SUB W4, #0x0, [W15]
002184  320002     BRA Z, 0x218A
2458:                  // Lambda Faultis active - Set this bit
2459:                  temp_lat_a |= BIT_OUTPUT_HV_FAULT;
002186  A0001E     BSET [W14], #0
002188  370002     BRA 0x218E
2460:                } else {
2461:                  temp_lat_a &= ~BIT_OUTPUT_HV_FAULT;
00218A  2FFFE4     MOV #0xFFFE, W4
00218C  620F1E     AND W4, [W14], [W14]
2462:                }
2463:              
2464:                if (faults_high_voltage_fault_reg & 0x00FF) {
00218E  80C345     MOV faults_high_voltage_fault_reg, W5
002190  200FF4     MOV #0xFF, W4
002192  628204     AND W5, W4, W4
002194  520FE0     SUB W4, #0x0, [W15]
002196  320002     BRA Z, 0x219C
2465:                  // Pulse Fault is active - Set this bit
2466:                  temp_lat_a |= BIT_OUTPUT_PULSE_FAULT;
002198  A0101E     BSET [W14], #1
00219A  370002     BRA 0x21A0
2467:                } else {
2468:                  temp_lat_a &= ~BIT_OUTPUT_PULSE_FAULT;
00219C  2FFFD4     MOV #0xFFFD, W4
00219E  620F1E     AND W4, [W14], [W14]
2469:                }
2470:                
2471:                if (control_state == STATE_HV_ON) {
0021A0  208325     MOV #0x832, W5
0021A2  784295     MOV.B [W5], W5
0021A4  B3C444     MOV #0x44, W4
0021A6  52CF84     SUB.B W5, W4, [W15]
0021A8  3A0004     BRA NZ, 0x21B2
2472:                  // HV is ON - Set this bit
2473:                  temp_lat_b |= BIT_OUTPUT_HV_ON_READBACK;
0021AA  90021E     MOV [W14+2], W4
0021AC  A02004     BSET W4, #2
0021AE  980714     MOV W4, [W14+2]
0021B0  370004     BRA 0x21BA
2474:                } else {
2475:                  temp_lat_b &= ~BIT_OUTPUT_HV_ON_READBACK;
0021B2  90029E     MOV [W14+2], W5
0021B4  2FFFB4     MOV #0xFFFB, W4
0021B6  628204     AND W5, W4, W4
0021B8  980714     MOV W4, [W14+2]
2476:                }
2477:              
2478:              
2479:                // We only want to update if there is a change in state.  Otherwise we have a lot of unnessary I2C traffic
2480:                if (U64_MCP23017.output_latch_a_in_ram != temp_lat_a) {
0021BA  208F64     MOV #0x8F6, W4
0021BC  784214     MOV.B [W4], W4
0021BE  FB8204     ZE W4, W4
0021C0  520F9E     SUB W4, [W14], [W15]
0021C2  320010     BRA Z, 0x21E4
2481:                  U64_MCP23017.output_latch_a_in_ram = temp_lat_a;
0021C4  78021E     MOV [W14], W4
0021C6  784204     MOV.B W4, W4
0021C8  784004     MOV.B W4, W0
0021CA  B7E8F6     MOV.B WREG, 0x8F6
2482:                  if (MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATA, U64_MCP23017.output_latch_a_in_ram) != 0) {
0021CC  208F64     MOV #0x8F6, W4
0021CE  784214     MOV.B [W4], W4
0021D0  784104     MOV.B W4, W2
0021D2  B3C141     MOV #0x14, W1
0021D4  208EE0     MOV #0x8EE, W0
0021D6  0714C7     RCALL MCP23017WriteSingleByte
0021D8  780200     MOV W0, W4
0021DA  520FE0     SUB W4, #0x0, [W15]
0021DC  320003     BRA Z, 0x21E4
2483:                    global_debug_counter.i2c_bus_error++;
0021DE  80C264     MOV 0x184C, W4
0021E0  E80204     INC W4, W4
0021E2  88C264     MOV W4, 0x184C
2484:                  }
2485:                }
2486:              
2487:                // We only want to update if there is a change in state.  Otherwise we have a lot of unnessary I2C traffic
2488:                if (U64_MCP23017.output_latch_b_in_ram != temp_lat_b) {
0021E4  208F74     MOV #0x8F7, W4
0021E6  784214     MOV.B [W4], W4
0021E8  FB8284     ZE W4, W5
0021EA  90021E     MOV [W14+2], W4
0021EC  528F84     SUB W5, W4, [W15]
0021EE  320010     BRA Z, 0x2210
2489:                  U64_MCP23017.output_latch_b_in_ram = temp_lat_b;
0021F0  90021E     MOV [W14+2], W4
0021F2  784204     MOV.B W4, W4
0021F4  784004     MOV.B W4, W0
0021F6  B7E8F7     MOV.B WREG, 0x8F7
2490:                  if (MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATB, U64_MCP23017.output_latch_b_in_ram) != 0) { 
0021F8  208F74     MOV #0x8F7, W4
0021FA  784214     MOV.B [W4], W4
0021FC  784104     MOV.B W4, W2
0021FE  B3C151     MOV #0x15, W1
002200  208EE0     MOV #0x8EE, W0
002202  0714B1     RCALL MCP23017WriteSingleByte
002204  780200     MOV W0, W4
002206  520FE0     SUB W4, #0x0, [W15]
002208  320003     BRA Z, 0x2210
2491:                    global_debug_counter.i2c_bus_error++;
00220A  80C264     MOV 0x184C, W4
00220C  E80204     INC W4, W4
00220E  88C264     MOV W4, 0x184C
2492:                  }
2493:                }
2494:              }
002210  FA8000     ULNK
002212  060000     RETURN
2495:              
2496:              
2497:              void HVLambdaStartCharging(void) {
002214  FA0000     LNK #0x0
2498:                /*
2499:                  This starts the charging process . . .
2500:                  The following ocurrs . . .
2501:                  * The Lamabda is enabled via the ENABLE Pin
2502:                  * The Lamabda Inhibit input is set to NOT INHIBIT
2503:                  * TMR1 is set up to time the charging process and ensure the lamabda reaches EOC before the first pulse
2504:                  * TMR2 is set up to time the 100ms Timeout for the next pulse
2505:                  * HouseKeeping - global_run_post_pulse_process is cleared
2506:                  
2507:                */
2508:              
2509:                // --------  Select A or B mode based on the input ----------- //
2510:                if (PIN_A_B_MODE_SELECT == ILL_A_MODE_SELECTED) {
002216  801615     MOV PORTA, W5
002218  220004     MOV #0x2000, W4
00221A  628204     AND W5, W4, W4
00221C  520FE0     SUB W4, #0x0, [W15]
00221E  320005     BRA Z, 0x222A
2511:                  a_b_selected_mode = PULSE_MODE_A;
002220  EB4200     CLR.B W4
002222  784004     MOV.B W4, W0
002224  B7F6CE     MOV.B WREG, a_b_selected_mode
2512:                  PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002226  A9C2CB     BCLR 0x2CB, #6
002228  370004     BRA 0x2232
2513:                } else {
2514:                  a_b_selected_mode = PULSE_MODE_B;
00222A  B3C014     MOV #0x1, W4
00222C  784004     MOV.B W4, W0
00222E  B7F6CE     MOV.B WREG, a_b_selected_mode
2515:                  PIN_LAMBDA_VOLTAGE_SELECT = !OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002230  A8C2CB     BSET 0x2CB, #6
2516:                }
2517:              
2518:                // Actually enable the Lambda
2519:                PIN_HV_LAMBDA_ENABLE = OLL_HV_LAMBDA_ENABLED;
002232  A862D7     BSET 0x2D7, #3
2520:                PIN_HV_LAMBDA_INHIBIT = !OLL_HV_LAMBDA_INHIBITED;
002234  A902D6     BCLR LATD, #0
2521:                
2522:              
2523:                // Setup T1 to time to first charge
2524:                T1CONbits.TON = 0;
002236  A9E105     BCLR 0x105, #7
2525:                TMR1 = 0;
002238  EB0200     CLR W4
00223A  880804     MOV W4, TMR1
2526:                _T1IF = 0;
00223C  A96084     BCLR IFS0, #3
2527:                _T1IE = 1;
00223E  A8608C     BSET IEC0, #3
2528:                PR1 = (TMR1_LAMBDA_CHARGE_PERIOD);
002240  201774     MOV #0x177, W4
002242  880814     MOV W4, PR1
2529:                T1CONbits.TON = 1;
002244  A8E105     BSET 0x105, #7
2530:              
2531:                // Setup T2 to roll in 100ms if there are no pulses
2532:                TMR2 = 0;  
002246  EB0200     CLR W4
002248  880834     MOV W4, TMR2
2533:                _T2IF = 0;
00224A  A9C084     BCLR IFS0, #6
2534:              }
00224C  FA8000     ULNK
00224E  060000     RETURN
2535:              
2536:              
2537:              
2538:              /*
2539:                Scaling
2540:                
2541:                Scaling is up as Q13.
2542:                0x0000 = 0
2543:                0xFFFF = 7.99988
2544:                
2545:                Scaling = (num/den) * (2^13))
2546:              */
2547:              
2548:              unsigned int MakeScale(unsigned int num, unsigned int den) {
002250  FA000A     LNK #0xA
002252  980730     MOV W0, [W14+6]
002254  980741     MOV W1, [W14+8]
2549:                unsigned long temp;
2550:                unsigned int return_value;
2551:                
2552:                temp = num;
002256  90023E     MOV [W14+6], W4
002258  200005     MOV #0x0, W5
00225A  980714     MOV W4, [W14+2]
00225C  980725     MOV W5, [W14+4]
2553:                temp = temp << 16;
00225E  90021E     MOV [W14+2], W4
002260  9002AE     MOV [W14+4], W5
002262  DD22C0     SL W4, #0, W5
002264  200004     MOV #0x0, W4
002266  980714     MOV W4, [W14+2]
002268  980725     MOV W5, [W14+4]
2554:                temp /= den;
00226A  90024E     MOV [W14+8], W4
00226C  200005     MOV #0x0, W5
00226E  BE0104     MOV.D W4, W2
002270  90001E     MOV [W14+2], W0
002272  9000AE     MOV [W14+4], W1
002274  07F020     RCALL ___udivsi3
002276  BE0200     MOV.D W0, W4
002278  980714     MOV W4, [W14+2]
00227A  980725     MOV W5, [W14+4]
2555:                temp = temp >> 3;
00227C  90021E     MOV [W14+2], W4
00227E  9002AE     MOV [W14+4], W5
002280  DD2B4D     SL W5, #13, W6
002282  DE2243     LSR W4, #3, W4
002284  730204     IOR W6, W4, W4
002286  DE2AC3     LSR W5, #3, W5
002288  980714     MOV W4, [W14+2]
00228A  980725     MOV W5, [W14+4]
2556:                
2557:                if (temp & 0xFFFF0000) {
00228C  90031E     MOV [W14+2], W6
00228E  9003AE     MOV [W14+4], W7
002290  200004     MOV #0x0, W4
002292  2FFFF5     MOV #0xFFFF, W5
002294  780006     MOV W6, W0
002296  780307     MOV W7, W6
002298  780384     MOV W4, W7
00229A  780205     MOV W5, W4
00229C  600007     AND W0, W7, W0
00229E  630204     AND W6, W4, W4
0022A0  200005     MOV #0x0, W5
0022A2  DD22C0     SL W4, #0, W5
0022A4  200004     MOV #0x0, W4
0022A6  BE0304     MOV.D W4, W6
0022A8  B80261     MUL.UU W0, #1, W4
0022AA  730304     IOR W6, W4, W6
0022AC  738385     IOR W7, W5, W7
0022AE  530FE0     SUB W6, #0x0, [W15]
0022B0  5B8FE0     SUBB W7, #0x0, [W15]
0022B2  320003     BRA Z, 0x22BA
2558:                  // DPARKER saturation error
2559:                  return_value = 0xFFFF;
0022B4  EB8200     SETM W4
0022B6  780F04     MOV W4, [W14]
0022B8  370002     BRA 0x22BE
2560:                } else {
2561:                  return_value = temp & 0xFFFF;
0022BA  90021E     MOV [W14+2], W4
0022BC  780F04     MOV W4, [W14]
2562:                }
2563:                return return_value;
0022BE  78021E     MOV [W14], W4
2564:              }
0022C0  780004     MOV W4, W0
0022C2  FA8000     ULNK
0022C4  060000     RETURN
2565:              
2566:              
2567:              unsigned int Scale16Bit(unsigned int value, unsigned int scale) {
0022C6  FA0008     LNK #0x8
0022C8  980720     MOV W0, [W14+4]
0022CA  980731     MOV W1, [W14+6]
2568:                unsigned long temp;
2569:                temp = value;
0022CC  90022E     MOV [W14+4], W4
0022CE  200005     MOV #0x0, W5
0022D0  BE8F04     MOV.D W4, [W14]
2570:                temp *= scale;
0022D2  90023E     MOV [W14+6], W4
0022D4  200005     MOV #0x0, W5
0022D6  90031E     MOV [W14+2], W6
0022D8  B9B304     MUL.SS W6, W4, W6
0022DA  780306     MOV W6, W6
0022DC  78039E     MOV [W14], W7
0022DE  B9B805     MUL.SS W7, W5, W0
0022E0  780380     MOV W0, W7
0022E2  430307     ADD W6, W7, W6
0022E4  78039E     MOV [W14], W7
0022E6  780204     MOV W4, W4
0022E8  B82207     MUL.UU W4, W7, W4
0022EA  430305     ADD W6, W5, W6
0022EC  780286     MOV W6, W5
0022EE  BE8F04     MOV.D W4, [W14]
0022F0  BE8F04     MOV.D W4, [W14]
2571:                temp = temp >> 13;
0022F2  BE021E     MOV.D [W14], W4
0022F4  DD2B43     SL W5, #3, W6
0022F6  DE224D     LSR W4, #13, W4
0022F8  730204     IOR W6, W4, W4
0022FA  DE2ACD     LSR W5, #13, W5
0022FC  BE8F04     MOV.D W4, [W14]
2572:                if (temp > 0x0000FFFF) {
0022FE  2FFFF4     MOV #0xFFFF, W4
002300  200005     MOV #0x0, W5
002302  BE031E     MOV.D [W14], W6
002304  530F84     SUB W6, W4, [W15]
002306  5B8F85     SUBB W7, W5, [W15]
002308  360006     BRA LEU, 0x2316
2573:                  temp = 0x0000FFFF;
00230A  2FFFF4     MOV #0xFFFF, W4
00230C  200005     MOV #0x0, W5
00230E  BE8F04     MOV.D W4, [W14]
2574:                  global_debug_counter.scale16bit_saturation++;
002310  80C2C4     MOV 0x1858, W4
002312  E80204     INC W4, W4
002314  88C2C4     MOV W4, 0x1858
2575:                }
2576:                value = temp & 0xFFFF;
002316  78021E     MOV [W14], W4
002318  980724     MOV W4, [W14+4]
2577:                return value;
00231A  90022E     MOV [W14+4], W4
2578:              }
00231C  780004     MOV W4, W0
00231E  FA8000     ULNK
002320  060000     RETURN
2579:              
2580:              
2581:              
2582:              unsigned int RCFilter256Tau(unsigned int previous_value, unsigned int current_reading) {
002322  FA000A     LNK #0xA
002324  980730     MOV W0, [W14+6]
002326  980741     MOV W1, [W14+8]
2583:                unsigned long temp32;
2584:                unsigned int temp16;
2585:                if (previous_value == 0) {
002328  90023E     MOV [W14+6], W4
00232A  520FE0     SUB W4, #0x0, [W15]
00232C  3A0002     BRA NZ, 0x2332
2586:                  previous_value = current_reading;
00232E  90024E     MOV [W14+8], W4
002330  980734     MOV W4, [W14+6]
2587:                }
2588:                temp32 = previous_value;
002332  90023E     MOV [W14+6], W4
002334  200005     MOV #0x0, W5
002336  980714     MOV W4, [W14+2]
002338  980725     MOV W5, [W14+4]
2589:                temp32 *= 255;
00233A  9002AE     MOV [W14+4], W5
00233C  200FF4     MOV #0xFF, W4
00233E  B9AA04     MUL.SS W5, W4, W4
002340  780304     MOV W4, W6
002342  90021E     MOV [W14+2], W4
002344  B92260     MUL.SU W4, #0, W4
002346  780204     MOV W4, W4
002348  430304     ADD W6, W4, W6
00234A  90029E     MOV [W14+2], W5
00234C  200FF4     MOV #0xFF, W4
00234E  B82A04     MUL.UU W5, W4, W4
002350  430305     ADD W6, W5, W6
002352  780286     MOV W6, W5
002354  980714     MOV W4, [W14+2]
002356  980725     MOV W5, [W14+4]
002358  980714     MOV W4, [W14+2]
00235A  980725     MOV W5, [W14+4]
2590:                temp32 += current_reading;
00235C  90024E     MOV [W14+8], W4
00235E  200005     MOV #0x0, W5
002360  90031E     MOV [W14+2], W6
002362  9003AE     MOV [W14+4], W7
002364  420206     ADD W4, W6, W4
002366  4A8287     ADDC W5, W7, W5
002368  980714     MOV W4, [W14+2]
00236A  980725     MOV W5, [W14+4]
2591:                temp32 = temp32 >> 8;
00236C  90021E     MOV [W14+2], W4
00236E  9002AE     MOV [W14+4], W5
002370  DD2B48     SL W5, #8, W6
002372  DE2248     LSR W4, #8, W4
002374  730204     IOR W6, W4, W4
002376  DE2AC8     LSR W5, #8, W5
002378  980714     MOV W4, [W14+2]
00237A  980725     MOV W5, [W14+4]
2592:                temp16 = temp32;
00237C  90021E     MOV [W14+2], W4
00237E  780F04     MOV W4, [W14]
2593:                if (current_reading > temp16) {
002380  90024E     MOV [W14+8], W4
002382  520F9E     SUB W4, [W14], [W15]
002384  360002     BRA LEU, 0x238A
2594:                  temp16++;
002386  E80F1E     INC [W14], [W14]
002388  370004     BRA 0x2392
2595:                } else if (current_reading < temp16) {
00238A  90024E     MOV [W14+8], W4
00238C  520F9E     SUB W4, [W14], [W15]
00238E  310001     BRA C, 0x2392
2596:                  temp16--;
002390  E90F1E     DEC [W14], [W14]
2597:                }
2598:                return temp16;
002392  78021E     MOV [W14], W4
2599:              }
002394  780004     MOV W4, W0
002396  FA8000     ULNK
002398  060000     RETURN
2600:              
2601:              
2602:              unsigned int RCFilter64Tau(unsigned int previous_value, unsigned int current_reading) {
00239A  FA000A     LNK #0xA
00239C  980730     MOV W0, [W14+6]
00239E  980741     MOV W1, [W14+8]
2603:                unsigned long temp32;
2604:                unsigned int temp16;
2605:                if (previous_value == 0) {
0023A0  90023E     MOV [W14+6], W4
0023A2  520FE0     SUB W4, #0x0, [W15]
0023A4  3A0002     BRA NZ, 0x23AA
2606:                  previous_value = current_reading;
0023A6  90024E     MOV [W14+8], W4
0023A8  980734     MOV W4, [W14+6]
2607:                }
2608:                temp32 = previous_value;
0023AA  90023E     MOV [W14+6], W4
0023AC  200005     MOV #0x0, W5
0023AE  980714     MOV W4, [W14+2]
0023B0  980725     MOV W5, [W14+4]
2609:                temp32 *= 63;
0023B2  9002AE     MOV [W14+4], W5
0023B4  2003F4     MOV #0x3F, W4
0023B6  B9AA04     MUL.SS W5, W4, W4
0023B8  780304     MOV W4, W6
0023BA  90021E     MOV [W14+2], W4
0023BC  B92260     MUL.SU W4, #0, W4
0023BE  780204     MOV W4, W4
0023C0  430304     ADD W6, W4, W6
0023C2  90029E     MOV [W14+2], W5
0023C4  2003F4     MOV #0x3F, W4
0023C6  B82A04     MUL.UU W5, W4, W4
0023C8  430305     ADD W6, W5, W6
0023CA  780286     MOV W6, W5
0023CC  980714     MOV W4, [W14+2]
0023CE  980725     MOV W5, [W14+4]
0023D0  980714     MOV W4, [W14+2]
0023D2  980725     MOV W5, [W14+4]
2610:                temp32 += current_reading;
0023D4  90024E     MOV [W14+8], W4
0023D6  200005     MOV #0x0, W5
0023D8  90031E     MOV [W14+2], W6
0023DA  9003AE     MOV [W14+4], W7
0023DC  420206     ADD W4, W6, W4
0023DE  4A8287     ADDC W5, W7, W5
0023E0  980714     MOV W4, [W14+2]
0023E2  980725     MOV W5, [W14+4]
2611:                temp32 = temp32 >> 6;
0023E4  90021E     MOV [W14+2], W4
0023E6  9002AE     MOV [W14+4], W5
0023E8  DD2B4A     SL W5, #10, W6
0023EA  DE2246     LSR W4, #6, W4
0023EC  730204     IOR W6, W4, W4
0023EE  DE2AC6     LSR W5, #6, W5
0023F0  980714     MOV W4, [W14+2]
0023F2  980725     MOV W5, [W14+4]
2612:                temp16 = temp32;
0023F4  90021E     MOV [W14+2], W4
0023F6  780F04     MOV W4, [W14]
2613:                if (current_reading > temp16) {
0023F8  90024E     MOV [W14+8], W4
0023FA  520F9E     SUB W4, [W14], [W15]
0023FC  360002     BRA LEU, 0x2402
2614:                  temp16++;
0023FE  E80F1E     INC [W14], [W14]
002400  370004     BRA 0x240A
2615:                } else if (current_reading < temp16) {
002402  90024E     MOV [W14+8], W4
002404  520F9E     SUB W4, [W14], [W15]
002406  310001     BRA C, 0x240A
2616:                  temp16--;
002408  E90F1E     DEC [W14], [W14]
2617:                }
2618:                return temp16;
00240A  78021E     MOV [W14], W4
2619:              }
00240C  780004     MOV W4, W0
00240E  FA8000     ULNK
002410  060000     RETURN
2620:              
2621:              
2622:              unsigned int RCFilter16Tau(unsigned int previous_value, unsigned int current_reading) {
002412  FA000A     LNK #0xA
002414  980730     MOV W0, [W14+6]
002416  980741     MOV W1, [W14+8]
2623:                unsigned long temp32;
2624:                unsigned int temp16;
2625:                if (previous_value == 0) {
002418  90023E     MOV [W14+6], W4
00241A  520FE0     SUB W4, #0x0, [W15]
00241C  3A0002     BRA NZ, 0x2422
2626:                  previous_value = current_reading;
00241E  90024E     MOV [W14+8], W4
002420  980734     MOV W4, [W14+6]
2627:                }
2628:                temp32 = previous_value;
002422  90023E     MOV [W14+6], W4
002424  200005     MOV #0x0, W5
002426  980714     MOV W4, [W14+2]
002428  980725     MOV W5, [W14+4]
2629:                temp32 *= 15;
00242A  90022E     MOV [W14+4], W4
00242C  B9226F     MUL.SU W4, #15, W4
00242E  780304     MOV W4, W6
002430  90021E     MOV [W14+2], W4
002432  B92260     MUL.SU W4, #0, W4
002434  780204     MOV W4, W4
002436  430304     ADD W6, W4, W6
002438  90029E     MOV [W14+2], W5
00243A  2000F4     MOV #0xF, W4
00243C  B82A04     MUL.UU W5, W4, W4
00243E  430305     ADD W6, W5, W6
002440  780286     MOV W6, W5
002442  980714     MOV W4, [W14+2]
002444  980725     MOV W5, [W14+4]
002446  980714     MOV W4, [W14+2]
002448  980725     MOV W5, [W14+4]
2630:                temp32 += current_reading;
00244A  90024E     MOV [W14+8], W4
00244C  200005     MOV #0x0, W5
00244E  90031E     MOV [W14+2], W6
002450  9003AE     MOV [W14+4], W7
002452  420206     ADD W4, W6, W4
002454  4A8287     ADDC W5, W7, W5
002456  980714     MOV W4, [W14+2]
002458  980725     MOV W5, [W14+4]
2631:                temp32 = temp32 >> 4;
00245A  90021E     MOV [W14+2], W4
00245C  9002AE     MOV [W14+4], W5
00245E  DD2B4C     SL W5, #12, W6
002460  DE2244     LSR W4, #4, W4
002462  730204     IOR W6, W4, W4
002464  DE2AC4     LSR W5, #4, W5
002466  980714     MOV W4, [W14+2]
002468  980725     MOV W5, [W14+4]
2632:                temp16 = temp32;
00246A  90021E     MOV [W14+2], W4
00246C  780F04     MOV W4, [W14]
2633:                if (current_reading > temp16) {
00246E  90024E     MOV [W14+8], W4
002470  520F9E     SUB W4, [W14], [W15]
002472  360002     BRA LEU, 0x2478
2634:                  temp16++;
002474  E80F1E     INC [W14], [W14]
002476  370004     BRA 0x2480
2635:                } else if (current_reading < temp16) {
002478  90024E     MOV [W14+8], W4
00247A  520F9E     SUB W4, [W14], [W15]
00247C  310001     BRA C, 0x2480
2636:                  temp16--;
00247E  E90F1E     DEC [W14], [W14]
2637:                }
2638:                return temp16;
002480  78021E     MOV [W14], W4
2639:              }
002482  780004     MOV W4, W0
002484  FA8000     ULNK
002486  060000     RETURN
2640:              
2641:              
2642:              
2643:              
2644:              
2645:              
2646:              
2647:              
2648:              
2649:              
2650:              void _ISRFASTNOPSV _INT1Interrupt(void) {
002488  FEA000     PUSH.S
00248A  BE9F84     MOV.D W4, [W15++]
00248C  FA0000     LNK #0x0
2651:                /*
2652:                  This interrupt does NOTHING TO CONTROL THE TYHRATRON TRIGGER
2653:                  By the time this interrupt is called, the trigger has already been routed to the thyratron
2654:                  This interrupt just schedules data acquisition and prepares for the NEXT pulse.
2655:                  
2656:                  This interrupt is enabled when the PIN_THYRATRON_TRIGGER_ENABLE is set (and disabled when that output is cleared).
2657:                  Therefore, if this interrupt has been entered then a trigger pulse was probably sent to the thyratron.
2658:                  It is possible that a trigger pulse was masked by a hardware fault BEFORE the software could detect it.
2659:                  If this were to happen then, the hardware faults will be detected in the next flow through the control loop
2660:                  and the system will detect Magnetron Undervoltage Undercurrent faults (because it is expecting a pulse that does not happen)
2661:                  
2662:                  Assuming a sucessful trigger, this interupt will do the following conecptual steps
2663:                  (1) Wait a set amount of time to sample the Magnetron Voltage, Magnetron Current, and PFN Fault Current at the approriate time
2664:                  (2) Wait for the pulse EMI to pass
2665:                  (2) Read the Magnetron Voltage and Magnetron Current into RAM.
2666:                  (3) Inhibit the HV supply a set amount of time.
2667:                  (4) After the inhibt time has passed, !Inhibit the power supply, and start the EOC timer
2668:                  (5) Set the status bit that indicates a pulse occured
2669:                */ 
2670:              
2671:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;  
00248E  A802D6     BSET LATD, #0
2672:              
2673:                // Trigger Delay is 800ns
2674:                // ADC Trigger Delay Across barrier is 950ns (this should be made faster)
2675:                // ISR Call Delay from trigger to output going high is 10 TCy
2676:                // Repeat stament will exexute N+1 Times
2677:                // Repeate statement itself is 1 Cycle
2678:                // There fore to calculate the trigger delay (from the start of the pulse)
2679:                // ((PFN_Sample_Point_US + 800ns (trigger delay) - 950ns (ADC Trigger Delay)) = Total Delay
2680:                // Total Delay/Tcy = Total Clock Delay
2681:                // Repeat Call = Total Clock Delay - 10 - 2
2682:              
2683:                Nop();
002490  000000     NOP
2684:                Nop();
002492  000000     NOP
2685:                Nop();
002494  000000     NOP
2686:                Nop();
002496  000000     NOP
2687:              
2688:              
2689:                PIN_PULSE_ADC_TRIGGER = OLL_TRIGGER_PULSE_ADCS;                  // Trigger the conversion process on both ADCs
002498  A822E2     BSET LATF, #1
2690:                _INT1IF = 0;
00249A  A90086     BCLR IFS1, #0
2691:                _INT1IE = 0;
00249C  A9008E     BCLR IEC1, #0
2692:              
2693:                last_known_action = LAST_ACTION_INT1_INT;
00249E  200044     MOV #0x4, W4
0024A0  88C5A4     MOV W4, last_known_action
2694:              
2695:                // Setup timer1 to time the time it takes the PFN EMI to dissipate
2696:                T1CONbits.TON = 0;
0024A2  A9E105     BCLR 0x105, #7
2697:                TMR1 = 0;
0024A4  EB0200     CLR W4
0024A6  880804     MOV W4, TMR1
2698:                PR1 = TMR1_DELAY_HOLDOFF;
0024A8  200084     MOV #0x8, W4
0024AA  880814     MOV W4, PR1
2699:                _T1IE = 0;
0024AC  A9608C     BCLR IEC0, #3
2700:                _T1IF = 0;
0024AE  A96084     BCLR IFS0, #3
2701:                T1CONbits.TON = 1;
0024B0  A8E105     BSET 0x105, #7
2702:                
2703:                false_trigger = 0;
0024B2  EB0200     CLR W4
0024B4  884104     MOV W4, false_trigger
2704:              
2705:                while (TMR1 < 2);  // 128 clock cycles, 12.8uS
0024B6  000000     NOP
0024B8  800804     MOV TMR1, W4
0024BA  520FE1     SUB W4, #0x1, [W15]
0024BC  36FFFD     BRA LEU, 0x24B8
2706:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
0024BE  801615     MOV PORTA, W5
0024C0  210004     MOV #0x1000, W4
0024C2  628204     AND W5, W4, W4
0024C4  520FE0     SUB W4, #0x0, [W15]
0024C6  3A0003     BRA NZ, 0x24CE
2707:                  false_trigger = 1;
0024C8  200014     MOV #0x1, W4
0024CA  884104     MOV W4, false_trigger
2708:                }
2709:              
2710:                while (TMR1 < 3);  // 192 clock cycles, 19.2uS
0024CC  370001     BRA 0x24D0
0024CE  000000     NOP
0024D0  800804     MOV TMR1, W4
0024D2  520FE2     SUB W4, #0x2, [W15]
0024D4  36FFFD     BRA LEU, 0x24D0
2711:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
0024D6  801615     MOV PORTA, W5
0024D8  210004     MOV #0x1000, W4
0024DA  628204     AND W5, W4, W4
0024DC  520FE0     SUB W4, #0x0, [W15]
0024DE  3A0003     BRA NZ, 0x24E6
2712:                  false_trigger = 1;
0024E0  200014     MOV #0x1, W4
0024E2  884104     MOV W4, false_trigger
2713:                }
2714:              
2715:                while (TMR1 < 3);  // 256 clock cycles, 25.6uS
0024E4  370001     BRA 0x24E8
0024E6  000000     NOP
0024E8  800804     MOV TMR1, W4
0024EA  520FE2     SUB W4, #0x2, [W15]
0024EC  36FFFD     BRA LEU, 0x24E8
2716:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
0024EE  801615     MOV PORTA, W5
0024F0  210004     MOV #0x1000, W4
0024F2  628204     AND W5, W4, W4
0024F4  520FE0     SUB W4, #0x0, [W15]
0024F6  3A0002     BRA NZ, 0x24FC
2717:                  false_trigger = 1;
0024F8  200014     MOV #0x1, W4
0024FA  884104     MOV W4, false_trigger
2718:                }
2719:              
2720:                arc_detected = 0;
0024FC  EB0200     CLR W4
0024FE  884064     MOV W4, arc_detected
2721:                if ((PIN_PULSE_OVER_CUR_LATCH == ILL_PULSE_OVER_CURRENT_FAULT) || (PIN_PULSE_MIN_CUR_LATCH == ILL_PULSE_MIN_CURRENT_FAULT)) {
002500  8016A4     MOV PORTD, W4
002502  620270     AND W4, #0x10, W4
002504  520FE0     SUB W4, #0x0, [W15]
002506  320005     BRA Z, 0x2512
002508  8016A5     MOV PORTD, W5
00250A  200804     MOV #0x80, W4
00250C  628204     AND W5, W4, W4
00250E  520FE0     SUB W4, #0x0, [W15]
002510  320002     BRA Z, 0x2516
2722:                  arc_detected = 1;
002512  200014     MOV #0x1, W4
002514  884064     MOV W4, arc_detected
2723:                }
2724:              
2725:                PIN_PULSE_LATCH_RESET = OLL_PULSE_LATCH_RESET;  // Clear the pulse latches so we can detect a false trigger
002516  A922E8     BCLR LATG, #1
2726:              
2727:                while(!_T1IF);                                                   // what for the holdoff time to pass
002518  000000     NOP
00251A  800424     MOV IFS0, W4
00251C  620268     AND W4, #0x8, W4
00251E  520FE0     SUB W4, #0x0, [W15]
002520  32FFFC     BRA Z, 0x251A
2728:              
2729:              
2730:                // Read the state of the A_B select Optical input and adjust the system as nesseasry
2731:                if (PIN_A_B_MODE_SELECT == ILL_A_MODE_SELECTED) {
002522  801615     MOV PORTA, W5
002524  220004     MOV #0x2000, W4
002526  628204     AND W5, W4, W4
002528  520FE0     SUB W4, #0x0, [W15]
00252A  320005     BRA Z, 0x2536
2732:                  next_pulse_a_b_selected_mode = PULSE_MODE_A;
00252C  EB4200     CLR.B W4
00252E  784004     MOV.B W4, W0
002530  B7F6CF     MOV.B WREG, next_pulse_a_b_selected_mode
2733:                  PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002532  A9C2CB     BCLR 0x2CB, #6
002534  370004     BRA 0x253E
2734:                } else {
2735:                  next_pulse_a_b_selected_mode = PULSE_MODE_B;
002536  B3C014     MOV #0x1, W4
002538  784004     MOV.B W4, W0
00253A  B7F6CF     MOV.B WREG, next_pulse_a_b_selected_mode
2736:                  PIN_LAMBDA_VOLTAGE_SELECT = !OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
00253C  A8C2CB     BSET 0x2CB, #6
2737:                }
2738:              
2739:              
2740:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;   // Disable the Pic trigger signal gate
00253E  A9C2C4     BCLR LATA, #6
2741:                PIN_HV_LAMBDA_INHIBIT = !OLL_HV_LAMBDA_INHIBITED;                // Start the lambda charge process
002540  A902D6     BCLR LATD, #0
2742:              
2743:                // Set up Timer1 to produce interupt at end of charge period
2744:                T1CONbits.TON = 0;
002542  A9E105     BCLR 0x105, #7
2745:                TMR1 = 0;
002544  EB0200     CLR W4
002546  880804     MOV W4, TMR1
2746:                _T1IF = 0;
002548  A96084     BCLR IFS0, #3
2747:                _T1IE = 1;
00254A  A8608C     BSET IEC0, #3
2748:                PR1 = (TMR1_LAMBDA_CHARGE_PERIOD - TMR1_DELAY_HOLDOFF);
00254C  2016E4     MOV #0x16E, W4
00254E  880814     MOV W4, PR1
2749:                T1CONbits.TON = 1;
002550  A8E105     BSET 0x105, #7
2750:              
2751:                // Wait for the pulse latches to clear
2752:                while ((PIN_PULSE_OVER_CUR_LATCH == ILL_PULSE_OVER_CURRENT_FAULT) && (TMR1 < 20));
002552  000000     NOP
002554  8016A4     MOV PORTD, W4
002556  620270     AND W4, #0x10, W4
002558  520FE0     SUB W4, #0x0, [W15]
00255A  3A0004     BRA NZ, 0x2564
00255C  800804     MOV TMR1, W4
00255E  520FF3     SUB W4, #0x13, [W15]
002560  36FFF9     BRA LEU, 0x2554
2753:                while ((PIN_PULSE_MIN_CUR_LATCH == ILL_PULSE_MIN_CURRENT_FAULT) && (TMR1 < 20));
002562  370001     BRA 0x2566
002564  000000     NOP
002566  8016A5     MOV PORTD, W5
002568  200804     MOV #0x80, W4
00256A  628204     AND W5, W4, W4
00256C  520FE0     SUB W4, #0x0, [W15]
00256E  320003     BRA Z, 0x2576
002570  800804     MOV TMR1, W4
002572  520FF3     SUB W4, #0x13, [W15]
002574  36FFF8     BRA LEU, 0x2566
2754:                
2755:                if (TMR1 >= 20) {
002576  800804     MOV TMR1, W4
002578  520FF3     SUB W4, #0x13, [W15]
00257A  360003     BRA LEU, 0x2582
2756:                  // there was an error with the pulse latch reset 
2757:                  global_debug_counter.pulse_latch_reset_error++; 
00257C  80C2E4     MOV 0x185C, W4
00257E  E80204     INC W4, W4
002580  88C2E4     MOV W4, 0x185C
2758:                }
2759:              	 
2760:              	 
2761:              
2762:                PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
002582  A822E8     BSET LATG, #1
2763:                
2764:                // Clear the Change Notification data that is used to detect a false trigger
2765:                if (PIN_PULSE_MIN_CUR_LATCH); // We need to read this port in order to clear CN data
002584  8016A4     MOV PORTD, W4
2766:                _CNIF = 0; // Clear the interrupt flag that gets set when we have a valid pulse
002586  A9E085     BCLR 0x85, #7
2767:                
2768:                
2769:                
2770:                if (global_run_post_pulse_process) {
002588  216CC4     MOV #0x16CC, W4
00258A  784214     MOV.B [W4], W4
00258C  524FE0     SUB.B W4, #0x0, [W15]
00258E  320003     BRA Z, 0x2596
2771:                  timing_error_int1_count++;
002590  80C464     MOV timing_error_int1_count, W4
002592  E80204     INC W4, W4
002594  88C464     MOV W4, timing_error_int1_count
2772:                }
2773:              
2774:                global_run_post_pulse_process = 1; // This tells the main control loop that a pulse has occured and that it should run the post pulse process once (and only once) 
002596  B3C014     MOV #0x1, W4
002598  784004     MOV.B W4, W0
00259A  B7F6CC     MOV.B WREG, global_run_post_pulse_process
2775:                global_adc_ignore_this_sample = 1;  // This allows the internal ADC ISR to know that there was a pulse and to discard all the data from the sequence where the pulse occured
00259C  B3C014     MOV #0x1, W4
00259E  784004     MOV.B W4, W0
0025A0  B7F6CD     MOV.B WREG, global_adc_ignore_this_sample
2776:              }
0025A2  FA8000     ULNK
0025A4  BE024F     MOV.D [--W15], W4
0025A6  FE8000     POP.S
0025A8  064000     RETFIE
2777:              
2778:              
2779:              
2780:              void _ISRNOPSV _T1Interrupt(void) {
0025AA  F80036     PUSH RCOUNT
0025AC  BE9F80     MOV.D W0, [W15++]
0025AE  BE9F82     MOV.D W2, [W15++]
0025B0  BE9F84     MOV.D W4, [W15++]
0025B2  BE9F86     MOV.D W6, [W15++]
0025B4  FA0002     LNK #0x2
2781:                /*
2782:                  This interrupt indicates that the cap charger should have finished charging and it is time to enable the trigger pulse.
2783:              
2784:                  This interrupt is called X us after charging starts
2785:                  If the lambda is not at EOC, it does not enable the trigger and sets the Lambda EOC Timeout Fault bit
2786:                  If the lambda is at EOC, It enables the trigger & sets status bits to show that the lambda is not charging and that the system is ready to fire.    
2787:                */
2788:                unsigned char lambda_eoc_fault;
2789:              
2790:                last_known_action = LAST_ACTION_T1_INT;
0025B6  200034     MOV #0x3, W4
0025B8  88C5A4     MOV W4, last_known_action
2791:                
2792:                _T1IF = 0;         // Clear the interrupt flag
0025BA  A96084     BCLR IFS0, #3
2793:                _T1IE = 0;         // Disable the interrupt (This will be enabled the next time that a capacitor charging sequence starts)
0025BC  A9608C     BCLR IEC0, #3
2794:                T1CONbits.TON = 0;   // Stop the timer from incrementing (Again this will be restarted with the next time the capacitor charge sequence starts)
0025BE  A9E105     BCLR 0x105, #7
2795:                
2796:                // DPARKER - Consider adding more checks - Magnet Current, Actual Lambda Voltage, Check all the fault registers to confirm good to go!!!!
2797:              
2798:                lambda_eoc_fault = 0;
0025C0  EB4200     CLR.B W4
0025C2  784F04     MOV.B W4, [W14]
2799:                if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
0025C4  8016A4     MOV PORTD, W4
0025C6  620264     AND W4, #0x4, W4
0025C8  520FE0     SUB W4, #0x0, [W15]
0025CA  32001E     BRA Z, 0x2608
2800:                  __delay32(DELAY_TCY_10US);
0025CC  200640     MOV #0x64, W0
0025CE  200001     MOV #0x0, W1
0025D0  0713B6     RCALL ___delay32
2801:                  if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
0025D2  8016A4     MOV PORTD, W4
0025D4  620264     AND W4, #0x4, W4
0025D6  520FE0     SUB W4, #0x0, [W15]
0025D8  320017     BRA Z, 0x2608
2802:                    __delay32(DELAY_TCY_10US);
0025DA  200640     MOV #0x64, W0
0025DC  200001     MOV #0x0, W1
0025DE  0713AF     RCALL ___delay32
2803:                    if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
0025E0  8016A4     MOV PORTD, W4
0025E2  620264     AND W4, #0x4, W4
0025E4  520FE0     SUB W4, #0x0, [W15]
0025E6  320010     BRA Z, 0x2608
2804:              	__delay32(DELAY_TCY_10US);
0025E8  200640     MOV #0x64, W0
0025EA  200001     MOV #0x0, W1
0025EC  0713A8     RCALL ___delay32
2805:              	if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
0025EE  8016A4     MOV PORTD, W4
0025F0  620264     AND W4, #0x4, W4
0025F2  520FE0     SUB W4, #0x0, [W15]
0025F4  320009     BRA Z, 0x2608
2806:              	  __delay32(DELAY_TCY_10US);
0025F6  200640     MOV #0x64, W0
0025F8  200001     MOV #0x0, W1
0025FA  0713A1     RCALL ___delay32
2807:              	  if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
0025FC  8016A4     MOV PORTD, W4
0025FE  620264     AND W4, #0x4, W4
002600  520FE0     SUB W4, #0x0, [W15]
002602  320002     BRA Z, 0x2608
2808:              	    RecordThisHighVoltageFault(FAULT_HV_LAMBDA_EOC_TIMEOUT);
002604  202000     MOV #0x200, W0
002606  070C8E     RCALL RecordThisHighVoltageFault
2809:              	  }
2810:              	} 
2811:                    }
2812:                  }
2813:                }
2814:              
2815:                // Enable the the thyratron trigger and Enable the Trigger Interrupt 
2816:                PIN_THYRATRON_TRIGGER_ENABLE = OLL_THYRATRON_TRIGGER_ENABLED; // Enable the thyratron trigger pass through.
002608  A8C2C4     BSET LATA, #6
2817:                _INT1IF = 0;                                                  // Enable INT1 (thyratron trigger) interrupt
00260A  A90086     BCLR IFS1, #0
2818:                _INT1IE = 1;
00260C  A8008E     BSET IEC1, #0
2819:              
2820:              }  
00260E  FA8000     ULNK
002610  BE034F     MOV.D [--W15], W6
002612  BE024F     MOV.D [--W15], W4
002614  BE014F     MOV.D [--W15], W2
002616  BE004F     MOV.D [--W15], W0
002618  F90036     POP RCOUNT
00261A  064000     RETFIE
2821:              
2822:              
2823:              void _ISRNOPSV _ADCInterrupt(void) {
00261C  781F80     MOV W0, [W15++]
00261E  BE9F84     MOV.D W4, [W15++]
002620  781F86     MOV W6, [W15++]
002622  FA0000     LNK #0x0
2824:                _ASAM = 0; // Stop Auto Sampling
002624  A942A0     BCLR ADCON1, #2
2825:                _ADIF = 0;
002626  A96085     BCLR 0x85, #3
2826:                
2827:                // Switch the sate of PIN_UART2_TX (debugging info)
2828:                if (PIN_UART2_TX) {
002628  801715     MOV LATF, W5
00262A  200204     MOV #0x20, W4
00262C  628204     AND W5, W4, W4
00262E  520FE0     SUB W4, #0x0, [W15]
002630  320002     BRA Z, 0x2636
2829:                  PIN_UART2_TX = 0;
002632  A9A2E2     BCLR LATF, #5
002634  370001     BRA 0x2638
2830:                } else {
2831:                  PIN_UART2_TX = 1;
002636  A8A2E2     BSET LATF, #5
2832:                }
2833:              
2834:                last_known_action = LAST_ACTION_ADC_INTERRUPT;
002638  200014     MOV #0x1, W4
00263A  88C5A4     MOV W4, last_known_action
2835:                // DPARKER what for the conversion to complete???
2836:                
2837:                if (global_adc_ignore_this_sample) {
00263C  216CD4     MOV #0x16CD, W4
00263E  784214     MOV.B [W4], W4
002640  524FE0     SUB.B W4, #0x0, [W15]
002642  320004     BRA Z, 0x264C
2838:                  // There was a pulse durring the sample sequence.  Throw the data away!!!
2839:                  global_adc_ignore_this_sample = 0;
002644  EB4200     CLR.B W4
002646  784004     MOV.B W4, W0
002648  B7F6CD     MOV.B WREG, global_adc_ignore_this_sample
00264A  370062     BRA 0x2710
2840:                } else {
2841:                  // Copy Data From Buffer to RAM
2842:                  pfn_rev_current_array[adc_result_index] = ADCBUF0;
00264C  20BCA4     MOV #0xBCA, W4
00264E  784214     MOV.B [W4], W4
002650  FB8204     ZE W4, W4
002652  801405     MOV ADCBUF0, W5
002654  420304     ADD W4, W4, W6
002656  20BCC4     MOV #0xBCC, W4
002658  430204     ADD W6, W4, W4
00265A  780A05     MOV W5, [W4]
2843:                  
2844:                  pac_1_array[adc_result_index] = ADCBUF1;
00265C  20BCA4     MOV #0xBCA, W4
00265E  784214     MOV.B [W4], W4
002660  FB8204     ZE W4, W4
002662  801415     MOV ADCBUF1, W5
002664  420304     ADD W4, W4, W6
002666  20CCC4     MOV #0xCCC, W4
002668  430204     ADD W6, W4, W4
00266A  780A05     MOV W5, [W4]
2845:                  pac_2_array[adc_result_index] = ADCBUF2;
00266C  20BCA4     MOV #0xBCA, W4
00266E  784214     MOV.B [W4], W4
002670  FB8204     ZE W4, W4
002672  801425     MOV ADCBUF2, W5
002674  420304     ADD W4, W4, W6
002676  20DCC4     MOV #0xDCC, W4
002678  430204     ADD W6, W4, W4
00267A  780A05     MOV W5, [W4]
2846:                  
2847:                  thyratron_cathode_heater_voltage_array[adc_result_index] = ADCBUF3;
00267C  20BCA4     MOV #0xBCA, W4
00267E  784214     MOV.B [W4], W4
002680  FB8204     ZE W4, W4
002682  801435     MOV ADCBUF3, W5
002684  420304     ADD W4, W4, W6
002686  20ECC4     MOV #0xECC, W4
002688  430204     ADD W6, W4, W4
00268A  780A05     MOV W5, [W4]
2848:                  thyratron_reservoir_heater_voltage_array[adc_result_index] = ADCBUF4;
00268C  20BCA4     MOV #0xBCA, W4
00268E  784214     MOV.B [W4], W4
002690  FB8204     ZE W4, W4
002692  801445     MOV ADCBUF4, W5
002694  420304     ADD W4, W4, W6
002696  20FCC4     MOV #0xFCC, W4
002698  430204     ADD W6, W4, W4
00269A  780A05     MOV W5, [W4]
2849:                  
2850:                  magnetron_magnet_current_array[adc_result_index]= ADCBUF5;
00269C  20BCA4     MOV #0xBCA, W4
00269E  784214     MOV.B [W4], W4
0026A0  FB8204     ZE W4, W4
0026A2  801455     MOV ADCBUF5, W5
0026A4  420304     ADD W4, W4, W6
0026A6  210CC4     MOV #0x10CC, W4
0026A8  430204     ADD W6, W4, W4
0026AA  780A05     MOV W5, [W4]
2851:                  magnetron_magnet_voltage_array[adc_result_index]= ADCBUF6;
0026AC  20BCA4     MOV #0xBCA, W4
0026AE  784214     MOV.B [W4], W4
0026B0  FB8204     ZE W4, W4
0026B2  801465     MOV ADCBUF6, W5
0026B4  420304     ADD W4, W4, W6
0026B6  211CC4     MOV #0x11CC, W4
0026B8  430204     ADD W6, W4, W4
0026BA  780A05     MOV W5, [W4]
2852:                  
2853:                  magnetron_filament_voltage_array[adc_result_index] = ADCBUF7;
0026BC  20BCA4     MOV #0xBCA, W4
0026BE  784214     MOV.B [W4], W4
0026C0  FB8204     ZE W4, W4
0026C2  801475     MOV ADCBUF7, W5
0026C4  420304     ADD W4, W4, W6
0026C6  213CC4     MOV #0x13CC, W4
0026C8  430204     ADD W6, W4, W4
0026CA  780A05     MOV W5, [W4]
2854:                  magnetron_filament_current_array[adc_result_index] = ADCBUF8;
0026CC  20BCA4     MOV #0xBCA, W4
0026CE  784214     MOV.B [W4], W4
0026D0  FB8204     ZE W4, W4
0026D2  801485     MOV ADCBUF8, W5
0026D4  420304     ADD W4, W4, W6
0026D6  212CC4     MOV #0x12CC, W4
0026D8  430204     ADD W6, W4, W4
0026DA  780A05     MOV W5, [W4]
2855:              
2856:                  
2857:                  lambda_vpeak_array[adc_result_index] = ADCBUF9;
0026DC  20BCA4     MOV #0xBCA, W4
0026DE  784214     MOV.B [W4], W4
0026E0  FB8204     ZE W4, W4
0026E2  801495     MOV ADCBUF9, W5
0026E4  420304     ADD W4, W4, W6
0026E6  214CC4     MOV #0x14CC, W4
0026E8  430204     ADD W6, W4, W4
0026EA  780A05     MOV W5, [W4]
2858:                  lambda_vmon_array[adc_result_index] = ADCBUFA;
0026EC  20BCA4     MOV #0xBCA, W4
0026EE  784214     MOV.B [W4], W4
0026F0  FB8204     ZE W4, W4
0026F2  8014A5     MOV ADCBUFA, W5
0026F4  420304     ADD W4, W4, W6
0026F6  215CC4     MOV #0x15CC, W4
0026F8  430204     ADD W6, W4, W4
0026FA  780A05     MOV W5, [W4]
2859:                  
2860:                  adc_result_index++;
0026FC  20BCA4     MOV #0xBCA, W4
0026FE  784214     MOV.B [W4], W4
002700  E84204     INC.B W4, W4
002702  784004     MOV.B W4, W0
002704  B7EBCA     MOV.B WREG, adc_result_index
2861:                  adc_result_index &= 0b01111111;
002706  20BCA4     MOV #0xBCA, W4
002708  784214     MOV.B [W4], W4
00270A  A17404     BCLR.B W4, #7
00270C  784004     MOV.B W4, W0
00270E  B7EBCA     MOV.B WREG, adc_result_index
2862:                }
2863:                _ASAM = 1; // Start Auto Sampling
002710  A842A0     BSET ADCON1, #2
2864:              }
002712  FA8000     ULNK
002714  78034F     MOV [--W15], W6
002716  BE024F     MOV.D [--W15], W4
002718  78004F     MOV [--W15], W0
00271A  064000     RETFIE
2865:              
2866:              
2867:              void _ISRNOPSV _CNInterrupt(void) {
00271C  F80036     PUSH RCOUNT
00271E  BE9F80     MOV.D W0, [W15++]
002720  BE9F82     MOV.D W2, [W15++]
002722  BE9F84     MOV.D W4, [W15++]
002724  BE9F86     MOV.D W6, [W15++]
002726  FA0000     LNK #0x0
2868:                if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
002728  8016A5     MOV PORTD, W5
00272A  200804     MOV #0x80, W4
00272C  628204     AND W5, W4, W4
00272E  520FE0     SUB W4, #0x0, [W15]
002730  3A0012     BRA NZ, 0x2756
2869:                  __delay32(100); // 10uS
002732  200640     MOV #0x64, W0
002734  200001     MOV #0x0, W1
002736  071303     RCALL ___delay32
2870:                  if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
002738  8016A5     MOV PORTD, W5
00273A  200804     MOV #0x80, W4
00273C  628204     AND W5, W4, W4
00273E  520FE0     SUB W4, #0x0, [W15]
002740  3A000A     BRA NZ, 0x2756
2871:                    __delay32(100); // 10uS
002742  200640     MOV #0x64, W0
002744  200001     MOV #0x0, W1
002746  0712FB     RCALL ___delay32
2872:                    if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
002748  8016A5     MOV PORTD, W5
00274A  200804     MOV #0x80, W4
00274C  628204     AND W5, W4, W4
00274E  520FE0     SUB W4, #0x0, [W15]
002750  3A0002     BRA NZ, 0x2756
2873:              	RecordThisThyratronFault(FAULT_THYR_FALSE_TRIGGER);
002752  204000     MOV #0x400, W0
002754  070C03     RCALL RecordThisThyratronFault
2874:                    }
2875:                  }
2876:                }
2877:                _CNIF = 0;
002756  A9E085     BCLR 0x85, #7
2878:              }
002758  FA8000     ULNK
00275A  BE034F     MOV.D [--W15], W6
00275C  BE024F     MOV.D [--W15], W4
00275E  BE014F     MOV.D [--W15], W2
002760  BE004F     MOV.D [--W15], W0
002762  F90036     POP RCOUNT
002764  064000     RETFIE
2879:              
2880:              
2881:              void _ISRNOPSV _LVDInterrupt(void) {
002766  781F84     MOV W4, [W15++]
002768  FA0000     LNK #0x0
2882:                last_known_action = LAST_ACTION_LVD_INT;
00276A  200024     MOV #0x2, W4
00276C  88C5A4     MOV W4, last_known_action
2883:                _LVDIF = 0;
00276E  A94089     BCLR 0x89, #2
2884:                lvdinterrupt_counter++;
002770  80C484     MOV lvdinterrupt_counter, W4
002772  E80204     INC W4, W4
002774  88C484     MOV W4, lvdinterrupt_counter
2885:              }
002776  FA8000     ULNK
002778  78024F     MOV [--W15], W4
00277A  064000     RETFIE
2886:              
2887:              
2888:              void _ISRNOPSV _OscillatorFail(void) {
00277C  781F84     MOV W4, [W15++]
00277E  FA0000     LNK #0x0
2889:               last_known_action = LAST_ACTION_OSC_FAIL;
002780  2000D4     MOV #0xD, W4
002782  88C5A4     MOV W4, last_known_action
2890:               last_osccon = OSCCON;
002784  803A14     MOV OSCCON, W4
002786  88C5B4     MOV W4, last_osccon
2891:                Nop();
002788  000000     NOP
2892:                Nop();
00278A  000000     NOP
2893:                __asm__ ("Reset");
00278C  FE0000     RESET
2894:              }
00278E  FA8000     ULNK
002790  78024F     MOV [--W15], W4
002792  064000     RETFIE
2895:              
2896:              void _ISRNOPSV _AddressError(void) {
002794  781F84     MOV W4, [W15++]
002796  FA0000     LNK #0x0
2897:               last_known_action = LAST_ACTION_ADDRESS_ERROR;
002798  2000E4     MOV #0xE, W4
00279A  88C5A4     MOV W4, last_known_action
2898:                Nop();
00279C  000000     NOP
2899:                Nop();
00279E  000000     NOP
2900:                __asm__ ("Reset");
0027A0  FE0000     RESET
2901:              }
0027A2  FA8000     ULNK
0027A4  78024F     MOV [--W15], W4
0027A6  064000     RETFIE
2902:              
2903:              void _ISRNOPSV _StackError(void) {
0027A8  781F84     MOV W4, [W15++]
0027AA  FA0000     LNK #0x0
2904:               last_known_action = LAST_ACTION_STACK_ERROR;
0027AC  2000F4     MOV #0xF, W4
0027AE  88C5A4     MOV W4, last_known_action
2905:                Nop();
0027B0  000000     NOP
2906:                Nop();
0027B2  000000     NOP
2907:                __asm__ ("Reset");
0027B4  FE0000     RESET
2908:              }
0027B6  FA8000     ULNK
0027B8  78024F     MOV [--W15], W4
0027BA  064000     RETFIE
2909:              
2910:              void _ISRNOPSV _MathError(void) {
0027BC  781F84     MOV W4, [W15++]
0027BE  FA0000     LNK #0x0
2911:               last_known_action = LAST_ACTION_MATH_ERROR;
0027C0  200104     MOV #0x10, W4
0027C2  88C5A4     MOV W4, last_known_action
2912:                Nop();
0027C4  000000     NOP
2913:                Nop();
0027C6  000000     NOP
2914:                __asm__ ("Reset");
0027C8  FE0000     RESET
2915:              }
0027CA  FA8000     ULNK
0027CC  78024F     MOV [--W15], W4
0027CE  064000     RETFIE
2916:              
2917:              
2918:              
2919:              // DPARKER THIS FUNCTION FOR DEBUGGING ONLY
2920:              void _ISRNOPSV _DefaultInterrupt(void) {
0027D0  781F84     MOV W4, [W15++]
0027D2  FA0000     LNK #0x0
2921:                /*
2922:                control_state = STATE_FAULT_ILLEGAL_INTERRUPT;
2923:                global_debug_counter.magnetron_current_adc_glitch = IFS0;
2924:                global_debug_counter.magnetron_voltage_adc_glitch = IFS1;
2925:                global_debug_counter.i2c_bus_error = IFS2;
2926:              
2927:                global_debug_counter.spi1_bus_error = IEC0;
2928:                global_debug_counter.spi2_bus_error = IEC1;
2929:                global_debug_counter.external_adc_false_trigger = IEC2;
2930:              
2931:                while (1) {
2932:                  ClrWdt();
2933:                  DoSerialCommand();
2934:                }
2935:                */
2936:                last_known_action = LAST_ACTION_DEFAULT_INT;
0027D4  2FABC4     MOV #0xFABC, W4
0027D6  88C5A4     MOV W4, last_known_action
2937:                Nop();
0027D8  000000     NOP
2938:                Nop();
0027DA  000000     NOP
2939:                __asm__ ("Reset");
0027DC  FE0000     RESET
2940:              }
0027DE  FA8000     ULNK
0027E0  78024F     MOV [--W15], W4
0027E2  064000     RETFIE
2941:              
2942:              
2943:              
2944:              
2945:              unsigned int CalculatePoly(unsigned int set_point) {
0027E4  FA000C     LNK #0xC
0027E6  980750     MOV W0, [W14+10]
2946:              
2947:                signed long sum;
2948:                signed long temp;
2949:                unsigned int value;
2950:              
2951:                temp = set_point;
0027E8  90025E     MOV [W14+10], W4
0027EA  200005     MOV #0x0, W5
0027EC  BE8F04     MOV.D W4, [W14]
2952:                temp *= set_point;
0027EE  90025E     MOV [W14+10], W4
0027F0  200005     MOV #0x0, W5
0027F2  90031E     MOV [W14+2], W6
0027F4  B9B304     MUL.SS W6, W4, W6
0027F6  780306     MOV W6, W6
0027F8  78039E     MOV [W14], W7
0027FA  B9B805     MUL.SS W7, W5, W0
0027FC  780380     MOV W0, W7
0027FE  430307     ADD W6, W7, W6
002800  78039E     MOV [W14], W7
002802  780204     MOV W4, W4
002804  B82207     MUL.UU W4, W7, W4
002806  430305     ADD W6, W5, W6
002808  780286     MOV W6, W5
00280A  BE8F04     MOV.D W4, [W14]
00280C  BE8F04     MOV.D W4, [W14]
2953:                temp = temp >> 14;
00280E  BE021E     MOV.D [W14], W4
002810  DD2B42     SL W5, #2, W6
002812  DE224E     LSR W4, #14, W4
002814  730204     IOR W6, W4, W4
002816  DEAACE     ASR W5, #14, W5
002818  BE8F04     MOV.D W4, [W14]
2954:                temp *= control_loop_cal_data_ram_copy[EEPROM_CNTRL_MAGNET_FACTOR_SQUARE];
00281A  80C144     MOV control_loop_cal_data_ram_copy, W4
00281C  DEA2CF     ASR W4, #15, W5
00281E  90031E     MOV [W14+2], W6
002820  B9B304     MUL.SS W6, W4, W6
002822  780306     MOV W6, W6
002824  78039E     MOV [W14], W7
002826  B9B805     MUL.SS W7, W5, W0
002828  780380     MOV W0, W7
00282A  430307     ADD W6, W7, W6
00282C  78039E     MOV [W14], W7
00282E  780204     MOV W4, W4
002830  B82207     MUL.UU W4, W7, W4
002832  430305     ADD W6, W5, W6
002834  780286     MOV W6, W5
002836  BE8F04     MOV.D W4, [W14]
002838  BE8F04     MOV.D W4, [W14]
2955:                temp = temp >> 10;
00283A  BE021E     MOV.D [W14], W4
00283C  DD2BC6     SL W5, #6, W7
00283E  DE224A     LSR W4, #10, W4
002840  738204     IOR W7, W4, W4
002842  DEAACA     ASR W5, #10, W5
002844  BE8F04     MOV.D W4, [W14]
2956:                sum = temp;
002846  BE021E     MOV.D [W14], W4
002848  980724     MOV W4, [W14+4]
00284A  980735     MOV W5, [W14+6]
2957:              
2958:                temp = set_point;
00284C  90025E     MOV [W14+10], W4
00284E  200005     MOV #0x0, W5
002850  BE8F04     MOV.D W4, [W14]
2959:                temp *= control_loop_cal_data_ram_copy[EEPROM_CNTRL_MAGNET_FACTOR_LINEAR];
002852  80C154     MOV 0x182A, W4
002854  DEA2CF     ASR W4, #15, W5
002856  90031E     MOV [W14+2], W6
002858  B9B304     MUL.SS W6, W4, W6
00285A  780306     MOV W6, W6
00285C  78039E     MOV [W14], W7
00285E  B9B805     MUL.SS W7, W5, W0
002860  780380     MOV W0, W7
002862  430307     ADD W6, W7, W6
002864  78039E     MOV [W14], W7
002866  780204     MOV W4, W4
002868  B82207     MUL.UU W4, W7, W4
00286A  430305     ADD W6, W5, W6
00286C  780286     MOV W6, W5
00286E  BE8F04     MOV.D W4, [W14]
002870  BE8F04     MOV.D W4, [W14]
2960:                temp = temp >> 10;
002872  BE021E     MOV.D [W14], W4
002874  DD2B46     SL W5, #6, W6
002876  DE224A     LSR W4, #10, W4
002878  730204     IOR W6, W4, W4
00287A  DEAACA     ASR W5, #10, W5
00287C  BE8F04     MOV.D W4, [W14]
2961:              
2962:                sum += temp;
00287E  90022E     MOV [W14+4], W4
002880  9002BE     MOV [W14+6], W5
002882  42033E     ADD W4, [W14++], W6
002884  4A83AE     ADDC W5, [W14--], W7
002886  BE0206     MOV.D W6, W4
002888  980724     MOV W4, [W14+4]
00288A  980735     MOV W5, [W14+6]
2963:              
2964:                temp = control_loop_cal_data_ram_copy[EEPROM_CNTRL_MAGNET_FACTOR_CONST];
00288C  80C164     MOV 0x182C, W4
00288E  DEA2CF     ASR W4, #15, W5
002890  BE8F04     MOV.D W4, [W14]
2965:                
2966:                temp = temp << 2;
002892  BE031E     MOV.D [W14], W6
002894  DD3A42     SL W7, #2, W4
002896  DE32CE     LSR W6, #14, W5
002898  720285     IOR W4, W5, W5
00289A  DD3242     SL W6, #2, W4
00289C  BE8F04     MOV.D W4, [W14]
2967:              
2968:                sum += temp;
00289E  90022E     MOV [W14+4], W4
0028A0  9002BE     MOV [W14+6], W5
0028A2  42033E     ADD W4, [W14++], W6
0028A4  4A83AE     ADDC W5, [W14--], W7
0028A6  BE0206     MOV.D W6, W4
0028A8  980724     MOV W4, [W14+4]
0028AA  980735     MOV W5, [W14+6]
2969:              
2970:                value = (sum & 0xFFFF);
0028AC  9003AE     MOV [W14+4], W7
0028AE  980747     MOV W7, [W14+8]
2971:                
2972:                return value; 
0028B0  90024E     MOV [W14+8], W4
2973:              }
0028B2  780004     MOV W4, W0
0028B4  FA8000     ULNK
0028B6  060000     RETURN
2974:              
2975:              
2976:              
