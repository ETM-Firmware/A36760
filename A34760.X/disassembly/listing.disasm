Disassembly Listing for A34760
Generated From:
C:/Users/dparker/Documents/GitHub/A36760/A34760.X/dist/default/production/A34760.X.production.elf
Oct 30, 2018 8:44:18 AM

---  C:/Users/dparker/Documents/GitHub/A36760/faults.c  -------------------------------------------------
1:                 #include "A34760.h"
2:                 #include "faults.h"
3:                 #include "A34760_PINS.h"
4:                 #include <libpic30.h>
5:                 #include "Config.h"
6:                 #include "MCP23017.h"
7:                 
8:                 
9:                 TYPE_DEBUG_COUNTER global_debug_counter;
10:                
11:                unsigned int CalculatePulseEnergyMilliJoules(unsigned int lambda_voltage);
12:                
13:                void StorePulseData(POWERSUPPLY* ptr);
14:                
15:                // The status register used for debug purposes
16:                unsigned int debug_status_register;
17:                
18:                // MAGNETRON CONTROL FAULT REGISTERS
19:                unsigned int faults_magnetron_status_reg;
20:                unsigned int faults_magnetron_fault_reg;
21:                unsigned int faults_magnetron_warning_reg;
22:                
23:                // HIGH VOLTAGE FAULT REGISTERS
24:                unsigned int faults_high_voltage_status_reg;
25:                unsigned int faults_high_voltage_fault_reg;
26:                unsigned int faults_high_voltage_warning_reg;
27:                
28:                // THYRATRON HEATER FAULT REGISTERS
29:                unsigned int faults_thyratron_status_reg;
30:                unsigned int faults_thyratron_fault_reg;
31:                unsigned int faults_thyratron_warning_reg;
32:                
33:                
34:                // CONTROL BOARD FAULT REGISTERS
35:                unsigned int faults_control_board_status_reg;
36:                unsigned int faults_control_board_fault_reg;
37:                unsigned int faults_control_board_warning_reg;
38:                
39:                
40:                
41:                // Variables to save the active fault/warning masks for this control loop state
42:                unsigned int magnetron_fault_mask;
43:                unsigned int high_voltage_fault_mask;
44:                unsigned int thyratron_fault_mask;
45:                unsigned int control_board_fault_mask;
46:                
47:                unsigned int magnetron_warning_mask;
48:                unsigned int high_voltage_warning_mask;
49:                unsigned int thyratron_warning_mask;
50:                unsigned int control_board_warning_mask;
51:                
52:                
53:                void LoadFaultMaskRegisters(void);
54:                void WriteToEventLog(unsigned char fault_register, unsigned int fault_bit);
55:                unsigned char CheckOverVoltFault(POWERSUPPLY* ptr);
56:                unsigned char CheckUnderVoltFault(POWERSUPPLY* ptr);
57:                unsigned char CheckOverCurrentFault(POWERSUPPLY* ptr);
58:                unsigned char CheckUnderCurrentFault(POWERSUPPLY* ptr);
59:                
60:                
61:                /*
62:                  FAULT EVALUATION
63:                  
64:                  10_ms_tic_toc
65:                  Once every 10ms, the internal ADC is read and faults are updated
66:                
67:                  After Every Pulse
68:                
69:                  DPARKER give a big description of each fault here - How the input is measured, how the data is filtered, how the fault is generated (delay if included)
70:                
71:                */
72:                
73:                
74:                /*
75:                  In each State, Each fault input can do one of the following . . .
76:                
77:                  1) It can be totally ignored (This is the default behavior - If the warning mask & the fault mask are NOT set)
78:                  2) It can cause a fault  (This is set by the fault MASK)
79:                     There are no "warm" or "cold" faults.  Any fault in state warm_ready or hv_on will go to state warm fault.
80:                     If the fault is still active in the warm state fault then it will move to cold fault.
81:                  3) It can cause a latched warning (This is set the warning MASK)
82:                     NOTE: the warning register is independent of the fault mask.  To be latched as a warning, the fault input MUST BE IN THE WARNING REGISTER
83:                  4) Special state at startup to handle board level failures . . . ????
84:                */
85:                
86:                /*  
87:                    Fault Log
88:                    
89:                    Each entry in the fault log contains the following information
90:                    4 bits for fault register bit
91:                    2 bits for fault register select
92:                    2 bits for the calling state (HV_ON, WARM_READY, FAULT, STARTUP)
93:                */
94:                
95:                /*
96:                  For each state there are three fault masks for each fault register.
97:                  Warning Ignore Mask - This shows which fault inputs will NOT generate a warning (this is mainly for debugging and and is used to filter out non-events, if a fault is in the warning ignore mask and in the warm or cold fault mask it will still generate a fault)
98:                  Faul Mask - this shows which fault inputs will generate a fault in the current state
99:                
100:               
101:               */
102:               
103:               /*
104:               
105:                 Status_Register -> This register shows the current states of all the Inputs.  It IS NOT LATCHED.
106:                 Fault_Register -> This register latches any fault input that matches the fault_mask for the current state.
107:                 Warning_Latch_Regisiter -> Any fault input that matches the fault_mask or the warning_mask will be latched in this register.
108:               
109:                 How faults are checked . . .
110:                 
111:                 Every time through a control loop, 50us->500us depending upon the state, all faults registeres are updated and checked.
112:                 Faults like magnetron_heater_over_current - The limit is compared to the filtered data in RAM every time, even though the filtered data in ram is only update once every 10mS
113:                 The fault status register is then compared to the masks to generate the warnings and faults.
114:               
115:                */
116:               
117:               /* ----------------------FAULT MANAGEMENT ----------------------*/
118:               
119:               /*
120:                 There are lots of Fault Conditions, see A34335.h for a list of fault registeres and faults.
121:                 For a given state a particular Input may
122:                 1) No Action - But set a non latching status bit indicating the state of the fault input
123:                 2) No Action - But set a latching "warning" bit 
124:                 3) Generate a fault Condition - This will change the state to warm fault (or cold fault if the fault is globably defined as a cold fault)
125:                
126:               
127:                 How are faults handeled . . .
128:                 There a 3 data storage locations for each fault register.
129:                 Status_Register -> This register shows the current states of all the Inputs.  It IS NOT LATCHED.
130:                 Latch_Regisiter -> This is a latched version of the the status register.
131:                 Fault_Register  -> If the Input is a Fault (it matches the warm_fault OR cold_fault mask) it is latched into the Fault Register
132:                 
133:                 How external data and faults are processesed . . . 
134:               
135:                 Data is read from the external ADCs and inernal ADCs on a regular 10ms interval or after a pulse (for pulse data types).
136:                 This inerval is scheduled to occur directly proceding a pulse if possible (pulse rate > 100 Hz).
137:                 At PRF less than 100Hz (or in any other state) the readings will take place at opproximate 10ms intervals
138:                 ADC values are filtered with software RC/glitch filters when they are read.
139:                
140:                
141:                 Faults are evaluated durring the 10ms_tic_toc the occurs once every (approximatly) 10mS
142:                 The following steps occur
143:                 1) Status registers are reset to zero
144:                 2) The input condition is tested, if it is a "logical fault" then (record_this_xxxxx_fault) is called which does the following
145:                   a) Sets the appropriate bit in the status register
146:                   b) If the bit matches the fault_mask, 
147:                      ^ The appropriate bit in the fault register is set
148:                      ^ The fault is added to the error log - TO BE IMPLEMENTED
149:                   c) If the bit matches the warning_mask, the appropriate bit in the warning register is set 
150:                 
151:                 STEP 2 is repeated for all fault conditions.
152:               
153:                 Some faults can not be tested durring the 10ms TicToc.
154:                 These faults will have record_this_xxxxx_fault called when the fault is checked.
155:                 These faults are . . .
156:                 FAULT_HV_LAMBDA_EOC_TIMEOUT - this is evaluated in the TMR1 interrupt and set there.
157:               
158:               
159:                 After all the faults have been tested and the fault registers updated the following action occurs
160:                 
161:                 + A cold shutdown occurs
162:                 + A warm shutdown occurs
163:                 
164:                 + The fault is added to the Log
165:                 + For *some* important faults, the fault counter is incremented.
166:               
167:                 + The fault is added to the Log
168:                 + For *some* important faults, the fault counter is incremented.
169:                 
170:               */
171:               
172:               
173:               
174:               // DPARKER update pulse fault must be called at 10ms Interval or the sections that count "out of range" counts will be arbitrary time lengths
175:               
176:               void UpdateFaults(void) {
003CA6  FA0002     LNK #0x2
177:                 // See h file for documentation
178:                 unsigned int temp_u16int;
179:               
180:                 // The status registers are not latched so they are reset to zero each time the faults are evaluated
181:                 faults_magnetron_status_reg = 0;  
003CA8  EB0200     CLR W4
003CAA  88C3A4     MOV W4, faults_magnetron_status_reg
182:                 faults_high_voltage_status_reg = 0;
003CAC  EB0200     CLR W4
003CAE  88C3D4     MOV W4, faults_high_voltage_status_reg
183:                 faults_thyratron_status_reg = 0;
003CB0  EB0200     CLR W4
003CB2  88C404     MOV W4, faults_thyratron_status_reg
184:                 faults_control_board_status_reg = 0;
003CB4  EB0200     CLR W4
003CB6  88C434     MOV W4, faults_control_board_status_reg
185:                 
186:                 
187:                 // Load the fault masks for the current state
188:                 LoadFaultMaskRegisters();
003CB8  07025E     RCALL LoadFaultMaskRegisters
189:                 
190:                 //------------------------- START MAGNETRON FAULTS ------------------------------//
191:                 
192:                 // Check External Magnetron Heater Over Voltage Latch
193:                 if (PIN_FILAMENT_OV_LATCH == ILL_FILAMENT_OV_FAULT) {
003CBA  8016A5     MOV PORTD, W5
003CBC  220004     MOV #0x2000, W4
003CBE  628204     AND W5, W4, W4
003CC0  520FE0     SUB W4, #0x0, [W15]
003CC2  3A0002     BRA NZ, 0x3CC8
194:                   RecordThisMagnetronFault(FAULT_HW_MAGNETRON_FILAMENT_OV);
003CC4  200010     MOV #0x1, W0
003CC6  070304     RCALL RecordThisMagnetronFault
195:                 } 
196:                 
197:                 // Check that the magnetron heater voltage ADC reading has exceed fixed value set Config.h 
198:                 if (ps_filament.v_adc_reading > ps_filament.v_adc_over_abs) {
003CC8  8056D5     MOV 0xADA, W5
003CCA  805714     MOV 0xAE2, W4
003CCC  528F84     SUB W5, W4, [W15]
003CCE  360002     BRA LEU, 0x3CD4
199:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OV_HARD_LIMIT);
003CD0  200020     MOV #0x2, W0
003CD2  0702FE     RCALL RecordThisMagnetronFault
200:                 }
201:                 
202:                 // Check that the magnetron heater voltage ADC reading is not greater than X% of its program point (set in Config.h)
203:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
204:                 if (CheckOverVoltFault(&ps_filament)) {
003CD4  20ACA0     MOV #0xACA, W0
003CD6  07038C     RCALL CheckOverVoltFault
003CD8  784200     MOV.B W0, W4
003CDA  524FE0     SUB.B W4, #0x0, [W15]
003CDC  320002     BRA Z, 0x3CE2
205:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OV);
003CDE  200040     MOV #0x4, W0
003CE0  0702F7     RCALL RecordThisMagnetronFault
206:                 }
207:                 
208:                 // Check that the magnetron heater voltage ADC reading is not less than X% of its program point (set in Config.h)
209:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
210:                 if (CheckUnderVoltFault(&ps_filament)) {
003CE2  20ACA0     MOV #0xACA, W0
003CE4  0703AC     RCALL CheckUnderVoltFault
003CE6  784200     MOV.B W0, W4
003CE8  524FE0     SUB.B W4, #0x0, [W15]
003CEA  320002     BRA Z, 0x3CF0
211:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_UV);
003CEC  200080     MOV #0x8, W0
003CEE  0702F0     RCALL RecordThisMagnetronFault
212:                 }
213:                 
214:                 // Check that the magnetron heater current ADC reading is not greater than X% of its expected point (set in Config.h)
215:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
216:                 if (CheckOverCurrentFault(&ps_filament)) {
003CF0  20ACA0     MOV #0xACA, W0
003CF2  0703D3     RCALL CheckOverCurrentFault
003CF4  784200     MOV.B W0, W4
003CF6  524FE0     SUB.B W4, #0x0, [W15]
003CF8  320002     BRA Z, 0x3CFE
217:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_OC);
003CFA  200100     MOV #0x10, W0
003CFC  0702E9     RCALL RecordThisMagnetronFault
218:                 }
219:                 
220:                 
221:                 // Check that the magnetron heater current ADC reading is not less than X% of its expected point (set in Config.h)
222:                 // It must remain outside this range for at least v_out_of_range_count before a fault is generated
223:                 if (CheckUnderCurrentFault(&ps_filament)) {
003CFE  20ACA0     MOV #0xACA, W0
003D00  0703F3     RCALL CheckUnderCurrentFault
003D02  784200     MOV.B W0, W4
003D04  524FE0     SUB.B W4, #0x0, [W15]
003D06  320002     BRA Z, 0x3D0C
224:                   RecordThisMagnetronFault(FAULT_MAGNETRON_FILAMENT_UC);
003D08  200200     MOV #0x20, W0
003D0A  0702E2     RCALL RecordThisMagnetronFault
225:                 }
226:                 
227:                 
228:                 // Check External Magnetron Magnet Current Out of Range Latch
229:                 if (PIN_MAGNET_CURRENT_OOR_LATCH == ILL_MAGNET_CURRENT_OOR_FAULT) {
003D0C  8016A5     MOV PORTD, W5
003D0E  210004     MOV #0x1000, W4
003D10  628204     AND W5, W4, W4
003D12  520FE0     SUB W4, #0x0, [W15]
003D14  3A0002     BRA NZ, 0x3D1A
230:                   RecordThisMagnetronFault(FAULT_HW_MAGNETRON_MAGNET_COOR);
003D16  201000     MOV #0x100, W0
003D18  0702DB     RCALL RecordThisMagnetronFault
231:                 }
232:                 
233:                 // Check that the magnetron magnet current ADC reading has no exceeded fixed value set Config.h 
234:                 if (ps_magnet.i_adc_reading > ps_magnet.i_adc_over_abs) {
003D1A  805565     MOV 0xAAC, W5
003D1C  8055A4     MOV 0xAB4, W4
003D1E  528F84     SUB W5, W4, [W15]
003D20  360002     BRA LEU, 0x3D26
235:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OC_HARD_LIMIT);
003D22  202000     MOV #0x200, W0
003D24  0702D5     RCALL RecordThisMagnetronFault
236:                 }
237:                 
238:                 // Check that the magnetron magnet current ADC reading is not greater than X% of its program point (set in Config.h)
239:                 if (CheckOverCurrentFault(&ps_magnet)) {
003D26  20A700     MOV #0xA70, W0
003D28  0703B8     RCALL CheckOverCurrentFault
003D2A  784200     MOV.B W0, W4
003D2C  524FE0     SUB.B W4, #0x0, [W15]
003D2E  320002     BRA Z, 0x3D34
240:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OC);
003D30  204000     MOV #0x400, W0
003D32  0702CE     RCALL RecordThisMagnetronFault
241:                 }
242:                 
243:                 // Check that the magnetron magnet current ADC reading is not less than X% of its program point (set in Config.h)
244:                 if (CheckUnderCurrentFault(&ps_magnet)) {
003D34  20A700     MOV #0xA70, W0
003D36  0703D8     RCALL CheckUnderCurrentFault
003D38  784200     MOV.B W0, W4
003D3A  524FE0     SUB.B W4, #0x0, [W15]
003D3C  320002     BRA Z, 0x3D42
245:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_UC);
003D3E  208000     MOV #0x800, W0
003D40  0702C7     RCALL RecordThisMagnetronFault
246:                 }
247:                 
248:                 // Check that the magnetron magnet voltage ADC reading is not greater than X% of its expected value (set in Config.h)
249:                 if (CheckOverVoltFault(&ps_magnet)) {
003D42  20A700     MOV #0xA70, W0
003D44  070355     RCALL CheckOverVoltFault
003D46  784200     MOV.B W0, W4
003D48  524FE0     SUB.B W4, #0x0, [W15]
003D4A  320002     BRA Z, 0x3D50
250:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_OV);
003D4C  210000     MOV #0x1000, W0
003D4E  0702C0     RCALL RecordThisMagnetronFault
251:                 }
252:                 
253:                 // Check that the magnetron magnet voltage ADC reading is not less than X% of its expected value (set in Config.h)
254:                 if (CheckUnderVoltFault(&ps_magnet)) {
003D50  20A700     MOV #0xA70, W0
003D52  070375     RCALL CheckUnderVoltFault
003D54  784200     MOV.B W0, W4
003D56  524FE0     SUB.B W4, #0x0, [W15]
003D58  320002     BRA Z, 0x3D5E
255:                   RecordThisMagnetronFault(FAULT_MAGNETRON_MAGNET_UV);
003D5A  220000     MOV #0x2000, W0
003D5C  0702B9     RCALL RecordThisMagnetronFault
256:                 }
257:                 
258:                 
259:                 //------------------------- START HIGH VOLTAGE FAULTS ------------------------------//
260:                 
261:                 // THE ARC FAULTS ARE CURRENTLY SET IN UpdatePulseData()
262:                 // UpdatesPulseData() is called after every pulse.
263:                 
264:                 // Check the digital fault outputs from from HV LAMBDA -
265:                 // The sum fault line must be set for HV_LAMBDA_SUM_FAULT_COUNTER_TRIP_POINT consective readings before a trip will occur
266:                 
267:                 
268:                 
269:                 if (PIN_HV_LAMBDA_SUM_FAULT == ILL_HV_LAMBDA_SUM_FAULT_FAULTED) {
003D5E  801675     MOV PORTC, W5
003D60  240004     MOV #0x4000, W4
003D62  628204     AND W5, W4, W4
003D64  520FE0     SUB W4, #0x0, [W15]
003D66  3A0035     BRA NZ, 0x3DD2
270:                   // Record the sum fault and check the other fault lines
271:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_SUM_FAULT);
003D68  201000     MOV #0x100, W0
003D6A  0702CE     RCALL RecordThisHighVoltageFault
272:                   
273:                   temp_u16int = MCP23017ReadSingleByte(&U64_MCP23017, MCP23017_REGISTER_GPIOA);
003D6C  B3C121     MOV.B #0x12, W1
003D6E  208FC0     MOV #0x8FC, W0
003D70  07091E     RCALL MCP23017ReadSingleByte
003D72  780200     MOV W0, W4
003D74  780F04     MOV W4, [W14]
274:                   if (temp_u16int >= 0xFA00) {
003D76  2F9FF4     MOV #0xF9FF, W4
003D78  78029E     MOV [W14], W5
003D7A  528F84     SUB W5, W4, [W15]
003D7C  360004     BRA LEU, 0x3D86
275:                     global_debug_counter.i2c_bus_error++;
003D7E  80C304     MOV 0x1860, W4
003D80  E80204     INC W4, W4
003D82  88C304     MOV W4, 0x1860
003D84  370026     BRA 0x3DD2
276:                   } else {
277:                     U64_MCP23017.input_port_a_in_ram = temp_u16int & 0xFF;
003D86  78021E     MOV [W14], W4
003D88  784204     MOV.B W4, W4
003D8A  784004     MOV.B W4, W0
003D8C  B7E906     MOV.B WREG, 0x906
278:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_OVER_TEMP) {
003D8E  209064     MOV #0x906, W4
003D90  784214     MOV.B [W4], W4
003D92  FB8284     ZE W4, W5
003D94  200404     MOV #0x40, W4
003D96  628204     AND W5, W4, W4
003D98  520FE0     SUB W4, #0x0, [W15]
003D9A  320002     BRA Z, 0x3DA0
279:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_OVER_TEMP);
003D9C  210000     MOV #0x1000, W0
003D9E  0702B4     RCALL RecordThisHighVoltageFault
280:                     }
281:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_INTERLOCK_FAULT) {
003DA0  209064     MOV #0x906, W4
003DA2  784214     MOV.B [W4], W4
003DA4  FB8284     ZE W4, W5
003DA6  200204     MOV #0x20, W4
003DA8  628204     AND W5, W4, W4
003DAA  520FE0     SUB W4, #0x0, [W15]
003DAC  320002     BRA Z, 0x3DB2
282:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_INTERLOCK_FAULT);
003DAE  220000     MOV #0x2000, W0
003DB0  0702AB     RCALL RecordThisHighVoltageFault
283:                     }
284:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_LOAD_FLT) {
003DB2  209064     MOV #0x906, W4
003DB4  784214     MOV.B [W4], W4
003DB6  FB8204     ZE W4, W4
003DB8  620270     AND W4, #0x10, W4
003DBA  520FE0     SUB W4, #0x0, [W15]
003DBC  320002     BRA Z, 0x3DC2
285:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_LOAD_FAULT);
003DBE  240000     MOV #0x4000, W0
003DC0  0702A3     RCALL RecordThisHighVoltageFault
286:                     }
287:                     if (U64_MCP23017.input_port_a_in_ram & BIT_INPUT_HV_LAMBDA_PHASE_LOSS) {
003DC2  209064     MOV #0x906, W4
003DC4  784214     MOV.B [W4], W4
003DC6  FB8204     ZE W4, W4
003DC8  620268     AND W4, #0x8, W4
003DCA  520FE0     SUB W4, #0x0, [W15]
003DCC  320002     BRA Z, 0x3DD2
288:               	RecordThisHighVoltageFault(FAULT_HV_LAMBDA_PHASE_LOSS);
003DCE  280000     MOV #0x8000, W0
003DD0  07029B     RCALL RecordThisHighVoltageFault
289:                     }
290:                   }
291:                 }
292:                 
293:                 /*
294:                   FAULT_LAMBDA_EOC_TIMEOUT is checked/set by the TMR1 Interrupt
295:                 */
296:               
297:               
298:                 // DPARKER these vpeak readings . . . do we need them?  do they serve any purpose????
299:                 /*
300:               
301:                 // Check that the lambda vpeak ADC reading is not greater than X% of its set point (set in Config.h)
302:                 // It must remain outside this range for at least HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT before a fault is generated
303:                 if (hv_lambda_vpeak_adc_reading > hv_lambda_vpeak_adc_over_trip_point) {
304:                   hv_lambda_vpeak_over_voltage_count++;
305:                 } else if (hv_lambda_vpeak_over_voltage_count >= 1) {
306:                   hv_lambda_vpeak_over_voltage_count--;
307:                 }
308:                 if (hv_lambda_vpeak_over_voltage_count > HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT) {
309:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_VPEAK_OVER_VOLTAGE);
310:                 }
311:               
312:                 // Check that the lambda vpeak ADC reading is not less than X% of its set point (set in Config.h)
313:                 // It must remain outside this range for at least HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT before a fault is generated
314:                 if (hv_lambda_vpeak_adc_reading < hv_lambda_vpeak_adc_under_trip_point) {
315:                   hv_lambda_vpeak_under_voltage_count++;
316:                 } else if (hv_lambda_vpeak_under_voltage_count >= 1) {
317:                   hv_lambda_vpeak_under_voltage_count--;
318:                 }
319:                 if (hv_lambda_vpeak_under_voltage_count > HV_LAMBDA_VPEAK_MAX_OUT_OF_RANGE_COUNT) {
320:                   RecordThisHighVoltageFault(FAULT_HV_LAMBDA_VPEAK_UNDER_VOLTAGE);
321:                 }
322:                 */
323:                 
324:                 //------------------------- START THYRATRON FAULTS ------------------------------//
325:                
326:                 // Check that the thyratron cathode heater voltage ADC reading has exceed fixed value set Config.h 
327:                 if (ps_thyr_cathode_htr.v_adc_reading > ps_thyr_cathode_htr.v_adc_over_abs) {
003DD2  8059A5     MOV 0xB34, W5
003DD4  8059E4     MOV 0xB3C, W4
003DD6  528F84     SUB W5, W4, [W15]
003DD8  360002     BRA LEU, 0x3DDE
328:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_OV_HARD_LIMIT);
003DDA  200010     MOV #0x1, W0
003DDC  0702B1     RCALL RecordThisThyratronFault
329:                 }
330:                   
331:                 // Check that the thyratron heater voltage ADC reading is not greater than X% of its program point (set in Config.h)
332:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated  
333:                 if (CheckOverVoltFault(&ps_thyr_cathode_htr)) {
003DDE  20B240     MOV #0xB24, W0
003DE0  070307     RCALL CheckOverVoltFault
003DE2  784200     MOV.B W0, W4
003DE4  524FE0     SUB.B W4, #0x0, [W15]
003DE6  320002     BRA Z, 0x3DEC
334:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_OV);
003DE8  200020     MOV #0x2, W0
003DEA  0702AA     RCALL RecordThisThyratronFault
335:                 }
336:               
337:                 // Check that the thyratron heater voltage ADC reading is not less than X% of its program point (set in Config.h)
338:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated
339:                 if (CheckUnderVoltFault(&ps_thyr_cathode_htr)) {
003DEC  20B240     MOV #0xB24, W0
003DEE  070327     RCALL CheckUnderVoltFault
003DF0  784200     MOV.B W0, W4
003DF2  524FE0     SUB.B W4, #0x0, [W15]
003DF4  320002     BRA Z, 0x3DFA
340:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_UV);
003DF6  200040     MOV #0x4, W0
003DF8  0702A3     RCALL RecordThisThyratronFault
341:                 }
342:                   
343:                 // Check if the 4-20ma Driver has reported a fault
344:                 if (PIN_4_20_DRVR_FLT == ILL_4_20_DRIVER_FAULT) {
003DFA  801615     MOV PORTA, W5
003DFC  204004     MOV #0x400, W4
003DFE  628204     AND W5, W4, W4
003E00  520FE0     SUB W4, #0x0, [W15]
003E02  3A0002     BRA NZ, 0x3E08
345:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_DRVR_FLT);
003E04  200080     MOV #0x8, W0
003E06  07029C     RCALL RecordThisThyratronFault
346:                 }
347:               
348:                 // Check to see if the control loop has saturated.
349:                 // If it has that means that the SCR controller is no longer responding and it should be shut down
350:                 temp_u16int = thyratron_cathode_heater_PID.controlOutput;
003E08  804334     MOV 0x866, W4
003E0A  780F04     MOV W4, [W14]
351:                 if (temp_u16int & 0x8000) {
003E0C  78021E     MOV [W14], W4
003E0E  520FE0     SUB W4, #0x0, [W15]
003E10  3D0002     BRA GE, 0x3E16
352:                   temp_u16int = 0x0000;
003E12  EB0200     CLR W4
003E14  780F04     MOV W4, [W14]
353:                 }
354:                 temp_u16int = temp_u16int << 1;
003E16  78021E     MOV [W14], W4
003E18  420204     ADD W4, W4, W4
003E1A  780F04     MOV W4, [W14]
355:                 if (temp_u16int >= THYRATRON_DAC_SATURATED) {
003E1C  27CFF4     MOV #0x7CFF, W4
003E1E  78029E     MOV [W14], W5
003E20  528F84     SUB W5, W4, [W15]
003E22  360002     BRA LEU, 0x3E28
356:                   RecordThisThyratronFault(FAULT_THYR_CATHODE_HEATER_CONTROL_SAT);
003E24  200100     MOV #0x10, W0
003E26  07028C     RCALL RecordThisThyratronFault
357:                 }
358:                 
359:               
360:               
361:                 // Check if the thyratron reservoir ADC reading has exceed fixed value set Config.h 
362:                 if (ps_thyr_reservoir_htr.v_adc_reading > ps_thyr_reservoir_htr.v_adc_over_abs) {
003E28  805C75     MOV 0xB8E, W5
003E2A  805CB4     MOV 0xB96, W4
003E2C  528F84     SUB W5, W4, [W15]
003E2E  360002     BRA LEU, 0x3E34
363:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_OV_HARD_LIMIT);
003E30  200200     MOV #0x20, W0
003E32  070286     RCALL RecordThisThyratronFault
364:                 }
365:               
366:               
367:                 // Check that the thyratron reservoir voltage ADC reading is not greater than X% of its program point (set in Config.h)
368:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated  
369:                 if (CheckOverVoltFault(&ps_thyr_reservoir_htr)) {
003E34  20B7E0     MOV #0xB7E, W0
003E36  0702DC     RCALL CheckOverVoltFault
003E38  784200     MOV.B W0, W4
003E3A  524FE0     SUB.B W4, #0x0, [W15]
003E3C  320002     BRA Z, 0x3E42
370:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_OV);
003E3E  200400     MOV #0x40, W0
003E40  07027F     RCALL RecordThisThyratronFault
371:                 }
372:               
373:                 // Check that the thyratron reservoir voltage ADC reading is not less than X% of its program point (set in Config.h)
374:                 // It must remain outside this range for at least THYRATRON_HEATER_MAX_OUT_OF_RANGE_COUNT before a fault is generated
375:                 if (CheckUnderVoltFault(&ps_thyr_reservoir_htr)) {
003E42  20B7E0     MOV #0xB7E, W0
003E44  0702FC     RCALL CheckUnderVoltFault
003E46  784200     MOV.B W0, W4
003E48  524FE0     SUB.B W4, #0x0, [W15]
003E4A  320002     BRA Z, 0x3E50
376:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_UV);
003E4C  200800     MOV #0x80, W0
003E4E  070278     RCALL RecordThisThyratronFault
377:                 }
378:               
379:                 // Check if the 4-20ma Driver has reported a fault
380:                 if (PIN_4_20_DRVR_FLT == ILL_4_20_DRIVER_FAULT) {
003E50  801615     MOV PORTA, W5
003E52  204004     MOV #0x400, W4
003E54  628204     AND W5, W4, W4
003E56  520FE0     SUB W4, #0x0, [W15]
003E58  3A0002     BRA NZ, 0x3E5E
381:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_DRVR_FLT);
003E5A  201000     MOV #0x100, W0
003E5C  070271     RCALL RecordThisThyratronFault
382:                 }
383:                 
384:                 // Check to see if the control loop has saturated.
385:                 // If it has that means that the SCR controller is no longer responding and it should be shut down
386:                 temp_u16int = thyratron_reservoir_heater_PID.controlOutput;
003E5E  8042E4     MOV 0x85C, W4
003E60  780F04     MOV W4, [W14]
387:                 if (temp_u16int & 0x8000) {
003E62  78021E     MOV [W14], W4
003E64  520FE0     SUB W4, #0x0, [W15]
003E66  3D0002     BRA GE, 0x3E6C
388:                   temp_u16int = 0x0000;
003E68  EB0200     CLR W4
003E6A  780F04     MOV W4, [W14]
389:                 }
390:                 temp_u16int = temp_u16int << 1;
003E6C  78021E     MOV [W14], W4
003E6E  420204     ADD W4, W4, W4
003E70  780F04     MOV W4, [W14]
391:                 if (temp_u16int >= THYRATRON_DAC_SATURATED) {
003E72  27CFF4     MOV #0x7CFF, W4
003E74  78029E     MOV [W14], W5
003E76  528F84     SUB W5, W4, [W15]
003E78  360002     BRA LEU, 0x3E7E
392:                   RecordThisThyratronFault(FAULT_THYR_RESER_HEATER_CONTROL_SAT);
003E7A  202000     MOV #0x200, W0
003E7C  070261     RCALL RecordThisThyratronFault
393:                 }
394:               
395:               
396:                 //------------------------- START CONTROL BOARD FAULTS ------------------------------//
397:               
398:               
399:                 // Check that the lambda supply powered up
400:                 if (PIN_HV_LAMBDA_POWER_UP == ILL_PIN_HV_LAMBDA_DID_NOT_POWER_UP) {
003E7E  8016A4     MOV PORTD, W4
003E80  620262     AND W4, #0x2, W4
003E82  520FE0     SUB W4, #0x0, [W15]
003E84  320002     BRA Z, 0x3E8A
401:                   RecordThisControlBoardFault(FAULT_LAMBDA_OFF);
003E86  200010     MOV #0x1, W0
003E88  070277     RCALL RecordThisControlBoardFault
402:                 }
403:                 
404:                 // Check to see if digital interlock 1 is open  
405:                 if (PIN_INTERLOCK_1 == ILL_INTERLOCK_OPEN) {
003E8A  801674     MOV PORTC, W4
003E8C  620268     AND W4, #0x8, W4
003E8E  520FE0     SUB W4, #0x0, [W15]
003E90  320002     BRA Z, 0x3E96
406:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_1);
003E92  200020     MOV #0x2, W0
003E94  070271     RCALL RecordThisControlBoardFault
407:                 }
408:                 
409:                 // Check to see if digital interlock 2 is open  
410:                 if (PIN_INTERLOCK_2 == ILL_INTERLOCK_OPEN) {
003E96  801674     MOV PORTC, W4
003E98  620270     AND W4, #0x10, W4
003E9A  520FE0     SUB W4, #0x0, [W15]
003E9C  320002     BRA Z, 0x3EA2
411:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_2);
003E9E  200040     MOV #0x4, W0
003EA0  07026B     RCALL RecordThisControlBoardFault
412:                 }
413:                 
414:                 // Check to see if digital interlock 3 is open  
415:                 if (PIN_INTERLOCK_3 == ILL_INTERLOCK_OPEN) {
003EA2  801735     MOV PORTG, W5
003EA4  201004     MOV #0x100, W4
003EA6  628204     AND W5, W4, W4
003EA8  520FE0     SUB W4, #0x0, [W15]
003EAA  320002     BRA Z, 0x3EB0
416:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_3);
003EAC  200080     MOV #0x8, W0
003EAE  070264     RCALL RecordThisControlBoardFault
417:                 }
418:                 
419:                 // Check to see if digital interlock 4 is open  
420:                 if (PIN_INTERLOCK_4 == ILL_INTERLOCK_OPEN) {
003EB0  801735     MOV PORTG, W5
003EB2  202004     MOV #0x200, W4
003EB4  628204     AND W5, W4, W4
003EB6  520FE0     SUB W4, #0x0, [W15]
003EB8  320002     BRA Z, 0x3EBE
421:                   RecordThisControlBoardFault(FAULT_DIGITAL_INTERLOCK_4);
003EBA  200100     MOV #0x10, W0
003EBC  07025D     RCALL RecordThisControlBoardFault
422:                 }
423:                 
424:               }
003EBE  FA8000     ULNK
003EC0  060000     RETURN
425:               
426:               void ResetPulseLatches(void) {
003EC2  FA0000     LNK #0x0
427:                 PIN_PULSE_LATCH_RESET = OLL_PULSE_LATCH_RESET;
003EC4  A9A2E2     BCLR LATF, #5
428:                 __delay32(DELAY_PULSE_LATCH_RESET);
003EC6  20BB80     MOV #0xBB8, W0
003EC8  200001     MOV #0x0, W1
003ECA  07095B     RCALL ___delay32
429:                 PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
003ECC  A8A2E2     BSET LATF, #5
430:               }
003ECE  FA8000     ULNK
003ED0  060000     RETURN
431:               
432:               
433:               void ResetHWLatches(void) {
003ED2  FA0000     LNK #0x0
434:                 // Reset the latches
435:                 PIN_LATCH_RESET = OLL_RESET_LATCH;
003ED4  A962D6     BCLR LATD, #3
436:                 __delay32(DELAY_LATCH_RESET);
003ED6  2003C0     MOV #0x3C, W0
003ED8  200001     MOV #0x0, W1
003EDA  070953     RCALL ___delay32
437:                 PIN_LATCH_RESET = !OLL_RESET_LATCH;
003EDC  A862D6     BSET LATD, #3
438:               }
003EDE  FA8000     ULNK
003EE0  060000     RETURN
439:               
440:               void ResetAllFaults(void) {
003EE2  FA0000     LNK #0x0
441:                 ResetHWLatches();
003EE4  07FFF6     RCALL ResetHWLatches
442:               
443:                 // Clear all fault registers
444:               
445:                 // MAGNETRON CONTROL FAULT REGISTERS
446:                 faults_magnetron_fault_reg       = 0;
003EE6  EB0200     CLR W4
003EE8  88C3B4     MOV W4, faults_magnetron_fault_reg
447:                 faults_magnetron_warning_reg     = 0;
003EEA  EB0200     CLR W4
003EEC  88C3C4     MOV W4, faults_magnetron_warning_reg
448:                 
449:                 // HIGH VOLTAGE FAULT REGISTERS
450:                 faults_high_voltage_fault_reg    = 0;
003EEE  EB0200     CLR W4
003EF0  88C3E4     MOV W4, faults_high_voltage_fault_reg
451:                 faults_high_voltage_warning_reg  = 0;
003EF2  EB0200     CLR W4
003EF4  88C3F4     MOV W4, faults_high_voltage_warning_reg
452:                 
453:                 // THYRATRON HEATER FAULT REGISTERS
454:                 faults_thyratron_fault_reg       = 0;
003EF6  EB0200     CLR W4
003EF8  88C414     MOV W4, faults_thyratron_fault_reg
455:                 faults_thyratron_warning_reg     = 0;
003EFA  EB0200     CLR W4
003EFC  88C424     MOV W4, faults_thyratron_warning_reg
456:                   
457:                 // CONTROL BOARD FAULT REGISTERS
458:                 faults_control_board_fault_reg   = 0;
003EFE  EB0200     CLR W4
003F00  88C444     MOV W4, faults_control_board_fault_reg
459:                 faults_control_board_warning_reg = 0;
003F02  EB0200     CLR W4
003F04  88C454     MOV W4, faults_control_board_warning_reg
460:               }
003F06  FA8000     ULNK
003F08  060000     RETURN
461:               
462:               
463:               void UpdatePulseData(unsigned char mode) {
003F0A  FA0004     LNK #0x4
003F0C  984720     MOV.B W0, [W14+2]
464:                 unsigned int pulse_energy_milli_joules;
465:               
466:                 /*
467:                   FAULT_PFN_TRIGGER_PERIOD_TOO_SHORT is evaluated by the TMR1 Interrupt
468:                 */
469:                 
470:                 /* 
471:                    First Perform Data itegrity checks on the data from the AD converter
472:                    
473:                    Arc detection is the responsibility of the HW circuits.
474:               
475:                    In the event of an ARC the current readback IS NOT INCLUDED in the filtered Values.
476:               
477:                    If there was NOT AN ARC, further checking is done on the current readback to insure it is valid.
478:                    
479:                    If the current is inside a specified value (ADC_PULSE_CURRENT_UNDER_GLITCH -> ADC_PULSE_CURRENT_OVER_GLITCH) it is included in filtering math.
480:                    If not the value is ignored from a filtering point of view
481:               
482:                    Sowftware over/under current/voltage detection.
483:                       
484:                 */
485:               
486:                 /*
487:                   Tracking  Arcs
488:               
489:               
490:                   Hardware Arc is defined as 
491:                        (1) setting Overcurrent Latch 
492:                     OR (2) failing to set Undercurrent Latch
493:               
494:               
495:                   Software Glitch is defined as 
496:                        (1) Not setting the ( Hardware ARC OR Software ARC)
497:                    AND (2) Reading outside the Hardware range limits
498:               
499:                   There is an Arc Counter that increments with every Hardware Arc (this is stored in EEPROM) (32 bit)
500:                   There is an Arc Counter in RAM that counts number of Hardware arc since the last HV_ON Command (32 bit)
501:               
502:               
503:                   If (overcurrent latch is set) OR (undercurrent latch is not set)
504:                      Then Hardware Arc
505:                   Else if (ADC reading > overcurrent set point) OR (ADC reading < undercurrent set point)
506:                      Then Software Glitch
507:                   Else 
508:                      The Pulse was good, record the pulse info into the A or B register
509:               
510:               
511:                   Hardware Arcs can generate faults in the following ways.
512:                   1) Too many consecutive arcs.
513:                   2) Too many arcs per 300 pulses (per second 300 Hz)
514:                   3) Too many arcs per 18000 pulses (per minute at 300 Hz)
515:                   
516:                 */
517:                 
518:                 if (arc_detected == 1) {
003F0E  804064     MOV arc_detected, W4
003F10  520FE1     SUB W4, #0x1, [W15]
003F12  3A0015     BRA NZ, 0x3F3E
519:                   // The high voltage tank current was too high (indicating an arc) or was too low (indicating a short in the modulator)
520:                   // Record and arc and throw away the data from the ADC
521:                   arc_detected = 0;
003F14  EB0200     CLR W4
003F16  884064     MOV W4, arc_detected
522:                   arc_counter_persistent++;
003F18  80C654     MOV arc_counter_persistent, W4
003F1A  80C665     MOV 0x18CC, W5
003F1C  420261     ADD W4, #0x1, W4
003F1E  4A82E0     ADDC W5, #0x0, W5
003F20  88C654     MOV W4, arc_counter_persistent
003F22  88C665     MOV W5, 0x18CC
523:                   arc_counter_this_hv_on++;
003F24  80C6E4     MOV arc_counter_this_hv_on, W4
003F26  E80204     INC W4, W4
003F28  88C6E4     MOV W4, arc_counter_this_hv_on
524:                   
525:                   arc_counter_consecutive++;
003F2A  804244     MOV arc_counter_consecutive, W4
003F2C  E80204     INC W4, W4
003F2E  884244     MOV W4, arc_counter_consecutive
526:                   arc_counter_fast++;
003F30  804254     MOV arc_counter_fast, W4
003F32  E80204     INC W4, W4
003F34  884254     MOV W4, arc_counter_fast
527:                   arc_counter_slow++;
003F36  804264     MOV arc_counter_slow, W4
003F38  E80204     INC W4, W4
003F3A  884264     MOV W4, arc_counter_slow
003F3C  37001A     BRA 0x3F72
528:                 } else {
529:                   // Hardware did not detect an arc.  Software appears to have read a valid pulse.  Update all data
530:                   
531:                   arc_counter_consecutive = 0;
003F3E  EB0200     CLR W4
003F40  884244     MOV W4, arc_counter_consecutive
532:                   
533:                   if (mode == PULSE_MODE_A) {
003F42  90422E     MOV.B [W14+2], W4
003F44  524FE0     SUB.B W4, #0x0, [W15]
003F46  3A0008     BRA NZ, 0x3F58
534:                     StorePulseData(&ps_magnetron_mode_A);
003F48  209620     MOV #0x962, W0
003F4A  070090     RCALL StorePulseData
535:                     pulse_energy_milli_joules = CalculatePulseEnergyMilliJoules(ps_hv_lambda_mode_A.v_command_set_point);
003F4C  804854     MOV 0x90A, W4
003F4E  780004     MOV W4, W0
003F50  0700C3     RCALL CalculatePulseEnergyMilliJoules
003F52  780200     MOV W0, W4
003F54  780F04     MOV W4, [W14]
003F56  370007     BRA 0x3F66
536:                   } else {
537:                     StorePulseData(&ps_magnetron_mode_B);
003F58  20A160     MOV #0xA16, W0
003F5A  070088     RCALL StorePulseData
538:                     pulse_energy_milli_joules = CalculatePulseEnergyMilliJoules(ps_hv_lambda_mode_B.v_command_set_point);
003F5C  804DF4     MOV 0x9BE, W4
003F5E  780004     MOV W4, W0
003F60  0700BB     RCALL CalculatePulseEnergyMilliJoules
003F62  780200     MOV W0, W4
003F64  780F04     MOV W4, [W14]
539:                   }
540:                   average_energy_per_pulse_milli_joules = RCFilter64Tau(average_energy_per_pulse_milli_joules, pulse_energy_milli_joules);
003F66  8041C4     MOV average_energy_per_pulse_milli_joules, W4
003F68  78009E     MOV [W14], W1
003F6A  780004     MOV W4, W0
003F6C  07F2A4     RCALL RCFilter64Tau
003F6E  780200     MOV W0, W4
003F70  8841C4     MOV W4, average_energy_per_pulse_milli_joules
541:                 }   
542:                 
543:                 
544:                 if ((pulse_magnetron_current_adc_reading > ADC_PULSE_CURRENT_OVER_GLITCH) || (pulse_magnetron_current_adc_reading < ADC_PULSE_CURRENT_UNDER_GLITCH)) {
003F72  8042A5     MOV pulse_magnetron_current_adc_reading, W5
003F74  2FA004     MOV #0xFA00, W4
003F76  528F84     SUB W5, W4, [W15]
003F78  3E0004     BRA GTU, 0x3F82
003F7A  8042A5     MOV pulse_magnetron_current_adc_reading, W5
003F7C  22FFF4     MOV #0x2FFF, W4
003F7E  528F84     SUB W5, W4, [W15]
003F80  3E0003     BRA GTU, 0x3F88
545:                   // The current readback was outside of the "GLITCH" limits.  Assume it was an error with the ADC and record an ADC error
546:                   global_debug_counter.magnetron_current_adc_glitch++;
003F82  80C2E4     MOV global_debug_counter, W4
003F84  E80204     INC W4, W4
003F86  88C2E4     MOV W4, global_debug_counter
547:                 }
548:               
549:                 if ((pulse_magnetron_voltage_adc_reading > ADC_PULSE_VOLTAGE_OVER_GLITCH) || (pulse_magnetron_voltage_adc_reading < ADC_PULSE_VOLTAGE_UNDER_GLITCH)) {
003F88  8042B5     MOV pulse_magnetron_voltage_adc_reading, W5
003F8A  2F0004     MOV #0xF000, W4
003F8C  528F84     SUB W5, W4, [W15]
003F8E  3E0004     BRA GTU, 0x3F98
003F90  8042B5     MOV pulse_magnetron_voltage_adc_reading, W5
003F92  207FF4     MOV #0x7FF, W4
003F94  528F84     SUB W5, W4, [W15]
003F96  3E0003     BRA GTU, 0x3F9E
550:                   global_debug_counter.magnetron_voltage_adc_glitch++;
003F98  80C2F4     MOV 0x185E, W4
003F9A  E80204     INC W4, W4
003F9C  88C2F4     MOV W4, 0x185E
551:                 }
552:                 
553:                 //ResetPulseLatches();  // This must be called to clear the over/under current latches.  //DPARKER the pulse latches are now reset in the pulse interrupt
554:                 
555:                 // Decrement the arc_counter_fast if we need to
556:                 pulse_counter_fast++;
003F9E  804274     MOV pulse_counter_fast, W4
003FA0  E80204     INC W4, W4
003FA2  884274     MOV W4, pulse_counter_fast
557:                 if (pulse_counter_fast > ARC_COUNTER_FAST_DECREMENT_INTERVAL) {
003FA4  804274     MOV pulse_counter_fast, W4
003FA6  520FF9     SUB W4, #0x19, [W15]
003FA8  360008     BRA LEU, 0x3FBA
558:                   pulse_counter_fast = 0;
003FAA  EB0200     CLR W4
003FAC  884274     MOV W4, pulse_counter_fast
559:                   if (arc_counter_fast) {
003FAE  804254     MOV arc_counter_fast, W4
003FB0  520FE0     SUB W4, #0x0, [W15]
003FB2  320003     BRA Z, 0x3FBA
560:                     arc_counter_fast--;
003FB4  804254     MOV arc_counter_fast, W4
003FB6  E90204     DEC W4, W4
003FB8  884254     MOV W4, arc_counter_fast
561:                   }
562:                 }
563:                 
564:                 // decrement the arc_counter_slow if we need to
565:                 pulse_counter_slow++;
003FBA  804284     MOV pulse_counter_slow, W4
003FBC  E80204     INC W4, W4
003FBE  884284     MOV W4, pulse_counter_slow
566:                 if (pulse_counter_slow > ARC_COUNTER_SLOW_DECREMENT_INTERVAL) {
003FC0  804284     MOV pulse_counter_slow, W4
003FC2  520FF4     SUB W4, #0x14, [W15]
003FC4  360008     BRA LEU, 0x3FD6
567:                   pulse_counter_slow = 0;
003FC6  EB0200     CLR W4
003FC8  884284     MOV W4, pulse_counter_slow
568:                   if (arc_counter_slow) {
003FCA  804264     MOV arc_counter_slow, W4
003FCC  520FE0     SUB W4, #0x0, [W15]
003FCE  320003     BRA Z, 0x3FD6
569:                     arc_counter_slow--;
003FD0  804264     MOV arc_counter_slow, W4
003FD2  E90204     DEC W4, W4
003FD4  884264     MOV W4, arc_counter_slow
570:                   }
571:                 }
572:                 
573:               
574:                 // CHECK FOR PULSE FAULTS - Too many arcs, voltage/current out of range
575:                 
576:                 // Check for too many consecutive arcs
577:                 if (arc_counter_consecutive > ARC_COUNTER_MAX_CONSECUTIVE) {
003FD6  804244     MOV arc_counter_consecutive, W4
003FD8  520FE5     SUB W4, #0x5, [W15]
003FDA  360002     BRA LEU, 0x3FE0
578:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_CONSECUTIVE);
003FDC  200010     MOV #0x1, W0
003FDE  070194     RCALL RecordThisHighVoltageFault
579:                 }
580:                 
581:                 // Check for too many arcs in a short amount of time
582:                 if (arc_counter_fast > ARC_COUNTER_FAST_MAX_ARCS) {
003FE0  804255     MOV arc_counter_fast, W5
003FE2  201904     MOV #0x190, W4
003FE4  528F84     SUB W5, W4, [W15]
003FE6  360002     BRA LEU, 0x3FEC
583:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_FAST);
003FE8  200020     MOV #0x2, W0
003FEA  07018E     RCALL RecordThisHighVoltageFault
584:                 }
585:                 
586:                 // Check for too many arc is a long amount of time
587:                 if (arc_counter_slow > ARC_COUNTER_SLOW_MAX_ARCS) {
003FEC  804265     MOV arc_counter_slow, W5
003FEE  201F44     MOV #0x1F4, W4
003FF0  528F84     SUB W5, W4, [W15]
003FF2  360002     BRA LEU, 0x3FF8
588:                   RecordThisHighVoltageFault(FAULT_ARC_OVER_COUNT_SLOW);
003FF4  200040     MOV #0x4, W0
003FF6  070188     RCALL RecordThisHighVoltageFault
589:                 }
590:                 
591:               
592:                 // Check that the magnetron voltage ADC reading is not greater than X% of its program point (set in Config.h)
593:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
594:                 if (CheckOverVoltFault(&ps_magnetron_mode_A)) {
003FF8  209620     MOV #0x962, W0
003FFA  0701FA     RCALL CheckOverVoltFault
003FFC  784200     MOV.B W0, W4
003FFE  524FE0     SUB.B W4, #0x0, [W15]
004000  320002     BRA Z, 0x4006
595:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_A);
004002  200400     MOV #0x40, W0
004004  070181     RCALL RecordThisHighVoltageFault
596:                 }
597:                 
598:                 // Check that the magnetron voltage ADC reading is not less than X% of its program point (set in Config.h)
599:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
600:                 if (CheckUnderVoltFault(&ps_magnetron_mode_A)) {
004006  209620     MOV #0x962, W0
004008  07021A     RCALL CheckUnderVoltFault
00400A  784200     MOV.B W0, W4
00400C  524FE0     SUB.B W4, #0x0, [W15]
00400E  320002     BRA Z, 0x4014
601:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_A);
004010  200400     MOV #0x40, W0
004012  07017A     RCALL RecordThisHighVoltageFault
602:                 }
603:               
604:                 // Check that the magnetron current ADC reading is not greater than X% of its program point (set in Config.h)
605:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
606:                 if (CheckOverCurrentFault(&ps_magnetron_mode_A)) {
004014  209620     MOV #0x962, W0
004016  070241     RCALL CheckOverCurrentFault
004018  784200     MOV.B W0, W4
00401A  524FE0     SUB.B W4, #0x0, [W15]
00401C  320002     BRA Z, 0x4022
607:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_A);
00401E  200100     MOV #0x10, W0
004020  070173     RCALL RecordThisHighVoltageFault
608:                 }
609:                 
610:                 // Check that the magnetron current ADC reading is not less than X% of its program point (set in Config.h)
611:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
612:                 if (CheckUnderCurrentFault(&ps_magnetron_mode_A)) {
004022  209620     MOV #0x962, W0
004024  070261     RCALL CheckUnderCurrentFault
004026  784200     MOV.B W0, W4
004028  524FE0     SUB.B W4, #0x0, [W15]
00402A  320002     BRA Z, 0x4030
613:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_A);
00402C  200100     MOV #0x10, W0
00402E  07016C     RCALL RecordThisHighVoltageFault
614:                 }
615:               
616:               
617:                 // Check that the magnetron voltage ADC reading is not greater than X% of its program point (set in Config.h)
618:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
619:                 if (CheckOverVoltFault(&ps_magnetron_mode_B)) {
004030  20A160     MOV #0xA16, W0
004032  0701DE     RCALL CheckOverVoltFault
004034  784200     MOV.B W0, W4
004036  524FE0     SUB.B W4, #0x0, [W15]
004038  320002     BRA Z, 0x403E
620:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_B);
00403A  200800     MOV #0x80, W0
00403C  070165     RCALL RecordThisHighVoltageFault
621:                 }
622:                 
623:                 // Check that the magnetron voltage ADC reading is not less than X% of its program point (set in Config.h)
624:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
625:                 if (CheckUnderVoltFault(&ps_magnetron_mode_B)) {
00403E  20A160     MOV #0xA16, W0
004040  0701FE     RCALL CheckUnderVoltFault
004042  784200     MOV.B W0, W4
004044  524FE0     SUB.B W4, #0x0, [W15]
004046  320002     BRA Z, 0x404C
626:                   RecordThisHighVoltageFault(FAULT_PULSE_VOLTAGE_OOR_MODE_B);
004048  200800     MOV #0x80, W0
00404A  07015E     RCALL RecordThisHighVoltageFault
627:                 }
628:                 
629:                 // Check that the magnetron current ADC reading is not greater than X% of its program point (set in Config.h)
630:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
631:                 if (CheckOverCurrentFault(&ps_magnetron_mode_B)) {
00404C  20A160     MOV #0xA16, W0
00404E  070225     RCALL CheckOverCurrentFault
004050  784200     MOV.B W0, W4
004052  524FE0     SUB.B W4, #0x0, [W15]
004054  320002     BRA Z, 0x405A
632:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_B);
004056  200200     MOV #0x20, W0
004058  070157     RCALL RecordThisHighVoltageFault
633:                 }
634:                 
635:                 // Check that the magnetron current ADC reading is not less than X% of its program point (set in Config.h)
636:                 // It must remain outside this range for at least PULSE_MAX_OUT_OF_RANGE_COUNT pulses before a fault is generated  
637:                 if (CheckUnderCurrentFault(&ps_magnetron_mode_B)) {
00405A  20A160     MOV #0xA16, W0
00405C  070245     RCALL CheckUnderCurrentFault
00405E  784200     MOV.B W0, W4
004060  524FE0     SUB.B W4, #0x0, [W15]
004062  320002     BRA Z, 0x4068
638:                   RecordThisHighVoltageFault(FAULT_PULSE_CURRENT_OOR_MODE_B);
004064  200200     MOV #0x20, W0
004066  070150     RCALL RecordThisHighVoltageFault
639:                 }
640:                 
641:               
642:                 // DPARKER NEED TO IMPLEMENT and TEST the PFN fault current input Logic
643:               }
004068  FA8000     ULNK
00406A  060000     RETURN
644:               
645:               void StorePulseData(POWERSUPPLY* ptr) {
00406C  FA0002     LNK #0x2
00406E  780F00     MOV W0, [W14]
646:                 
647:                 ptr->i_adc_reading = RCFilter16Tau(ptr->i_adc_reading, pulse_magnetron_current_adc_reading);
004070  8042A5     MOV pulse_magnetron_current_adc_reading, W5
004072  78021E     MOV [W14], W4
004074  901A64     MOV [W4+60], W4
004076  780085     MOV W5, W1
004078  780004     MOV W4, W0
00407A  07F259     RCALL RCFilter16Tau
00407C  780200     MOV W0, W4
00407E  78029E     MOV [W14], W5
004080  981AE4     MOV W4, [W5+60]
648:                 ptr->v_adc_reading = RCFilter16Tau(ptr->v_adc_reading, pulse_magnetron_voltage_adc_reading);
004082  8042B5     MOV pulse_magnetron_voltage_adc_reading, W5
004084  78021E     MOV [W14], W4
004086  900A04     MOV [W4+16], W4
004088  780085     MOV W5, W1
00408A  780004     MOV W4, W0
00408C  07F250     RCALL RCFilter16Tau
00408E  780200     MOV W0, W4
004090  78029E     MOV [W14], W5
004092  980A84     MOV W4, [W5+16]
649:                 
650:                 // record min/max current
651:                 if (pulse_magnetron_current_adc_reading > ptr->i_adc_max_reading) {
004094  78021E     MOV [W14], W4
004096  902AB4     MOV [W4+86], W5
004098  8042A4     MOV pulse_magnetron_current_adc_reading, W4
00409A  528F84     SUB W5, W4, [W15]
00409C  310003     BRA C, 0x40A4
652:                   ptr->i_adc_max_reading = pulse_magnetron_current_adc_reading;
00409E  8042A5     MOV pulse_magnetron_current_adc_reading, W5
0040A0  78021E     MOV [W14], W4
0040A2  982A35     MOV W5, [W4+86]
653:                 }
654:                 if (pulse_magnetron_current_adc_reading < ptr->i_adc_min_reading) {
0040A4  78021E     MOV [W14], W4
0040A6  902AC4     MOV [W4+88], W5
0040A8  8042A4     MOV pulse_magnetron_current_adc_reading, W4
0040AA  528F84     SUB W5, W4, [W15]
0040AC  360003     BRA LEU, 0x40B4
655:                   ptr->i_adc_min_reading = pulse_magnetron_current_adc_reading;
0040AE  8042A5     MOV pulse_magnetron_current_adc_reading, W5
0040B0  78021E     MOV [W14], W4
0040B2  982A45     MOV W5, [W4+88]
656:                 }
657:               
658:                 // record min/max voltage
659:                 if (pulse_magnetron_voltage_adc_reading > ptr->v_adc_max_reading) {
0040B4  78021E     MOV [W14], W4
0040B6  9012D4     MOV [W4+42], W5
0040B8  8042B4     MOV pulse_magnetron_voltage_adc_reading, W4
0040BA  528F84     SUB W5, W4, [W15]
0040BC  310003     BRA C, 0x40C4
660:                   ptr->v_adc_max_reading = pulse_magnetron_voltage_adc_reading;
0040BE  8042B5     MOV pulse_magnetron_voltage_adc_reading, W5
0040C0  78021E     MOV [W14], W4
0040C2  981255     MOV W5, [W4+42]
661:                 }
662:                 if (pulse_magnetron_voltage_adc_reading < ptr->v_adc_min_reading) {
0040C4  78021E     MOV [W14], W4
0040C6  9012E4     MOV [W4+44], W5
0040C8  8042B4     MOV pulse_magnetron_voltage_adc_reading, W4
0040CA  528F84     SUB W5, W4, [W15]
0040CC  360003     BRA LEU, 0x40D4
663:                   ptr->v_adc_min_reading = pulse_magnetron_voltage_adc_reading;
0040CE  8042B5     MOV pulse_magnetron_voltage_adc_reading, W5
0040D0  78021E     MOV [W14], W4
0040D2  981265     MOV W5, [W4+44]
664:                 }
665:               
666:               }
0040D4  FA8000     ULNK
0040D6  060000     RETURN
667:               
668:               unsigned int CalculatePulseEnergyMilliJoules(unsigned int lambda_voltage) {
0040D8  FA0008     LNK #0x8
0040DA  980730     MOV W0, [W14+6]
669:                 unsigned long power_milli_joule;
670:                 unsigned int return_data;
671:               
672:                 /*
673:                   The Pulse Energy is Calculated for Each Pulse
674:                   The Pulse Energy is Filtered/Averaged with a 64 pulse/tau filter
675:                   The Average Pulse Energy is then multiplied by the PRF to generate the power.
676:                   The filament heater voltage is generated from the power.
677:               
678:                   Power = 1/2 * C * V^2
679:                   C = 90nF
680:                   In Floating Point Math
681:                   power(milli_joule) = .5 * 90e-9 * V^2 * 1000
682:               
683:                   power_milli_joule = .5 * 90e-9 * V^2 * 1000
684:                                     = v^2/22222.22
685:               		      = v*v / 2^6 / 347.22
686:               		      = v*v / 2^6 * 47 / 2^14 (.4% fixed point error)
687:               
688:               		      
689:                   C = 60nF for 800Hz
690:                   power_milli_joule = .5 * 60e-9 * V^2 * 1000
691:                                     = v^2/33333.33
692:               		      = v*v / 2^6 / 520.83
693:               		      = v*v / 2^6 * 31 / 2^14 (.4% fixed point error)		      
694:                 */
695:               
696:                 power_milli_joule = lambda_voltage;
0040DC  90023E     MOV [W14+6], W4
0040DE  200005     MOV #0x0, W5
0040E0  BE8F04     MOV.D W4, [W14]
697:                 power_milli_joule *= lambda_voltage;
0040E2  90023E     MOV [W14+6], W4
0040E4  200005     MOV #0x0, W5
0040E6  90031E     MOV [W14+2], W6
0040E8  B9B304     MUL.SS W6, W4, W6
0040EA  780306     MOV W6, W6
0040EC  78039E     MOV [W14], W7
0040EE  B9B805     MUL.SS W7, W5, W0
0040F0  780380     MOV W0, W7
0040F2  430307     ADD W6, W7, W6
0040F4  78039E     MOV [W14], W7
0040F6  780204     MOV W4, W4
0040F8  B82207     MUL.UU W4, W7, W4
0040FA  430305     ADD W6, W5, W6
0040FC  780286     MOV W6, W5
0040FE  BE8F04     MOV.D W4, [W14]
004100  BE8F04     MOV.D W4, [W14]
698:                 power_milli_joule >>= 6;
004102  BE021E     MOV.D [W14], W4
004104  DD2B4A     SL W5, #10, W6
004106  DE2246     LSR W4, #6, W4
004108  730204     IOR W6, W4, W4
00410A  DE2AC6     LSR W5, #6, W5
00410C  BE8F04     MOV.D W4, [W14]
699:                 power_milli_joule *= 31;
00410E  90021E     MOV [W14+2], W4
004110  B9227F     MUL.SU W4, #31, W4
004112  780304     MOV W4, W6
004114  78021E     MOV [W14], W4
004116  B92260     MUL.SU W4, #0, W4
004118  780204     MOV W4, W4
00411A  430304     ADD W6, W4, W6
00411C  78029E     MOV [W14], W5
00411E  2001F4     MOV #0x1F, W4
004120  B82A04     MUL.UU W5, W4, W4
004122  430305     ADD W6, W5, W6
004124  780286     MOV W6, W5
004126  BE8F04     MOV.D W4, [W14]
004128  BE8F04     MOV.D W4, [W14]
700:                 power_milli_joule >>= 14;
00412A  BE021E     MOV.D [W14], W4
00412C  DD2B42     SL W5, #2, W6
00412E  DE224E     LSR W4, #14, W4
004130  730204     IOR W6, W4, W4
004132  DE2ACE     LSR W5, #14, W5
004134  BE8F04     MOV.D W4, [W14]
701:               
702:                 if (power_milli_joule >= 0xFFFF) {
004136  2FFFE4     MOV #0xFFFE, W4
004138  200005     MOV #0x0, W5
00413A  BE031E     MOV.D [W14], W6
00413C  530F84     SUB W6, W4, [W15]
00413E  5B8F85     SUBB W7, W5, [W15]
004140  360003     BRA LEU, 0x4148
703:                   power_milli_joule = 0xFFFF;
004142  2FFFF4     MOV #0xFFFF, W4
004144  200005     MOV #0x0, W5
004146  BE8F04     MOV.D W4, [W14]
704:                 }
705:                 power_milli_joule &= 0xFFFF;
004148  2FFFF4     MOV #0xFFFF, W4
00414A  200005     MOV #0x0, W5
00414C  BE031E     MOV.D [W14], W6
00414E  780006     MOV W6, W0
004150  780307     MOV W7, W6
004152  780384     MOV W4, W7
004154  780205     MOV W5, W4
004156  600007     AND W0, W7, W0
004158  630204     AND W6, W4, W4
00415A  200005     MOV #0x0, W5
00415C  DD22C0     SL W4, #0, W5
00415E  200004     MOV #0x0, W4
004160  BE0304     MOV.D W4, W6
004162  B80261     MUL.UU W0, #1, W4
004164  730304     IOR W6, W4, W6
004166  738385     IOR W7, W5, W7
004168  BE8F06     MOV.D W6, [W14]
706:               
707:                 return_data = power_milli_joule;
00416A  78021E     MOV [W14], W4
00416C  980724     MOV W4, [W14+4]
708:               
709:                 return return_data;
00416E  90022E     MOV [W14+4], W4
710:               }
004170  780004     MOV W4, W0
004172  FA8000     ULNK
004174  060000     RETURN
711:               
712:               
713:               void LoadFaultMaskRegisters(void) {
004176  FA0000     LNK #0x0
714:                 
715:                 switch(control_state) {
004178  208404     MOV #0x840, W4
00417A  784214     MOV.B [W4], W4
00417C  FB8204     ZE W4, W4
00417E  200345     MOV #0x34, W5
004180  520F85     SUB W4, W5, [W15]
004182  32004F     BRA Z, 0x4222
004184  200345     MOV #0x34, W5
004186  520F85     SUB W4, W5, [W15]
004188  3C0008     BRA GT, 0x419A
00418A  520FF4     SUB W4, #0x14, [W15]
00418C  320028     BRA Z, 0x41DE
00418E  200245     MOV #0x24, W5
004190  520F85     SUB W4, W5, [W15]
004192  320036     BRA Z, 0x4200
004194  520FE4     SUB W4, #0x4, [W15]
004196  320012     BRA Z, 0x41BC
004198  370099     BRA 0x42CC
00419A  200445     MOV #0x44, W5
00419C  520F85     SUB W4, W5, [W15]
00419E  320063     BRA Z, 0x4266
0041A0  200445     MOV #0x44, W5
0041A2  520F85     SUB W4, W5, [W15]
0041A4  3C0004     BRA GT, 0x41AE
0041A6  200355     MOV #0x35, W5
0041A8  520F85     SUB W4, W5, [W15]
0041AA  32004C     BRA Z, 0x4244
0041AC  37008F     BRA 0x42CC
0041AE  200A45     MOV #0xA4, W5
0041B0  520F85     SUB W4, W5, [W15]
0041B2  32007B     BRA Z, 0x42AA
0041B4  200A85     MOV #0xA8, W5
0041B6  520F85     SUB W4, W5, [W15]
0041B8  320067     BRA Z, 0x4288
0041BA  370088     BRA 0x42CC
716:                   
717:                 case STATE_START_UP:
718:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_START_UP;
0041BC  EB0200     CLR W4
0041BE  88C464     MOV W4, magnetron_fault_mask
719:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_START_UP;
0041C0  EB0200     CLR W4
0041C2  88C484     MOV W4, thyratron_fault_mask
720:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_START_UP;
0041C4  EB0200     CLR W4
0041C6  88C474     MOV W4, high_voltage_fault_mask
721:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_START_UP;
0041C8  EB0200     CLR W4
0041CA  88C494     MOV W4, control_board_fault_mask
722:                
723:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_START_UP;
0041CC  EB0200     CLR W4
0041CE  88C4A4     MOV W4, magnetron_warning_mask
724:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_START_UP;
0041D0  EB0200     CLR W4
0041D2  88C4C4     MOV W4, thyratron_warning_mask
725:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_START_UP;
0041D4  EB0200     CLR W4
0041D6  88C4B4     MOV W4, high_voltage_warning_mask
726:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_START_UP;
0041D8  EB0200     CLR W4
0041DA  88C4D4     MOV W4, control_board_warning_mask
727:                   break;  
0041DC  370077     BRA 0x42CC
728:               
729:                 case STATE_SYSTEM_COLD_READY:
730:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_COLD_READY;
0041DE  EB0200     CLR W4
0041E0  88C464     MOV W4, magnetron_fault_mask
731:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_COLD_READY;
0041E2  EB0200     CLR W4
0041E4  88C484     MOV W4, thyratron_fault_mask
732:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_COLD_READY;
0041E6  EB0200     CLR W4
0041E8  88C474     MOV W4, high_voltage_fault_mask
733:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_COLD_READY;
0041EA  EB0200     CLR W4
0041EC  88C494     MOV W4, control_board_fault_mask
734:                
735:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_COLD_READY;
0041EE  EB0200     CLR W4
0041F0  88C4A4     MOV W4, magnetron_warning_mask
736:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_COLD_READY;
0041F2  EB0200     CLR W4
0041F4  88C4C4     MOV W4, thyratron_warning_mask
737:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_COLD_READY;
0041F6  EB0200     CLR W4
0041F8  88C4B4     MOV W4, high_voltage_warning_mask
738:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_COLD_READY;
0041FA  EB0200     CLR W4
0041FC  88C4D4     MOV W4, control_board_warning_mask
739:                   break;
0041FE  370066     BRA 0x42CC
740:                   
741:                 case STATE_WARM_UP:
742:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_UP;
004200  202034     MOV #0x203, W4
004202  88C464     MOV W4, magnetron_fault_mask
743:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_UP;
004204  EB0200     CLR W4
004206  88C484     MOV W4, thyratron_fault_mask
744:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_UP;
004208  EB0200     CLR W4
00420A  88C474     MOV W4, high_voltage_fault_mask
745:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_UP;
00420C  EB0200     CLR W4
00420E  88C494     MOV W4, control_board_fault_mask
746:                
747:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_UP;
004210  EB0200     CLR W4
004212  88C4A4     MOV W4, magnetron_warning_mask
748:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_UP;
004214  EB0200     CLR W4
004216  88C4C4     MOV W4, thyratron_warning_mask
749:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_UP;
004218  EB0200     CLR W4
00421A  88C4B4     MOV W4, high_voltage_warning_mask
750:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_UP;
00421C  EB0200     CLR W4
00421E  88C4D4     MOV W4, control_board_warning_mask
751:                   break;
004220  370055     BRA 0x42CC
752:               
753:                 case STATE_SYSTEM_WARM_READY:
754:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_READY;
004222  2003F4     MOV #0x3F, W4
004224  88C464     MOV W4, magnetron_fault_mask
755:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_READY;
004226  EB0200     CLR W4
004228  88C484     MOV W4, thyratron_fault_mask
756:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
00422A  EB0200     CLR W4
00422C  88C474     MOV W4, high_voltage_fault_mask
757:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_READY;
00422E  EB0200     CLR W4
004230  88C494     MOV W4, control_board_fault_mask
758:                
759:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_READY;
004232  EB0200     CLR W4
004234  88C4A4     MOV W4, magnetron_warning_mask
760:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_READY;
004236  EB0200     CLR W4
004238  88C4C4     MOV W4, thyratron_warning_mask
761:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
00423A  EB0200     CLR W4
00423C  88C4B4     MOV W4, high_voltage_warning_mask
762:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_READY;
00423E  EB0200     CLR W4
004240  88C4D4     MOV W4, control_board_warning_mask
763:                   break;
004242  370044     BRA 0x42CC
764:               
765:               
766:                 case STATE_HV_STARTUP:
767:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_READY;
004244  2003F4     MOV #0x3F, W4
004246  88C464     MOV W4, magnetron_fault_mask
768:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_READY;
004248  EB0200     CLR W4
00424A  88C484     MOV W4, thyratron_fault_mask
769:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
00424C  EB0200     CLR W4
00424E  88C474     MOV W4, high_voltage_fault_mask
770:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_READY;
004250  EB0200     CLR W4
004252  88C494     MOV W4, control_board_fault_mask
771:                
772:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_READY;
004254  EB0200     CLR W4
004256  88C4A4     MOV W4, magnetron_warning_mask
773:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_READY;
004258  EB0200     CLR W4
00425A  88C4C4     MOV W4, thyratron_warning_mask
774:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_READY;
00425C  EB0200     CLR W4
00425E  88C4B4     MOV W4, high_voltage_warning_mask
775:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_READY;
004260  EB0200     CLR W4
004262  88C4D4     MOV W4, control_board_warning_mask
776:                   break;
004264  370033     BRA 0x42CC
777:               
778:               
779:                 case STATE_HV_ON:
780:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_HV_ON;
004266  2003F4     MOV #0x3F, W4
004268  88C464     MOV W4, magnetron_fault_mask
781:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_HV_ON;
00426A  EB0200     CLR W4
00426C  88C484     MOV W4, thyratron_fault_mask
782:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_HV_ON;
00426E  201064     MOV #0x106, W4
004270  88C474     MOV W4, high_voltage_fault_mask
783:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_HV_ON;
004272  200014     MOV #0x1, W4
004274  88C494     MOV W4, control_board_fault_mask
784:                
785:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_HV_ON;
004276  EB0200     CLR W4
004278  88C4A4     MOV W4, magnetron_warning_mask
786:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_HV_ON;
00427A  EB0200     CLR W4
00427C  88C4C4     MOV W4, thyratron_warning_mask
787:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_HV_ON;
00427E  EB0200     CLR W4
004280  88C4B4     MOV W4, high_voltage_warning_mask
788:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_HV_ON;
004282  EB0200     CLR W4
004284  88C4D4     MOV W4, control_board_warning_mask
789:                   break;
004286  370022     BRA 0x42CC
790:               
791:                 case STATE_FAULT_WARM_FAULT:
792:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_WARM_FAULT;
004288  202004     MOV #0x200, W4
00428A  88C464     MOV W4, magnetron_fault_mask
793:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_WARM_FAULT;
00428C  EB0200     CLR W4
00428E  88C484     MOV W4, thyratron_fault_mask
794:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_WARM_FAULT;
004290  EB0200     CLR W4
004292  88C474     MOV W4, high_voltage_fault_mask
795:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_WARM_FAULT;
004294  EB0200     CLR W4
004296  88C494     MOV W4, control_board_fault_mask
796:                
797:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_WARM_FAULT;
004298  EB0200     CLR W4
00429A  88C4A4     MOV W4, magnetron_warning_mask
798:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_WARM_FAULT;
00429C  EB0200     CLR W4
00429E  88C4C4     MOV W4, thyratron_warning_mask
799:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_WARM_FAULT;
0042A0  EB0200     CLR W4
0042A2  88C4B4     MOV W4, high_voltage_warning_mask
800:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_WARM_FAULT;
0042A4  EB0200     CLR W4
0042A6  88C4D4     MOV W4, control_board_warning_mask
801:                   break;
0042A8  370011     BRA 0x42CC
802:                   
803:                 case STATE_FAULT_COLD_FAULT:
804:                   magnetron_fault_mask = FAULT_MASK_MAGNETRON_STATE_COLD_FAULT;
0042AA  EB0200     CLR W4
0042AC  88C464     MOV W4, magnetron_fault_mask
805:                   thyratron_fault_mask = FAULT_MASK_THYRATRON_STATE_COLD_FAULT;
0042AE  EB0200     CLR W4
0042B0  88C484     MOV W4, thyratron_fault_mask
806:                   high_voltage_fault_mask = FAULT_MASK_HIGH_VOLTAGE_STATE_COLD_FAULT;
0042B2  EB0200     CLR W4
0042B4  88C474     MOV W4, high_voltage_fault_mask
807:                   control_board_fault_mask = FAULT_MASK_CONTROL_BOARD_STATE_COLD_FAULT;
0042B6  EB0200     CLR W4
0042B8  88C494     MOV W4, control_board_fault_mask
808:                
809:                   magnetron_warning_mask = WARNING_MASK_MAGNETRON_STATE_COLD_FAULT;
0042BA  EB0200     CLR W4
0042BC  88C4A4     MOV W4, magnetron_warning_mask
810:                   thyratron_warning_mask = WARNING_MASK_THYRATRON_STATE_COLD_FAULT;
0042BE  EB0200     CLR W4
0042C0  88C4C4     MOV W4, thyratron_warning_mask
811:                   high_voltage_warning_mask = WARNING_MASK_HIGH_VOLTAGE_STATE_COLD_FAULT;
0042C2  EB0200     CLR W4
0042C4  88C4B4     MOV W4, high_voltage_warning_mask
812:                   control_board_warning_mask = WARNING_MASK_CONTROL_BOARD_STATE_COLD_FAULT;
0042C6  EB0200     CLR W4
0042C8  88C4D4     MOV W4, control_board_warning_mask
813:                   break;
0042CA  000000     NOP
814:                 }
815:               }
0042CC  FA8000     ULNK
0042CE  060000     RETURN
816:               
817:               
818:               
819:               void RecordThisMagnetronFault(unsigned int fault_bit) {  
0042D0  FA0002     LNK #0x2
0042D2  780F00     MOV W0, [W14]
820:               
821:                 faults_magnetron_status_reg |= fault_bit;
0042D4  80C3A4     MOV faults_magnetron_status_reg, W4
0042D6  72021E     IOR W4, [W14], W4
0042D8  88C3A4     MOV W4, faults_magnetron_status_reg
822:               
823:                 if (fault_bit & magnetron_warning_mask) {
0042DA  80C4A4     MOV magnetron_warning_mask, W4
0042DC  62021E     AND W4, [W14], W4
0042DE  520FE0     SUB W4, #0x0, [W15]
0042E0  320003     BRA Z, 0x42E8
824:                   faults_magnetron_warning_reg |= fault_bit;
0042E2  80C3C4     MOV faults_magnetron_warning_reg, W4
0042E4  72021E     IOR W4, [W14], W4
0042E6  88C3C4     MOV W4, faults_magnetron_warning_reg
825:                 }
826:               
827:                 if (fault_bit & magnetron_fault_mask) {
0042E8  80C464     MOV magnetron_fault_mask, W4
0042EA  62021E     AND W4, [W14], W4
0042EC  520FE0     SUB W4, #0x0, [W15]
0042EE  32000A     BRA Z, 0x4304
828:                   if (!(faults_magnetron_fault_reg & fault_bit)) {
0042F0  80C3B4     MOV faults_magnetron_fault_reg, W4
0042F2  62021E     AND W4, [W14], W4
0042F4  520FE0     SUB W4, #0x0, [W15]
0042F6  3A0006     BRA NZ, 0x4304
829:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
830:                     // Set the coresponding bit and save the fault
831:                     faults_magnetron_fault_reg |= fault_bit;
0042F8  80C3B4     MOV faults_magnetron_fault_reg, W4
0042FA  72021E     IOR W4, [W14], W4
0042FC  88C3B4     MOV W4, faults_magnetron_fault_reg
832:                     WriteToEventLog(MAGNETRON_FAULT,fault_bit);
0042FE  78009E     MOV [W14], W1
004300  EB4000     CLR.B W0
004302  070056     RCALL WriteToEventLog
833:                   }
834:                 }
835:               }
004304  FA8000     ULNK
004306  060000     RETURN
836:               
837:               
838:               
839:               void RecordThisHighVoltageFault(unsigned int fault_bit) {
004308  FA0002     LNK #0x2
00430A  780F00     MOV W0, [W14]
840:               
841:                 faults_high_voltage_status_reg |= fault_bit;
00430C  80C3D4     MOV faults_high_voltage_status_reg, W4
00430E  72021E     IOR W4, [W14], W4
004310  88C3D4     MOV W4, faults_high_voltage_status_reg
842:               
843:                 if (fault_bit & high_voltage_warning_mask) {
004312  80C4B4     MOV high_voltage_warning_mask, W4
004314  62021E     AND W4, [W14], W4
004316  520FE0     SUB W4, #0x0, [W15]
004318  320003     BRA Z, 0x4320
844:                   faults_high_voltage_warning_reg |= fault_bit;
00431A  80C3F4     MOV faults_high_voltage_warning_reg, W4
00431C  72021E     IOR W4, [W14], W4
00431E  88C3F4     MOV W4, faults_high_voltage_warning_reg
845:                 }
846:               
847:                 if (fault_bit & high_voltage_fault_mask) {
004320  80C474     MOV high_voltage_fault_mask, W4
004322  62021E     AND W4, [W14], W4
004324  520FE0     SUB W4, #0x0, [W15]
004326  32000A     BRA Z, 0x433C
848:                   if (!(faults_high_voltage_fault_reg & fault_bit)) {
004328  80C3E4     MOV faults_high_voltage_fault_reg, W4
00432A  62021E     AND W4, [W14], W4
00432C  520FE0     SUB W4, #0x0, [W15]
00432E  3A0006     BRA NZ, 0x433C
849:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
850:                     // Set the coresponding bit and save the fault
851:                     faults_high_voltage_fault_reg |= fault_bit;
004330  80C3E4     MOV faults_high_voltage_fault_reg, W4
004332  72021E     IOR W4, [W14], W4
004334  88C3E4     MOV W4, faults_high_voltage_fault_reg
852:                     WriteToEventLog(HIGH_VOLTAGE_FAULT,fault_bit);
004336  78009E     MOV [W14], W1
004338  B3C010     MOV.B #0x1, W0
00433A  07003A     RCALL WriteToEventLog
853:                   }
854:                 }
855:               }
00433C  FA8000     ULNK
00433E  060000     RETURN
856:               
857:               void RecordThisThyratronFault(unsigned int fault_bit) {
004340  FA0002     LNK #0x2
004342  780F00     MOV W0, [W14]
858:                 
859:                 faults_thyratron_status_reg |= fault_bit;
004344  80C404     MOV faults_thyratron_status_reg, W4
004346  72021E     IOR W4, [W14], W4
004348  88C404     MOV W4, faults_thyratron_status_reg
860:                 
861:                 if (fault_bit & thyratron_warning_mask) {
00434A  80C4C4     MOV thyratron_warning_mask, W4
00434C  62021E     AND W4, [W14], W4
00434E  520FE0     SUB W4, #0x0, [W15]
004350  320003     BRA Z, 0x4358
862:                   faults_thyratron_warning_reg |= fault_bit;
004352  80C424     MOV faults_thyratron_warning_reg, W4
004354  72021E     IOR W4, [W14], W4
004356  88C424     MOV W4, faults_thyratron_warning_reg
863:                 }
864:               
865:                 if (fault_bit & thyratron_fault_mask) {
004358  80C484     MOV thyratron_fault_mask, W4
00435A  62021E     AND W4, [W14], W4
00435C  520FE0     SUB W4, #0x0, [W15]
00435E  32000A     BRA Z, 0x4374
866:                   if (!(faults_thyratron_fault_reg & fault_bit)) {
004360  80C414     MOV faults_thyratron_fault_reg, W4
004362  62021E     AND W4, [W14], W4
004364  520FE0     SUB W4, #0x0, [W15]
004366  3A0006     BRA NZ, 0x4374
867:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
868:                     // Set the coresponding bit and save the fault
869:                     faults_thyratron_fault_reg |= fault_bit;
004368  80C414     MOV faults_thyratron_fault_reg, W4
00436A  72021E     IOR W4, [W14], W4
00436C  88C414     MOV W4, faults_thyratron_fault_reg
870:                     WriteToEventLog(THYRATRON_FAULT,fault_bit);
00436E  78009E     MOV [W14], W1
004370  B3C020     MOV.B #0x2, W0
004372  07001E     RCALL WriteToEventLog
871:                   }
872:                 }
873:               }
004374  FA8000     ULNK
004376  060000     RETURN
874:               
875:               
876:               void RecordThisControlBoardFault(unsigned int fault_bit) { 
004378  FA0002     LNK #0x2
00437A  780F00     MOV W0, [W14]
877:               
878:                 faults_control_board_status_reg |= fault_bit;
00437C  80C434     MOV faults_control_board_status_reg, W4
00437E  72021E     IOR W4, [W14], W4
004380  88C434     MOV W4, faults_control_board_status_reg
879:               
880:                 if (fault_bit & control_board_warning_mask) {
004382  80C4D4     MOV control_board_warning_mask, W4
004384  62021E     AND W4, [W14], W4
004386  520FE0     SUB W4, #0x0, [W15]
004388  320003     BRA Z, 0x4390
881:                   faults_control_board_warning_reg |= fault_bit;
00438A  80C454     MOV faults_control_board_warning_reg, W4
00438C  72021E     IOR W4, [W14], W4
00438E  88C454     MOV W4, faults_control_board_warning_reg
882:                 }
883:               
884:                 if (fault_bit & control_board_fault_mask) {
004390  80C494     MOV control_board_fault_mask, W4
004392  62021E     AND W4, [W14], W4
004394  520FE0     SUB W4, #0x0, [W15]
004396  32000A     BRA Z, 0x43AC
885:                   if (!(faults_control_board_fault_reg & fault_bit)) {
004398  80C444     MOV faults_control_board_fault_reg, W4
00439A  62021E     AND W4, [W14], W4
00439C  520FE0     SUB W4, #0x0, [W15]
00439E  3A0006     BRA NZ, 0x43AC
886:                     // This fault has NOT YET BEEN SET in the fault register so it is a NEW Fault
887:                     // Set the coresponding bit and save the fault
888:                     faults_control_board_fault_reg |= fault_bit;
0043A0  80C444     MOV faults_control_board_fault_reg, W4
0043A2  72021E     IOR W4, [W14], W4
0043A4  88C444     MOV W4, faults_control_board_fault_reg
889:                     WriteToEventLog(CONTROL_BOARD_FAULT,fault_bit);
0043A6  78009E     MOV [W14], W1
0043A8  B3C030     MOV.B #0x3, W0
0043AA  070002     RCALL WriteToEventLog
890:                   }
891:                 }
892:               }
0043AC  FA8000     ULNK
0043AE  060000     RETURN
893:               
894:               
895:               void WriteToEventLog(unsigned char fault_register, unsigned int fault_bit) {
0043B0  FA0004     LNK #0x4
0043B2  784F00     MOV.B W0, [W14]
0043B4  980711     MOV W1, [W14+2]
896:                 // DPARKER this function should write to the event log in ram and update the fault counter in RAM
897:                 // These values are moved to EEPROM later on  . . . like programmed later on
898:               }
0043B6  FA8000     ULNK
0043B8  060000     RETURN
899:               
900:               
901:               unsigned int CheckStartupFailed(void) {
0043BA  FA0000     LNK #0x0
902:                 return 0;
0043BC  EB0200     CLR W4
903:               }
0043BE  780004     MOV W4, W0
0043C0  FA8000     ULNK
0043C2  060000     RETURN
904:               
905:               unsigned int CheckFaultActive(void) {
0043C4  FA0000     LNK #0x0
906:                 return (faults_control_board_fault_reg | faults_thyratron_fault_reg | faults_magnetron_fault_reg | faults_high_voltage_fault_reg);
0043C6  80C445     MOV faults_control_board_fault_reg, W5
0043C8  80C414     MOV faults_thyratron_fault_reg, W4
0043CA  728284     IOR W5, W4, W5
0043CC  80C3B4     MOV faults_magnetron_fault_reg, W4
0043CE  728284     IOR W5, W4, W5
0043D0  80C3E4     MOV faults_high_voltage_fault_reg, W4
0043D2  728204     IOR W5, W4, W4
907:               }
0043D4  780004     MOV W4, W0
0043D6  FA8000     ULNK
0043D8  060000     RETURN
908:               
909:               
910:               unsigned int CheckColdFaultActive(void) {
0043DA  FA0002     LNK #0x2
911:                 unsigned int temp;
912:                 temp = (faults_control_board_fault_reg & MASK_CONTROL_BOARD_COLD_FAULTS);
0043DC  EB0200     CLR W4
0043DE  780F04     MOV W4, [W14]
913:                 temp |= (faults_thyratron_fault_reg & MASK_THYRATRON_COLD_FAULTS);
914:                 temp |= (faults_magnetron_fault_reg & MASK_MAGNETRON_COLD_FAULTS);
0043E0  80C3B5     MOV faults_magnetron_fault_reg, W5
0043E2  202034     MOV #0x203, W4
0043E4  628204     AND W5, W4, W4
0043E6  720F1E     IOR W4, [W14], [W14]
915:                 temp |= (faults_high_voltage_fault_reg & MASK_HIGH_VOLTAGE_COLD_FAULTS);
916:                 return temp;
0043E8  78021E     MOV [W14], W4
917:               }
0043EA  780004     MOV W4, W0
0043EC  FA8000     ULNK
0043EE  060000     RETURN
918:               
919:               
920:               
921:               unsigned char CheckOverVoltFault(POWERSUPPLY* ptr) {
0043F0  FA0002     LNK #0x2
0043F2  780F00     MOV W0, [W14]
922:                 if (ptr->v_adc_reading > ptr->v_adc_over_rel) {
0043F4  78021E     MOV [W14], W4
0043F6  900A84     MOV [W4+16], W5
0043F8  78021E     MOV [W14], W4
0043FA  900A54     MOV [W4+26], W4
0043FC  528F84     SUB W5, W4, [W15]
0043FE  360012     BRA LEU, 0x4424
923:                   ptr->v_adc_over_count++;
004400  78021E     MOV [W14], W4
004402  901234     MOV [W4+38], W4
004404  E80284     INC W4, W5
004406  78021E     MOV [W14], W4
004408  981235     MOV W5, [W4+38]
924:                   if (ptr->v_adc_over_count > ptr->v_adc_max_oor) {
00440A  78021E     MOV [W14], W4
00440C  9012B4     MOV [W4+38], W5
00440E  78021E     MOV [W14], W4
004410  901224     MOV [W4+36], W4
004412  528F84     SUB W5, W4, [W15]
004414  360010     BRA LEU, 0x4436
925:                     ptr->v_adc_over_count = ptr->v_adc_max_oor + 10;
004416  78021E     MOV [W14], W4
004418  901224     MOV [W4+36], W4
00441A  4202EA     ADD W4, #0xA, W5
00441C  78021E     MOV [W14], W4
00441E  981235     MOV W5, [W4+38]
926:                     return 1;
004420  B3C014     MOV.B #0x1, W4
004422  37000A     BRA 0x4438
927:                   }
928:                 } else if (ptr->v_adc_over_count >= 1) {
004424  78021E     MOV [W14], W4
004426  901234     MOV [W4+38], W4
004428  520FE0     SUB W4, #0x0, [W15]
00442A  320005     BRA Z, 0x4436
929:                   ptr->v_adc_over_count--;
00442C  78021E     MOV [W14], W4
00442E  901234     MOV [W4+38], W4
004430  E90284     DEC W4, W5
004432  78021E     MOV [W14], W4
004434  981235     MOV W5, [W4+38]
930:                 }
931:                 return 0;
004436  EB4200     CLR.B W4
932:               }
004438  784004     MOV.B W4, W0
00443A  FA8000     ULNK
00443C  060000     RETURN
933:               
934:               unsigned char CheckUnderVoltFault(POWERSUPPLY* ptr) {
00443E  FA0004     LNK #0x4
004440  980710     MOV W0, [W14+2]
935:                 unsigned int mod_v_adc_reading;
936:               
937:                 mod_v_adc_reading = ptr->v_adc_reading;
004442  90021E     MOV [W14+2], W4
004444  900A84     MOV [W4+16], W5
004446  780F05     MOV W5, [W14]
938:                 if (mod_v_adc_reading < 0x0100) {
004448  200FF4     MOV #0xFF, W4
00444A  78029E     MOV [W14], W5
00444C  528F84     SUB W5, W4, [W15]
00444E  3E0002     BRA GTU, 0x4454
939:                   mod_v_adc_reading = 0x0100; // DPARKER add parameter
004450  201004     MOV #0x100, W4
004452  780F04     MOV W4, [W14]
940:                 }
941:                 if (mod_v_adc_reading < ptr->v_adc_under_rel) {
004454  90021E     MOV [W14+2], W4
004456  900A64     MOV [W4+28], W4
004458  520F9E     SUB W4, [W14], [W15]
00445A  360012     BRA LEU, 0x4480
942:                   ptr->v_adc_under_count++;
00445C  90021E     MOV [W14+2], W4
00445E  901244     MOV [W4+40], W4
004460  E80284     INC W4, W5
004462  90021E     MOV [W14+2], W4
004464  981245     MOV W5, [W4+40]
943:                   if (ptr->v_adc_under_count > ptr->v_adc_max_oor) {
004466  90021E     MOV [W14+2], W4
004468  9012C4     MOV [W4+40], W5
00446A  90021E     MOV [W14+2], W4
00446C  901224     MOV [W4+36], W4
00446E  528F84     SUB W5, W4, [W15]
004470  360010     BRA LEU, 0x4492
944:                     ptr->v_adc_under_count = ptr->v_adc_max_oor + 10;
004472  90021E     MOV [W14+2], W4
004474  901224     MOV [W4+36], W4
004476  4202EA     ADD W4, #0xA, W5
004478  90021E     MOV [W14+2], W4
00447A  981245     MOV W5, [W4+40]
945:                     return 1;
00447C  B3C014     MOV.B #0x1, W4
00447E  37000A     BRA 0x4494
946:                   }
947:                 } else if (ptr->v_adc_under_count >= 1) {
004480  90021E     MOV [W14+2], W4
004482  901244     MOV [W4+40], W4
004484  520FE0     SUB W4, #0x0, [W15]
004486  320005     BRA Z, 0x4492
948:                   ptr->v_adc_under_count--;
004488  90021E     MOV [W14+2], W4
00448A  901244     MOV [W4+40], W4
00448C  E90284     DEC W4, W5
00448E  90021E     MOV [W14+2], W4
004490  981245     MOV W5, [W4+40]
949:                 }
950:                 return 0;
004492  EB4200     CLR.B W4
951:               }
004494  784004     MOV.B W4, W0
004496  FA8000     ULNK
004498  060000     RETURN
952:               
953:               
954:               unsigned char CheckOverCurrentFault(POWERSUPPLY* ptr) {
00449A  FA0002     LNK #0x2
00449C  780F00     MOV W0, [W14]
955:                 if (ptr->i_adc_reading > ptr->i_adc_over_rel) {
00449E  78021E     MOV [W14], W4
0044A0  901AE4     MOV [W4+60], W5
0044A2  78021E     MOV [W14], W4
0044A4  902234     MOV [W4+70], W4
0044A6  528F84     SUB W5, W4, [W15]
0044A8  360012     BRA LEU, 0x44CE
956:                   ptr->i_adc_over_count++;
0044AA  78021E     MOV [W14], W4
0044AC  902A14     MOV [W4+82], W4
0044AE  E80284     INC W4, W5
0044B0  78021E     MOV [W14], W4
0044B2  982A15     MOV W5, [W4+82]
957:                   if (ptr->i_adc_over_count > ptr->i_adc_max_oor) {
0044B4  78021E     MOV [W14], W4
0044B6  902A94     MOV [W4+82], W5
0044B8  78021E     MOV [W14], W4
0044BA  902A04     MOV [W4+80], W4
0044BC  528F84     SUB W5, W4, [W15]
0044BE  360010     BRA LEU, 0x44E0
958:                     ptr->i_adc_over_count = ptr->i_adc_max_oor + 10;
0044C0  78021E     MOV [W14], W4
0044C2  902A04     MOV [W4+80], W4
0044C4  4202EA     ADD W4, #0xA, W5
0044C6  78021E     MOV [W14], W4
0044C8  982A15     MOV W5, [W4+82]
959:                     return 1; 
0044CA  B3C014     MOV.B #0x1, W4
0044CC  37000A     BRA 0x44E2
960:                   }
961:                 } else if (ptr->i_adc_over_count >= 1) {
0044CE  78021E     MOV [W14], W4
0044D0  902A14     MOV [W4+82], W4
0044D2  520FE0     SUB W4, #0x0, [W15]
0044D4  320005     BRA Z, 0x44E0
962:                   ptr->i_adc_over_count--;
0044D6  78021E     MOV [W14], W4
0044D8  902A14     MOV [W4+82], W4
0044DA  E90284     DEC W4, W5
0044DC  78021E     MOV [W14], W4
0044DE  982A15     MOV W5, [W4+82]
963:                 }
964:                 return 0;
0044E0  EB4200     CLR.B W4
965:               }
0044E2  784004     MOV.B W4, W0
0044E4  FA8000     ULNK
0044E6  060000     RETURN
966:               
967:               unsigned char CheckUnderCurrentFault(POWERSUPPLY* ptr) {
0044E8  FA0004     LNK #0x4
0044EA  980710     MOV W0, [W14+2]
968:                 unsigned int mod_i_adc_reading;
969:               
970:                 mod_i_adc_reading = ptr->i_adc_reading;
0044EC  90021E     MOV [W14+2], W4
0044EE  901AE4     MOV [W4+60], W5
0044F0  780F05     MOV W5, [W14]
971:                 if (mod_i_adc_reading < 0x0100) {
0044F2  200FF4     MOV #0xFF, W4
0044F4  78029E     MOV [W14], W5
0044F6  528F84     SUB W5, W4, [W15]
0044F8  3E0002     BRA GTU, 0x44FE
972:                   mod_i_adc_reading = 0x0100;  // DPARKER add parameter
0044FA  201004     MOV #0x100, W4
0044FC  780F04     MOV W4, [W14]
973:                 }
974:                 if (mod_i_adc_reading < ptr->i_adc_under_rel) {
0044FE  90021E     MOV [W14+2], W4
004500  902244     MOV [W4+72], W4
004502  520F9E     SUB W4, [W14], [W15]
004504  360012     BRA LEU, 0x452A
975:                   ptr->i_adc_under_count++;
004506  90021E     MOV [W14+2], W4
004508  902A24     MOV [W4+84], W4
00450A  E80284     INC W4, W5
00450C  90021E     MOV [W14+2], W4
00450E  982A25     MOV W5, [W4+84]
976:                   if (ptr->i_adc_under_count > ptr->i_adc_max_oor) {
004510  90021E     MOV [W14+2], W4
004512  902AA4     MOV [W4+84], W5
004514  90021E     MOV [W14+2], W4
004516  902A04     MOV [W4+80], W4
004518  528F84     SUB W5, W4, [W15]
00451A  360010     BRA LEU, 0x453C
977:                     ptr->i_adc_under_count = ptr->i_adc_max_oor + 10;
00451C  90021E     MOV [W14+2], W4
00451E  902A04     MOV [W4+80], W4
004520  4202EA     ADD W4, #0xA, W5
004522  90021E     MOV [W14+2], W4
004524  982A25     MOV W5, [W4+84]
978:                     return 1;
004526  B3C014     MOV.B #0x1, W4
004528  37000A     BRA 0x453E
979:                   }
980:                 } else if (ptr->i_adc_under_count >= 1) {
00452A  90021E     MOV [W14+2], W4
00452C  902A24     MOV [W4+84], W4
00452E  520FE0     SUB W4, #0x0, [W15]
004530  320005     BRA Z, 0x453C
981:                   ptr->i_adc_under_count--;
004532  90021E     MOV [W14+2], W4
004534  902A24     MOV [W4+84], W4
004536  E90284     DEC W4, W5
004538  90021E     MOV [W14+2], W4
00453A  982A25     MOV W5, [W4+84]
982:                 }
983:                 return 0;
00453C  EB4200     CLR.B W4
984:               }
00453E  784004     MOV.B W4, W0
004540  FA8000     ULNK
004542  060000     RETURN
985:               
986:               
987:               
---  C:/Users/dparker/Documents/GitHub/A36760/Serial.c  -------------------------------------------------
1:                 #include "Serial.h"
2:                 #include "A34760_PINS.h"
3:                 #include "Buffer64.h"
4:                 #include "A34760.h"
5:                 #include "config.h"
6:                 #include "faults.h"
7:                 #include "Version.h"
8:                 #include <libpic30.h>
9:                 
10:                /*
11:                  Serial Commands
12:                
13:                  A single command is stored in command_string
14:                  If there is a valid command stored in command_string, then the command_string.data_state = COMMAND_BUFFER_FULL
15:                  If there is NOT a volid command stored in command_string, then command_string.data_state = COMMAND_BUFFER_EMPTY
16:                  
17:                  
18:                  When a byte is received on the UART it is transfered to the "uart1_input_buffer" by the UART receive interrupt - the input buffer is a circular buffer that is 64 Bytes deep
19:                  (see buffer64.h for more infor on the buffer)
20:                  
21:                  Every time through the command loop (200us to 1ms) DoSerialCommand() will be called
22:                  If the command_string is empty, then the input buffer is searched for a valid command (the oldest valid command will be moved to command_string)
23:                
24:                  If a command was found OR the command_string was already full, then the command is executed.
25:                
26:                  Assume an average execution cycle of 1mS and 9 bytes per command.  A command rate of 72 K Baund can be sustained. (57.6 K Baud Standard will work)
27:                  
28:                  Assume an average execution cycle of 500uS and 9 bytes per command, A command rate of 144 K Baud can be sustained (115.2 K Baud Standard should be safe) 
29:                
30:                */
31:                
32:                void LookForCommand(void);
33:                void ExecuteCommand(void);
34:                unsigned char CheckCRC(unsigned int crc);
35:                unsigned int MakeCRC(unsigned char command_byte, unsigned char register_byte, unsigned int data_word);
36:                unsigned int ReadFromRam(unsigned int ram_location);
37:                void SendCommand(unsigned char command_byte, unsigned char register_byte, unsigned int data_word);
38:                
39:                unsigned int GenerateFilamentIprog(unsigned int vprog);
40:                unsigned int GenerateFilamentVprog(unsigned int iprog);
41:                unsigned int GenerateLambdaIprog(unsigned int vprog);
42:                
43:                unsigned int GenerateMagnetronVprog(unsigned int iprog);
44:                
45:                struct CommandStringStruct command_string;
46:                
47:                unsigned char data_logging_to_uart;
48:                
49:                unsigned int ReturnPowerSupplyADCScaledVoltage(POWERSUPPLY* ptr, unsigned int value);
50:                unsigned int ReturnPowerSupplyADCScaledCurrent(POWERSUPPLY* ptr, unsigned int value);
51:                
52:                
53:                unsigned int ReverseScale16Bit(unsigned int value, unsigned int scale);
54:                
55:                
56:                void DoSerialCommand(void) {
0029EC  FA0000     LNK #0x0
57:                  /* 
58:                     Look for a command and execute it.
59:                  */
60:                  if (_OERR) {
0029EE  801074     MOV U1STA, W4
0029F0  620262     AND W4, #0x2, W4
0029F2  520FE0     SUB W4, #0x0, [W15]
0029F4  320001     BRA Z, 0x29F8
61:                    _OERR = 0;
0029F6  A9220E     BCLR U1STA, #1
62:                  }
63:                
64:                  if (command_string.data_state != COMMAND_BUFFER_FULL) {
0029F8  218C84     MOV #0x18C8, W4
0029FA  784214     MOV.B [W4], W4
0029FC  524FE2     SUB.B W4, #0x2, [W15]
0029FE  320001     BRA Z, 0x2A02
65:                    LookForCommand();
002A00  070007     RCALL LookForCommand
66:                  }
67:                  if (command_string.data_state == COMMAND_BUFFER_FULL) {
002A02  218C84     MOV #0x18C8, W4
002A04  784214     MOV.B [W4], W4
002A06  524FE2     SUB.B W4, #0x2, [W15]
002A08  3A0001     BRA NZ, 0x2A0C
68:                    ExecuteCommand();
002A0A  070101     RCALL ExecuteCommand
69:                  }
70:                }
002A0C  FA8000     ULNK
002A0E  060000     RETURN
71:                
72:                
73:                
74:                void LookForCommand(void) {
002A10  FA0004     LNK #0x4
002A12  781F88     MOV W8, [W15++]
75:                  unsigned char read_byte;
76:                  unsigned int crc;
77:                  /*
78:                    If the state is "waitng for command" then it looks for a command in the buffer, if the state is "executing command" it does nothing
79:                    
80:                    To look for a command in the buffer.
81:                    1) See if there are enough bytes in the buffer to contain a command.
82:                    2) If there are look for command sync
83:                       2b) If there are less bytes in the buffer than it takes to make a command, exit
84:                    3) If command Syncs, check the checksum ^ increment the read_position as each byte is read
85:                       3b) If command does not sync, increment the the read positon and return to step 1    
86:                    4) If the checksum checks out, move the command data into the command data structure
87:                    4b) If the checksum fails, return to step 1     
88:                  */
89:                  
90:                  while ((command_string.data_state == COMMAND_BUFFER_EMPTY) && (Buffer64BytesInBuffer(&uart1_input_buffer) >= COMMAND_LENGTH)) {
002A14  37003E     BRA 0x2A92
002A92  218C84     MOV #0x18C8, W4
002A94  784214     MOV.B [W4], W4
002A96  524FE0     SUB.B W4, #0x0, [W15]
002A98  3A0005     BRA NZ, 0x2AA4
002A9A  2086C0     MOV #0x86C, W0
002A9C  07130B     RCALL Buffer64BytesInBuffer
002A9E  784200     MOV.B W0, W4
002AA0  524FE8     SUB.B W4, #0x8, [W15]
002AA2  3EFFB9     BRA GTU, 0x2A16
91:                    // Look for a command
92:                    read_byte = Buffer64ReadByte(&uart1_input_buffer);
002A16  2086C0     MOV #0x86C, W0
002A18  07132F     RCALL Buffer64ReadByte
002A1A  784200     MOV.B W0, W4
002A1C  784F04     MOV.B W4, [W14]
93:                    if (read_byte == SYNC_BYTE_1) {
002A1E  78421E     MOV.B [W14], W4
002A20  424FEF     ADD.B W4, #0xF, [W15]
002A22  3A0037     BRA NZ, 0x2A92
94:                      read_byte = Buffer64ReadByte(&uart1_input_buffer);
002A24  2086C0     MOV #0x86C, W0
002A26  071328     RCALL Buffer64ReadByte
002A28  784200     MOV.B W0, W4
002A2A  784F04     MOV.B W4, [W14]
95:                      if (read_byte == SYNC_BYTE_2) {
002A2C  78421E     MOV.B [W14], W4
002A2E  424FEE     ADD.B W4, #0xE, [W15]
002A30  3A0030     BRA NZ, 0x2A92
96:                	read_byte = Buffer64ReadByte(&uart1_input_buffer);
002A32  2086C0     MOV #0x86C, W0
002A34  071321     RCALL Buffer64ReadByte
002A36  784200     MOV.B W0, W4
002A38  784F04     MOV.B W4, [W14]
97:                	if (read_byte == SYNC_BYTE_3_RECEIVE) {
002A3A  78421E     MOV.B [W14], W4
002A3C  424FED     ADD.B W4, #0xD, [W15]
002A3E  3A0029     BRA NZ, 0x2A92
98:                	  // All of the sync bytes matched, this should be a valid command
99:                	  command_string.command_byte   = Buffer64ReadByte(&uart1_input_buffer);
002A40  2086C0     MOV #0x86C, W0
002A42  07131A     RCALL Buffer64ReadByte
002A44  784200     MOV.B W0, W4
002A46  784004     MOV.B W4, W0
002A48  B7F8C4     MOV.B WREG, command_string
100:               	  command_string.data_high_byte = Buffer64ReadByte(&uart1_input_buffer);
002A4A  2086C0     MOV #0x86C, W0
002A4C  071315     RCALL Buffer64ReadByte
002A4E  784200     MOV.B W0, W4
002A50  784004     MOV.B W4, W0
002A52  B7F8C6     MOV.B WREG, 0x18C6
101:               	  command_string.data_low_byte  = Buffer64ReadByte(&uart1_input_buffer);
002A54  2086C0     MOV #0x86C, W0
002A56  071310     RCALL Buffer64ReadByte
002A58  784200     MOV.B W0, W4
002A5A  784004     MOV.B W4, W0
002A5C  B7F8C7     MOV.B WREG, 0x18C7
102:               	  command_string.register_byte  = Buffer64ReadByte(&uart1_input_buffer);
002A5E  2086C0     MOV #0x86C, W0
002A60  07130B     RCALL Buffer64ReadByte
002A62  784200     MOV.B W0, W4
002A64  784004     MOV.B W4, W0
002A66  B7F8C5     MOV.B WREG, 0x18C5
103:               	  crc                           = Buffer64ReadByte(&uart1_input_buffer);
002A68  2086C0     MOV #0x86C, W0
002A6A  071306     RCALL Buffer64ReadByte
002A6C  784200     MOV.B W0, W4
002A6E  FB8204     ZE W4, W4
002A70  980714     MOV W4, [W14+2]
104:               	  crc                           = (crc << 8) + Buffer64ReadByte(&uart1_input_buffer);
002A72  90021E     MOV [W14+2], W4
002A74  DD2448     SL W4, #8, W8
002A76  2086C0     MOV #0x86C, W0
002A78  0712FF     RCALL Buffer64ReadByte
002A7A  784200     MOV.B W0, W4
002A7C  FB8204     ZE W4, W4
002A7E  440204     ADD W8, W4, W4
002A80  980714     MOV W4, [W14+2]
105:               	  if (CheckCRC(crc)) {
002A82  90001E     MOV [W14+2], W0
002A84  0707EF     RCALL CheckCRC
002A86  784200     MOV.B W0, W4
002A88  524FE0     SUB.B W4, #0x0, [W15]
002A8A  320003     BRA Z, 0x2A92
106:               	    command_string.data_state = COMMAND_BUFFER_FULL;
002A8C  B3C024     MOV.B #0x2, W4
002A8E  784004     MOV.B W4, W0
002A90  B7F8C8     MOV.B WREG, 0x18C8
107:               	  }
108:               	}
109:                     }
110:                   }
111:                 }
112:               }
002AA4  78044F     MOV [--W15], W8
002AA6  FA8000     ULNK
002AA8  060000     RETURN
113:               
114:               
115:               void SendLoggingDataToUart() {
002AAA  FA0000     LNK #0x0
116:                 /* 
117:                    Data that we need to log with each pulse
118:                    byte 0,1    = 0xFE, 0xF1 - used to sync message
119:                    byte 2,3    = low_energy_target_current_set_point_derived (low 16 bits)
120:                    byte 4,5    = linac_high_energy_target_current_adc_reading
121:                    byte 6,7    = linac_low_energy_target_current_adc_reading
122:                    byte 8,9    = linac_high_energy_program_offset
123:                    byte 10,11    = linac_low_energy_program_offset
124:                    
125:               
126:                    byte 12,13    = pulse_counter_this_run
127:                    byte 14,15   = pulse_magnetron_current_adc_reading
128:                    
129:                 */
130:               
131:                 if (data_logging_to_uart) {
002AAC  218C94     MOV #0x18C9, W4
002AAE  784214     MOV.B [W4], W4
002AB0  524FE0     SUB.B W4, #0x0, [W15]
002AB2  320067     BRA Z, 0x2B82
132:               
133:                   Buffer64WriteByte(&uart1_output_buffer, 0xFE);
002AB4  B3CFE1     MOV.B #0xFE, W1
002AB6  208AE0     MOV #0x8AE, W0
002AB8  0712BA     RCALL Buffer64WriteByte
134:                   Buffer64WriteByte(&uart1_output_buffer, 0xF1);
002ABA  B3CF11     MOV.B #0xF1, W1
002ABC  208AE0     MOV #0x8AE, W0
002ABE  0712B7     RCALL Buffer64WriteByte
135:               
136:                   Buffer64WriteByte(&uart1_output_buffer, (low_energy_target_current_set_point_derived >> 8));
002AC0  804074     MOV low_energy_target_current_set_point_derived, W4
002AC2  804085     MOV 0x810, W5
002AC4  DD2B48     SL W5, #8, W6
002AC6  DE2248     LSR W4, #8, W4
002AC8  730204     IOR W6, W4, W4
002ACA  DE2AC8     LSR W5, #8, W5
002ACC  784204     MOV.B W4, W4
002ACE  784084     MOV.B W4, W1
002AD0  208AE0     MOV #0x8AE, W0
002AD2  0712AD     RCALL Buffer64WriteByte
137:                   Buffer64WriteByte(&uart1_output_buffer, (low_energy_target_current_set_point_derived & 0xFF));
002AD4  804074     MOV low_energy_target_current_set_point_derived, W4
002AD6  804085     MOV 0x810, W5
002AD8  784204     MOV.B W4, W4
002ADA  784084     MOV.B W4, W1
002ADC  208AE0     MOV #0x8AE, W0
002ADE  0712A7     RCALL Buffer64WriteByte
138:               
139:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_target_current_adc_reading >> 8));
002AE0  8040D4     MOV linac_high_energy_target_current_adc_reading, W4
002AE2  DE2248     LSR W4, #8, W4
002AE4  784204     MOV.B W4, W4
002AE6  784084     MOV.B W4, W1
002AE8  208AE0     MOV #0x8AE, W0
002AEA  0712A1     RCALL Buffer64WriteByte
140:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_target_current_adc_reading & 0x00FF));
002AEC  8040D4     MOV linac_high_energy_target_current_adc_reading, W4
002AEE  784204     MOV.B W4, W4
002AF0  784084     MOV.B W4, W1
002AF2  208AE0     MOV #0x8AE, W0
002AF4  07129C     RCALL Buffer64WriteByte
141:               
142:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_target_current_adc_reading >> 8));
002AF6  8040F4     MOV linac_low_energy_target_current_adc_reading, W4
002AF8  DE2248     LSR W4, #8, W4
002AFA  784204     MOV.B W4, W4
002AFC  784084     MOV.B W4, W1
002AFE  208AE0     MOV #0x8AE, W0
002B00  071296     RCALL Buffer64WriteByte
143:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_target_current_adc_reading & 0x00FF));
002B02  8040F4     MOV linac_low_energy_target_current_adc_reading, W4
002B04  784204     MOV.B W4, W4
002B06  784084     MOV.B W4, W1
002B08  208AE0     MOV #0x8AE, W0
002B0A  071291     RCALL Buffer64WriteByte
144:               
145:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_program_offset >> 8));
002B0C  804134     MOV linac_high_energy_program_offset, W4
002B0E  DEA248     ASR W4, #8, W4
002B10  784204     MOV.B W4, W4
002B12  784084     MOV.B W4, W1
002B14  208AE0     MOV #0x8AE, W0
002B16  07128B     RCALL Buffer64WriteByte
146:                   Buffer64WriteByte(&uart1_output_buffer, (linac_high_energy_program_offset & 0x00FF));
002B18  804134     MOV linac_high_energy_program_offset, W4
002B1A  784204     MOV.B W4, W4
002B1C  784084     MOV.B W4, W1
002B1E  208AE0     MOV #0x8AE, W0
002B20  071286     RCALL Buffer64WriteByte
147:               
148:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_program_offset >> 8));
002B22  804144     MOV linac_low_energy_program_offset, W4
002B24  DEA248     ASR W4, #8, W4
002B26  784204     MOV.B W4, W4
002B28  784084     MOV.B W4, W1
002B2A  208AE0     MOV #0x8AE, W0
002B2C  071280     RCALL Buffer64WriteByte
149:                   Buffer64WriteByte(&uart1_output_buffer, (linac_low_energy_program_offset & 0x00FF));
002B2E  804144     MOV linac_low_energy_program_offset, W4
002B30  784204     MOV.B W4, W4
002B32  784084     MOV.B W4, W1
002B34  208AE0     MOV #0x8AE, W0
002B36  07127B     RCALL Buffer64WriteByte
150:               
151:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_counter_this_run >> 8));
002B38  804164     MOV pulse_counter_this_run, W4
002B3A  DE2248     LSR W4, #8, W4
002B3C  784204     MOV.B W4, W4
002B3E  784084     MOV.B W4, W1
002B40  208AE0     MOV #0x8AE, W0
002B42  071275     RCALL Buffer64WriteByte
152:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_counter_this_run & 0x00FF));
002B44  804164     MOV pulse_counter_this_run, W4
002B46  784204     MOV.B W4, W4
002B48  784084     MOV.B W4, W1
002B4A  208AE0     MOV #0x8AE, W0
002B4C  071270     RCALL Buffer64WriteByte
153:               
154:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_magnetron_current_adc_reading >> 8));
002B4E  8042A4     MOV pulse_magnetron_current_adc_reading, W4
002B50  DE2248     LSR W4, #8, W4
002B52  784204     MOV.B W4, W4
002B54  784084     MOV.B W4, W1
002B56  208AE0     MOV #0x8AE, W0
002B58  07126A     RCALL Buffer64WriteByte
155:                   Buffer64WriteByte(&uart1_output_buffer, (pulse_magnetron_current_adc_reading & 0x00FF));
002B5A  8042A4     MOV pulse_magnetron_current_adc_reading, W4
002B5C  784204     MOV.B W4, W4
002B5E  784084     MOV.B W4, W1
002B60  208AE0     MOV #0x8AE, W0
002B62  071265     RCALL Buffer64WriteByte
156:               
157:               
158:                   if ((!U1STAbits.UTXBF) && (Buffer64IsNotEmpty(&uart1_output_buffer))) {
002B64  801075     MOV U1STA, W5
002B66  202004     MOV #0x200, W4
002B68  628204     AND W5, W4, W4
002B6A  520FE0     SUB W4, #0x0, [W15]
002B6C  3A000A     BRA NZ, 0x2B82
002B6E  208AE0     MOV #0x8AE, W0
002B70  0712AC     RCALL Buffer64IsNotEmpty
002B72  784200     MOV.B W0, W4
002B74  524FE0     SUB.B W4, #0x0, [W15]
002B76  320005     BRA Z, 0x2B82
159:                     /*
160:               	There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
161:               	Move a byte from the output buffer into the transmit buffer
162:               	All subsequent bytes will be moved from the output buffer to the transmit buffer by the U1 TX Interrupt
163:                     */
164:                     U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
002B78  208AE0     MOV #0x8AE, W0
002B7A  07127E     RCALL Buffer64ReadByte
002B7C  784200     MOV.B W0, W4
002B7E  FB8204     ZE W4, W4
002B80  881084     MOV W4, U1TXREG
165:                   }
166:                 }
167:               }
002B82  FA8000     ULNK
002B84  060000     RETURN
168:               
169:               
170:               
171:               void SendCommand(unsigned char command_byte, unsigned char register_byte, unsigned int data_word) {
002B86  FA0006     LNK #0x6
002B88  984720     MOV.B W0, [W14+2]
002B8A  984731     MOV.B W1, [W14+3]
002B8C  980722     MOV W2, [W14+4]
172:                 unsigned int crc;
173:                 if (!data_logging_to_uart) {
002B8E  218C94     MOV #0x18C9, W4
002B90  784214     MOV.B [W4], W4
002B92  524FE0     SUB.B W4, #0x0, [W15]
002B94  3A003A     BRA NZ, 0x2C0A
174:                   crc = MakeCRC(command_byte, register_byte, data_word);
002B96  90012E     MOV [W14+4], W2
002B98  9040BE     MOV.B [W14+3], W1
002B9A  90402E     MOV.B [W14+2], W0
002B9C  07074C     RCALL MakeCRC
002B9E  780200     MOV W0, W4
002BA0  780F04     MOV W4, [W14]
175:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_1);
002BA2  B3CF11     MOV.B #0xF1, W1
002BA4  208AE0     MOV #0x8AE, W0
002BA6  071243     RCALL Buffer64WriteByte
176:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_2);
002BA8  B3CF21     MOV.B #0xF2, W1
002BAA  208AE0     MOV #0x8AE, W0
002BAC  071240     RCALL Buffer64WriteByte
177:                   Buffer64WriteByte(&uart1_output_buffer, SYNC_BYTE_3_SEND);
002BAE  B3CF41     MOV.B #0xF4, W1
002BB0  208AE0     MOV #0x8AE, W0
002BB2  07123D     RCALL Buffer64WriteByte
178:                   Buffer64WriteByte(&uart1_output_buffer, command_byte);
002BB4  9040AE     MOV.B [W14+2], W1
002BB6  208AE0     MOV #0x8AE, W0
002BB8  07123A     RCALL Buffer64WriteByte
179:                   Buffer64WriteByte(&uart1_output_buffer, (data_word >> 8));
002BBA  90022E     MOV [W14+4], W4
002BBC  DE2248     LSR W4, #8, W4
002BBE  784204     MOV.B W4, W4
002BC0  784084     MOV.B W4, W1
002BC2  208AE0     MOV #0x8AE, W0
002BC4  071234     RCALL Buffer64WriteByte
180:                   Buffer64WriteByte(&uart1_output_buffer, (data_word & 0x00FF));
002BC6  90022E     MOV [W14+4], W4
002BC8  784204     MOV.B W4, W4
002BCA  784084     MOV.B W4, W1
002BCC  208AE0     MOV #0x8AE, W0
002BCE  07122F     RCALL Buffer64WriteByte
181:                   Buffer64WriteByte(&uart1_output_buffer, register_byte);
002BD0  9040BE     MOV.B [W14+3], W1
002BD2  208AE0     MOV #0x8AE, W0
002BD4  07122C     RCALL Buffer64WriteByte
182:                   Buffer64WriteByte(&uart1_output_buffer, (crc >> 8));
002BD6  78021E     MOV [W14], W4
002BD8  DE2248     LSR W4, #8, W4
002BDA  784204     MOV.B W4, W4
002BDC  784084     MOV.B W4, W1
002BDE  208AE0     MOV #0x8AE, W0
002BE0  071226     RCALL Buffer64WriteByte
183:                   Buffer64WriteByte(&uart1_output_buffer, (crc & 0x00FF));
002BE2  78021E     MOV [W14], W4
002BE4  784204     MOV.B W4, W4
002BE6  784084     MOV.B W4, W1
002BE8  208AE0     MOV #0x8AE, W0
002BEA  071221     RCALL Buffer64WriteByte
184:                   
185:                   if ((!U1STAbits.UTXBF) && (Buffer64IsNotEmpty(&uart1_output_buffer))) {
002BEC  801075     MOV U1STA, W5
002BEE  202004     MOV #0x200, W4
002BF0  628204     AND W5, W4, W4
002BF2  520FE0     SUB W4, #0x0, [W15]
002BF4  3A000A     BRA NZ, 0x2C0A
002BF6  208AE0     MOV #0x8AE, W0
002BF8  071268     RCALL Buffer64IsNotEmpty
002BFA  784200     MOV.B W0, W4
002BFC  524FE0     SUB.B W4, #0x0, [W15]
002BFE  320005     BRA Z, 0x2C0A
186:                     /*
187:               	There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
188:               	Move a byte from the output buffer into the transmit buffer
189:               	All subsequent bytes will be moved from the output buffer to the transmit buffer by the U1 TX Interrupt
190:                     */
191:                     U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
002C00  208AE0     MOV #0x8AE, W0
002C02  07123A     RCALL Buffer64ReadByte
002C04  784200     MOV.B W0, W4
002C06  FB8204     ZE W4, W4
002C08  881084     MOV W4, U1TXREG
192:                   }
193:                 }
194:               }
002C0A  FA8000     ULNK
002C0C  060000     RETURN
195:               
196:               void ExecuteCommand(void) {
002C0E  FA000A     LNK #0xA
197:                 unsigned int itemp;
198:                 unsigned int vtemp;
199:                 unsigned int data_word;
200:                 unsigned int return_data_word;
201:                 unsigned int return_command_byte;
202:                 
203:                 data_word = command_string.data_high_byte;
002C10  218C64     MOV #0x18C6, W4
002C12  784214     MOV.B [W4], W4
002C14  FB8204     ZE W4, W4
002C16  980714     MOV W4, [W14+2]
204:                 data_word = data_word << 8;
002C18  90021E     MOV [W14+2], W4
002C1A  DD2248     SL W4, #8, W4
002C1C  980714     MOV W4, [W14+2]
205:                 data_word = data_word + command_string.data_low_byte;
002C1E  218C74     MOV #0x18C7, W4
002C20  784214     MOV.B [W4], W4
002C22  FB8204     ZE W4, W4
002C24  90029E     MOV [W14+2], W5
002C26  428204     ADD W5, W4, W4
002C28  980714     MOV W4, [W14+2]
206:                 
207:                 return_data_word = data_word;
002C2A  90001E     MOV [W14+2], W0
002C2C  780F00     MOV W0, [W14]
208:                 return_command_byte = command_string.command_byte;
002C2E  218C44     MOV #0x18C4, W4
002C30  784214     MOV.B [W4], W4
002C32  FB8204     ZE W4, W4
002C34  980724     MOV W4, [W14+4]
209:                 switch (command_string.command_byte) 
002C36  218C44     MOV #0x18C4, W4
002C38  784214     MOV.B [W4], W4
002C3A  FB8204     ZE W4, W4
002C3C  B92361     MUL.SU W4, #1, W6
002C3E  2FFF04     MOV #0xFFF0, W4
002C40  2FFFF5     MOV #0xFFFF, W5
002C42  420206     ADD W4, W6, W4
002C44  4A8287     ADDC W5, W7, W5
002C46  200DA6     MOV #0xDA, W6
002C48  200007     MOV #0x0, W7
002C4A  520F86     SUB W4, W6, [W15]
002C4C  5A8F87     SUBB W5, W7, [W15]
002C4E  3E0446     BRA GTU, 0x34DC
002C50  016004     BRA W4
002C52  370166     BRA 0x2F20
002C54  370169     BRA 0x2F28
002C56  370442     BRA 0x34DC
002C58  370441     BRA 0x34DC
002C5A  370440     BRA 0x34DC
002C5C  37043F     BRA 0x34DC
002C5E  37043E     BRA 0x34DC
002C60  37043D     BRA 0x34DC
002C62  37043C     BRA 0x34DC
002C64  37043B     BRA 0x34DC
002C66  37043A     BRA 0x34DC
002C68  370439     BRA 0x34DC
002C6A  370438     BRA 0x34DC
002C6C  370437     BRA 0x34DC
002C6E  370436     BRA 0x34DC
002C70  370435     BRA 0x34DC
002C72  3700CA     BRA 0x2E08
002C74  3700EC     BRA 0x2E4E
002C76  370432     BRA 0x34DC
002C78  370431     BRA 0x34DC
002C7A  370430     BRA 0x34DC
002C7C  37042F     BRA 0x34DC
002C7E  37042E     BRA 0x34DC
002C80  37042D     BRA 0x34DC
002C82  37042C     BRA 0x34DC
002C84  37042B     BRA 0x34DC
002C86  370106     BRA 0x2E94
002C88  370153     BRA 0x2F30
002C8A  3703F4     BRA 0x3474
002C8C  370126     BRA 0x2EDA
002C8E  3703CF     BRA 0x342E
002C90  370425     BRA 0x34DC
002C92  370175     BRA 0x2F7E
002C94  370423     BRA 0x34DC
002C96  370422     BRA 0x34DC
002C98  370421     BRA 0x34DC
002C9A  370420     BRA 0x34DC
002C9C  37041F     BRA 0x34DC
002C9E  37041E     BRA 0x34DC
002CA0  37041D     BRA 0x34DC
002CA2  37041C     BRA 0x34DC
002CA4  37041B     BRA 0x34DC
002CA6  37041A     BRA 0x34DC
002CA8  370419     BRA 0x34DC
002CAA  370418     BRA 0x34DC
002CAC  370417     BRA 0x34DC
002CAE  370416     BRA 0x34DC
002CB0  370415     BRA 0x34DC
002CB2  370403     BRA 0x34BA
002CB4  370413     BRA 0x34DC
002CB6  370412     BRA 0x34DC
002CB8  370411     BRA 0x34DC
002CBA  370410     BRA 0x34DC
002CBC  37040F     BRA 0x34DC
002CBE  37040E     BRA 0x34DC
002CC0  37040D     BRA 0x34DC
002CC2  37040C     BRA 0x34DC
002CC4  37040B     BRA 0x34DC
002CC6  37040A     BRA 0x34DC
002CC8  370409     BRA 0x34DC
002CCA  370408     BRA 0x34DC
002CCC  370407     BRA 0x34DC
002CCE  370406     BRA 0x34DC
002CD0  370405     BRA 0x34DC
002CD2  37015D     BRA 0x2F8E
002CD4  370168     BRA 0x2FA6
002CD6  370186     BRA 0x2FE4
002CD8  3701C3     BRA 0x3060
002CDA  370210     BRA 0x30FC
002CDC  370228     BRA 0x312E
002CDE  3701A1     BRA 0x3022
002CE0  3701D8     BRA 0x3092
002CE2  3701DA     BRA 0x3098
002CE4  3701F2     BRA 0x30CA
002CE6  3703FA     BRA 0x34DC
002CE8  3703F9     BRA 0x34DC
002CEA  3703F8     BRA 0x34DC
002CEC  3703F7     BRA 0x34DC
002CEE  3703F6     BRA 0x34DC
002CF0  3703F5     BRA 0x34DC
002CF2  3703F4     BRA 0x34DC
002CF4  3703F3     BRA 0x34DC
002CF6  3703F2     BRA 0x34DC
002CF8  3703F1     BRA 0x34DC
002CFA  3703F0     BRA 0x34DC
002CFC  3703EF     BRA 0x34DC
002CFE  3703EE     BRA 0x34DC
002D00  3703ED     BRA 0x34DC
002D02  3703EC     BRA 0x34DC
002D04  3703EB     BRA 0x34DC
002D06  3703EA     BRA 0x34DC
002D08  3703E9     BRA 0x34DC
002D0A  3703E8     BRA 0x34DC
002D0C  3703E7     BRA 0x34DC
002D0E  3703E6     BRA 0x34DC
002D10  3703E5     BRA 0x34DC
002D12  3703E4     BRA 0x34DC
002D14  3703E3     BRA 0x34DC
002D16  3703E2     BRA 0x34DC
002D18  3703E1     BRA 0x34DC
002D1A  3703E0     BRA 0x34DC
002D1C  3703DF     BRA 0x34DC
002D1E  3703DE     BRA 0x34DC
002D20  3703DD     BRA 0x34DC
002D22  3703DC     BRA 0x34DC
002D24  3703DB     BRA 0x34DC
002D26  3703DA     BRA 0x34DC
002D28  3703D9     BRA 0x34DC
002D2A  3703D8     BRA 0x34DC
002D2C  3703D7     BRA 0x34DC
002D2E  3703D6     BRA 0x34DC
002D30  3703D5     BRA 0x34DC
002D32  3703D4     BRA 0x34DC
002D34  3703D3     BRA 0x34DC
002D36  3703D2     BRA 0x34DC
002D38  3703D1     BRA 0x34DC
002D3A  3703D0     BRA 0x34DC
002D3C  3703CF     BRA 0x34DC
002D3E  3703CE     BRA 0x34DC
002D40  3703CD     BRA 0x34DC
002D42  3703CC     BRA 0x34DC
002D44  3703CB     BRA 0x34DC
002D46  3703CA     BRA 0x34DC
002D48  3703C9     BRA 0x34DC
002D4A  3703C8     BRA 0x34DC
002D4C  3703C7     BRA 0x34DC
002D4E  3703C6     BRA 0x34DC
002D50  3703C5     BRA 0x34DC
002D52  3703C4     BRA 0x34DC
002D54  3703C3     BRA 0x34DC
002D56  3703C2     BRA 0x34DC
002D58  3703C1     BRA 0x34DC
002D5A  3703C0     BRA 0x34DC
002D5C  3703BF     BRA 0x34DC
002D5E  3703BE     BRA 0x34DC
002D60  3703BD     BRA 0x34DC
002D62  3703BC     BRA 0x34DC
002D64  3703BB     BRA 0x34DC
002D66  3703BA     BRA 0x34DC
002D68  3703B9     BRA 0x34DC
002D6A  3703B8     BRA 0x34DC
002D6C  3703B7     BRA 0x34DC
002D6E  3703B6     BRA 0x34DC
002D70  3703B5     BRA 0x34DC
002D72  3703B4     BRA 0x34DC
002D74  3701F5     BRA 0x3160
002D76  3703B2     BRA 0x34DC
002D78  3703B1     BRA 0x34DC
002D7A  3703B0     BRA 0x34DC
002D7C  3703AF     BRA 0x34DC
002D7E  3703AE     BRA 0x34DC
002D80  3703AD     BRA 0x34DC
002D82  3703AC     BRA 0x34DC
002D84  3703AB     BRA 0x34DC
002D86  3703AA     BRA 0x34DC
002D88  3703A9     BRA 0x34DC
002D8A  3703A8     BRA 0x34DC
002D8C  3703A7     BRA 0x34DC
002D8E  3703A6     BRA 0x34DC
002D90  3703A5     BRA 0x34DC
002D92  3703A4     BRA 0x34DC
002D94  3703A3     BRA 0x34DC
002D96  3703A2     BRA 0x34DC
002D98  3703A1     BRA 0x34DC
002D9A  3703A0     BRA 0x34DC
002D9C  37039F     BRA 0x34DC
002D9E  37039E     BRA 0x34DC
002DA0  37039D     BRA 0x34DC
002DA2  37039C     BRA 0x34DC
002DA4  37039B     BRA 0x34DC
002DA6  37039A     BRA 0x34DC
002DA8  370399     BRA 0x34DC
002DAA  370398     BRA 0x34DC
002DAC  370397     BRA 0x34DC
002DAE  370396     BRA 0x34DC
002DB0  370395     BRA 0x34DC
002DB2  370394     BRA 0x34DC
002DB4  370393     BRA 0x34DC
002DB6  370392     BRA 0x34DC
002DB8  370391     BRA 0x34DC
002DBA  370390     BRA 0x34DC
002DBC  37038F     BRA 0x34DC
002DBE  37038E     BRA 0x34DC
002DC0  37038D     BRA 0x34DC
002DC2  37038C     BRA 0x34DC
002DC4  37038B     BRA 0x34DC
002DC6  37038A     BRA 0x34DC
002DC8  370389     BRA 0x34DC
002DCA  370388     BRA 0x34DC
002DCC  370387     BRA 0x34DC
002DCE  370386     BRA 0x34DC
002DD0  370385     BRA 0x34DC
002DD2  3701CE     BRA 0x3170
002DD4  3701D6     BRA 0x3182
002DD6  3701DE     BRA 0x3194
002DD8  3701F2     BRA 0x31BE
002DDA  3701FA     BRA 0x31D0
002DDC  370202     BRA 0x31E2
002DDE  370216     BRA 0x320C
002DE0  37021E     BRA 0x321E
002DE2  370226     BRA 0x3230
002DE4  37023A     BRA 0x325A
002DE6  370242     BRA 0x326C
002DE8  37024A     BRA 0x327E
002DEA  37025E     BRA 0x32A8
002DEC  370266     BRA 0x32BA
002DEE  37026E     BRA 0x32CC
002DF0  370282     BRA 0x32F6
002DF2  37028A     BRA 0x3308
002DF4  370292     BRA 0x331A
002DF6  3702A6     BRA 0x3344
002DF8  3702AE     BRA 0x3356
002DFA  3702B6     BRA 0x3368
002DFC  3702CA     BRA 0x3392
002DFE  3702D2     BRA 0x33A4
002E00  3702DA     BRA 0x33B6
002E02  3702EE     BRA 0x33E0
002E04  3702F6     BRA 0x33F2
002E06  3702FE     BRA 0x3404
210:                   {
211:               
212:               
213:                     
214:               #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
215:                     // We have compiled in the mode that untilizes the serial port to set the magnetron operating parameters (instead of the analong interface)
216:                   case CMD_PAC_SET_MODE_A:
217:                     itemp = data_word;
002E08  90021E     MOV [W14+2], W4
002E0A  980734     MOV W4, [W14+6]
218:                     vtemp = GenerateMagnetronVprog(itemp);
002E0C  90003E     MOV [W14+6], W0
002E0E  07067E     RCALL GenerateMagnetronVprog
002E10  780200     MOV W0, W4
002E12  980744     MOV W4, [W14+8]
219:                     SetPowerSupplyTarget(&ps_magnetron_mode_A, vtemp, itemp);
002E14  90013E     MOV [W14+6], W2
002E16  9000CE     MOV [W14+8], W1
002E18  209620     MOV #0x962, W0
002E1A  07F33B     RCALL SetPowerSupplyTarget
220:                     ps_magnetron_mode_A_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnetron_mode_A.v_command_set_point;
002E1C  804B24     MOV 0x964, W4
002E1E  88BE84     MOV W4, ps_magnetron_mode_A_config_ram_copy
221:                     ps_magnetron_mode_A_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnetron_mode_A.i_command_set_point;
002E20  804C84     MOV 0x990, W4
002E22  88BED4     MOV W4, 0x17DA
222:                     _wait_eedata();
002E24  803B05     MOV NVMCON, W5
002E26  280004     MOV #0x8000, W4
002E28  628204     AND W5, W4, W4
002E2A  520FE0     SUB W4, #0x0, [W15]
002E2C  3AFFFB     BRA NZ, 0x2E24
223:                     _erase_eedata(EE_address_ps_magnetron_mode_A_config_in_EEPROM, _EE_ROW);
002E2E  80BE64     MOV EE_address_ps_magnetron_mode_A_config_in_EEPROM, W4
002E30  80BE75     MOV 0x17CE, W5
002E32  200202     MOV #0x20, W2
002E34  BE0004     MOV.D W4, W0
002E36  07E9ED     RCALL __eedata_helper1
224:                     _wait_eedata();
002E38  803B05     MOV NVMCON, W5
002E3A  280004     MOV #0x8000, W4
002E3C  628204     AND W5, W4, W4
002E3E  520FE0     SUB W4, #0x0, [W15]
002E40  3AFFFB     BRA NZ, 0x2E38
225:                     _write_eedata_row(EE_address_ps_magnetron_mode_A_config_in_EEPROM, ps_magnet_config_ram_copy);
002E42  80BE64     MOV EE_address_ps_magnetron_mode_A_config_in_EEPROM, W4
002E44  80BE75     MOV 0x17CE, W5
002E46  216F82     MOV #0x16F8, W2
002E48  BE0004     MOV.D W4, W0
002E4A  07EA02     RCALL __eedata_helper4
226:                     break;
002E4C  370347     BRA 0x34DC
227:               
228:                   case CMD_PAC_SET_MODE_B:
229:                     itemp = data_word;
002E4E  90001E     MOV [W14+2], W0
002E50  980730     MOV W0, [W14+6]
230:                     vtemp = GenerateMagnetronVprog(itemp);
002E52  90003E     MOV [W14+6], W0
002E54  07065B     RCALL GenerateMagnetronVprog
002E56  780200     MOV W0, W4
002E58  980744     MOV W4, [W14+8]
231:                     SetPowerSupplyTarget(&ps_magnetron_mode_B, vtemp, itemp);
002E5A  90013E     MOV [W14+6], W2
002E5C  9000CE     MOV [W14+8], W1
002E5E  20A160     MOV #0xA16, W0
002E60  07F318     RCALL SetPowerSupplyTarget
232:                     ps_magnetron_mode_B_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnetron_mode_B.v_command_set_point;
002E62  8050C4     MOV 0xA18, W4
002E64  88BFA4     MOV W4, ps_magnetron_mode_B_config_ram_copy
233:                     ps_magnetron_mode_B_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnetron_mode_B.i_command_set_point;
002E66  805224     MOV 0xA44, W4
002E68  88BFF4     MOV W4, 0x17FE
234:                     _wait_eedata();
002E6A  803B05     MOV NVMCON, W5
002E6C  280004     MOV #0x8000, W4
002E6E  628204     AND W5, W4, W4
002E70  520FE0     SUB W4, #0x0, [W15]
002E72  3AFFFB     BRA NZ, 0x2E6A
235:                     _erase_eedata(EE_address_ps_magnetron_mode_B_config_in_EEPROM, _EE_ROW);
002E74  80BF84     MOV EE_address_ps_magnetron_mode_B_config_in_EEPROM, W4
002E76  80BF95     MOV 0x17F2, W5
002E78  200202     MOV #0x20, W2
002E7A  BE0004     MOV.D W4, W0
002E7C  07E9CA     RCALL __eedata_helper1
236:                     _wait_eedata();
002E7E  803B05     MOV NVMCON, W5
002E80  280004     MOV #0x8000, W4
002E82  628204     AND W5, W4, W4
002E84  520FE0     SUB W4, #0x0, [W15]
002E86  3AFFFB     BRA NZ, 0x2E7E
237:                     _write_eedata_row(EE_address_ps_magnetron_mode_B_config_in_EEPROM, ps_magnet_config_ram_copy);
002E88  80BF84     MOV EE_address_ps_magnetron_mode_B_config_in_EEPROM, W4
002E8A  80BF95     MOV 0x17F2, W5
002E8C  216F82     MOV #0x16F8, W2
002E8E  BE0004     MOV.D W4, W0
002E90  07E9DF     RCALL __eedata_helper4
238:                     break;
002E92  370324     BRA 0x34DC
239:               #endif
240:               
241:               
242:               
243:               #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
244:                     // The lambda voltage is set directly over the serial interface.
245:                   case CMD_SET_LAMBDA_VOLTAGE_MODE_A:
246:                     vtemp = data_word;
002E94  90021E     MOV [W14+2], W4
002E96  980744     MOV W4, [W14+8]
247:                     itemp = GenerateLambdaIprog(vtemp);
002E98  90004E     MOV [W14+8], W0
002E9A  07063E     RCALL GenerateLambdaIprog
002E9C  780200     MOV W0, W4
002E9E  980734     MOV W4, [W14+6]
248:                     SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp, itemp);
002EA0  90013E     MOV [W14+6], W2
002EA2  9000CE     MOV [W14+8], W1
002EA4  209080     MOV #0x908, W0
002EA6  07F2F5     RCALL SetPowerSupplyTarget
249:                     ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_SET_POINT] = ps_hv_lambda_mode_A.v_command_set_point;
002EA8  804854     MOV 0x90A, W4
002EAA  88BC44     MOV W4, ps_hv_lambda_mode_A_config_ram_copy
250:                     ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_SET_POINT] = ps_hv_lambda_mode_A.i_command_set_point;
002EAC  8049B4     MOV 0x936, W4
002EAE  88BC94     MOV W4, 0x1792
251:                     _wait_eedata();
002EB0  803B05     MOV NVMCON, W5
002EB2  280004     MOV #0x8000, W4
002EB4  628204     AND W5, W4, W4
002EB6  520FE0     SUB W4, #0x0, [W15]
002EB8  3AFFFB     BRA NZ, 0x2EB0
252:                     _erase_eedata(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, _EE_ROW);
002EBA  80BC24     MOV EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, W4
002EBC  80BC35     MOV 0x1786, W5
002EBE  200202     MOV #0x20, W2
002EC0  BE0004     MOV.D W4, W0
002EC2  07E9A7     RCALL __eedata_helper1
253:                     _wait_eedata();
002EC4  803B05     MOV NVMCON, W5
002EC6  280004     MOV #0x8000, W4
002EC8  628204     AND W5, W4, W4
002ECA  520FE0     SUB W4, #0x0, [W15]
002ECC  3AFFFB     BRA NZ, 0x2EC4
254:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, ps_hv_lambda_mode_A_config_ram_copy);
002ECE  80BC24     MOV EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, W4
002ED0  80BC35     MOV 0x1786, W5
002ED2  217882     MOV #0x1788, W2
002ED4  BE0004     MOV.D W4, W0
002ED6  07E9BC     RCALL __eedata_helper4
255:                     break;
002ED8  370301     BRA 0x34DC
256:               
257:                   case CMD_SET_LAMBDA_VOLTAGE_MODE_B:
258:                     vtemp = data_word;
002EDA  90001E     MOV [W14+2], W0
002EDC  980740     MOV W0, [W14+8]
259:                     itemp = GenerateLambdaIprog(vtemp);
002EDE  90004E     MOV [W14+8], W0
002EE0  07061B     RCALL GenerateLambdaIprog
002EE2  780200     MOV W0, W4
002EE4  980734     MOV W4, [W14+6]
260:                     SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, itemp);
002EE6  90013E     MOV [W14+6], W2
002EE8  9000CE     MOV [W14+8], W1
002EEA  209BC0     MOV #0x9BC, W0
002EEC  07F2D2     RCALL SetPowerSupplyTarget
261:                     ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_SET_POINT] = ps_hv_lambda_mode_B.v_command_set_point;
002EEE  804DF4     MOV 0x9BE, W4
002EF0  88BD64     MOV W4, ps_hv_lambda_mode_B_config_ram_copy
262:                     ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_SET_POINT] = ps_hv_lambda_mode_B.i_command_set_point;
002EF2  804F54     MOV 0x9EA, W4
002EF4  88BDB4     MOV W4, 0x17B6
263:                     _wait_eedata();
002EF6  803B05     MOV NVMCON, W5
002EF8  280004     MOV #0x8000, W4
002EFA  628204     AND W5, W4, W4
002EFC  520FE0     SUB W4, #0x0, [W15]
002EFE  3AFFFB     BRA NZ, 0x2EF6
264:                     _erase_eedata(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, _EE_ROW);
002F00  80BD44     MOV EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, W4
002F02  80BD55     MOV 0x17AA, W5
002F04  200202     MOV #0x20, W2
002F06  BE0004     MOV.D W4, W0
002F08  07E984     RCALL __eedata_helper1
265:                     _wait_eedata();
002F0A  803B05     MOV NVMCON, W5
002F0C  280004     MOV #0x8000, W4
002F0E  628204     AND W5, W4, W4
002F10  520FE0     SUB W4, #0x0, [W15]
002F12  3AFFFB     BRA NZ, 0x2F0A
266:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, ps_hv_lambda_mode_B_config_ram_copy);
002F14  80BD44     MOV EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, W4
002F16  80BD55     MOV 0x17AA, W5
002F18  217AC2     MOV #0x17AC, W2
002F1A  BE0004     MOV.D W4, W0
002F1C  07E999     RCALL __eedata_helper4
267:                     break;
002F1E  3702DE     BRA 0x34DC
268:               
269:               #endif // #if defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
270:                   case CMD_SET_MAGNETRON_CURRENT_REMOTE_MODE:
271:                     ram_config_set_magnetron_magnet_current_from_GUI = 0;
002F20  EB4200     CLR.B W4
002F22  784004     MOV.B W4, W0
002F24  B7E830     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
272:                     break;
002F26  3702DA     BRA 0x34DC
273:                     
274:                   case CMD_SET_MAGNETRON_CURRENT_LOCAL_MODE:
275:                     ram_config_set_magnetron_magnet_current_from_GUI = 1;
002F28  B3C014     MOV.B #0x1, W4
002F2A  784004     MOV.B W4, W0
002F2C  B7E830     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
276:                     break;
002F2E  3702D6     BRA 0x34DC
277:               
278:               
279:                     //#if defined(__SET_MAGNET_CURRENT_OVER_SERIAL_INTERFACE)
280:                   case CMD_SET_MAGNETRON_MAGNET_CURRENT:
281:                     if (ram_config_set_magnetron_magnet_current_from_GUI) {
002F30  208304     MOV #0x830, W4
002F32  784214     MOV.B [W4], W4
002F34  524FE0     SUB.B W4, #0x0, [W15]
002F36  3202CF     BRA Z, 0x34D6
282:               	itemp = data_word;
002F38  90021E     MOV [W14+2], W4
002F3A  980734     MOV W4, [W14+6]
283:               	vtemp = GenerateMagnetVprog(itemp);
002F3C  90003E     MOV [W14+6], W0
002F3E  0705F2     RCALL GenerateMagnetVprog
002F40  780200     MOV W0, W4
002F42  980744     MOV W4, [W14+8]
284:               	SetPowerSupplyTarget(&ps_magnet, vtemp, itemp);
002F44  90013E     MOV [W14+6], W2
002F46  9000CE     MOV [W14+8], W1
002F48  20A700     MOV #0xA70, W0
002F4A  07F2A3     RCALL SetPowerSupplyTarget
285:               	ps_magnet_config_ram_copy[EEPROM_V_SET_POINT] = ps_magnet.v_command_set_point;
002F4C  805394     MOV 0xA72, W4
002F4E  88B7C4     MOV W4, ps_magnet_config_ram_copy
286:               	ps_magnet_config_ram_copy[EEPROM_I_SET_POINT] = ps_magnet.i_command_set_point;
002F50  8054F4     MOV 0xA9E, W4
002F52  88B814     MOV W4, 0x1702
287:               	_wait_eedata();
002F54  803B05     MOV NVMCON, W5
002F56  280004     MOV #0x8000, W4
002F58  628204     AND W5, W4, W4
002F5A  520FE0     SUB W4, #0x0, [W15]
002F5C  3AFFFB     BRA NZ, 0x2F54
288:               	_erase_eedata(EE_address_ps_magnet_config_in_EEPROM, _EE_ROW);
002F5E  80B7A4     MOV EE_address_ps_magnet_config_in_EEPROM, W4
002F60  80B7B5     MOV 0x16F6, W5
002F62  200202     MOV #0x20, W2
002F64  BE0004     MOV.D W4, W0
002F66  07E955     RCALL __eedata_helper1
289:               	_wait_eedata();
002F68  803B05     MOV NVMCON, W5
002F6A  280004     MOV #0x8000, W4
002F6C  628204     AND W5, W4, W4
002F6E  520FE0     SUB W4, #0x0, [W15]
002F70  3AFFFB     BRA NZ, 0x2F68
290:               	_write_eedata_row(EE_address_ps_magnet_config_in_EEPROM, ps_magnet_config_ram_copy);
002F72  80B7A4     MOV EE_address_ps_magnet_config_in_EEPROM, W4
002F74  80B7B5     MOV 0x16F6, W5
002F76  216F82     MOV #0x16F8, W2
002F78  BE0004     MOV.D W4, W0
002F7A  07E96A     RCALL __eedata_helper4
291:                     }
292:                     break;
002F7C  3702AF     BRA 0x34DC
0034D6  000000     NOP
0034D8  370001     BRA 0x34DC
293:               
294:                     //#endif //#if defined(__SET_MAGNET_CURRENT_OVER_SERIAL_INTERFACE)
295:               
296:                     
297:                   case CMD_READ_RAM_VALUE:
298:                     return_data_word = ReadFromRam(command_string.register_byte);
002F7E  218C54     MOV #0x18C5, W4
002F80  784214     MOV.B [W4], W4
002F82  FB8204     ZE W4, W4
002F84  780004     MOV W4, W0
002F86  0702B7     RCALL ReadFromRam
002F88  780200     MOV W0, W4
002F8A  780F04     MOV W4, [W14]
299:                     break;
002F8C  3702A7     BRA 0x34DC
300:               
301:                     
302:                   case CMD_DATA_LOGGING:
303:                     if (command_string.register_byte == 1) {
002F8E  218C54     MOV #0x18C5, W4
002F90  784214     MOV.B [W4], W4
002F92  524FE1     SUB.B W4, #0x1, [W15]
002F94  3A0004     BRA NZ, 0x2F9E
304:               	data_logging_to_uart = 1;
002F96  B3C014     MOV.B #0x1, W4
002F98  784004     MOV.B W4, W0
002F9A  B7F8C9     MOV.B WREG, data_logging_to_uart
305:                     } else {
306:                     	data_logging_to_uart = 0;
002F9E  EB4200     CLR.B W4
002FA0  784004     MOV.B W4, W0
002FA2  B7F8C9     MOV.B WREG, data_logging_to_uart
307:                     }
308:                     break;
002F9C  37029F     BRA 0x34DC
002FA4  37029B     BRA 0x34DC
309:               
310:               
311:                   case CMD_SET_HIGH_ENERGY_TARGET_CURRENT_SETPOINT:
312:                     linac_high_energy_target_current_set_point = data_word;
002FA6  90021E     MOV [W14+2], W4
002FA8  8840E4     MOV W4, linac_high_energy_target_current_set_point
313:                     if (linac_high_energy_target_current_set_point < LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR) {
002FAA  8040E5     MOV linac_high_energy_target_current_set_point, W5
002FAC  200314     MOV #0x31, W4
002FAE  528F84     SUB W5, W4, [W15]
002FB0  3E0002     BRA GTU, 0x2FB6
314:               	linac_high_energy_target_current_set_point = LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR;
002FB2  200324     MOV #0x32, W4
002FB4  8840E4     MOV W4, linac_high_energy_target_current_set_point
315:                     }
316:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_HIGH_ENERGY_TARGET] = linac_high_energy_target_current_set_point;
002FB6  8040E4     MOV linac_high_energy_target_current_set_point, W4
002FB8  88C214     MOV W4, 0x1842
317:                     _wait_eedata();
002FBA  803B05     MOV NVMCON, W5
002FBC  280004     MOV #0x8000, W4
002FBE  628204     AND W5, W4, W4
002FC0  520FE0     SUB W4, #0x0, [W15]
002FC2  3AFFFB     BRA NZ, 0x2FBA
318:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
002FC4  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
002FC6  80C1D5     MOV 0x183A, W5
002FC8  200202     MOV #0x20, W2
002FCA  BE0004     MOV.D W4, W0
002FCC  07E922     RCALL __eedata_helper1
319:                     _wait_eedata();
002FCE  803B05     MOV NVMCON, W5
002FD0  280004     MOV #0x8000, W4
002FD2  628204     AND W5, W4, W4
002FD4  520FE0     SUB W4, #0x0, [W15]
002FD6  3AFFFB     BRA NZ, 0x2FCE
320:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
002FD8  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
002FDA  80C1D5     MOV 0x183A, W5
002FDC  2183C2     MOV #0x183C, W2
002FDE  BE0004     MOV.D W4, W0
002FE0  07E937     RCALL __eedata_helper4
321:                     break;
002FE2  37027C     BRA 0x34DC
322:                     
323:               
324:                   case CMD_SET_LOW_ENERGY_PORTAL_TARGET_CURRENT_SETPOINT:
325:                     linac_low_energy_target_current_set_point_portal_mode = data_word;
002FE4  90001E     MOV [W14+2], W0
002FE6  884110     MOV W0, linac_low_energy_target_current_set_point_portal_mode
326:                     if (linac_low_energy_target_current_set_point_portal_mode < LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR) {
002FE8  804115     MOV linac_low_energy_target_current_set_point_portal_mode, W5
002FEA  200314     MOV #0x31, W4
002FEC  528F84     SUB W5, W4, [W15]
002FEE  3E0002     BRA GTU, 0x2FF4
327:               	linac_low_energy_target_current_set_point_portal_mode = LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR;
002FF0  200324     MOV #0x32, W4
002FF2  884114     MOV W4, linac_low_energy_target_current_set_point_portal_mode
328:                     }
329:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_PORTAL_TARGET] = linac_low_energy_target_current_set_point_portal_mode;
002FF4  804114     MOV linac_low_energy_target_current_set_point_portal_mode, W4
002FF6  88C264     MOV W4, 0x184C
330:                     _wait_eedata();
002FF8  803B05     MOV NVMCON, W5
002FFA  280004     MOV #0x8000, W4
002FFC  628204     AND W5, W4, W4
002FFE  520FE0     SUB W4, #0x0, [W15]
003000  3AFFFB     BRA NZ, 0x2FF8
331:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
003002  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003004  80C1D5     MOV 0x183A, W5
003006  200202     MOV #0x20, W2
003008  BE0004     MOV.D W4, W0
00300A  07E903     RCALL __eedata_helper1
332:                     _wait_eedata();
00300C  803B05     MOV NVMCON, W5
00300E  280004     MOV #0x8000, W4
003010  628204     AND W5, W4, W4
003012  520FE0     SUB W4, #0x0, [W15]
003014  3AFFFB     BRA NZ, 0x300C
333:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
003016  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003018  80C1D5     MOV 0x183A, W5
00301A  2183C2     MOV #0x183C, W2
00301C  BE0004     MOV.D W4, W0
00301E  07E918     RCALL __eedata_helper4
334:                     break;
003020  37025D     BRA 0x34DC
335:               
336:                   case CMD_SET_LOW_ENERGY_GANTRY_TARGET_CURRENT_SETPOINT:
337:                     linac_low_energy_target_current_set_point_gantry_mode = data_word;
003022  90021E     MOV [W14+2], W4
003024  884124     MOV W4, linac_low_energy_target_current_set_point_gantry_mode
338:                     if (linac_low_energy_target_current_set_point_gantry_mode < LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR) {
003026  804125     MOV linac_low_energy_target_current_set_point_gantry_mode, W5
003028  200314     MOV #0x31, W4
00302A  528F84     SUB W5, W4, [W15]
00302C  3E0002     BRA GTU, 0x3032
339:               	linac_low_energy_target_current_set_point_gantry_mode = LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR;
00302E  200324     MOV #0x32, W4
003030  884124     MOV W4, linac_low_energy_target_current_set_point_gantry_mode
340:                     }
341:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_GANTRY_TARGET] = linac_low_energy_target_current_set_point_gantry_mode;
003032  804124     MOV linac_low_energy_target_current_set_point_gantry_mode, W4
003034  88C224     MOV W4, 0x1844
342:                     _wait_eedata();
003036  803B05     MOV NVMCON, W5
003038  280004     MOV #0x8000, W4
00303A  628204     AND W5, W4, W4
00303C  520FE0     SUB W4, #0x0, [W15]
00303E  3AFFFB     BRA NZ, 0x3036
343:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
003040  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003042  80C1D5     MOV 0x183A, W5
003044  200202     MOV #0x20, W2
003046  BE0004     MOV.D W4, W0
003048  07E8E4     RCALL __eedata_helper1
344:                     _wait_eedata();
00304A  803B05     MOV NVMCON, W5
00304C  280004     MOV #0x8000, W4
00304E  628204     AND W5, W4, W4
003050  520FE0     SUB W4, #0x0, [W15]
003052  3AFFFB     BRA NZ, 0x304A
345:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
003054  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003056  80C1D5     MOV 0x183A, W5
003058  2183C2     MOV #0x183C, W2
00305A  BE0004     MOV.D W4, W0
00305C  07E8F9     RCALL __eedata_helper4
346:                     break;
00305E  37023E     BRA 0x34DC
347:               
348:                   case CMD_SET_TARGET_CURRENT_STARTUP_PULSES:
349:                     low_energy_target_current_startup_adjust_decay_time_pulses = data_word;
003060  90001E     MOV [W14+2], W0
003062  88C510     MOV W0, 0x18A2
350:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_STARTUP_PULSES] = low_energy_target_current_startup_adjust_decay_time_pulses;
003064  80C514     MOV 0x18A2, W4
003066  88C234     MOV W4, 0x1846
351:                     _wait_eedata();
003068  803B05     MOV NVMCON, W5
00306A  280004     MOV #0x8000, W4
00306C  628204     AND W5, W4, W4
00306E  520FE0     SUB W4, #0x0, [W15]
003070  3AFFFB     BRA NZ, 0x3068
352:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
003072  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003074  80C1D5     MOV 0x183A, W5
003076  200202     MOV #0x20, W2
003078  BE0004     MOV.D W4, W0
00307A  07E8CB     RCALL __eedata_helper1
353:                     _wait_eedata();
00307C  803B05     MOV NVMCON, W5
00307E  280004     MOV #0x8000, W4
003080  628204     AND W5, W4, W4
003082  520FE0     SUB W4, #0x0, [W15]
003084  3AFFFB     BRA NZ, 0x307C
354:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
003086  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003088  80C1D5     MOV 0x183A, W5
00308A  2183C2     MOV #0x183C, W2
00308C  BE0004     MOV.D W4, W0
00308E  07E8E0     RCALL __eedata_helper4
355:                     break;
003090  370225     BRA 0x34DC
356:               
357:                   case CMD_SET_FILAMENT_OFFSET:
358:                     look_up_offset = (signed int)data_word;
003092  90021E     MOV [W14+2], W4
003094  884094     MOV W4, look_up_offset
359:                     break;
003096  370222     BRA 0x34DC
360:               
361:                   case CMD_SET_SCALE_INTERLEAVED:
362:                     scale_interleaved = data_word;
003098  90021E     MOV [W14+2], W4
00309A  88B704     MOV W4, scale_interleaved
363:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_INTERLEAVED_POWER_SCALE] = data_word;
00309C  90021E     MOV [W14+2], W4
00309E  88C274     MOV W4, 0x184E
364:                     _wait_eedata();
0030A0  803B05     MOV NVMCON, W5
0030A2  280004     MOV #0x8000, W4
0030A4  628204     AND W5, W4, W4
0030A6  520FE0     SUB W4, #0x0, [W15]
0030A8  3AFFFB     BRA NZ, 0x30A0
365:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
0030AA  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
0030AC  80C1D5     MOV 0x183A, W5
0030AE  200202     MOV #0x20, W2
0030B0  BE0004     MOV.D W4, W0
0030B2  07E8AF     RCALL __eedata_helper1
366:                     _wait_eedata();
0030B4  803B05     MOV NVMCON, W5
0030B6  280004     MOV #0x8000, W4
0030B8  628204     AND W5, W4, W4
0030BA  520FE0     SUB W4, #0x0, [W15]
0030BC  3AFFFB     BRA NZ, 0x30B4
367:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);   
0030BE  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
0030C0  80C1D5     MOV 0x183A, W5
0030C2  2183C2     MOV #0x183C, W2
0030C4  BE0004     MOV.D W4, W0
0030C6  07E8C4     RCALL __eedata_helper4
368:                     break;
0030C8  370209     BRA 0x34DC
369:                     
370:                   case CMD_SET_SCALE_LOW_ENERGY:
371:                     scale_low_energy = data_word;
0030CA  90001E     MOV [W14+2], W0
0030CC  88B710     MOV W0, scale_low_energy
372:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_POWER_SCALE] = data_word;
0030CE  90021E     MOV [W14+2], W4
0030D0  88C284     MOV W4, 0x1850
373:                     _wait_eedata();
0030D2  803B05     MOV NVMCON, W5
0030D4  280004     MOV #0x8000, W4
0030D6  628204     AND W5, W4, W4
0030D8  520FE0     SUB W4, #0x0, [W15]
0030DA  3AFFFB     BRA NZ, 0x30D2
374:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
0030DC  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
0030DE  80C1D5     MOV 0x183A, W5
0030E0  200202     MOV #0x20, W2
0030E2  BE0004     MOV.D W4, W0
0030E4  07E896     RCALL __eedata_helper1
375:                     _wait_eedata();
0030E6  803B05     MOV NVMCON, W5
0030E8  280004     MOV #0x8000, W4
0030EA  628204     AND W5, W4, W4
0030EC  520FE0     SUB W4, #0x0, [W15]
0030EE  3AFFFB     BRA NZ, 0x30E6
376:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);   
0030F0  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
0030F2  80C1D5     MOV 0x183A, W5
0030F4  2183C2     MOV #0x183C, W2
0030F6  BE0004     MOV.D W4, W0
0030F8  07E8AB     RCALL __eedata_helper4
377:                     break;
0030FA  3701F0     BRA 0x34DC
378:               
379:                   case CMD_SET_TARGET_CURRENT_STARTUP_MAGNITUDE:
380:                     max_low_energy_target_current_startup_adjust_initital_value = data_word;
0030FC  90021E     MOV [W14+2], W4
0030FE  88C4E4     MOV W4, 0x189C
381:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_MAX_MAGNITUDE] = max_low_energy_target_current_startup_adjust_initital_value;
003100  80C4E4     MOV 0x189C, W4
003102  88C244     MOV W4, 0x1848
382:                     _wait_eedata();
003104  803B05     MOV NVMCON, W5
003106  280004     MOV #0x8000, W4
003108  628204     AND W5, W4, W4
00310A  520FE0     SUB W4, #0x0, [W15]
00310C  3AFFFB     BRA NZ, 0x3104
383:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
00310E  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003110  80C1D5     MOV 0x183A, W5
003112  200202     MOV #0x20, W2
003114  BE0004     MOV.D W4, W0
003116  07E87D     RCALL __eedata_helper1
384:                     _wait_eedata();
003118  803B05     MOV NVMCON, W5
00311A  280004     MOV #0x8000, W4
00311C  628204     AND W5, W4, W4
00311E  520FE0     SUB W4, #0x0, [W15]
003120  3AFFFB     BRA NZ, 0x3118
385:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
003122  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003124  80C1D5     MOV 0x183A, W5
003126  2183C2     MOV #0x183C, W2
003128  BE0004     MOV.D W4, W0
00312A  07E892     RCALL __eedata_helper4
386:                     break;
00312C  3701D7     BRA 0x34DC
387:               
388:                   case CMD_SET_TARGET_CURRENT_STARTUP_DIRECTION:
389:                     low_energy_target_current_startup_max_cooldown = data_word;
00312E  90001E     MOV [W14+2], W0
003130  88C4F0     MOV W0, 0x189E
390:                     control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_MAX_COOLDOWN] = low_energy_target_current_startup_max_cooldown;
003132  80C4F4     MOV 0x189E, W4
003134  88C254     MOV W4, 0x184A
391:                     _wait_eedata();
003136  803B05     MOV NVMCON, W5
003138  280004     MOV #0x8000, W4
00313A  628204     AND W5, W4, W4
00313C  520FE0     SUB W4, #0x0, [W15]
00313E  3AFFFB     BRA NZ, 0x3136
392:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
003140  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003142  80C1D5     MOV 0x183A, W5
003144  200202     MOV #0x20, W2
003146  BE0004     MOV.D W4, W0
003148  07E864     RCALL __eedata_helper1
393:                     _wait_eedata();
00314A  803B05     MOV NVMCON, W5
00314C  280004     MOV #0x8000, W4
00314E  628204     AND W5, W4, W4
003150  520FE0     SUB W4, #0x0, [W15]
003152  3AFFFB     BRA NZ, 0x314A
394:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);      
003154  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003156  80C1D5     MOV 0x183A, W5
003158  2183C2     MOV #0x183C, W2
00315A  BE0004     MOV.D W4, W0
00315C  07E879     RCALL __eedata_helper4
395:                     break;
00315E  3701BE     BRA 0x34DC
396:               
397:               
398:                   case CMD_FORCE_SOFTWARE_RESTART:
399:                     /*
400:               	We don't want to be forcing software resets on a production system
401:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
402:                     __delay32(100000); // this should be 10ms
403:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 1;
404:                     __delay32(100);
405:                     PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
406:                    __asm__ ("Reset");
407:                     */
408:                     break;
409:               
410:                   case CMD_SOFTWARE_SKIP_WARMUP:
411:                     if (control_state == STATE_WARM_UP) {
003160  208405     MOV #0x840, W5
003162  784295     MOV.B [W5], W5
003164  B3C244     MOV.B #0x24, W4
003166  52CF84     SUB.B W5, W4, [W15]
003168  3A01B8     BRA NZ, 0x34DA
412:               	software_skip_warmup = 1;
00316A  200014     MOV #0x1, W4
00316C  88C564     MOV W4, 0x18AC
413:                     }
414:                     break;
00316E  3701B6     BRA 0x34DC
0034DA  000000     NOP
415:               
416:                   case CMD_SET_MAGNET_PS_CAL_DATA:
417:                     ps_magnet_config_ram_copy[command_string.register_byte] = data_word;
003170  218C54     MOV #0x18C5, W4
003172  784214     MOV.B [W4], W4
003174  FB8204     ZE W4, W4
003176  90029E     MOV [W14+2], W5
003178  420304     ADD W4, W4, W6
00317A  216F84     MOV #0x16F8, W4
00317C  430204     ADD W6, W4, W4
00317E  780A05     MOV W5, [W4]
418:                     break;
003180  3701AD     BRA 0x34DC
419:                     
420:                   case CMD_READ_MAGNET_PS_CAL_DATA:
421:                     return_data_word = ps_magnet_config_ram_copy[command_string.register_byte];
003182  218C54     MOV #0x18C5, W4
003184  784214     MOV.B [W4], W4
003186  FB8204     ZE W4, W4
003188  420284     ADD W4, W4, W5
00318A  216F84     MOV #0x16F8, W4
00318C  428204     ADD W5, W4, W4
00318E  780214     MOV [W4], W4
003190  780F04     MOV W4, [W14]
422:                     break;
003192  3701A4     BRA 0x34DC
423:                     
424:                   case CMD_SAVE_MAGNET_PS_CAL_DATA_TO_EEPROM:
425:                     _wait_eedata();
003194  803B05     MOV NVMCON, W5
003196  280004     MOV #0x8000, W4
003198  628204     AND W5, W4, W4
00319A  520FE0     SUB W4, #0x0, [W15]
00319C  3AFFFB     BRA NZ, 0x3194
426:                     _erase_eedata(EE_address_ps_magnet_config_in_EEPROM, _EE_ROW);
00319E  80B7A4     MOV EE_address_ps_magnet_config_in_EEPROM, W4
0031A0  80B7B5     MOV 0x16F6, W5
0031A2  200202     MOV #0x20, W2
0031A4  BE0004     MOV.D W4, W0
0031A6  07E835     RCALL __eedata_helper1
427:                     _wait_eedata();
0031A8  803B05     MOV NVMCON, W5
0031AA  280004     MOV #0x8000, W4
0031AC  628204     AND W5, W4, W4
0031AE  520FE0     SUB W4, #0x0, [W15]
0031B0  3AFFFB     BRA NZ, 0x31A8
428:                     _write_eedata_row(EE_address_ps_magnet_config_in_EEPROM, ps_magnet_config_ram_copy);
0031B2  80B7A4     MOV EE_address_ps_magnet_config_in_EEPROM, W4
0031B4  80B7B5     MOV 0x16F6, W5
0031B6  216F82     MOV #0x16F8, W2
0031B8  BE0004     MOV.D W4, W0
0031BA  07E84A     RCALL __eedata_helper4
429:                     break;
0031BC  37018F     BRA 0x34DC
430:               
431:                   case CMD_SET_FILAMENT_PS_CAL_DATA:
432:                     ps_filament_config_ram_copy[command_string.register_byte] = data_word;
0031BE  218C54     MOV #0x18C5, W4
0031C0  784214     MOV.B [W4], W4
0031C2  FB8204     ZE W4, W4
0031C4  90029E     MOV [W14+2], W5
0031C6  420304     ADD W4, W4, W6
0031C8  2171C4     MOV #0x171C, W4
0031CA  430204     ADD W6, W4, W4
0031CC  780A05     MOV W5, [W4]
433:                     break;
0031CE  370186     BRA 0x34DC
434:                     
435:                   case CMD_READ_FILAMENT_PS_CAL_DATA:
436:                     return_data_word = ps_filament_config_ram_copy[command_string.register_byte];
0031D0  218C54     MOV #0x18C5, W4
0031D2  784214     MOV.B [W4], W4
0031D4  FB8204     ZE W4, W4
0031D6  420284     ADD W4, W4, W5
0031D8  2171C4     MOV #0x171C, W4
0031DA  428204     ADD W5, W4, W4
0031DC  780214     MOV [W4], W4
0031DE  780F04     MOV W4, [W14]
437:                     break;
0031E0  37017D     BRA 0x34DC
438:                     
439:                   case CMD_SAVE_FILAMENT_PS_CAL_DATA_TO_EEPROM:
440:                     _wait_eedata();
0031E2  803B05     MOV NVMCON, W5
0031E4  280004     MOV #0x8000, W4
0031E6  628204     AND W5, W4, W4
0031E8  520FE0     SUB W4, #0x0, [W15]
0031EA  3AFFFB     BRA NZ, 0x31E2
441:                     _erase_eedata(EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
0031EC  80B8C4     MOV EE_address_ps_filament_config_in_EEPROM, W4
0031EE  80B8D5     MOV 0x171A, W5
0031F0  200202     MOV #0x20, W2
0031F2  BE0004     MOV.D W4, W0
0031F4  07E80E     RCALL __eedata_helper1
442:                     _wait_eedata();
0031F6  803B05     MOV NVMCON, W5
0031F8  280004     MOV #0x8000, W4
0031FA  628204     AND W5, W4, W4
0031FC  520FE0     SUB W4, #0x0, [W15]
0031FE  3AFFFB     BRA NZ, 0x31F6
443:                     _write_eedata_row(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_ram_copy);
003200  80B8C4     MOV EE_address_ps_filament_config_in_EEPROM, W4
003202  80B8D5     MOV 0x171A, W5
003204  2171C2     MOV #0x171C, W2
003206  BE0004     MOV.D W4, W0
003208  07E823     RCALL __eedata_helper4
444:                     break;
00320A  370168     BRA 0x34DC
445:               
446:                   case CMD_SET_THYR_CATHODE_PS_CAL_DATA:
447:                     ps_thyr_cathode_htr_config_ram_copy[command_string.register_byte] = data_word;
00320C  218C54     MOV #0x18C5, W4
00320E  784214     MOV.B [W4], W4
003210  FB8204     ZE W4, W4
003212  90029E     MOV [W14+2], W5
003214  420304     ADD W4, W4, W6
003216  217404     MOV #0x1740, W4
003218  430204     ADD W6, W4, W4
00321A  780A05     MOV W5, [W4]
448:                     break;
00321C  37015F     BRA 0x34DC
449:                     
450:                   case CMD_READ_THYR_CATHODE_PS_CAL_DATA:
451:                     return_data_word = ps_thyr_cathode_htr_config_ram_copy[command_string.register_byte];
00321E  218C54     MOV #0x18C5, W4
003220  784214     MOV.B [W4], W4
003222  FB8204     ZE W4, W4
003224  420284     ADD W4, W4, W5
003226  217404     MOV #0x1740, W4
003228  428204     ADD W5, W4, W4
00322A  780214     MOV [W4], W4
00322C  780F04     MOV W4, [W14]
452:                     break;
00322E  370156     BRA 0x34DC
453:                     
454:                   case CMD_SAVE_THYR_CATHODE_PS_CAL_DATA_TO_EEPROM:
455:                     _wait_eedata();
003230  803B05     MOV NVMCON, W5
003232  280004     MOV #0x8000, W4
003234  628204     AND W5, W4, W4
003236  520FE0     SUB W4, #0x0, [W15]
003238  3AFFFB     BRA NZ, 0x3230
456:                     _erase_eedata(EE_address_ps_thyr_cathode_htr_config_in_EEPROM, _EE_ROW);
00323A  80B9E4     MOV EE_address_ps_thyr_cathode_htr_config_in_EEPROM, W4
00323C  80B9F5     MOV 0x173E, W5
00323E  200202     MOV #0x20, W2
003240  BE0004     MOV.D W4, W0
003242  07E7E7     RCALL __eedata_helper1
457:                     _wait_eedata();
003244  803B05     MOV NVMCON, W5
003246  280004     MOV #0x8000, W4
003248  628204     AND W5, W4, W4
00324A  520FE0     SUB W4, #0x0, [W15]
00324C  3AFFFB     BRA NZ, 0x3244
458:                     _write_eedata_row(EE_address_ps_thyr_cathode_htr_config_in_EEPROM, ps_thyr_cathode_htr_config_ram_copy);
00324E  80B9E4     MOV EE_address_ps_thyr_cathode_htr_config_in_EEPROM, W4
003250  80B9F5     MOV 0x173E, W5
003252  217402     MOV #0x1740, W2
003254  BE0004     MOV.D W4, W0
003256  07E7FC     RCALL __eedata_helper4
459:                     break;
003258  370141     BRA 0x34DC
460:               
461:                   case CMD_SET_THYR_RESERVOIR_PS_CAL_DATA:
462:                     ps_thyr_reservoir_htr_config_ram_copy[command_string.register_byte] = data_word;
00325A  218C54     MOV #0x18C5, W4
00325C  784214     MOV.B [W4], W4
00325E  FB8204     ZE W4, W4
003260  90029E     MOV [W14+2], W5
003262  420304     ADD W4, W4, W6
003264  217644     MOV #0x1764, W4
003266  430204     ADD W6, W4, W4
003268  780A05     MOV W5, [W4]
463:                     break;
00326A  370138     BRA 0x34DC
464:                     
465:                   case CMD_READ_THYR_RESERVOIR_PS_CAL_DATA:
466:                     return_data_word = ps_thyr_reservoir_htr_config_ram_copy[command_string.register_byte];
00326C  218C54     MOV #0x18C5, W4
00326E  784214     MOV.B [W4], W4
003270  FB8204     ZE W4, W4
003272  420284     ADD W4, W4, W5
003274  217644     MOV #0x1764, W4
003276  428204     ADD W5, W4, W4
003278  780214     MOV [W4], W4
00327A  780F04     MOV W4, [W14]
467:                     break;
00327C  37012F     BRA 0x34DC
468:                     
469:                   case CMD_SAVE_THYR_RESERVOIR_PS_CAL_DATA_TO_EEPROM:
470:                     _wait_eedata();
00327E  803B05     MOV NVMCON, W5
003280  280004     MOV #0x8000, W4
003282  628204     AND W5, W4, W4
003284  520FE0     SUB W4, #0x0, [W15]
003286  3AFFFB     BRA NZ, 0x327E
471:                     _erase_eedata(EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, _EE_ROW);
003288  80BB04     MOV EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, W4
00328A  80BB15     MOV 0x1762, W5
00328C  200202     MOV #0x20, W2
00328E  BE0004     MOV.D W4, W0
003290  07E7C0     RCALL __eedata_helper1
472:                     _wait_eedata();
003292  803B05     MOV NVMCON, W5
003294  280004     MOV #0x8000, W4
003296  628204     AND W5, W4, W4
003298  520FE0     SUB W4, #0x0, [W15]
00329A  3AFFFB     BRA NZ, 0x3292
473:                     _write_eedata_row(EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, ps_thyr_reservoir_htr_config_ram_copy);
00329C  80BB04     MOV EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, W4
00329E  80BB15     MOV 0x1762, W5
0032A0  217642     MOV #0x1764, W2
0032A2  BE0004     MOV.D W4, W0
0032A4  07E7D5     RCALL __eedata_helper4
474:                     break;
0032A6  37011A     BRA 0x34DC
475:               
476:                   case CMD_SET_HV_LAMBDA_MODE_A_CAL_DATA:
477:                     ps_hv_lambda_mode_A_config_ram_copy[command_string.register_byte] = data_word;
0032A8  218C54     MOV #0x18C5, W4
0032AA  784214     MOV.B [W4], W4
0032AC  FB8204     ZE W4, W4
0032AE  90029E     MOV [W14+2], W5
0032B0  420304     ADD W4, W4, W6
0032B2  217884     MOV #0x1788, W4
0032B4  430204     ADD W6, W4, W4
0032B6  780A05     MOV W5, [W4]
478:                     break;
0032B8  370111     BRA 0x34DC
479:                     
480:                   case CMD_READ_HV_LAMBDA_MODE_A_CAL_DATA:
481:                     return_data_word = ps_hv_lambda_mode_A_config_ram_copy[command_string.register_byte];
0032BA  218C54     MOV #0x18C5, W4
0032BC  784214     MOV.B [W4], W4
0032BE  FB8204     ZE W4, W4
0032C0  420284     ADD W4, W4, W5
0032C2  217884     MOV #0x1788, W4
0032C4  428204     ADD W5, W4, W4
0032C6  780214     MOV [W4], W4
0032C8  780F04     MOV W4, [W14]
482:                     break;
0032CA  370108     BRA 0x34DC
483:                     
484:                   case CMD_SAVE_HV_LAMBDA_MODE_A_CAL_DATA_TO_EEPROM:
485:                     _wait_eedata();
0032CC  803B05     MOV NVMCON, W5
0032CE  280004     MOV #0x8000, W4
0032D0  628204     AND W5, W4, W4
0032D2  520FE0     SUB W4, #0x0, [W15]
0032D4  3AFFFB     BRA NZ, 0x32CC
486:                     _erase_eedata(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, _EE_ROW);
0032D6  80BC24     MOV EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, W4
0032D8  80BC35     MOV 0x1786, W5
0032DA  200202     MOV #0x20, W2
0032DC  BE0004     MOV.D W4, W0
0032DE  07E799     RCALL __eedata_helper1
487:                     _wait_eedata();
0032E0  803B05     MOV NVMCON, W5
0032E2  280004     MOV #0x8000, W4
0032E4  628204     AND W5, W4, W4
0032E6  520FE0     SUB W4, #0x0, [W15]
0032E8  3AFFFB     BRA NZ, 0x32E0
488:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, ps_hv_lambda_mode_A_config_ram_copy);
0032EA  80BC24     MOV EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, W4
0032EC  80BC35     MOV 0x1786, W5
0032EE  217882     MOV #0x1788, W2
0032F0  BE0004     MOV.D W4, W0
0032F2  07E7AE     RCALL __eedata_helper4
489:                     break;
0032F4  3700F3     BRA 0x34DC
490:               
491:                   case CMD_SET_HV_LAMBDA_MODE_B_CAL_DATA:
492:                     ps_hv_lambda_mode_B_config_ram_copy[command_string.register_byte] = data_word;
0032F6  218C54     MOV #0x18C5, W4
0032F8  784214     MOV.B [W4], W4
0032FA  FB8204     ZE W4, W4
0032FC  90029E     MOV [W14+2], W5
0032FE  420304     ADD W4, W4, W6
003300  217AC4     MOV #0x17AC, W4
003302  430204     ADD W6, W4, W4
003304  780A05     MOV W5, [W4]
493:                     break;
003306  3700EA     BRA 0x34DC
494:                     
495:                   case CMD_READ_HV_LAMBDA_MODE_B_CAL_DATA:
496:                     return_data_word = ps_hv_lambda_mode_B_config_ram_copy[command_string.register_byte];
003308  218C54     MOV #0x18C5, W4
00330A  784214     MOV.B [W4], W4
00330C  FB8204     ZE W4, W4
00330E  420284     ADD W4, W4, W5
003310  217AC4     MOV #0x17AC, W4
003312  428204     ADD W5, W4, W4
003314  780214     MOV [W4], W4
003316  780F04     MOV W4, [W14]
497:                     break;
003318  3700E1     BRA 0x34DC
498:                     
499:                   case CMD_SAVE_HV_LAMBDA_MODE_B_CAL_DATA_TO_EEPROM:
500:                     _wait_eedata();
00331A  803B05     MOV NVMCON, W5
00331C  280004     MOV #0x8000, W4
00331E  628204     AND W5, W4, W4
003320  520FE0     SUB W4, #0x0, [W15]
003322  3AFFFB     BRA NZ, 0x331A
501:                     _erase_eedata(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, _EE_ROW);
003324  80BD44     MOV EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, W4
003326  80BD55     MOV 0x17AA, W5
003328  200202     MOV #0x20, W2
00332A  BE0004     MOV.D W4, W0
00332C  07E772     RCALL __eedata_helper1
502:                     _wait_eedata();
00332E  803B05     MOV NVMCON, W5
003330  280004     MOV #0x8000, W4
003332  628204     AND W5, W4, W4
003334  520FE0     SUB W4, #0x0, [W15]
003336  3AFFFB     BRA NZ, 0x332E
503:                     _write_eedata_row(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, ps_hv_lambda_mode_B_config_ram_copy);
003338  80BD44     MOV EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, W4
00333A  80BD55     MOV 0x17AA, W5
00333C  217AC2     MOV #0x17AC, W2
00333E  BE0004     MOV.D W4, W0
003340  07E787     RCALL __eedata_helper4
504:                     break;
003342  3700CC     BRA 0x34DC
505:               
506:                   case CMD_SET_MAGNETRON_MODE_A_CAL_DATA:
507:                     ps_magnetron_mode_A_config_ram_copy[command_string.register_byte] = data_word;
003344  218C54     MOV #0x18C5, W4
003346  784214     MOV.B [W4], W4
003348  FB8204     ZE W4, W4
00334A  90029E     MOV [W14+2], W5
00334C  420304     ADD W4, W4, W6
00334E  217D04     MOV #0x17D0, W4
003350  430204     ADD W6, W4, W4
003352  780A05     MOV W5, [W4]
508:                     break;
003354  3700C3     BRA 0x34DC
509:                     
510:                   case CMD_READ_MAGNETRON_MODE_A_CAL_DATA:
511:                     return_data_word = ps_magnetron_mode_A_config_ram_copy[command_string.register_byte];
003356  218C54     MOV #0x18C5, W4
003358  784214     MOV.B [W4], W4
00335A  FB8204     ZE W4, W4
00335C  420284     ADD W4, W4, W5
00335E  217D04     MOV #0x17D0, W4
003360  428204     ADD W5, W4, W4
003362  780214     MOV [W4], W4
003364  780F04     MOV W4, [W14]
512:                     break;
003366  3700BA     BRA 0x34DC
513:                     
514:                   case CMD_SAVE_MAGNETRON_MODE_A_CAL_DATA_TO_EEPROM:
515:                     _wait_eedata();
003368  803B05     MOV NVMCON, W5
00336A  280004     MOV #0x8000, W4
00336C  628204     AND W5, W4, W4
00336E  520FE0     SUB W4, #0x0, [W15]
003370  3AFFFB     BRA NZ, 0x3368
516:                     _erase_eedata(EE_address_ps_magnetron_mode_A_config_in_EEPROM, _EE_ROW);
003372  80BE64     MOV EE_address_ps_magnetron_mode_A_config_in_EEPROM, W4
003374  80BE75     MOV 0x17CE, W5
003376  200202     MOV #0x20, W2
003378  BE0004     MOV.D W4, W0
00337A  07E74B     RCALL __eedata_helper1
517:                     _wait_eedata();
00337C  803B05     MOV NVMCON, W5
00337E  280004     MOV #0x8000, W4
003380  628204     AND W5, W4, W4
003382  520FE0     SUB W4, #0x0, [W15]
003384  3AFFFB     BRA NZ, 0x337C
518:                     _write_eedata_row(EE_address_ps_magnetron_mode_A_config_in_EEPROM, ps_magnetron_mode_A_config_ram_copy);
003386  80BE64     MOV EE_address_ps_magnetron_mode_A_config_in_EEPROM, W4
003388  80BE75     MOV 0x17CE, W5
00338A  217D02     MOV #0x17D0, W2
00338C  BE0004     MOV.D W4, W0
00338E  07E760     RCALL __eedata_helper4
519:                     break;
003390  3700A5     BRA 0x34DC
520:               
521:                   case CMD_SET_MAGNETRON_MODE_B_CAL_DATA:
522:                     ps_magnetron_mode_B_config_ram_copy[command_string.register_byte] = data_word;
003392  218C54     MOV #0x18C5, W4
003394  784214     MOV.B [W4], W4
003396  FB8204     ZE W4, W4
003398  90029E     MOV [W14+2], W5
00339A  420304     ADD W4, W4, W6
00339C  217F44     MOV #0x17F4, W4
00339E  430204     ADD W6, W4, W4
0033A0  780A05     MOV W5, [W4]
523:                     break;
0033A2  37009C     BRA 0x34DC
524:                     
525:                   case CMD_READ_MAGNETRON_MODE_B_CAL_DATA:
526:                     return_data_word = ps_magnetron_mode_B_config_ram_copy[command_string.register_byte];
0033A4  218C54     MOV #0x18C5, W4
0033A6  784214     MOV.B [W4], W4
0033A8  FB8204     ZE W4, W4
0033AA  420284     ADD W4, W4, W5
0033AC  217F44     MOV #0x17F4, W4
0033AE  428204     ADD W5, W4, W4
0033B0  780214     MOV [W4], W4
0033B2  780F04     MOV W4, [W14]
527:                     break;
0033B4  370093     BRA 0x34DC
528:                     
529:                   case CMD_SAVE_MAGNETRON_MODE_B_CAL_DATA_TO_EEPROM:
530:                     _wait_eedata();
0033B6  803B05     MOV NVMCON, W5
0033B8  280004     MOV #0x8000, W4
0033BA  628204     AND W5, W4, W4
0033BC  520FE0     SUB W4, #0x0, [W15]
0033BE  3AFFFB     BRA NZ, 0x33B6
531:                     _erase_eedata(EE_address_ps_magnetron_mode_B_config_in_EEPROM, _EE_ROW);
0033C0  80BF84     MOV EE_address_ps_magnetron_mode_B_config_in_EEPROM, W4
0033C2  80BF95     MOV 0x17F2, W5
0033C4  200202     MOV #0x20, W2
0033C6  BE0004     MOV.D W4, W0
0033C8  07E724     RCALL __eedata_helper1
532:                     _wait_eedata();
0033CA  803B05     MOV NVMCON, W5
0033CC  280004     MOV #0x8000, W4
0033CE  628204     AND W5, W4, W4
0033D0  520FE0     SUB W4, #0x0, [W15]
0033D2  3AFFFB     BRA NZ, 0x33CA
533:                     _write_eedata_row(EE_address_ps_magnetron_mode_B_config_in_EEPROM, ps_magnetron_mode_B_config_ram_copy);
0033D4  80BF84     MOV EE_address_ps_magnetron_mode_B_config_in_EEPROM, W4
0033D6  80BF95     MOV 0x17F2, W5
0033D8  217F42     MOV #0x17F4, W2
0033DA  BE0004     MOV.D W4, W0
0033DC  07E739     RCALL __eedata_helper4
534:                     break;
0033DE  37007E     BRA 0x34DC
535:               
536:                   case CMD_SET_CNTRL_CAL_DATA:
537:                     control_loop_cal_data_ram_copy[command_string.register_byte] = data_word;
0033E0  218C54     MOV #0x18C5, W4
0033E2  784214     MOV.B [W4], W4
0033E4  FB8204     ZE W4, W4
0033E6  90029E     MOV [W14+2], W5
0033E8  420304     ADD W4, W4, W6
0033EA  2183C4     MOV #0x183C, W4
0033EC  430204     ADD W6, W4, W4
0033EE  780A05     MOV W5, [W4]
538:                     break;
0033F0  370075     BRA 0x34DC
539:               
540:                   case CMD_READ_CNTRL_CAL_DATA:
541:                     return_data_word = control_loop_cal_data_ram_copy[command_string.register_byte];
0033F2  218C54     MOV #0x18C5, W4
0033F4  784214     MOV.B [W4], W4
0033F6  FB8204     ZE W4, W4
0033F8  420284     ADD W4, W4, W5
0033FA  2183C4     MOV #0x183C, W4
0033FC  428204     ADD W5, W4, W4
0033FE  780214     MOV [W4], W4
003400  780F04     MOV W4, [W14]
542:                     break;
003402  37006C     BRA 0x34DC
543:                     
544:                   case CMD_SAVE_CNTRL_CAL_DATA_TO_EEPROM:
545:                     _wait_eedata();
003404  803B05     MOV NVMCON, W5
003406  280004     MOV #0x8000, W4
003408  628204     AND W5, W4, W4
00340A  520FE0     SUB W4, #0x0, [W15]
00340C  3AFFFB     BRA NZ, 0x3404
546:                     _erase_eedata(EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
00340E  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003410  80C1D5     MOV 0x183A, W5
003412  200202     MOV #0x20, W2
003414  BE0004     MOV.D W4, W0
003416  07E6FD     RCALL __eedata_helper1
547:                     _wait_eedata();
003418  803B05     MOV NVMCON, W5
00341A  280004     MOV #0x8000, W4
00341C  628204     AND W5, W4, W4
00341E  520FE0     SUB W4, #0x0, [W15]
003420  3AFFFB     BRA NZ, 0x3418
548:                     _write_eedata_row(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_ram_copy);
003422  80C1C4     MOV EE_address_control_loop_cal_data_in_EEPROM, W4
003424  80C1D5     MOV 0x183A, W5
003426  2183C2     MOV #0x183C, W2
003428  BE0004     MOV.D W4, W0
00342A  07E712     RCALL __eedata_helper4
549:                     break;
00342C  370057     BRA 0x34DC
550:               
551:               
552:               
553:                   case CMD_SET_MAGNETRON_FILAMENT_CURRENT:
554:                     itemp = data_word;
00342E  90021E     MOV [W14+2], W4
003430  980734     MOV W4, [W14+6]
555:                     vtemp = GenerateFilamentVprog(itemp);
003432  90003E     MOV [W14+6], W0
003434  07038D     RCALL GenerateFilamentVprog
003436  780200     MOV W0, W4
003438  980744     MOV W4, [W14+8]
556:                     SetPowerSupplyTarget(&ps_filament, vtemp, itemp);
00343A  90013E     MOV [W14+6], W2
00343C  9000CE     MOV [W14+8], W1
00343E  20ACA0     MOV #0xACA, W0
003440  07F028     RCALL SetPowerSupplyTarget
557:                     ps_filament_config_ram_copy[EEPROM_V_SET_POINT] = ps_filament.v_command_set_point;
003442  805664     MOV 0xACC, W4
003444  88B8E4     MOV W4, ps_filament_config_ram_copy
558:                     ps_filament_config_ram_copy[EEPROM_I_SET_POINT] = ps_filament.i_command_set_point;
003446  8057C4     MOV 0xAF8, W4
003448  88B934     MOV W4, 0x1726
559:                     _wait_eedata();
00344A  803B05     MOV NVMCON, W5
00344C  280004     MOV #0x8000, W4
00344E  628204     AND W5, W4, W4
003450  520FE0     SUB W4, #0x0, [W15]
003452  3AFFFB     BRA NZ, 0x344A
560:                     _erase_eedata(EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
003454  80B8C4     MOV EE_address_ps_filament_config_in_EEPROM, W4
003456  80B8D5     MOV 0x171A, W5
003458  200202     MOV #0x20, W2
00345A  BE0004     MOV.D W4, W0
00345C  07E6DA     RCALL __eedata_helper1
561:                     _wait_eedata();
00345E  803B05     MOV NVMCON, W5
003460  280004     MOV #0x8000, W4
003462  628204     AND W5, W4, W4
003464  520FE0     SUB W4, #0x0, [W15]
003466  3AFFFB     BRA NZ, 0x345E
562:                     _write_eedata_row(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_ram_copy);
003468  80B8C4     MOV EE_address_ps_filament_config_in_EEPROM, W4
00346A  80B8D5     MOV 0x171A, W5
00346C  2171C2     MOV #0x171C, W2
00346E  BE0004     MOV.D W4, W0
003470  07E6EF     RCALL __eedata_helper4
563:                     break;
003472  370034     BRA 0x34DC
564:               
565:                   case CMD_SET_MAGNETRON_FILAMENT_VOLTAGE:
566:                     vtemp = data_word;
003474  90001E     MOV [W14+2], W0
003476  980740     MOV W0, [W14+8]
567:                     itemp = GenerateFilamentIprog(vtemp);
003478  90004E     MOV [W14+8], W0
00347A  07035F     RCALL GenerateFilamentIprog
00347C  780200     MOV W0, W4
00347E  980734     MOV W4, [W14+6]
568:                     SetPowerSupplyTarget(&ps_filament, vtemp, itemp);
003480  90013E     MOV [W14+6], W2
003482  9000CE     MOV [W14+8], W1
003484  20ACA0     MOV #0xACA, W0
003486  07F005     RCALL SetPowerSupplyTarget
569:                     ps_filament_config_ram_copy[EEPROM_V_SET_POINT] = ps_filament.v_command_set_point;
003488  805664     MOV 0xACC, W4
00348A  88B8E4     MOV W4, ps_filament_config_ram_copy
570:                     ps_filament_config_ram_copy[EEPROM_I_SET_POINT] = ps_filament.i_command_set_point;
00348C  8057C4     MOV 0xAF8, W4
00348E  88B934     MOV W4, 0x1726
571:                     _wait_eedata();
003490  803B05     MOV NVMCON, W5
003492  280004     MOV #0x8000, W4
003494  628204     AND W5, W4, W4
003496  520FE0     SUB W4, #0x0, [W15]
003498  3AFFFB     BRA NZ, 0x3490
572:                     _erase_eedata(EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
00349A  80B8C4     MOV EE_address_ps_filament_config_in_EEPROM, W4
00349C  80B8D5     MOV 0x171A, W5
00349E  200202     MOV #0x20, W2
0034A0  BE0004     MOV.D W4, W0
0034A2  07E6B7     RCALL __eedata_helper1
573:                     _wait_eedata();
0034A4  803B05     MOV NVMCON, W5
0034A6  280004     MOV #0x8000, W4
0034A8  628204     AND W5, W4, W4
0034AA  520FE0     SUB W4, #0x0, [W15]
0034AC  3AFFFB     BRA NZ, 0x34A4
574:                     _write_eedata_row(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_ram_copy);
0034AE  80B8C4     MOV EE_address_ps_filament_config_in_EEPROM, W4
0034B0  80B8D5     MOV 0x171A, W5
0034B2  2171C2     MOV #0x171C, W2
0034B4  BE0004     MOV.D W4, W0
0034B6  07E6CC     RCALL __eedata_helper4
575:                     break;
0034B8  370011     BRA 0x34DC
576:               
577:                   case CMD_CLEAR_PROCESSOR_RESET_DATA:
578:                     // DPARKER using this command to reset "reset data"
579:                     debug_status_register = 0;
0034BA  EB0200     CLR W4
0034BC  88C394     MOV W4, debug_status_register
580:                     _POR = 0;
0034BE  A90740     BCLR RCON, #0
581:                     _EXTR = 0;
0034C0  A9E740     BCLR RCON, #7
582:                     _SWR = 0;
0034C2  A9C740     BCLR RCON, #6
583:                     _BOR = 0;
0034C4  A92740     BCLR RCON, #1
584:                     _TRAPR = 0;
0034C6  A9E741     BCLR 0x741, #7
585:                     _WDTO = 0;
0034C8  A98740     BCLR RCON, #4
586:                     _IOPUWR = 0;
0034CA  A9C741     BCLR 0x741, #6
587:                     last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
0034CC  EB0200     CLR W4
0034CE  88C6B4     MOV W4, last_known_action
588:                     processor_crash_count = 0;
0034D0  EB0200     CLR W4
0034D2  88C6D4     MOV W4, processor_crash_count
589:                     break;
0034D4  370003     BRA 0x34DC
590:               
591:               
592:                   }
593:                 
594:                 // Echo the command that was recieved back to the controller
595:                 SendCommand(return_command_byte, command_string.register_byte, return_data_word);
0034DC  218C55     MOV #0x18C5, W5
0034DE  784295     MOV.B [W5], W5
0034E0  90022E     MOV [W14+4], W4
0034E2  784204     MOV.B W4, W4
0034E4  78011E     MOV [W14], W2
0034E6  784085     MOV.B W5, W1
0034E8  784004     MOV.B W4, W0
0034EA  07FB4D     RCALL SendCommand
596:                 
597:                 command_string.data_state = COMMAND_BUFFER_EMPTY;
0034EC  EB4200     CLR.B W4
0034EE  784004     MOV.B W4, W0
0034F0  B7F8C8     MOV.B WREG, 0x18C8
598:               }
0034F2  FA8000     ULNK
0034F4  060000     RETURN
599:               
600:               
601:               
602:               unsigned int ReadFromRam(unsigned int ram_location) {
0034F6  FA0010     LNK #0x10
0034F8  BE9F88     MOV.D W8, [W15++]
0034FA  BE9F8A     MOV.D W10, [W15++]
0034FC  980770     MOV W0, [W14+14]
603:                 unsigned long temp_long;
604:                 unsigned int data_return;
605:                 unsigned long long int temp_long_long;
606:                 switch (ram_location) 
0034FE  90027E     MOV [W14+14], W4
003500  B82361     MUL.UU W4, #1, W6
003502  EB8200     SETM W4
003504  EB8280     SETM W5
003506  420206     ADD W4, W6, W4
003508  4A8287     ADDC W5, W7, W5
00350A  200B66     MOV #0xB6, W6
00350C  200007     MOV #0x0, W7
00350E  520F86     SUB W4, W6, [W15]
003510  5A8F87     SUBB W5, W7, [W15]
003512  3E028B     BRA GTU, 0x3A2A
003514  016004     BRA W4
003516  370226     BRA 0x3964
003518  37022A     BRA 0x396E
00351A  37022C     BRA 0x3974
00351C  370230     BRA 0x397E
00351E  370232     BRA 0x3984
003520  370284     BRA 0x3A2A
003522  370283     BRA 0x3A2A
003524  370282     BRA 0x3A2A
003526  370281     BRA 0x3A2A
003528  370280     BRA 0x3A2A
00352A  37027F     BRA 0x3A2A
00352C  37027E     BRA 0x3A2A
00352E  37027D     BRA 0x3A2A
003530  37027C     BRA 0x3A2A
003532  37027B     BRA 0x3A2A
003534  3700D5     BRA 0x36E0
003536  3700D1     BRA 0x36DA
003538  3700DD     BRA 0x36F4
00353A  3700D9     BRA 0x36EE
00353C  370276     BRA 0x3A2A
00353E  370275     BRA 0x3A2A
003540  370274     BRA 0x3A2A
003542  370273     BRA 0x3A2A
003544  370272     BRA 0x3A2A
003546  370271     BRA 0x3A2A
003548  370270     BRA 0x3A2A
00354A  37026F     BRA 0x3A2A
00354C  37026E     BRA 0x3A2A
00354E  37026D     BRA 0x3A2A
003550  37026C     BRA 0x3A2A
003552  37026B     BRA 0x3A2A
003554  3700A8     BRA 0x36A6
003556  3700B5     BRA 0x36C2
003558  3700AD     BRA 0x36B4
00355A  3700B6     BRA 0x36C8
00355C  370266     BRA 0x3A2A
00355E  370265     BRA 0x3A2A
003560  370264     BRA 0x3A2A
003562  370263     BRA 0x3A2A
003564  370262     BRA 0x3A2A
003566  370261     BRA 0x3A2A
003568  370260     BRA 0x3A2A
00356A  37025F     BRA 0x3A2A
00356C  37025E     BRA 0x3A2A
00356E  37025D     BRA 0x3A2A
003570  37025C     BRA 0x3A2A
003572  37025B     BRA 0x3A2A
003574  37008E     BRA 0x3692
003576  370094     BRA 0x36A0
003578  370085     BRA 0x3684
00357A  370257     BRA 0x3A2A
00357C  370256     BRA 0x3A2A
00357E  370255     BRA 0x3A2A
003580  370254     BRA 0x3A2A
003582  370253     BRA 0x3A2A
003584  370252     BRA 0x3A2A
003586  370251     BRA 0x3A2A
003588  370250     BRA 0x3A2A
00358A  37024F     BRA 0x3A2A
00358C  37024E     BRA 0x3A2A
00358E  37024D     BRA 0x3A2A
003590  37024C     BRA 0x3A2A
003592  37024B     BRA 0x3A2A
003594  37009C     BRA 0x36CE
003596  370249     BRA 0x3A2A
003598  370248     BRA 0x3A2A
00359A  370247     BRA 0x3A2A
00359C  370246     BRA 0x3A2A
00359E  370245     BRA 0x3A2A
0035A0  370244     BRA 0x3A2A
0035A2  370243     BRA 0x3A2A
0035A4  370097     BRA 0x36D4
0035A6  370241     BRA 0x3A2A
0035A8  370240     BRA 0x3A2A
0035AA  37023F     BRA 0x3A2A
0035AC  37023E     BRA 0x3A2A
0035AE  37023D     BRA 0x3A2A
0035B0  37023C     BRA 0x3A2A
0035B2  37023B     BRA 0x3A2A
0035B4  3700FA     BRA 0x37AA
0035B6  370100     BRA 0x37B8
0035B8  370238     BRA 0x3A2A
0035BA  370237     BRA 0x3A2A
0035BC  370236     BRA 0x3A2A
0035BE  370235     BRA 0x3A2A
0035C0  370102     BRA 0x37C6
0035C2  37010E     BRA 0x37E0
0035C4  370114     BRA 0x37EE
0035C6  370116     BRA 0x37F4
0035C8  370129     BRA 0x381C
0035CA  37013C     BRA 0x3844
0035CC  370150     BRA 0x386E
0035CE  370159     BRA 0x3882
0035D0  370165     BRA 0x389C
0035D2  37022B     BRA 0x3A2A
0035D4  37017D     BRA 0x38D0
0035D6  37017F     BRA 0x38D6
0035D8  370181     BRA 0x38DC
0035DA  370183     BRA 0x38E2
0035DC  370189     BRA 0x38F0
0035DE  37018F     BRA 0x38FE
0035E0  370191     BRA 0x3904
0035E2  370193     BRA 0x390A
0035E4  370195     BRA 0x3910
0035E6  370221     BRA 0x3A2A
0035E8  370220     BRA 0x3A2A
0035EA  37021F     BRA 0x3A2A
0035EC  37021E     BRA 0x3A2A
0035EE  37021D     BRA 0x3A2A
0035F0  37021C     BRA 0x3A2A
0035F2  37021B     BRA 0x3A2A
0035F4  370086     BRA 0x3702
0035F6  37008C     BRA 0x3710
0035F8  370092     BRA 0x371E
0035FA  370098     BRA 0x372C
0035FC  37009E     BRA 0x373A
0035FE  3700A4     BRA 0x3748
003600  370214     BRA 0x3A2A
003602  370213     BRA 0x3A2A
003604  3700A8     BRA 0x3756
003606  3700AE     BRA 0x3764
003608  3700B4     BRA 0x3772
00360A  3700BA     BRA 0x3780
00360C  3700C0     BRA 0x378E
00360E  3700C6     BRA 0x379C
003610  37020C     BRA 0x3A2A
003612  37020B     BRA 0x3A2A
003614  37020A     BRA 0x3A2A
003616  370209     BRA 0x3A2A
003618  370208     BRA 0x3A2A
00361A  370207     BRA 0x3A2A
00361C  370206     BRA 0x3A2A
00361E  370205     BRA 0x3A2A
003620  370204     BRA 0x3A2A
003622  370203     BRA 0x3A2A
003624  370202     BRA 0x3A2A
003626  370201     BRA 0x3A2A
003628  370200     BRA 0x3A2A
00362A  3701FF     BRA 0x3A2A
00362C  3701FE     BRA 0x3A2A
00362E  3701FD     BRA 0x3A2A
003630  3701FC     BRA 0x3A2A
003632  3701FB     BRA 0x3A2A
003634  370170     BRA 0x3916
003636  370172     BRA 0x391C
003638  370174     BRA 0x3922
00363A  370176     BRA 0x3928
00363C  370178     BRA 0x392E
00363E  37017A     BRA 0x3934
003640  37017C     BRA 0x393A
003642  37017E     BRA 0x3940
003644  370180     BRA 0x3946
003646  370182     BRA 0x394C
003648  370184     BRA 0x3952
00364A  370186     BRA 0x3958
00364C  370188     BRA 0x395E
00364E  3701ED     BRA 0x3A2A
003650  3701EC     BRA 0x3A2A
003652  3701EB     BRA 0x3A2A
003654  37019A     BRA 0x398A
003656  37019C     BRA 0x3990
003658  37019E     BRA 0x3996
00365A  3701A0     BRA 0x399C
00365C  3701A2     BRA 0x39A2
00365E  3701A4     BRA 0x39A8
003660  3701A6     BRA 0x39AE
003662  3701A8     BRA 0x39B4
003664  3701AA     BRA 0x39BA
003666  3701B2     BRA 0x39CC
003668  3701BD     BRA 0x39E4
00366A  3701B9     BRA 0x39DE
00366C  3701B5     BRA 0x39D8
00366E  3701B1     BRA 0x39D2
003670  3701A7     BRA 0x39C0
003672  3701A9     BRA 0x39C6
003674  3701C2     BRA 0x39FA
003676  3701C4     BRA 0x3A00
003678  3701C6     BRA 0x3A06
00367A  3701C8     BRA 0x3A0C
00367C  3701CA     BRA 0x3A12
00367E  3701CC     BRA 0x3A18
003680  3701CE     BRA 0x3A1E
003682  3701D0     BRA 0x3A24
607:                   {
608:               
609:                     // Magnet Supply Data
610:                   case RAM_READ_MAGNETRON_MAGNET_VOLTAGE_ADC:
611:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnet, ps_magnet.v_adc_reading);
003684  805404     MOV 0xA80, W4
003686  780084     MOV W4, W1
003688  20A700     MOV #0xA70, W0
00368A  07026D     RCALL ReturnPowerSupplyADCScaledVoltage
00368C  780200     MOV W0, W4
00368E  780F04     MOV W4, [W14]
612:                     break;
003690  3701CC     BRA 0x3A2A
613:                     
614:                   case RAM_READ_MAGNETRON_MAGNET_CURRENT_ADC:
615:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnet, ps_magnet.i_adc_reading);
003692  805564     MOV 0xAAC, W4
003694  780084     MOV W4, W1
003696  20A700     MOV #0xA70, W0
003698  07029C     RCALL ReturnPowerSupplyADCScaledCurrent
00369A  780200     MOV W0, W4
00369C  780F04     MOV W4, [W14]
616:                     break;
00369E  3701C5     BRA 0x3A2A
617:                     
618:                   case RAM_READ_MAGNETRON_MAGNET_CURRENT_SET_POINT:
619:                     data_return = ps_magnet.i_command_set_point;
0036A0  8054F1     MOV 0xA9E, W1
0036A2  780F01     MOV W1, [W14]
620:                     break;
0036A4  3701C2     BRA 0x3A2A
621:               
622:               
623:                     // Filament Supply Data
624:                   case RAM_READ_MAGNETRON_FILAMENT_VOLTAGE_ADC:
625:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_filament, ps_filament.v_adc_reading);
0036A6  8056D4     MOV 0xADA, W4
0036A8  780084     MOV W4, W1
0036AA  20ACA0     MOV #0xACA, W0
0036AC  07025C     RCALL ReturnPowerSupplyADCScaledVoltage
0036AE  780200     MOV W0, W4
0036B0  780F04     MOV W4, [W14]
626:                     break;
0036B2  3701BB     BRA 0x3A2A
627:                     
628:                   case RAM_READ_MAGNETRON_FILAMENT_CURRENT_ADC:
629:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_filament, ps_filament.i_adc_reading);
0036B4  805834     MOV 0xB06, W4
0036B6  780084     MOV W4, W1
0036B8  20ACA0     MOV #0xACA, W0
0036BA  07028B     RCALL ReturnPowerSupplyADCScaledCurrent
0036BC  780200     MOV W0, W4
0036BE  780F04     MOV W4, [W14]
630:                     break;
0036C0  3701B4     BRA 0x3A2A
631:                     
632:                   case RAM_READ_MAGNETRON_FILAMENT_VOLTAGE_SET_POINT:
633:                     data_return = ps_filament.v_command_set_point;
0036C2  805664     MOV 0xACC, W4
0036C4  780F04     MOV W4, [W14]
634:                     break;
0036C6  3701B1     BRA 0x3A2A
635:               
636:                   case RAM_READ_MAGNETRON_FILAMENT_CURRENT_SET_POINT:
637:                     data_return = ps_filament.i_command_set_point;
0036C8  8057C5     MOV 0xAF8, W5
0036CA  780F05     MOV W5, [W14]
638:                     break;
0036CC  3701AE     BRA 0x3A2A
639:               
640:               
641:                     // Lambda Mode A Data
642:                   case RAM_READ_HV_LAMBDA_SET_POINT_MODE_A:
643:                     data_return = ps_hv_lambda_mode_A.v_command_set_point;
0036CE  804858     MOV 0x90A, W8
0036D0  780F08     MOV W8, [W14]
644:                     break;
0036D2  3701AB     BRA 0x3A2A
645:               
646:               
647:                     // Lambda Mode B Data
648:                   case RAM_READ_HV_LAMBDA_SET_POINT_MODE_B:
649:                     data_return = ps_hv_lambda_mode_B.v_command_set_point;
0036D4  804DF9     MOV 0x9BE, W9
0036D6  780F09     MOV W9, [W14]
650:                     break;
0036D8  3701A8     BRA 0x3A2A
651:               
652:                     
653:                     // Thyratron Cathode Heater data
654:                   case RAM_READ_THYR_CATH_HTR_VOTAGE_SET_POINT:
655:                     data_return = ps_thyr_cathode_htr.v_command_set_point;
0036DA  80593A     MOV 0xB26, W10
0036DC  780F0A     MOV W10, [W14]
656:                     break;
0036DE  3701A5     BRA 0x3A2A
657:                     
658:                   case RAM_READ_THYR_CATH_HTR_VOTAGE_ADC:
659:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_thyr_cathode_htr, ps_thyr_cathode_htr.v_adc_reading);
0036E0  8059A4     MOV 0xB34, W4
0036E2  780084     MOV W4, W1
0036E4  20B240     MOV #0xB24, W0
0036E6  07023F     RCALL ReturnPowerSupplyADCScaledVoltage
0036E8  780200     MOV W0, W4
0036EA  780F04     MOV W4, [W14]
660:                     break;
0036EC  37019E     BRA 0x3A2A
661:               
662:               
663:                     // Thyratron Reservoir Heater data
664:                   case RAM_READ_THYR_RESER_HTR_VOLTAGE_SET_POINT:
665:                     data_return = ps_thyr_reservoir_htr.v_command_set_point;
0036EE  805C0B     MOV 0xB80, W11
0036F0  780F0B     MOV W11, [W14]
666:                     break;
0036F2  37019B     BRA 0x3A2A
667:                     
668:                   case RAM_READ_THYR_RESER_HTR_VOLTAGE_ADC:
669:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_thyr_reservoir_htr, ps_thyr_reservoir_htr.v_adc_reading);
0036F4  805C74     MOV 0xB8E, W4
0036F6  780084     MOV W4, W1
0036F8  20B7E0     MOV #0xB7E, W0
0036FA  070235     RCALL ReturnPowerSupplyADCScaledVoltage
0036FC  780200     MOV W0, W4
0036FE  780F04     MOV W4, [W14]
670:                     break;
003700  370194     BRA 0x3A2A
671:                     
672:               
673:                     // PULSE MODE A DATA
674:                   case RAM_READ_PULSE_MODE_A_FILTERED_CURRENT:
675:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_reading);
003702  804CF4     MOV 0x99E, W4
003704  780084     MOV W4, W1
003706  209620     MOV #0x962, W0
003708  070264     RCALL ReturnPowerSupplyADCScaledCurrent
00370A  780200     MOV W0, W4
00370C  780F04     MOV W4, [W14]
676:                     break;
00370E  37018D     BRA 0x3A2A
677:               
678:                   case RAM_READ_PULSE_MODE_A_FILTERED_VOLTAGE:
679:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_reading);
003710  804B94     MOV 0x972, W4
003712  780084     MOV W4, W1
003714  209620     MOV #0x962, W0
003716  070227     RCALL ReturnPowerSupplyADCScaledVoltage
003718  780200     MOV W0, W4
00371A  780F04     MOV W4, [W14]
680:                     break;
00371C  370186     BRA 0x3A2A
681:               
682:                   case RAM_READ_PULSE_MODE_A_MAX_CURRENT:
683:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_max_reading);
00371E  804DC4     MOV 0x9B8, W4
003720  780084     MOV W4, W1
003722  209620     MOV #0x962, W0
003724  070256     RCALL ReturnPowerSupplyADCScaledCurrent
003726  780200     MOV W0, W4
003728  780F04     MOV W4, [W14]
684:                     break;
00372A  37017F     BRA 0x3A2A
685:               
686:                   case RAM_READ_PULSE_MODE_A_MIN_CURRENT:
687:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, ps_magnetron_mode_A.i_adc_min_reading);
00372C  804DD4     MOV 0x9BA, W4
00372E  780084     MOV W4, W1
003730  209620     MOV #0x962, W0
003732  07024F     RCALL ReturnPowerSupplyADCScaledCurrent
003734  780200     MOV W0, W4
003736  780F04     MOV W4, [W14]
688:                     break;
003738  370178     BRA 0x3A2A
689:               
690:                  case RAM_READ_PULSE_MODE_A_MAX_VOLTAGE:
691:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_max_reading);
00373A  804C64     MOV 0x98C, W4
00373C  780084     MOV W4, W1
00373E  209620     MOV #0x962, W0
003740  070212     RCALL ReturnPowerSupplyADCScaledVoltage
003742  780200     MOV W0, W4
003744  780F04     MOV W4, [W14]
692:                     break;
003746  370171     BRA 0x3A2A
693:               
694:                   case RAM_READ_PULSE_MODE_A_MIN_VOLTAGE:
695:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, ps_magnetron_mode_A.v_adc_min_reading);
003748  804C74     MOV 0x98E, W4
00374A  780084     MOV W4, W1
00374C  209620     MOV #0x962, W0
00374E  07020B     RCALL ReturnPowerSupplyADCScaledVoltage
003750  780200     MOV W0, W4
003752  780F04     MOV W4, [W14]
696:                     break;
003754  37016A     BRA 0x3A2A
697:               
698:               
699:                   // PULSE MODE B DATA
700:                   case RAM_READ_PULSE_MODE_B_FILTERED_CURRENT:
701:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_reading);
003756  805294     MOV 0xA52, W4
003758  780084     MOV W4, W1
00375A  20A160     MOV #0xA16, W0
00375C  07023A     RCALL ReturnPowerSupplyADCScaledCurrent
00375E  780200     MOV W0, W4
003760  780F04     MOV W4, [W14]
702:                     break;
003762  370163     BRA 0x3A2A
703:               
704:                   case RAM_READ_PULSE_MODE_B_FILTERED_VOLTAGE:
705:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_reading);
003764  805134     MOV 0xA26, W4
003766  780084     MOV W4, W1
003768  20A160     MOV #0xA16, W0
00376A  0701FD     RCALL ReturnPowerSupplyADCScaledVoltage
00376C  780200     MOV W0, W4
00376E  780F04     MOV W4, [W14]
706:                     break;
003770  37015C     BRA 0x3A2A
707:               
708:                   case RAM_READ_PULSE_MODE_B_MAX_CURRENT:
709:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_max_reading);
003772  805364     MOV 0xA6C, W4
003774  780084     MOV W4, W1
003776  20A160     MOV #0xA16, W0
003778  07022C     RCALL ReturnPowerSupplyADCScaledCurrent
00377A  780200     MOV W0, W4
00377C  780F04     MOV W4, [W14]
710:                     break;
00377E  370155     BRA 0x3A2A
711:               
712:                   case RAM_READ_PULSE_MODE_B_MIN_CURRENT:
713:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_B, ps_magnetron_mode_B.i_adc_min_reading);
003780  805374     MOV 0xA6E, W4
003782  780084     MOV W4, W1
003784  20A160     MOV #0xA16, W0
003786  070225     RCALL ReturnPowerSupplyADCScaledCurrent
003788  780200     MOV W0, W4
00378A  780F04     MOV W4, [W14]
714:                     break;      
00378C  37014E     BRA 0x3A2A
715:               
716:                   case RAM_READ_PULSE_MODE_B_MAX_VOLTAGE:
717:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_max_reading);
00378E  805204     MOV 0xA40, W4
003790  780084     MOV W4, W1
003792  20A160     MOV #0xA16, W0
003794  0701E8     RCALL ReturnPowerSupplyADCScaledVoltage
003796  780200     MOV W0, W4
003798  780F04     MOV W4, [W14]
718:                     break;     
00379A  370147     BRA 0x3A2A
719:               
720:                   case RAM_READ_PULSE_MODE_B_MIN_VOLTAGE:
721:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_B, ps_magnetron_mode_B.v_adc_min_reading);
00379C  805214     MOV 0xA42, W4
00379E  780084     MOV W4, W1
0037A0  20A160     MOV #0xA16, W0
0037A2  0701E1     RCALL ReturnPowerSupplyADCScaledVoltage
0037A4  780200     MOV W0, W4
0037A6  780F04     MOV W4, [W14]
722:                     break;
0037A8  370140     BRA 0x3A2A
723:               
724:               
725:                     // Magnetron Data
726:                   case RAM_READ_PREVIOUS_PULSE_MAGNETRON_VOLTAGE_ADC:
727:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_magnetron_mode_A, pulse_magnetron_voltage_adc_reading);
0037AA  8042B4     MOV pulse_magnetron_voltage_adc_reading, W4
0037AC  780084     MOV W4, W1
0037AE  209620     MOV #0x962, W0
0037B0  0701DA     RCALL ReturnPowerSupplyADCScaledVoltage
0037B2  780200     MOV W0, W4
0037B4  780F04     MOV W4, [W14]
728:                     break;
0037B6  370139     BRA 0x3A2A
729:                     
730:                   case RAM_READ_PREVIOUS_PULSE_MAGNETRON_CURRENT_ADC:
731:                     data_return = ReturnPowerSupplyADCScaledCurrent(&ps_magnetron_mode_A, pulse_magnetron_current_adc_reading);
0037B8  8042A4     MOV pulse_magnetron_current_adc_reading, W4
0037BA  780084     MOV W4, W1
0037BC  209620     MOV #0x962, W0
0037BE  070209     RCALL ReturnPowerSupplyADCScaledCurrent
0037C0  780200     MOV W0, W4
0037C2  780F04     MOV W4, [W14]
732:                     break;
0037C4  370132     BRA 0x3A2A
733:               
734:               
735:               
736:                     // Counter Data 
737:                   case RAM_READ_ARC_COUNTER_PERSISTENT_HIGH_WORD:
738:                     temp_long = arc_counter_persistent;
0037C6  80C654     MOV arc_counter_persistent, W4
0037C8  80C665     MOV 0x18CC, W5
0037CA  980714     MOV W4, [W14+2]
0037CC  980725     MOV W5, [W14+4]
739:                     temp_long = temp_long >> 16;
0037CE  90021E     MOV [W14+2], W4
0037D0  9002AE     MOV [W14+4], W5
0037D2  DE2A40     LSR W5, #0, W4
0037D4  200005     MOV #0x0, W5
0037D6  980714     MOV W4, [W14+2]
0037D8  980725     MOV W5, [W14+4]
740:                     data_return = temp_long;
0037DA  90029E     MOV [W14+2], W5
0037DC  780F05     MOV W5, [W14]
741:                     break;
0037DE  370125     BRA 0x3A2A
742:                     
743:                   case RAM_READ_ARC_COUNTER_PERSISTENT_LOW_WORD:
744:                     temp_long = arc_counter_persistent;
0037E0  80C658     MOV arc_counter_persistent, W8
0037E2  80C669     MOV 0x18CC, W9
0037E4  980718     MOV W8, [W14+2]
0037E6  980729     MOV W9, [W14+4]
745:                     data_return = temp_long;
0037E8  90049E     MOV [W14+2], W9
0037EA  780F09     MOV W9, [W14]
746:                     break;
0037EC  37011E     BRA 0x3A2A
747:                     
748:                   case RAM_READ_ARC_COUNTER_THIS_HV_ON:
749:                     data_return = arc_counter_this_hv_on;
0037EE  80C6EA     MOV arc_counter_this_hv_on, W10
0037F0  780F0A     MOV W10, [W14]
750:                     break;
0037F2  37011B     BRA 0x3A2A
751:                     
752:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_3_MSB:
753:                     temp_long_long = pulse_counter_persistent;
0037F4  218BC4     MOV #0x18BC, W4
0037F6  BE0434     MOV.D [W4++], W8
0037F8  BE0524     MOV.D [W4--], W10
0037FA  980738     MOV W8, [W14+6]
0037FC  980749     MOV W9, [W14+8]
0037FE  98075A     MOV W10, [W14+10]
003800  98076B     MOV W11, [W14+12]
754:                     temp_long_long = temp_long_long >> 48;
003802  90023E     MOV [W14+6], W4
003804  9002CE     MOV [W14+8], W5
003806  90035E     MOV [W14+10], W6
003808  9003EE     MOV [W14+12], W7
00380A  B83A61     MUL.UU W7, #1, W4
00380C  B83360     MUL.UU W6, #0, W6
00380E  980734     MOV W4, [W14+6]
003810  980745     MOV W5, [W14+8]
003812  980756     MOV W6, [W14+10]
003814  980767     MOV W7, [W14+12]
755:                     data_return = temp_long_long;
003816  90053E     MOV [W14+6], W10
003818  780F0A     MOV W10, [W14]
756:                     break;
00381A  370107     BRA 0x3A2A
757:                     
758:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_2:
759:                     temp_long_long = pulse_counter_persistent;
00381C  218BC4     MOV #0x18BC, W4
00381E  BE0434     MOV.D [W4++], W8
003820  BE0524     MOV.D [W4--], W10
003822  980738     MOV W8, [W14+6]
003824  980749     MOV W9, [W14+8]
003826  98075A     MOV W10, [W14+10]
003828  98076B     MOV W11, [W14+12]
760:                     temp_long_long = temp_long_long >> 32;
00382A  90023E     MOV [W14+6], W4
00382C  9002CE     MOV [W14+8], W5
00382E  90035E     MOV [W14+10], W6
003830  9003EE     MOV [W14+12], W7
003832  BE0206     MOV.D W6, W4
003834  B83360     MUL.UU W6, #0, W6
003836  980734     MOV W4, [W14+6]
003838  980745     MOV W5, [W14+8]
00383A  980756     MOV W6, [W14+10]
00383C  980767     MOV W7, [W14+12]
761:                     data_return = temp_long_long;
00383E  90053E     MOV [W14+6], W10
003840  780F0A     MOV W10, [W14]
762:                     break;
003842  3700F3     BRA 0x3A2A
763:                     
764:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_1:
765:                     temp_long_long = pulse_counter_persistent;
003844  218BC4     MOV #0x18BC, W4
003846  BE0434     MOV.D [W4++], W8
003848  BE0524     MOV.D [W4--], W10
00384A  980738     MOV W8, [W14+6]
00384C  980749     MOV W9, [W14+8]
00384E  98075A     MOV W10, [W14+10]
003850  98076B     MOV W11, [W14+12]
766:                     temp_long_long = temp_long_long >> 16;
003852  90023E     MOV [W14+6], W4
003854  9002CE     MOV [W14+8], W5
003856  90035E     MOV [W14+10], W6
003858  9003EE     MOV [W14+12], W7
00385A  780205     MOV W5, W4
00385C  780286     MOV W6, W5
00385E  B83B61     MUL.UU W7, #1, W6
003860  980734     MOV W4, [W14+6]
003862  980745     MOV W5, [W14+8]
003864  980756     MOV W6, [W14+10]
003866  980767     MOV W7, [W14+12]
767:                     data_return = temp_long_long;
003868  90053E     MOV [W14+6], W10
00386A  780F0A     MOV W10, [W14]
768:                     break;
00386C  3700DE     BRA 0x3A2A
769:                     
770:                   case RAM_READ_PULSE_COUNTER_PERSISTENT_WORD_0_LSB:
771:                     temp_long_long = pulse_counter_persistent;
00386E  218BC4     MOV #0x18BC, W4
003870  BE0434     MOV.D [W4++], W8
003872  BE0524     MOV.D [W4--], W10
003874  980738     MOV W8, [W14+6]
003876  980749     MOV W9, [W14+8]
003878  98075A     MOV W10, [W14+10]
00387A  98076B     MOV W11, [W14+12]
772:                     data_return = temp_long_long;
00387C  9004BE     MOV [W14+6], W9
00387E  780F09     MOV W9, [W14]
773:                     break;
003880  3700D4     BRA 0x3A2A
774:                     
775:                   case RAM_READ_PULSE_COUNTER_THIS_HV_ON_HIGH_WORD:
776:                     temp_long = pulse_counter_this_hv_on;
003882  80C67A     MOV pulse_counter_this_hv_on, W10
003884  80C68B     MOV 0x18D0, W11
003886  98071A     MOV W10, [W14+2]
003888  98072B     MOV W11, [W14+4]
777:                     temp_long = temp_long >> 16;
00388A  90021E     MOV [W14+2], W4
00388C  9002AE     MOV [W14+4], W5
00388E  DE2A40     LSR W5, #0, W4
003890  200005     MOV #0x0, W5
003892  980714     MOV W4, [W14+2]
003894  980725     MOV W5, [W14+4]
778:                     data_return = temp_long;
003896  90059E     MOV [W14+2], W11
003898  780F0B     MOV W11, [W14]
779:                     break;
00389A  3700C7     BRA 0x3A2A
780:                     
781:                   case RAM_READ_PULSE_COUNTER_THIS_HV_ON_LOW_WORD:
782:                     temp_long = pulse_counter_this_hv_on;
00389C  80C674     MOV pulse_counter_this_hv_on, W4
00389E  80C685     MOV 0x18D0, W5
0038A0  980714     MOV W4, [W14+2]
0038A2  980725     MOV W5, [W14+4]
783:                     temp_long &= 0x0000FFFF;
0038A4  90031E     MOV [W14+2], W6
0038A6  9003AE     MOV [W14+4], W7
0038A8  2FFFF4     MOV #0xFFFF, W4
0038AA  200005     MOV #0x0, W5
0038AC  780006     MOV W6, W0
0038AE  780307     MOV W7, W6
0038B0  780384     MOV W4, W7
0038B2  780205     MOV W5, W4
0038B4  600007     AND W0, W7, W0
0038B6  630204     AND W6, W4, W4
0038B8  200005     MOV #0x0, W5
0038BA  DD22C0     SL W4, #0, W5
0038BC  200004     MOV #0x0, W4
0038BE  BE0304     MOV.D W4, W6
0038C0  B80261     MUL.UU W0, #1, W4
0038C2  730304     IOR W6, W4, W6
0038C4  738385     IOR W7, W5, W7
0038C6  980716     MOV W6, [W14+2]
0038C8  980727     MOV W7, [W14+4]
784:                     data_return = temp_long;
0038CA  90029E     MOV [W14+2], W5
0038CC  780F05     MOV W5, [W14]
785:                     break;
0038CE  3700AD     BRA 0x3A2A
786:                     
787:               
788:                     // Power information
789:                   case RAM_READ_AVERAGE_PULSE_ENERGY:
790:                     data_return = average_energy_per_pulse_milli_joules;
0038D0  8041C8     MOV average_energy_per_pulse_milli_joules, W8
0038D2  780F08     MOV W8, [W14]
791:                     break;
0038D4  3700AA     BRA 0x3A2A
792:               
793:                   case RAM_READ_AVERAGE_PULSE_FREQUENCY:
794:                     //data_return = average_pulse_repetition_frequency_deci_herz;
795:                     data_return = prf_deciherz;
0038D6  80C549     MOV 0x18A8, W9
0038D8  780F09     MOV W9, [W14]
796:                     break;
0038DA  3700A7     BRA 0x3A2A
797:               
798:                   case RAM_READ_AVERAGE_MAGNETRON_INPUT_POWER:
799:                     data_return = average_output_power_watts;
0038DC  8041DA     MOV average_output_power_watts, W10
0038DE  780F0A     MOV W10, [W14]
800:                     break;
0038E0  3700A4     BRA 0x3A2A
801:               
802:                   case RAM_READ_HV_LAMBDA_VPEAK_ADC:
803:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_hv_lambda_mode_A, ps_hv_lambda_mode_A.v_adc_reading);
0038E2  8048C4     MOV 0x918, W4
0038E4  780084     MOV W4, W1
0038E6  209080     MOV #0x908, W0
0038E8  07013E     RCALL ReturnPowerSupplyADCScaledVoltage
0038EA  780200     MOV W0, W4
0038EC  780F04     MOV W4, [W14]
804:                     break;
0038EE  37009D     BRA 0x3A2A
805:               
806:                   case RAM_READ_HV_LAMBDA_VMON_ADC:
807:                     data_return = ReturnPowerSupplyADCScaledVoltage(&ps_hv_lambda_mode_B, ps_hv_lambda_mode_B.v_adc_reading);
0038F0  804E64     MOV 0x9CC, W4
0038F2  780084     MOV W4, W1
0038F4  209BC0     MOV #0x9BC, W0
0038F6  070137     RCALL ReturnPowerSupplyADCScaledVoltage
0038F8  780200     MOV W0, W4
0038FA  780F04     MOV W4, [W14]
808:                     break;
0038FC  370096     BRA 0x3A2A
809:                     
810:                   case RAM_READ_FILAMENT_OFFSET:
811:                     data_return = (unsigned int)look_up_offset;
0038FE  804094     MOV look_up_offset, W4
003900  780F04     MOV W4, [W14]
812:                     break;
003902  370093     BRA 0x3A2A
813:               
814:                   case RAM_READ_OPERATION_MODE:
815:                     data_return = operation_mode;
003904  80B6FB     MOV operation_mode, W11
003906  780F0B     MOV W11, [W14]
816:                     break;
003908  370090     BRA 0x3A2A
817:               
818:                   case RAM_READ_SCALE_INTERLEAVED:
819:                     data_return = scale_interleaved;
00390A  80B701     MOV scale_interleaved, W1
00390C  780F01     MOV W1, [W14]
820:                     break;
00390E  37008D     BRA 0x3A2A
821:               
822:                   case RAM_READ_SCALE_LOW_ENERGY:
823:                     data_return = scale_low_energy;
003910  80B714     MOV scale_low_energy, W4
003912  780F04     MOV W4, [W14]
824:               	break;
003914  37008A     BRA 0x3A2A
825:               
826:                     // Fault information
827:                   case RAM_READ_DEBUG_STATUS_REG:
828:                     data_return = debug_status_register;
003916  80C395     MOV debug_status_register, W5
003918  780F05     MOV W5, [W14]
829:                     break;
00391A  370087     BRA 0x3A2A
830:               
831:                   case RAM_READ_FAULT_MAGNETRON_FAULT_REG:
832:                     data_return = faults_magnetron_fault_reg;
00391C  80C3B8     MOV faults_magnetron_fault_reg, W8
00391E  780F08     MOV W8, [W14]
833:                     break;
003920  370084     BRA 0x3A2A
834:               
835:                   case RAM_READ_FAULT_MAGNETRON_STATUS_REG:
836:                     data_return = faults_magnetron_status_reg;
003922  80C3A9     MOV faults_magnetron_status_reg, W9
003924  780F09     MOV W9, [W14]
837:                     break;
003926  370081     BRA 0x3A2A
838:               
839:                   case RAM_READ_FAULT_MAGNETRON_WARNING_REG:
840:                     data_return = faults_magnetron_warning_reg;
003928  80C3CA     MOV faults_magnetron_warning_reg, W10
00392A  780F0A     MOV W10, [W14]
841:                     break;
00392C  37007E     BRA 0x3A2A
842:               
843:                   case RAM_READ_FAULT_HIGH_VOLTAGE_FAULT_REG:
844:                     data_return = faults_high_voltage_fault_reg;
00392E  80C3EB     MOV faults_high_voltage_fault_reg, W11
003930  780F0B     MOV W11, [W14]
845:                     break;
003932  37007B     BRA 0x3A2A
846:               
847:                   case RAM_READ_FAULT_HIGH_VOLTAGE_STATUS_REG:
848:                     data_return = faults_high_voltage_status_reg;
003934  80C3D1     MOV faults_high_voltage_status_reg, W1
003936  780F01     MOV W1, [W14]
849:                     break;
003938  370078     BRA 0x3A2A
850:               
851:                   case RAM_READ_FAULT_HIGH_VOLTAGE_WARNING_REG:
852:                     data_return = faults_high_voltage_warning_reg;
00393A  80C3F4     MOV faults_high_voltage_warning_reg, W4
00393C  780F04     MOV W4, [W14]
853:                     break;
00393E  370075     BRA 0x3A2A
854:               
855:                   case RAM_READ_FAULT_THYRATRON_FAULT_REG:
856:                     data_return = faults_thyratron_fault_reg;
003940  80C415     MOV faults_thyratron_fault_reg, W5
003942  780F05     MOV W5, [W14]
857:                     break;
003944  370072     BRA 0x3A2A
858:               
859:                   case RAM_READ_FAULT_THYRATRON_STATUS_REG:
860:                     data_return = faults_thyratron_status_reg;
003946  80C408     MOV faults_thyratron_status_reg, W8
003948  780F08     MOV W8, [W14]
861:                     break;
00394A  37006F     BRA 0x3A2A
862:               
863:                   case RAM_READ_FAULT_THYRATRON_WARNING_REG:
864:                     data_return = faults_thyratron_warning_reg;
00394C  80C429     MOV faults_thyratron_warning_reg, W9
00394E  780F09     MOV W9, [W14]
865:                     break;
003950  37006C     BRA 0x3A2A
866:               
867:                   case RAM_READ_FAULT_CONTROL_BOARD_FAULT_REG:
868:                     data_return = faults_control_board_fault_reg;
003952  80C44A     MOV faults_control_board_fault_reg, W10
003954  780F0A     MOV W10, [W14]
869:                     break;
003956  370069     BRA 0x3A2A
870:               
871:                   case RAM_READ_FAULT_CONTROL_BOARD_STATUS_REG:
872:                     data_return = faults_control_board_status_reg;
003958  80C43B     MOV faults_control_board_status_reg, W11
00395A  780F0B     MOV W11, [W14]
873:                     break;
00395C  370066     BRA 0x3A2A
874:               
875:                   case RAM_READ_FAULT_CONTROL_BOARD_WARNING_REG:
876:                     data_return = faults_control_board_warning_reg;
00395E  80C451     MOV faults_control_board_warning_reg, W1
003960  780F01     MOV W1, [W14]
877:                     break;
003962  370063     BRA 0x3A2A
878:                     
879:                     
880:                     // Read Status
881:                   case RAM_READ_STATE:
882:                     data_return = control_state;
003964  208404     MOV #0x840, W4
003966  784214     MOV.B [W4], W4
003968  FB8204     ZE W4, W4
00396A  780F04     MOV W4, [W14]
883:                     break;
00396C  37005E     BRA 0x3A2A
884:                     
885:                   case RAM_READ_VERSION:
886:                     data_return = VERSION_NUMBER;
00396E  2A1004     MOV #0xA100, W4
003970  780F04     MOV W4, [W14]
887:                     break;
003972  37005B     BRA 0x3A2A
888:               
889:                   case RAM_READ_LOCAL_REMOTE_MAGNET_CURRENT_CONTROL:
890:                     data_return = ram_config_set_magnetron_magnet_current_from_GUI;
003974  208304     MOV #0x830, W4
003976  784214     MOV.B [W4], W4
003978  FB8204     ZE W4, W4
00397A  780F04     MOV W4, [W14]
891:                     break;
00397C  370056     BRA 0x3A2A
892:                     
893:                   case RAM_READ_MAGNETRON_TYPE:
894:               #ifdef __MG7095
895:                     data_return = 7095;
00397E  21BB74     MOV #0x1BB7, W4
003980  780F04     MOV W4, [W14]
896:               #else
897:                     data_return = 5193;
898:               #endif
899:                     break;
003982  370053     BRA 0x3A2A
900:                  
901:                   case RAM_READ_CONTROL_BOARD_TYPE:
902:               #ifndef __A36760
903:                     data_return = 34760;
904:               #else
905:                     data_return = 36760;
003984  28F984     MOV #0x8F98, W4
003986  780F04     MOV W4, [W14]
906:               #endif
907:                     break;
003988  370050     BRA 0x3A2A
908:                     
909:                     
910:                     // Read Bedug Counters
911:                     
912:                   case RAM_READ_COUNT_MAGNETRON_CURRENT_ADC_GLITCH:
913:                     data_return = global_debug_counter.magnetron_current_adc_glitch;
00398A  80C2E4     MOV global_debug_counter, W4
00398C  780F04     MOV W4, [W14]
914:                     break;
00398E  37004D     BRA 0x3A2A
915:                     
916:                   case RAM_READ_COUNT_MAGNETRON_VOLTAGE_ADC_GLITCH:
917:                     data_return = global_debug_counter.magnetron_voltage_adc_glitch;
003990  80C2F5     MOV 0x185E, W5
003992  780F05     MOV W5, [W14]
918:                     break;
003994  37004A     BRA 0x3A2A
919:                     
920:                   case RAM_READ_COUNT_I2C_BUS_ERROR:
921:                     data_return = pac_2_adc_reading;
003996  804228     MOV pac_2_adc_reading, W8
003998  780F08     MOV W8, [W14]
922:                     break;
00399A  370047     BRA 0x3A2A
923:                     
924:                   case RAM_READ_COUNT_SPI1_BUS_ERROR:
925:                     data_return = default_pac_2_adc_reading;
00399C  8040A9     MOV default_pac_2_adc_reading, W9
00399E  780F09     MOV W9, [W14]
926:                     break;
0039A0  370044     BRA 0x3A2A
927:                     
928:                   case RAM_READ_COUNT_SPI2_BUS_ERROR:
929:                     data_return = pac_1_adc_reading;
0039A2  80421A     MOV pac_1_adc_reading, W10
0039A4  780F0A     MOV W10, [W14]
930:                     break;
0039A6  370041     BRA 0x3A2A
931:                     
932:                   case RAM_READ_COUNT_EXTERNAL_ADC_FALSE_TRIGGER:
933:                     data_return = global_debug_counter.external_adc_false_trigger;
0039A8  80C33B     MOV 0x1866, W11
0039AA  780F0B     MOV W11, [W14]
934:                     break;
0039AC  37003E     BRA 0x3A2A
935:               
936:                   case RAM_READ_COUNT_LTC2656_WRITE_ERROR:
937:                     data_return = global_debug_counter.LTC2656_write_error;
0039AE  80C341     MOV 0x1868, W1
0039B0  780F01     MOV W1, [W14]
938:                     break;
0039B2  37003B     BRA 0x3A2A
939:                     
940:                   case RAM_READ_COUNT_SETPOINT_NOT_VALID:
941:                     data_return = global_debug_counter.setpoint_not_valid;
0039B4  80C354     MOV 0x186A, W4
0039B6  780F04     MOV W4, [W14]
942:                     break;
0039B8  370038     BRA 0x3A2A
943:                     
944:                   case RAM_READ_COUNT_SCALE16BIT_SATURATION:
945:                     data_return = global_debug_counter.scale16bit_saturation;
0039BA  80C365     MOV 0x186C, W5
0039BC  780F05     MOV W5, [W14]
946:                     break;
0039BE  370035     BRA 0x3A2A
947:               
948:                   case RAM_READ_LAST_OSCCON_BEFORE_CRASH:
949:                     data_return = last_osccon;
0039C0  80C6C8     MOV last_osccon, W8
0039C2  780F08     MOV W8, [W14]
950:                     break;
0039C4  370032     BRA 0x3A2A
951:               
952:                   case RAM_READ_PULSE_LATCH_RESET_ERROR:
953:                     data_return = global_debug_counter.pulse_latch_reset_error;
0039C6  80C389     MOV 0x1870, W9
0039C8  780F09     MOV W9, [W14]
954:                     break;
0039CA  37002F     BRA 0x3A2A
955:               
956:                   case RAM_READ_COUNT_REVERSESCALE16BIT_SATURATION:
957:                     data_return = global_debug_counter.reversescale16bit_saturation;
0039CC  80C37A     MOV 0x186E, W10
0039CE  780F0A     MOV W10, [W14]
958:                     break;
0039D0  37002C     BRA 0x3A2A
959:               
960:                   case RAM_READ_COUNT_LVD_INTERRUPT:
961:                     data_return = lvdinterrupt_counter;
0039D2  80C57B     MOV 0x18AE, W11
0039D4  780F0B     MOV W11, [W14]
962:                     break;
0039D6  370029     BRA 0x3A2A
963:               
964:                   case RAM_READ_LAST_ACTION_BEFORE_CRASH:
965:                     data_return = previous_last_action;
0039D8  804191     MOV previous_last_action, W1
0039DA  780F01     MOV W1, [W14]
966:                     break;
0039DC  370026     BRA 0x3A2A
967:               
968:                   case RAM_READ_COUNT_PROCESSOR_CRASH:
969:                     data_return = processor_crash_count;
0039DE  80C6D4     MOV processor_crash_count, W4
0039E0  780F04     MOV W4, [W14]
970:                     break;
0039E2  370023     BRA 0x3A2A
971:                     
972:                   case RAM_READ_COUNT_TIMING_ERROR_INT1:
973:                     //data_return = timing_error_int1_count;
974:                     if (PIN_GANTRY_PORTAL_SELECT == ILL_GANTRY_MODE) {
0039E4  801735     MOV PORTG, W5
0039E6  280004     MOV #0x8000, W4
0039E8  628204     AND W5, W4, W4
0039EA  520FE0     SUB W4, #0x0, [W15]
0039EC  3A0003     BRA NZ, 0x39F4
975:               	data_return = 1;
0039EE  200014     MOV #0x1, W4
0039F0  780F04     MOV W4, [W14]
976:                     } else {
977:               	data_return = 0;
0039F4  EB0200     CLR W4
0039F6  780F04     MOV W4, [W14]
978:                     }
979:               
980:                     break;
0039F2  37001B     BRA 0x3A2A
0039F8  370018     BRA 0x3A2A
981:               
982:               
983:                   case RAM_READ_HIGH_TARGET_CURRENT_SET_POINT:
984:                     data_return = linac_high_energy_target_current_set_point;
0039FA  8040E5     MOV linac_high_energy_target_current_set_point, W5
0039FC  780F05     MOV W5, [W14]
985:                     break;
0039FE  370015     BRA 0x3A2A
986:               
987:                   case RAM_READ_LOW_TARGET_CURRENT_SET_POINT:
988:                     data_return = linac_low_energy_target_current_set_point;
003A00  804108     MOV linac_low_energy_target_current_set_point, W8
003A02  780F08     MOV W8, [W14]
989:                     break;
003A04  370012     BRA 0x3A2A
990:               
991:                   case RAM_READ_HIGH_TARGET_CURRENT_READING:
992:                     data_return = linac_high_energy_target_current_adc_reading;
003A06  8040D9     MOV linac_high_energy_target_current_adc_reading, W9
003A08  780F09     MOV W9, [W14]
993:                     break;
003A0A  37000F     BRA 0x3A2A
994:               
995:                   case RAM_READ_LOW_TARGET_CURRENT_READING:
996:                     data_return = linac_low_energy_target_current_adc_reading;
003A0C  8040FA     MOV linac_low_energy_target_current_adc_reading, W10
003A0E  780F0A     MOV W10, [W14]
997:                     break;
003A10  37000C     BRA 0x3A2A
998:               
999:                   case RAM_READ_TARGET_ADJUST_MAX_PULSES:
1000:                    data_return = low_energy_target_current_startup_adjust_decay_time_pulses;
003A12  80C51B     MOV 0x18A2, W11
003A14  780F0B     MOV W11, [W14]
1001:                    break;
003A16  370009     BRA 0x3A2A
1002:                    
1003:                  case RAM_READ_TARGET_ADJUST_MAX_MAGNITUDE:
1004:                    data_return = max_low_energy_target_current_startup_adjust_initital_value;
003A18  80C4E1     MOV 0x189C, W1
003A1A  780F01     MOV W1, [W14]
1005:                    break;
003A1C  370006     BRA 0x3A2A
1006:              
1007:                  case RAM_READ_TARGET_ADJUST_MAX_COOLDOWN:
1008:                    data_return = low_energy_target_current_startup_max_cooldown;
003A1E  80C4F4     MOV 0x189E, W4
003A20  780F04     MOV W4, [W14]
1009:                    break;
003A22  370003     BRA 0x3A2A
1010:              
1011:                  case RAM_READ_TARGET_ADJUST_INITIAL_MAGNITUDE:
1012:                    data_return = low_energy_target_current_startup_adjust_initital_value;
003A24  80C505     MOV 0x18A0, W5
003A26  780F05     MOV W5, [W14]
1013:                    break;
003A28  000000     NOP
1014:              
1015:                  }
1016:                
1017:                return data_return;
003A2A  78021E     MOV [W14], W4
1018:              }
003A2C  780004     MOV W4, W0
003A2E  BE054F     MOV.D [--W15], W10
003A30  BE044F     MOV.D [--W15], W8
003A32  FA8000     ULNK
003A34  060000     RETURN
1019:              
1020:              
1021:              unsigned int MakeCRC(unsigned char command_byte, unsigned char register_byte, unsigned int data_word) {
003A36  FA0006     LNK #0x6
003A38  984720     MOV.B W0, [W14+2]
003A3A  984731     MOV.B W1, [W14+3]
003A3C  980722     MOV W2, [W14+4]
1022:                unsigned int crc;
1023:                crc = SYNC_BYTE_1 + SYNC_BYTE_2 + SYNC_BYTE_3_SEND;
003A3E  202D74     MOV #0x2D7, W4
003A40  780F04     MOV W4, [W14]
1024:                crc += command_byte + register_byte;
003A42  90422E     MOV.B [W14+2], W4
003A44  FB8284     ZE W4, W5
003A46  90423E     MOV.B [W14+3], W4
003A48  FB8204     ZE W4, W4
003A4A  428204     ADD W5, W4, W4
003A4C  420F1E     ADD W4, [W14], [W14]
1025:                crc += (data_word >> 8);
003A4E  90022E     MOV [W14+4], W4
003A50  DE2248     LSR W4, #8, W4
003A52  420F1E     ADD W4, [W14], [W14]
1026:                crc += (data_word & 0x00FF);
003A54  9002AE     MOV [W14+4], W5
003A56  200FF4     MOV #0xFF, W4
003A58  628204     AND W5, W4, W4
003A5A  420F1E     ADD W4, [W14], [W14]
1027:                
1028:                return crc;
003A5C  78021E     MOV [W14], W4
1029:                // DPAKRER Make real CRC
1030:              }
003A5E  780004     MOV W4, W0
003A60  FA8000     ULNK
003A62  060000     RETURN
1031:              
1032:              
1033:              unsigned char CheckCRC(unsigned int crc) {
003A64  FA0004     LNK #0x4
003A66  980710     MOV W0, [W14+2]
1034:                unsigned int crcCheck;
1035:                // At the moment the CRC is just a checksum
1036:                crcCheck = SYNC_BYTE_1 + SYNC_BYTE_2 + SYNC_BYTE_3_RECEIVE; 
003A68  202D64     MOV #0x2D6, W4
003A6A  780F04     MOV W4, [W14]
1037:                crcCheck += command_string.command_byte + command_string.register_byte;
003A6C  218C44     MOV #0x18C4, W4
003A6E  784214     MOV.B [W4], W4
003A70  FB8284     ZE W4, W5
003A72  218C54     MOV #0x18C5, W4
003A74  784214     MOV.B [W4], W4
003A76  FB8204     ZE W4, W4
003A78  428204     ADD W5, W4, W4
003A7A  420F1E     ADD W4, [W14], [W14]
1038:                crcCheck += command_string.data_high_byte + command_string.data_low_byte;
003A7C  218C64     MOV #0x18C6, W4
003A7E  784214     MOV.B [W4], W4
003A80  FB8284     ZE W4, W5
003A82  218C74     MOV #0x18C7, W4
003A84  784214     MOV.B [W4], W4
003A86  FB8204     ZE W4, W4
003A88  428204     ADD W5, W4, W4
003A8A  420F1E     ADD W4, [W14], [W14]
1039:                if (crcCheck == crc) {
003A8C  90021E     MOV [W14+2], W4
003A8E  78029E     MOV [W14], W5
003A90  528F84     SUB W5, W4, [W15]
003A92  3A0002     BRA NZ, 0x3A98
1040:                  return 1;
003A94  B3C014     MOV.B #0x1, W4
003A96  370001     BRA 0x3A9A
1041:                } else {
1042:                  return 0;
003A98  EB4200     CLR.B W4
1043:                }
1044:                // DPARKER make Real CRC
1045:              
1046:              }
003A9A  784004     MOV.B W4, W0
003A9C  FA8000     ULNK
003A9E  060000     RETURN
1047:              
1048:              
1049:              
1050:              void _ISRNOPSV _U1RXInterrupt(void) {
003AA0  F80036     PUSH RCOUNT
003AA2  BE9F80     MOV.D W0, [W15++]
003AA4  BE9F82     MOV.D W2, [W15++]
003AA6  BE9F84     MOV.D W4, [W15++]
003AA8  BE9F86     MOV.D W6, [W15++]
003AAA  FA0000     LNK #0x0
1051:                _U1RXIF = 0;
003AAC  A92085     BCLR 0x85, #1
1052:                while (U1STAbits.URXDA) {
003AAE  370005     BRA 0x3ABA
003ABA  801074     MOV U1STA, W4
003ABC  620261     AND W4, #0x1, W4
003ABE  520FE0     SUB W4, #0x0, [W15]
003AC0  3AFFF7     BRA NZ, 0x3AB0
1053:                  Buffer64WriteByte(&uart1_input_buffer, U1RXREG);
003AB0  801094     MOV U1RXREG, W4
003AB2  784204     MOV.B W4, W4
003AB4  784084     MOV.B W4, W1
003AB6  2086C0     MOV #0x86C, W0
003AB8  070ABA     RCALL Buffer64WriteByte
1054:                }
1055:              }
003AC2  FA8000     ULNK
003AC4  BE034F     MOV.D [--W15], W6
003AC6  BE024F     MOV.D [--W15], W4
003AC8  BE014F     MOV.D [--W15], W2
003ACA  BE004F     MOV.D [--W15], W0
003ACC  F90036     POP RCOUNT
003ACE  064000     RETFIE
1056:              
1057:              
1058:              
1059:              void _ISRNOPSV _U1TXInterrupt(void) {
003AD0  F80036     PUSH RCOUNT
003AD2  BE9F80     MOV.D W0, [W15++]
003AD4  BE9F82     MOV.D W2, [W15++]
003AD6  BE9F84     MOV.D W4, [W15++]
003AD8  BE9F86     MOV.D W6, [W15++]
003ADA  FA0000     LNK #0x0
1060:                _U1TXIF = 0;
003ADC  A94085     BCLR 0x85, #2
1061:                while ((!U1STAbits.UTXBF) && (Buffer64BytesInBuffer(&uart1_output_buffer))) {
003ADE  370005     BRA 0x3AEA
003AEA  801075     MOV U1STA, W5
003AEC  202004     MOV #0x200, W4
003AEE  628204     AND W5, W4, W4
003AF0  520FE0     SUB W4, #0x0, [W15]
003AF2  3A0005     BRA NZ, 0x3AFE
003AF4  208AE0     MOV #0x8AE, W0
003AF6  070ADE     RCALL Buffer64BytesInBuffer
003AF8  784200     MOV.B W0, W4
003AFA  524FE0     SUB.B W4, #0x0, [W15]
003AFC  3AFFF1     BRA NZ, 0x3AE0
1062:                  /*
1063:                    There is at least one byte available for writing in the outputbuffer and the transmit buffer is not full.
1064:                    Move a byte from the output buffer into the transmit buffer
1065:                  */
1066:                  U1TXREG = Buffer64ReadByte(&uart1_output_buffer);
003AE0  208AE0     MOV #0x8AE, W0
003AE2  070ACA     RCALL Buffer64ReadByte
003AE4  784200     MOV.B W0, W4
003AE6  FB8204     ZE W4, W4
003AE8  881084     MOV W4, U1TXREG
1067:                }
1068:              }
003AFE  FA8000     ULNK
003B00  BE034F     MOV.D [--W15], W6
003B02  BE024F     MOV.D [--W15], W4
003B04  BE014F     MOV.D [--W15], W2
003B06  BE004F     MOV.D [--W15], W0
003B08  F90036     POP RCOUNT
003B0A  064000     RETFIE
1069:              
1070:              
1071:              unsigned int GenerateMagnetronVprog(unsigned int iprog) {
003B0C  FA0002     LNK #0x2
003B0E  780F00     MOV W0, [W14]
1072:                return 42000;
003B10  2A4104     MOV #0xA410, W4
1073:                // DPARKER write this function
1074:              }
003B12  780004     MOV W4, W0
003B14  FA8000     ULNK
003B16  060000     RETURN
1075:              
1076:              
1077:              
1078:              unsigned int GenerateLambdaIprog(unsigned int vprog) {
003B18  FA0002     LNK #0x2
003B1A  780F00     MOV W0, [W14]
1079:                return 0;
003B1C  EB0200     CLR W4
1080:              }
003B1E  780004     MOV W4, W0
003B20  FA8000     ULNK
003B22  060000     RETURN
1081:              
1082:               
1083:              unsigned int GenerateMagnetVprog(unsigned int iprog) {
003B24  FA0004     LNK #0x4
003B26  980710     MOV W0, [W14+2]
1084:                unsigned int temp;
1085:                temp = Scale16Bit(iprog,10240); // temp = iprog*1.25
003B28  228001     MOV #0x2800, W1
003B2A  90001E     MOV [W14+2], W0
003B2C  07F45A     RCALL Scale16Bit
003B2E  780200     MOV W0, W4
003B30  780F04     MOV W4, [W14]
1086:                return temp;
003B32  78021E     MOV [W14], W4
1087:              }
003B34  780004     MOV W4, W0
003B36  FA8000     ULNK
003B38  060000     RETURN
1088:              
1089:              
1090:              unsigned int GenerateFilamentIprog(unsigned int vprog) {
003B3A  FA0004     LNK #0x4
003B3C  980710     MOV W0, [W14+2]
1091:                unsigned int temp;
1092:                temp = Scale16Bit(vprog, 5425);
003B3E  215311     MOV #0x1531, W1
003B40  90001E     MOV [W14+2], W0
003B42  07F44F     RCALL Scale16Bit
003B44  780200     MOV W0, W4
003B46  780F04     MOV W4, [W14]
1093:                return temp;
003B48  78021E     MOV [W14], W4
1094:              }
003B4A  780004     MOV W4, W0
003B4C  FA8000     ULNK
003B4E  060000     RETURN
1095:              
1096:              unsigned int GenerateFilamentVprog(unsigned int iprog) {
003B50  FA0004     LNK #0x4
003B52  980710     MOV W0, [W14+2]
1097:                unsigned int temp;
1098:                temp = Scale16Bit(iprog, 19363);
003B54  24BA31     MOV #0x4BA3, W1
003B56  90001E     MOV [W14+2], W0
003B58  07F444     RCALL Scale16Bit
003B5A  780200     MOV W0, W4
003B5C  780F04     MOV W4, [W14]
1099:                return temp;
003B5E  78021E     MOV [W14], W4
1100:              }
003B60  780004     MOV W4, W0
003B62  FA8000     ULNK
003B64  060000     RETURN
1101:              
1102:              
1103:              unsigned int ReturnPowerSupplyADCScaledVoltage(POWERSUPPLY* ptr, unsigned int value) {
003B66  FA0004     LNK #0x4
003B68  780F00     MOV W0, [W14]
003B6A  980711     MOV W1, [W14+2]
1104:                //value = value - ptr->v_adc_cal_offset;
1105:                if (ptr->v_adc_cal_offset > 0) {
003B6C  78021E     MOV [W14], W4
003B6E  900A34     MOV [W4+22], W4
003B70  520FE0     SUB W4, #0x0, [W15]
003B72  34000F     BRA LE, 0x3B92
1106:                  // the offset is positive
1107:                  // Check to make sure we do not overflow below 0x0000
1108:                  if (ptr->v_adc_cal_offset >= value) {
003B74  78021E     MOV [W14], W4
003B76  900A34     MOV [W4+22], W4
003B78  780284     MOV W4, W5
003B7A  90021E     MOV [W14+2], W4
003B7C  528F84     SUB W5, W4, [W15]
003B7E  390003     BRA NC, 0x3B86
1109:                    value = 0;
003B80  EB0200     CLR W4
003B82  980714     MOV W4, [W14+2]
003B84  370014     BRA 0x3BAE
1110:                  } else {
1111:                    value = value - ptr->v_adc_cal_offset;
003B86  78021E     MOV [W14], W4
003B88  900A34     MOV [W4+22], W4
003B8A  90029E     MOV [W14+2], W5
003B8C  528204     SUB W5, W4, W4
003B8E  980714     MOV W4, [W14+2]
003B90  37000E     BRA 0x3BAE
1112:                  }
1113:                } else {
1114:                  // The offset is negative
1115:                  // Check to make sure we do not overflow above 0xFFFF
1116:                  if ((0xFFFF + ptr->v_adc_cal_offset) <= value) {
003B92  78021E     MOV [W14], W4
003B94  900A34     MOV [W4+22], W4
003B96  E90284     DEC W4, W5
003B98  90021E     MOV [W14+2], W4
003B9A  528F84     SUB W5, W4, [W15]
003B9C  3E0003     BRA GTU, 0x3BA4
1117:                    value = 0xFFFF;
003B9E  EB8200     SETM W4
003BA0  980714     MOV W4, [W14+2]
003BA2  370005     BRA 0x3BAE
1118:                  } else {
1119:                    value = value - ptr->v_adc_cal_offset;
003BA4  78021E     MOV [W14], W4
003BA6  900A34     MOV [W4+22], W4
003BA8  90029E     MOV [W14+2], W5
003BAA  528204     SUB W5, W4, W4
003BAC  980714     MOV W4, [W14+2]
1120:                  }
1121:                }
1122:                value = ReverseScale16Bit(value, ptr->v_adc_cal_gain);
003BAE  78021E     MOV [W14], W4
003BB0  900A24     MOV [W4+20], W4
003BB2  780084     MOV W4, W1
003BB4  90001E     MOV [W14+2], W0
003BB6  070043     RCALL ReverseScale16Bit
003BB8  780200     MOV W0, W4
003BBA  980714     MOV W4, [W14+2]
1123:                value = ReverseScale16Bit(value, ptr->v_adc_scale);
003BBC  78021E     MOV [W14], W4
003BBE  900A14     MOV [W4+18], W4
003BC0  780084     MOV W4, W1
003BC2  90001E     MOV [W14+2], W0
003BC4  07003C     RCALL ReverseScale16Bit
003BC6  780200     MOV W0, W4
003BC8  980714     MOV W4, [W14+2]
1124:                return value;
003BCA  90021E     MOV [W14+2], W4
1125:              }
003BCC  780004     MOV W4, W0
003BCE  FA8000     ULNK
003BD0  060000     RETURN
1126:              
1127:              unsigned int ReturnPowerSupplyADCScaledCurrent(POWERSUPPLY* ptr, unsigned int value) {
003BD2  FA0004     LNK #0x4
003BD4  780F00     MOV W0, [W14]
003BD6  980711     MOV W1, [W14+2]
1128:                if (ptr->i_adc_cal_offset > 0) {
003BD8  78021E     MOV [W14], W4
003BDA  902214     MOV [W4+66], W4
003BDC  520FE0     SUB W4, #0x0, [W15]
003BDE  34000F     BRA LE, 0x3BFE
1129:                  // Check to make sure we do not overflow below 0x0000
1130:                  // Our offset is 
1131:                  if (ptr->i_adc_cal_offset > value) {
003BE0  78021E     MOV [W14], W4
003BE2  902214     MOV [W4+66], W4
003BE4  780284     MOV W4, W5
003BE6  90021E     MOV [W14+2], W4
003BE8  528F84     SUB W5, W4, [W15]
003BEA  360003     BRA LEU, 0x3BF2
1132:                    value = 0;
003BEC  EB0200     CLR W4
003BEE  980714     MOV W4, [W14+2]
003BF0  370014     BRA 0x3C1A
1133:                  } else {
1134:                    value = value - ptr->i_adc_cal_offset;
003BF2  78021E     MOV [W14], W4
003BF4  902214     MOV [W4+66], W4
003BF6  90029E     MOV [W14+2], W5
003BF8  528204     SUB W5, W4, W4
003BFA  980714     MOV W4, [W14+2]
003BFC  37000E     BRA 0x3C1A
1135:                  }
1136:                } else {
1137:                  // Check to make sure we do not overflow above 0xFFFF
1138:                  if ((0xFFFF + ptr->i_adc_cal_offset) < value) {
003BFE  78021E     MOV [W14], W4
003C00  902214     MOV [W4+66], W4
003C02  E90284     DEC W4, W5
003C04  90021E     MOV [W14+2], W4
003C06  528F84     SUB W5, W4, [W15]
003C08  310003     BRA C, 0x3C10
1139:                    value = 0xFFFF;
003C0A  EB8200     SETM W4
003C0C  980714     MOV W4, [W14+2]
003C0E  370005     BRA 0x3C1A
1140:                  } else {
1141:                    value = value - ptr->i_adc_cal_offset;
003C10  78021E     MOV [W14], W4
003C12  902214     MOV [W4+66], W4
003C14  90029E     MOV [W14+2], W5
003C16  528204     SUB W5, W4, W4
003C18  980714     MOV W4, [W14+2]
1142:                  }
1143:                }
1144:                value = ReverseScale16Bit(value, ptr->i_adc_cal_gain);
003C1A  78021E     MOV [W14], W4
003C1C  902204     MOV [W4+64], W4
003C1E  780084     MOV W4, W1
003C20  90001E     MOV [W14+2], W0
003C22  07000D     RCALL ReverseScale16Bit
003C24  780200     MOV W0, W4
003C26  980714     MOV W4, [W14+2]
1145:                value = ReverseScale16Bit(value, ptr->i_adc_scale);
003C28  78021E     MOV [W14], W4
003C2A  901A74     MOV [W4+62], W4
003C2C  780084     MOV W4, W1
003C2E  90001E     MOV [W14+2], W0
003C30  070006     RCALL ReverseScale16Bit
003C32  780200     MOV W0, W4
003C34  980714     MOV W4, [W14+2]
1146:                return value;
003C36  90021E     MOV [W14+2], W4
1147:              }
003C38  780004     MOV W4, W0
003C3A  FA8000     ULNK
003C3C  060000     RETURN
1148:               
1149:              
1150:              unsigned int ReverseScale16Bit(unsigned int value, unsigned int scale) {
003C3E  FA0008     LNK #0x8
003C40  980720     MOV W0, [W14+4]
003C42  980731     MOV W1, [W14+6]
1151:                unsigned long temp;
1152:                temp = value;
003C44  90022E     MOV [W14+4], W4
003C46  200005     MOV #0x0, W5
003C48  BE8F04     MOV.D W4, [W14]
1153:                temp = temp << 13;
003C4A  BE031E     MOV.D [W14], W6
003C4C  DD3A4D     SL W7, #13, W4
003C4E  DE32C3     LSR W6, #3, W5
003C50  720285     IOR W4, W5, W5
003C52  DD324D     SL W6, #13, W4
003C54  BE8F04     MOV.D W4, [W14]
1154:                temp /= scale;
003C56  90023E     MOV [W14+6], W4
003C58  200005     MOV #0x0, W5
003C5A  BE0104     MOV.D W4, W2
003C5C  BE001E     MOV.D [W14], W0
003C5E  07E31C     RCALL ___udivsi3
003C60  BE0200     MOV.D W0, W4
003C62  BE8F04     MOV.D W4, [W14]
1155:                if (temp > 0x0000FFFF) {
003C64  2FFFF4     MOV #0xFFFF, W4
003C66  200005     MOV #0x0, W5
003C68  BE031E     MOV.D [W14], W6
003C6A  530F84     SUB W6, W4, [W15]
003C6C  5B8F85     SUBB W7, W5, [W15]
003C6E  360006     BRA LEU, 0x3C7C
1156:                  temp = 0x0000FFFF;
003C70  2FFFF4     MOV #0xFFFF, W4
003C72  200005     MOV #0x0, W5
003C74  BE8F04     MOV.D W4, [W14]
1157:                  global_debug_counter.reversescale16bit_saturation++;
003C76  80C374     MOV 0x186E, W4
003C78  E80204     INC W4, W4
003C7A  88C374     MOV W4, 0x186E
1158:                }
1159:                temp = temp & 0xFFFF;
003C7C  2FFFF4     MOV #0xFFFF, W4
003C7E  200005     MOV #0x0, W5
003C80  BE031E     MOV.D [W14], W6
003C82  780006     MOV W6, W0
003C84  780307     MOV W7, W6
003C86  780384     MOV W4, W7
003C88  780205     MOV W5, W4
003C8A  600007     AND W0, W7, W0
003C8C  630204     AND W6, W4, W4
003C8E  200005     MOV #0x0, W5
003C90  DD22C0     SL W4, #0, W5
003C92  200004     MOV #0x0, W4
003C94  BE0304     MOV.D W4, W6
003C96  B80261     MUL.UU W0, #1, W4
003C98  730304     IOR W6, W4, W6
003C9A  738385     IOR W7, W5, W7
003C9C  BE8F06     MOV.D W6, [W14]
1160:                return temp;
003C9E  78021E     MOV [W14], W4
1161:              }
003CA0  780004     MOV W4, W0
003CA2  FA8000     ULNK
003CA4  060000     RETURN
---  C:/Users/dparker/Documents/GitHub/A36760/Main.c  ---------------------------------------------------
1:                 #include <p30F6014a.h>
2:                 #include <libpic30.h>
3:                 #include <adc12.h>
4:                 #include "A34760.h"
5:                 #include "A34760_PINS.h"
6:                 #include "IOPorts.h"
7:                 #include "LTC2656.h"
8:                 #include <i2c.h>
9:                 #include "MCP23017.h"
10:                #include "ETMSPI.h"
11:                #include <spi.h>
12:                #include "ETMdsp.h"
13:                #include "config.h"
14:                
15:                
16:                void ReadAllEEpromToRAM(void);
17:                
18:                _prog_addressT EE_address_ps_magnet_config_in_EEPROM;
19:                unsigned int _EEDATA(32) ps_magnet_config_in_EEPROM[] = PS_MAGNET_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
20:                signed int ps_magnet_config_ram_copy[16];
21:                
22:                _prog_addressT EE_address_ps_filament_config_in_EEPROM;
23:                unsigned int _EEDATA(32) ps_filament_config_in_EEPROM[] = PS_FILAMENT_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
24:                signed int ps_filament_config_ram_copy[16];
25:                
26:                _prog_addressT EE_address_ps_thyr_cathode_htr_config_in_EEPROM;
27:                unsigned int _EEDATA(32) ps_thyr_cathode_htr_config_in_EEPROM[] = PS_THYR_CATH_HTR_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
28:                signed int ps_thyr_cathode_htr_config_ram_copy[16];
29:                
30:                _prog_addressT EE_address_ps_thyr_reservoir_htr_config_in_EEPROM;
31:                unsigned int _EEDATA(32) ps_thyr_reservoir_htr_config_in_EEPROM[] = PS_THYR_RESER_HTR_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
32:                signed int ps_thyr_reservoir_htr_config_ram_copy[16];
33:                
34:                
35:                _prog_addressT EE_address_ps_hv_lambda_mode_A_config_in_EEPROM;
36:                unsigned int _EEDATA(32) ps_hv_lambda_mode_A_config_in_EEPROM[] = PS_HV_LAMBDA_MODE_A_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
37:                signed int ps_hv_lambda_mode_A_config_ram_copy[16];
38:                
39:                _prog_addressT EE_address_ps_hv_lambda_mode_B_config_in_EEPROM;
40:                unsigned int _EEDATA(32) ps_hv_lambda_mode_B_config_in_EEPROM[] = PS_HV_LAMBDA_MODE_B_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
41:                signed int ps_hv_lambda_mode_B_config_ram_copy[16];
42:                
43:                
44:                _prog_addressT EE_address_ps_magnetron_mode_A_config_in_EEPROM;
45:                unsigned int _EEDATA(32) ps_magnetron_mode_A_config_in_EEPROM[] = PS_MAGNETRON_MODE_A_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
46:                signed int ps_magnetron_mode_A_config_ram_copy[16];
47:                
48:                _prog_addressT EE_address_ps_magnetron_mode_B_config_in_EEPROM;
49:                unsigned int _EEDATA(32) ps_magnetron_mode_B_config_in_EEPROM[] = PS_MAGNETRON_MODE_B_DEFAULT_CONFIG;  // Create 16 word structure in EEPROM and load default configuration values
50:                signed int ps_magnetron_mode_B_config_ram_copy[16];
51:                
52:                _prog_addressT EE_address_pulse_counter_repository_in_EEPROM;
53:                unsigned int _EEDATA(32) pulse_counter_repository_in_EEPROM[] = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};  // Create 16 word structure in EEPROM and load zeros
54:                signed int pulse_counter_repository_ram_copy[16];
55:                
56:                
57:                _prog_addressT EE_address_control_loop_cal_data_in_EEPROM;
58:                unsigned int _EEDATA(32) control_loop_cal_data_in_EEPROM[] = CONTROL_LOOP_CAL_DATA_DEFAULT_CONFIG; // Create 16 word structure in EEPROM and load default configuration values
59:                signed int control_loop_cal_data_ram_copy[16];
60:                
61:                
62:                /*
63:                  
64:                  
65:                 */
66:                
67:                
68:                
69:                /*
70:                  Pulse Counter Structure
71:                  pulse_counter_repository_ram_copy[0] = pulse_counter MSB
72:                  pulse_counter_repository_ram_copy[1] = pulse_counter 
73:                  pulse_counter_repository_ram_copy[2] = pulse_counter 
74:                  pulse_counter_repository_ram_copy[3] = pulse_counter LSB
75:                
76:                  pulse_counter_repository_ram_copy[4] = arc_counter MSB
77:                  pulse_counter_repository_ram_copy[5] = arc_counter LSB
78:                
79:                
80:                */
81:                
82:                
83:                
84:                /* Configuration Bit Settings */
85:                //_FOSC(LPRC & CSW_FSCM_OFF);
86:                _FOSC(ECIO & CSW_FSCM_OFF); // Primary Oscillator with PLL and Startup with User Selected Oscillator Source
87:                // DPARKER this is for use with 40MHz ext clock
88:                
89:                //_FOSC(FRC_PLL16 & CSW_FSCM_OFF); // Primary Oscillator with PLL and Startup with User Selected Oscillator Source
90:                                                 // External Oscillator is 7.3738MHz with 16x PLL and 4x Clocks per Instruction cycle
91:                                                 // This yields an Instruction Cycle Frequency of 29.4952 MHz
92:                                                 // This yields an Instruction Cycle Time of 33.904nS
93:                
94:                
95:                // Watchdog Timeout is 2 Millisconds with no pre scallers
96:                _FWDT(WDT_ON & WDTPSA_1 & WDTPSB_2);  // Watchdog Timer is enabled, 4ms TIMEOUT
97:                //_FWDT(WDT_ON & WDTPSA_1 & WDTPSB_16);  // Watchdog Timer is enabled, 32ms TIMEOUT
98:                //_FWDT(WDT_OFF & WDTPSA_1 & WDTPSB_16);  // Watchdog Timer is disnabled, 32ms TIMEOUT
99:                
100:               
101:               //_FBORPOR(PWRT_64 & BORV_27 & PBOR_ON & MCLR_EN); // Brown out and Power on Timer settings
102:               _FBORPOR(PWRT_OFF & BORV_45 & PBOR_OFF & MCLR_EN); // Brown out and Power on Timer settings
103:               
104:               // _FBS()  // No Boot Segment
105:               
106:               _FBS(WR_PROTECT_BOOT_OFF & NO_BOOT_CODE & NO_BOOT_EEPROM & NO_BOOT_RAM);
107:               
108:               _FSS(WR_PROT_SEC_OFF & NO_SEC_CODE & NO_SEC_EEPROM & NO_SEC_RAM);
109:               
110:               _FGS(CODE_PROT_OFF);
111:               
112:               _FICD(PGD);
113:               
114:               int main(void) {
004CFC  FA0000     LNK #0x0
115:               
116:                 TRIS_PIN_MAGNETRON_MAGNET_ENABLE = TRIS_OUTPUT_MODE;
004CFE  A922D3     BCLR 0x2D3, #1
117:                 PIN_MAGNETRON_MAGNET_ENABLE = OLL_MAGNETRON_MAGNET_ENABLED;
004D00  A822D7     BSET 0x2D7, #1
118:                 
119:                 PIN_MCU_CLOCK_OUT_TEST_POINT = 1;
004D02  A8E2D1     BSET 0x2D1, #7
120:                 TRIS_PIN_MCU_CLOCK_OUT_TEST_POINT = TRIS_OUTPUT_MODE;
004D04  A9E2CD     BCLR 0x2CD, #7
121:               
122:               
123:                 control_state = STATE_START_UP;
004D06  B3C044     MOV.B #0x4, W4
004D08  784004     MOV.B W4, W0
004D0A  B7E840     MOV.B WREG, control_state
124:                 if ((PIN_FP_MODULATOR_ENABLE_INPUT == ILL_MODULATOR_ENABLED) && (PIN_FP_MODULATOR_HV_ON_INPUT == ILL_MODULATOR_HV_ON) && (PIN_FAST_RESTART_STORAGE_CAP_INPUT == ILL_DO_FAST_RESTART)) {
004D0C  801615     MOV PORTA, W5
004D0E  240004     MOV #0x4000, W4
004D10  628204     AND W5, W4, W4
004D12  520FE0     SUB W4, #0x0, [W15]
004D14  3A000D     BRA NZ, 0x4D30
004D16  801615     MOV PORTA, W5
004D18  280004     MOV #0x8000, W4
004D1A  628204     AND W5, W4, W4
004D1C  520FE0     SUB W4, #0x0, [W15]
004D1E  3A0008     BRA NZ, 0x4D30
004D20  801645     MOV PORTB, W5
004D22  280004     MOV #0x8000, W4
004D24  628204     AND W5, W4, W4
004D26  520FE0     SUB W4, #0x0, [W15]
004D28  3A0003     BRA NZ, 0x4D30
125:                   control_state = STATE_FAST_RECOVERY_START_UP;  // Execute fast startup straight to HV ON
004D2A  B3C064     MOV.B #0x6, W4
004D2C  784004     MOV.B W4, W0
004D2E  B7E840     MOV.B WREG, control_state
126:                 }
127:                 
128:               
129:                 ReadAllEEpromToRAM();  // Ream all configuration from EEPROM into RAM
004D30  070005     RCALL ReadAllEEpromToRAM
130:               
131:                 ram_config_set_magnetron_magnet_current_from_GUI = 0;  // On processor rest, Magnet current is set from Mode A Voltage and not from the GUI
004D32  EB4200     CLR.B W4
004D34  784004     MOV.B W4, W0
004D36  B7E830     MOV.B WREG, ram_config_set_magnetron_magnet_current_from_GUI
132:               
133:               
134:                 while (1) {
135:                   DoStateMachine();
004D38  07DAFF     RCALL DoStateMachine
136:                 }
004D3A  37FFFE     BRA 0x4D38
137:               }
138:               
139:               
140:               
141:               void ReadAllEEpromToRAM(void) {
004D3C  FA0000     LNK #0x0
142:                 _init_prog_address(EE_address_ps_magnet_config_in_EEPROM, ps_magnet_config_in_EEPROM);
004D3E  2F0004     MOV #0xF000, W4
004D40  2007F5     MOV #0x7F, W5
004D42  88B7A4     MOV W4, EE_address_ps_magnet_config_in_EEPROM
004D44  88B7B5     MOV W5, 0x16F6
143:                 _memcpy_p2d16(ps_magnet_config_ram_copy, EE_address_ps_magnet_config_in_EEPROM, _EE_ROW);
004D46  80B7A6     MOV EE_address_ps_magnet_config_in_EEPROM, W6
004D48  80B7B7     MOV 0x16F6, W7
004D4A  EB0200     CLR W4
004D4C  200203     MOV #0x20, W3
004D4E  216F82     MOV #0x16F8, W2
004D50  BE0006     MOV.D W6, W0
004D52  07DA87     RCALL __memcpy_helper
144:                 ClrWdt();
004D54  FE6000     CLRWDT
145:               
146:                 _init_prog_address(EE_address_ps_filament_config_in_EEPROM, ps_filament_config_in_EEPROM);
004D56  2F0204     MOV #0xF020, W4
004D58  2007F5     MOV #0x7F, W5
004D5A  88B8C4     MOV W4, EE_address_ps_filament_config_in_EEPROM
004D5C  88B8D5     MOV W5, 0x171A
147:                 _memcpy_p2d16(ps_filament_config_ram_copy, EE_address_ps_filament_config_in_EEPROM, _EE_ROW);
004D5E  80B8C6     MOV EE_address_ps_filament_config_in_EEPROM, W6
004D60  80B8D7     MOV 0x171A, W7
004D62  EB0200     CLR W4
004D64  200203     MOV #0x20, W3
004D66  2171C2     MOV #0x171C, W2
004D68  BE0006     MOV.D W6, W0
004D6A  07DA7B     RCALL __memcpy_helper
148:                 ClrWdt();
004D6C  FE6000     CLRWDT
149:               
150:                 _init_prog_address(EE_address_ps_thyr_cathode_htr_config_in_EEPROM, ps_thyr_cathode_htr_config_in_EEPROM);
004D6E  2F0404     MOV #0xF040, W4
004D70  2007F5     MOV #0x7F, W5
004D72  88B9E4     MOV W4, EE_address_ps_thyr_cathode_htr_config_in_EEPROM
004D74  88B9F5     MOV W5, 0x173E
151:                 _memcpy_p2d16(ps_thyr_cathode_htr_config_ram_copy, EE_address_ps_thyr_cathode_htr_config_in_EEPROM, _EE_ROW);
004D76  80B9E6     MOV EE_address_ps_thyr_cathode_htr_config_in_EEPROM, W6
004D78  80B9F7     MOV 0x173E, W7
004D7A  EB0200     CLR W4
004D7C  200203     MOV #0x20, W3
004D7E  217402     MOV #0x1740, W2
004D80  BE0006     MOV.D W6, W0
004D82  07DA6F     RCALL __memcpy_helper
152:                 ClrWdt();
004D84  FE6000     CLRWDT
153:               
154:                 _init_prog_address(EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, ps_thyr_reservoir_htr_config_in_EEPROM);
004D86  2F0604     MOV #0xF060, W4
004D88  2007F5     MOV #0x7F, W5
004D8A  88BB04     MOV W4, EE_address_ps_thyr_reservoir_htr_config_in_EEPROM
004D8C  88BB15     MOV W5, 0x1762
155:                 _memcpy_p2d16(ps_thyr_reservoir_htr_config_ram_copy, EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, _EE_ROW);
004D8E  80BB06     MOV EE_address_ps_thyr_reservoir_htr_config_in_EEPROM, W6
004D90  80BB17     MOV 0x1762, W7
004D92  EB0200     CLR W4
004D94  200203     MOV #0x20, W3
004D96  217642     MOV #0x1764, W2
004D98  BE0006     MOV.D W6, W0
004D9A  07DA63     RCALL __memcpy_helper
156:                 ClrWdt();
004D9C  FE6000     CLRWDT
157:               
158:                 _init_prog_address(EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, ps_hv_lambda_mode_A_config_in_EEPROM);
004D9E  2F0804     MOV #0xF080, W4
004DA0  2007F5     MOV #0x7F, W5
004DA2  88BC24     MOV W4, EE_address_ps_hv_lambda_mode_A_config_in_EEPROM
004DA4  88BC35     MOV W5, 0x1786
159:                 _memcpy_p2d16(ps_hv_lambda_mode_A_config_ram_copy, EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, _EE_ROW);
004DA6  80BC26     MOV EE_address_ps_hv_lambda_mode_A_config_in_EEPROM, W6
004DA8  80BC37     MOV 0x1786, W7
004DAA  EB0200     CLR W4
004DAC  200203     MOV #0x20, W3
004DAE  217882     MOV #0x1788, W2
004DB0  BE0006     MOV.D W6, W0
004DB2  07DA57     RCALL __memcpy_helper
160:                 ClrWdt();
004DB4  FE6000     CLRWDT
161:               
162:                 _init_prog_address(EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, ps_hv_lambda_mode_B_config_in_EEPROM);
004DB6  2F0A04     MOV #0xF0A0, W4
004DB8  2007F5     MOV #0x7F, W5
004DBA  88BD44     MOV W4, EE_address_ps_hv_lambda_mode_B_config_in_EEPROM
004DBC  88BD55     MOV W5, 0x17AA
163:                 _memcpy_p2d16(ps_hv_lambda_mode_B_config_ram_copy, EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, _EE_ROW);
004DBE  80BD46     MOV EE_address_ps_hv_lambda_mode_B_config_in_EEPROM, W6
004DC0  80BD57     MOV 0x17AA, W7
004DC2  EB0200     CLR W4
004DC4  200203     MOV #0x20, W3
004DC6  217AC2     MOV #0x17AC, W2
004DC8  BE0006     MOV.D W6, W0
004DCA  07DA4B     RCALL __memcpy_helper
164:                 ClrWdt();
004DCC  FE6000     CLRWDT
165:               
166:                 _init_prog_address(EE_address_ps_magnetron_mode_A_config_in_EEPROM, ps_magnetron_mode_A_config_in_EEPROM);
004DCE  2F0C04     MOV #0xF0C0, W4
004DD0  2007F5     MOV #0x7F, W5
004DD2  88BE64     MOV W4, EE_address_ps_magnetron_mode_A_config_in_EEPROM
004DD4  88BE75     MOV W5, 0x17CE
167:                 _memcpy_p2d16(ps_magnetron_mode_A_config_ram_copy, EE_address_ps_magnetron_mode_A_config_in_EEPROM, _EE_ROW);
004DD6  80BE66     MOV EE_address_ps_magnetron_mode_A_config_in_EEPROM, W6
004DD8  80BE77     MOV 0x17CE, W7
004DDA  EB0200     CLR W4
004DDC  200203     MOV #0x20, W3
004DDE  217D02     MOV #0x17D0, W2
004DE0  BE0006     MOV.D W6, W0
004DE2  07DA3F     RCALL __memcpy_helper
168:                 ClrWdt();
004DE4  FE6000     CLRWDT
169:               
170:                 _init_prog_address(EE_address_ps_magnetron_mode_B_config_in_EEPROM, ps_magnetron_mode_B_config_in_EEPROM);
004DE6  2F0E04     MOV #0xF0E0, W4
004DE8  2007F5     MOV #0x7F, W5
004DEA  88BF84     MOV W4, EE_address_ps_magnetron_mode_B_config_in_EEPROM
004DEC  88BF95     MOV W5, 0x17F2
171:                 _memcpy_p2d16(ps_magnetron_mode_B_config_ram_copy, EE_address_ps_magnetron_mode_B_config_in_EEPROM, _EE_ROW);
004DEE  80BF86     MOV EE_address_ps_magnetron_mode_B_config_in_EEPROM, W6
004DF0  80BF97     MOV 0x17F2, W7
004DF2  EB0200     CLR W4
004DF4  200203     MOV #0x20, W3
004DF6  217F42     MOV #0x17F4, W2
004DF8  BE0006     MOV.D W6, W0
004DFA  07DA33     RCALL __memcpy_helper
172:                 ClrWdt();
004DFC  FE6000     CLRWDT
173:               
174:                 _init_prog_address(EE_address_pulse_counter_repository_in_EEPROM, pulse_counter_repository_in_EEPROM);
004DFE  2F1004     MOV #0xF100, W4
004E00  2007F5     MOV #0x7F, W5
004E02  88C0A4     MOV W4, EE_address_pulse_counter_repository_in_EEPROM
004E04  88C0B5     MOV W5, 0x1816
175:                 _memcpy_p2d16(pulse_counter_repository_ram_copy, EE_address_pulse_counter_repository_in_EEPROM, _EE_ROW);
004E06  80C0A6     MOV EE_address_pulse_counter_repository_in_EEPROM, W6
004E08  80C0B7     MOV 0x1816, W7
004E0A  EB0200     CLR W4
004E0C  200203     MOV #0x20, W3
004E0E  218182     MOV #0x1818, W2
004E10  BE0006     MOV.D W6, W0
004E12  07DA27     RCALL __memcpy_helper
176:                 ClrWdt();
004E14  FE6000     CLRWDT
177:               
178:                 _init_prog_address(EE_address_control_loop_cal_data_in_EEPROM, control_loop_cal_data_in_EEPROM);
004E16  2F1204     MOV #0xF120, W4
004E18  2007F5     MOV #0x7F, W5
004E1A  88C1C4     MOV W4, EE_address_control_loop_cal_data_in_EEPROM
004E1C  88C1D5     MOV W5, 0x183A
179:                 _memcpy_p2d16(control_loop_cal_data_ram_copy, EE_address_control_loop_cal_data_in_EEPROM, _EE_ROW);
004E1E  80C1C6     MOV EE_address_control_loop_cal_data_in_EEPROM, W6
004E20  80C1D7     MOV 0x183A, W7
004E22  EB0200     CLR W4
004E24  200203     MOV #0x20, W3
004E26  2183C2     MOV #0x183C, W2
004E28  BE0006     MOV.D W6, W0
004E2A  07DA1B     RCALL __memcpy_helper
180:                 ClrWdt();
004E2C  FE6000     CLRWDT
181:               }
004E2E  FA8000     ULNK
004E30  060000     RETURN
---  C:/Users/dparker/Documents/GitHub/A36760/MCP23017.c  -----------------------------------------------
1:                 #include "MCP23017.h"
2:                 #include "ETMI2C.h"
3:                 
4:                 unsigned int MCP23017WriteSingleByte(MCP23017* ptr_MCP23017, unsigned char MCP23017_register, unsigned char register_data) {
004F4A  FA0006     LNK #0x6
004F4C  980710     MOV W0, [W14+2]
004F4E  984741     MOV.B W1, [W14+4]
004F50  984752     MOV.B W2, [W14+5]
5:                   unsigned int error_check;
6:                   
7:                   error_check = WaitForI2CBusIdle(ptr_MCP23017->i2c_port);                                                    // Wait for I2C Bus idle
004F52  90021E     MOV [W14+2], W4
004F54  904274     MOV.B [W4+7], W4
004F56  784004     MOV.B W4, W0
004F58  07FDC2     RCALL WaitForI2CBusIdle
004F5A  780200     MOV W0, W4
004F5C  780F04     MOV W4, [W14]
8:                 
9:                   error_check |= GenerateI2CStart(ptr_MCP23017->i2c_port);                                                    // Generate start condition 
004F5E  90021E     MOV [W14+2], W4
004F60  904274     MOV.B [W4+7], W4
004F62  784004     MOV.B W4, W0
004F64  07FDE5     RCALL GenerateI2CStart
004F66  780200     MOV W0, W4
004F68  720F1E     IOR W4, [W14], [W14]
10:                
11:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_WRITE_CONTROL_BIT), ptr_MCP23017->i2c_port);  // Write the address to the bus in WRITE MODE
004F6A  90021E     MOV [W14+2], W4
004F6C  9042F4     MOV.B [W4+7], W5
004F6E  90021E     MOV [W14+2], W4
004F70  904264     MOV.B [W4+6], W4
004F72  784085     MOV.B W5, W1
004F74  784004     MOV.B W4, W0
004F76  07FE2C     RCALL WriteByteI2C
004F78  780200     MOV W0, W4
004F7A  720F1E     IOR W4, [W14], [W14]
12:                  
13:                  error_check |= WriteByteI2C(MCP23017_register, ptr_MCP23017->i2c_port);                                     // Write the register location to the bus
004F7C  90021E     MOV [W14+2], W4
004F7E  904274     MOV.B [W4+7], W4
004F80  784084     MOV.B W4, W1
004F82  90404E     MOV.B [W14+4], W0
004F84  07FE25     RCALL WriteByteI2C
004F86  780200     MOV W0, W4
004F88  720F1E     IOR W4, [W14], [W14]
14:                
15:                  error_check |= WriteByteI2C(register_data, ptr_MCP23017->i2c_port);                                         // Write the data to the bus
004F8A  90021E     MOV [W14+2], W4
004F8C  904274     MOV.B [W4+7], W4
004F8E  784084     MOV.B W4, W1
004F90  90405E     MOV.B [W14+5], W0
004F92  07FE1E     RCALL WriteByteI2C
004F94  780200     MOV W0, W4
004F96  720F1E     IOR W4, [W14], [W14]
16:                  
17:                  error_check |= GenerateI2CStop(ptr_MCP23017->i2c_port);                                                     // Generate Stop Condition
004F98  90021E     MOV [W14+2], W4
004F9A  904274     MOV.B [W4+7], W4
004F9C  784004     MOV.B W4, W0
004F9E  07FE86     RCALL GenerateI2CStop
004FA0  780200     MOV W0, W4
004FA2  720F1E     IOR W4, [W14], [W14]
18:                  
19:                  ClrWdt();
004FA4  FE6000     CLRWDT
20:                  return error_check;
004FA6  78021E     MOV [W14], W4
21:                }
004FA8  780004     MOV W4, W0
004FAA  FA8000     ULNK
004FAC  060000     RETURN
22:                
23:                unsigned int MCP23017ReadSingleByte(MCP23017* ptr_MCP23017, unsigned char MCP23017_register) {
004FAE  FA0006     LNK #0x6
004FB0  980710     MOV W0, [W14+2]
004FB2  984741     MOV.B W1, [W14+4]
24:                  unsigned int error_check;
25:                  
26:                  error_check = WaitForI2CBusIdle(ptr_MCP23017->i2c_port);                                                    // Wait for I2C Bus idle
004FB4  90021E     MOV [W14+2], W4
004FB6  904274     MOV.B [W4+7], W4
004FB8  784004     MOV.B W4, W0
004FBA  07FD91     RCALL WaitForI2CBusIdle
004FBC  780200     MOV W0, W4
004FBE  780F04     MOV W4, [W14]
27:                
28:                  error_check |= GenerateI2CStart(ptr_MCP23017->i2c_port);                                                    // Generate start condition 
004FC0  90021E     MOV [W14+2], W4
004FC2  904274     MOV.B [W4+7], W4
004FC4  784004     MOV.B W4, W0
004FC6  07FDB4     RCALL GenerateI2CStart
004FC8  780200     MOV W0, W4
004FCA  720F1E     IOR W4, [W14], [W14]
29:                
30:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_WRITE_CONTROL_BIT), ptr_MCP23017->i2c_port);  // Write the address to the bus in WRITE MODE
004FCC  90021E     MOV [W14+2], W4
004FCE  9042F4     MOV.B [W4+7], W5
004FD0  90021E     MOV [W14+2], W4
004FD2  904264     MOV.B [W4+6], W4
004FD4  784085     MOV.B W5, W1
004FD6  784004     MOV.B W4, W0
004FD8  07FDFB     RCALL WriteByteI2C
004FDA  780200     MOV W0, W4
004FDC  720F1E     IOR W4, [W14], [W14]
31:                
32:                  error_check |= WriteByteI2C(MCP23017_register, ptr_MCP23017->i2c_port);                                     // Write the register location to the bus
004FDE  90021E     MOV [W14+2], W4
004FE0  904274     MOV.B [W4+7], W4
004FE2  784084     MOV.B W4, W1
004FE4  90404E     MOV.B [W14+4], W0
004FE6  07FDF4     RCALL WriteByteI2C
004FE8  780200     MOV W0, W4
004FEA  720F1E     IOR W4, [W14], [W14]
33:                
34:                  error_check |= GenerateI2CRestart(ptr_MCP23017->i2c_port);                                                  // Generate re-start condition 
004FEC  90021E     MOV [W14+2], W4
004FEE  904274     MOV.B [W4+7], W4
004FF0  784004     MOV.B W4, W0
004FF2  07FDC6     RCALL GenerateI2CRestart
004FF4  780200     MOV W0, W4
004FF6  720F1E     IOR W4, [W14], [W14]
35:                
36:                  error_check |= WriteByteI2C((ptr_MCP23017->address | MCP23017_READ_CONTROL_BIT), ptr_MCP23017->i2c_port);   // Write the address to the bus in READ MODE
004FF8  90021E     MOV [W14+2], W4
004FFA  9042F4     MOV.B [W4+7], W5
004FFC  90021E     MOV [W14+2], W4
004FFE  904264     MOV.B [W4+6], W4
005000  A00404     BSET.B W4, #0
005002  784085     MOV.B W5, W1
005004  784004     MOV.B W4, W0
005006  07FDE4     RCALL WriteByteI2C
005008  780200     MOV W0, W4
00500A  720F1E     IOR W4, [W14], [W14]
37:                
38:                  error_check |= ReadByteI2C(ptr_MCP23017->i2c_port);                                                         // Read a byte from the bus
00500C  90021E     MOV [W14+2], W4
00500E  904274     MOV.B [W4+7], W4
005010  784004     MOV.B W4, W0
005012  07FE16     RCALL ReadByteI2C
005014  780200     MOV W0, W4
005016  720F1E     IOR W4, [W14], [W14]
39:                  
40:                  error_check |= GenerateI2CStop(ptr_MCP23017->i2c_port);                                                     // Generate Stop Condition
005018  90021E     MOV [W14+2], W4
00501A  904274     MOV.B [W4+7], W4
00501C  784004     MOV.B W4, W0
00501E  07FE46     RCALL GenerateI2CStop
005020  780200     MOV W0, W4
005022  720F1E     IOR W4, [W14], [W14]
41:                  
42:                  ClrWdt();
005024  FE6000     CLRWDT
43:                  return error_check;
005026  78021E     MOV [W14], W4
44:                }
005028  780004     MOV W4, W0
00502A  FA8000     ULNK
00502C  060000     RETURN
45:                
46:                
47:                
48:                
49:                
---  C:/Users/dparker/Documents/GitHub/A36760/LTC2656.c  ------------------------------------------------
1:                 #include "LTC2656.h"
2:                 
3:                 
4:                 void SetupLTC2656(LTC2656* ptr_LTC2656) {
004544  FA0002     LNK #0x2
004546  780F00     MOV W0, [W14]
5:                   // See h File For Documentation
6:                   
7:                   PinSetValue(ptr_LTC2656->pin_dac_clear, !LTC2656_CLEAR_OUTPUTS);
004548  78021E     MOV [W14], W4
00454A  900214     MOV [W4+2], W4
00454C  784204     MOV.B W4, W4
00454E  B3C011     MOV.B #0x1, W1
004550  784004     MOV.B W4, W0
004552  07021D     RCALL PinSetValue
8:                   PinSetValue(ptr_LTC2656->pin_load_dac, LTC2656_LOAD_DAC);
004554  78021E     MOV [W14], W4
004556  900224     MOV [W4+4], W4
004558  784204     MOV.B W4, W4
00455A  EB4080     CLR.B W1
00455C  784004     MOV.B W4, W0
00455E  070217     RCALL PinSetValue
9:                   PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
004560  78021E     MOV [W14], W4
004562  780214     MOV [W4], W4
004564  784204     MOV.B W4, W4
004566  B3C011     MOV.B #0x1, W1
004568  784004     MOV.B W4, W0
00456A  070211     RCALL PinSetValue
10:                  PinSetValue(ptr_LTC2656->pin_por_select, ptr_LTC2656->por_select_value);
00456C  78021E     MOV [W14], W4
00456E  900244     MOV [W4+8], W4
004570  784284     MOV.B W4, W5
004572  78021E     MOV [W14], W4
004574  900234     MOV [W4+6], W4
004576  784204     MOV.B W4, W4
004578  784085     MOV.B W5, W1
00457A  784004     MOV.B W4, W0
00457C  070208     RCALL PinSetValue
11:                  
12:                  PinSetTris(ptr_LTC2656->pin_cable_select, TRIS_DIGITAL_OUTPUT);
00457E  78021E     MOV [W14], W4
004580  780214     MOV [W4], W4
004582  784204     MOV.B W4, W4
004584  EB4080     CLR.B W1
004586  784004     MOV.B W4, W0
004588  07015A     RCALL PinSetTris
13:                  PinSetTris(ptr_LTC2656->pin_dac_clear, TRIS_DIGITAL_INPUT);
00458A  78021E     MOV [W14], W4
00458C  900214     MOV [W4+2], W4
00458E  784204     MOV.B W4, W4
004590  B3C011     MOV.B #0x1, W1
004592  784004     MOV.B W4, W0
004594  070154     RCALL PinSetTris
14:                  PinSetTris(ptr_LTC2656->pin_load_dac, TRIS_DIGITAL_OUTPUT);
004596  78021E     MOV [W14], W4
004598  900224     MOV [W4+4], W4
00459A  784204     MOV.B W4, W4
00459C  EB4080     CLR.B W1
00459E  784004     MOV.B W4, W0
0045A0  07014E     RCALL PinSetTris
15:                  PinSetTris(ptr_LTC2656->pin_por_select, TRIS_DIGITAL_OUTPUT);  
0045A2  78021E     MOV [W14], W4
0045A4  900234     MOV [W4+6], W4
0045A6  784204     MOV.B W4, W4
0045A8  EB4080     CLR.B W1
0045AA  784004     MOV.B W4, W0
0045AC  070148     RCALL PinSetTris
16:                }
0045AE  FA8000     ULNK
0045B0  060000     RETURN
17:                
18:                
19:                void ClearOutputsLTC2656(LTC2656* ptr_LTC2656) {
0045B2  FA0002     LNK #0x2
0045B4  780F00     MOV W0, [W14]
20:                  PinSetValue(ptr_LTC2656->pin_dac_clear, LTC2656_CLEAR_OUTPUTS);
0045B6  78021E     MOV [W14], W4
0045B8  900214     MOV [W4+2], W4
0045BA  784204     MOV.B W4, W4
0045BC  EB4080     CLR.B W1
0045BE  784004     MOV.B W4, W0
0045C0  0701E6     RCALL PinSetValue
21:                  PinSetValue(ptr_LTC2656->pin_dac_clear, !LTC2656_CLEAR_OUTPUTS);
0045C2  78021E     MOV [W14], W4
0045C4  900214     MOV [W4+2], W4
0045C6  784204     MOV.B W4, W4
0045C8  B3C011     MOV.B #0x1, W1
0045CA  784004     MOV.B W4, W0
0045CC  0701E0     RCALL PinSetValue
22:                }
0045CE  FA8000     ULNK
0045D0  060000     RETURN
23:                
24:                
25:                
26:                unsigned char WriteLTC2656(LTC2656* ptr_LTC2656, unsigned int command_word, unsigned int data_word) {
0045D2  FA0010     LNK #0x10
0045D4  980750     MOV W0, [W14+10]
0045D6  980761     MOV W1, [W14+12]
0045D8  980772     MOV W2, [W14+14]
27:                  // See h File For Documentation
28:                  
29:                  unsigned char spi_error;
30:                  unsigned int command_word_readback;
31:                  unsigned int data_word_readback;
32:                  unsigned long temp;
33:                  
34:                  spi_error = 0;
0045DA  EB4200     CLR.B W4
0045DC  784F04     MOV.B W4, [W14]
35:                
36:                  PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
0045DE  90025E     MOV [W14+10], W4
0045E0  780214     MOV [W4], W4
0045E2  784204     MOV.B W4, W4
0045E4  EB4080     CLR.B W1
0045E6  784004     MOV.B W4, W0
0045E8  0701D2     RCALL PinSetValue
37:                
38:                
39:                  temp = SendAndReceiveSPI(command_word, ptr_LTC2656->spi_port);
0045EA  90025E     MOV [W14+10], W4
0045EC  904A24     MOV.B [W4+10], W4
0045EE  784084     MOV.B W4, W1
0045F0  90006E     MOV [W14+12], W0
0045F2  07041F     RCALL SendAndReceiveSPI
0045F4  BE0200     MOV.D W0, W4
0045F6  980734     MOV W4, [W14+6]
0045F8  980745     MOV W5, [W14+8]
40:                  if (temp == 0x11110000) {
0045FA  90033E     MOV [W14+6], W6
0045FC  9003CE     MOV [W14+8], W7
0045FE  200004     MOV #0x0, W4
004600  211115     MOV #0x1111, W5
004602  530F84     SUB W6, W4, [W15]
004604  5B8F85     SUBB W7, W5, [W15]
004606  3A0002     BRA NZ, 0x460C
41:                    spi_error = 0b00000001;
004608  B3C014     MOV.B #0x1, W4
00460A  784F04     MOV.B W4, [W14]
42:                  } 
43:                
44:                  if (spi_error == 0) { 
00460C  78421E     MOV.B [W14], W4
00460E  524FE0     SUB.B W4, #0x0, [W15]
004610  3A0010     BRA NZ, 0x4632
45:                    temp = SendAndReceiveSPI(data_word, ptr_LTC2656->spi_port);
004612  90025E     MOV [W14+10], W4
004614  904A24     MOV.B [W4+10], W4
004616  784084     MOV.B W4, W1
004618  90007E     MOV [W14+14], W0
00461A  07040B     RCALL SendAndReceiveSPI
00461C  BE0200     MOV.D W0, W4
00461E  980734     MOV W4, [W14+6]
004620  980745     MOV W5, [W14+8]
46:                    if (temp == 0x11110000) {
004622  90033E     MOV [W14+6], W6
004624  9003CE     MOV [W14+8], W7
004626  200004     MOV #0x0, W4
004628  211115     MOV #0x1111, W5
00462A  530F84     SUB W6, W4, [W15]
00462C  5B8F85     SUBB W7, W5, [W15]
00462E  3A0001     BRA NZ, 0x4632
47:                      spi_error |= 0b00000010;
004630  A0141E     BSET.B [W14], #1
48:                    } 
49:                  }
50:                 
51:                
52:                  PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
004632  90025E     MOV [W14+10], W4
004634  780214     MOV [W4], W4
004636  784204     MOV.B W4, W4
004638  B3C011     MOV.B #0x1, W1
00463A  784004     MOV.B W4, W0
00463C  0701A8     RCALL PinSetValue
53:                 
54:                  Nop();
00463E  000000     NOP
55:                  
56:                  PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
004640  90025E     MOV [W14+10], W4
004642  780214     MOV [W4], W4
004644  784204     MOV.B W4, W4
004646  EB4080     CLR.B W1
004648  784004     MOV.B W4, W0
00464A  0701A1     RCALL PinSetValue
57:                
58:                
59:                  if (spi_error == 0) { 
00464C  78421E     MOV.B [W14], W4
00464E  524FE0     SUB.B W4, #0x0, [W15]
004650  3A0012     BRA NZ, 0x4676
60:                    temp = SendAndReceiveSPI(LTC2656_CMD_NO_OPERATION, ptr_LTC2656->spi_port);
004652  90025E     MOV [W14+10], W4
004654  904A24     MOV.B [W4+10], W4
004656  784084     MOV.B W4, W1
004658  200F00     MOV #0xF0, W0
00465A  0703EB     RCALL SendAndReceiveSPI
00465C  BE0200     MOV.D W0, W4
00465E  980734     MOV W4, [W14+6]
004660  980745     MOV W5, [W14+8]
61:                    command_word_readback = temp & 0xFFFF;
004662  90023E     MOV [W14+6], W4
004664  980714     MOV W4, [W14+2]
62:                    if (temp == 0x11110000) {
004666  90033E     MOV [W14+6], W6
004668  9003CE     MOV [W14+8], W7
00466A  200004     MOV #0x0, W4
00466C  211115     MOV #0x1111, W5
00466E  530F84     SUB W6, W4, [W15]
004670  5B8F85     SUBB W7, W5, [W15]
004672  3A0001     BRA NZ, 0x4676
63:                      spi_error |= 0b00000100;
004674  A0241E     BSET.B [W14], #2
64:                    } 
65:                  }
66:                
67:                  if (spi_error == 0) { 
004676  78421E     MOV.B [W14], W4
004678  524FE0     SUB.B W4, #0x0, [W15]
00467A  3A0012     BRA NZ, 0x46A0
68:                    temp = SendAndReceiveSPI(0, ptr_LTC2656->spi_port);
00467C  90025E     MOV [W14+10], W4
00467E  904A24     MOV.B [W4+10], W4
004680  784084     MOV.B W4, W1
004682  EB0000     CLR W0
004684  0703D6     RCALL SendAndReceiveSPI
004686  BE0200     MOV.D W0, W4
004688  980734     MOV W4, [W14+6]
00468A  980745     MOV W5, [W14+8]
69:                    data_word_readback = temp & 0xFFFF;
00468C  90023E     MOV [W14+6], W4
00468E  980724     MOV W4, [W14+4]
70:                    if (temp == 0x11110000) {
004690  90033E     MOV [W14+6], W6
004692  9003CE     MOV [W14+8], W7
004694  200004     MOV #0x0, W4
004696  211115     MOV #0x1111, W5
004698  530F84     SUB W6, W4, [W15]
00469A  5B8F85     SUBB W7, W5, [W15]
00469C  3A0001     BRA NZ, 0x46A0
71:                      spi_error |= 0b00001000;
00469E  A0341E     BSET.B [W14], #3
72:                    } 
73:                  }
74:                
75:                  PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
0046A0  90025E     MOV [W14+10], W4
0046A2  780214     MOV [W4], W4
0046A4  784204     MOV.B W4, W4
0046A6  B3C011     MOV.B #0x1, W1
0046A8  784004     MOV.B W4, W0
0046AA  070171     RCALL PinSetValue
76:                
77:                
78:                  if (command_word_readback != command_word) {
0046AC  90029E     MOV [W14+2], W5
0046AE  90026E     MOV [W14+12], W4
0046B0  528F84     SUB W5, W4, [W15]
0046B2  320001     BRA Z, 0x46B6
79:                    spi_error |= 0b00010000;
0046B4  A0441E     BSET.B [W14], #4
80:                  }
81:                  if (data_word_readback != data_word) {
0046B6  9002AE     MOV [W14+4], W5
0046B8  90027E     MOV [W14+14], W4
0046BA  528F84     SUB W5, W4, [W15]
0046BC  320002     BRA Z, 0x46C2
82:                    spi_error |= 0b00100000;
0046BE  B3C204     MOV.B #0x20, W4
0046C0  724F1E     IOR.B W4, [W14], [W14]
83:                  }
84:                  
85:                
86:                  return spi_error;
0046C2  78421E     MOV.B [W14], W4
87:                }
0046C4  784004     MOV.B W4, W0
0046C6  FA8000     ULNK
0046C8  060000     RETURN
88:                
89:                
90:                unsigned char WriteLTC2656AllDacChannels(LTC2656* ptr_LTC2656, unsigned int *dac_array) {
0046CA  FA0010     LNK #0x10
0046CC  980760     MOV W0, [W14+12]
0046CE  980771     MOV W1, [W14+14]
91:                  // See h File For Documentation
92:                  
93:                  unsigned char spi_error;
94:                  unsigned int command_word_readback;
95:                  unsigned int data_word_readback;
96:                  unsigned long temp;
97:                  unsigned char dac_number;
98:                
99:                  spi_error = 0;
0046D0  EB4200     CLR.B W4
0046D2  784F04     MOV.B W4, [W14]
100:                 dac_number = 0;
0046D4  EB4200     CLR.B W4
0046D6  984764     MOV.B W4, [W14+6]
101:                 
102:                 while ((spi_error == 0) && (dac_number < 8)) {
0046D8  370059     BRA 0x478C
00478C  78421E     MOV.B [W14], W4
00478E  524FE0     SUB.B W4, #0x0, [W15]
004790  3A0003     BRA NZ, 0x4798
004792  90426E     MOV.B [W14+6], W4
004794  524FE7     SUB.B W4, #0x7, [W15]
004796  36FFA1     BRA LEU, 0x46DA
103:                   // Send out two 16 bit words on the SPI BUS
104:               
105:                   PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
0046DA  90026E     MOV [W14+12], W4
0046DC  780214     MOV [W4], W4
0046DE  784204     MOV.B W4, W4
0046E0  EB4080     CLR.B W1
0046E2  784004     MOV.B W4, W0
0046E4  070154     RCALL PinSetValue
106:                   
107:                   temp = SendAndReceiveSPI(LTC2656_CMD_WRITE_AND_UPDATE_N | dac_number, ptr_LTC2656->spi_port);
0046E6  90026E     MOV [W14+12], W4
0046E8  904A24     MOV.B [W4+10], W4
0046EA  90436E     MOV.B [W14+6], W6
0046EC  B3C305     MOV.B #0x30, W5
0046EE  734285     IOR.B W6, W5, W5
0046F0  FB8285     ZE W5, W5
0046F2  784084     MOV.B W4, W1
0046F4  780005     MOV W5, W0
0046F6  07039D     RCALL SendAndReceiveSPI
0046F8  BE0200     MOV.D W0, W4
0046FA  980744     MOV W4, [W14+8]
0046FC  980755     MOV W5, [W14+10]
108:                   command_word_readback = temp & 0xFFFF;
0046FE  90024E     MOV [W14+8], W4
004700  980714     MOV W4, [W14+2]
109:                   if (temp == 0x11110000) {
004702  90034E     MOV [W14+8], W6
004704  9003DE     MOV [W14+10], W7
004706  200004     MOV #0x0, W4
004708  211115     MOV #0x1111, W5
00470A  530F84     SUB W6, W4, [W15]
00470C  5B8F85     SUBB W7, W5, [W15]
00470E  3A0002     BRA NZ, 0x4714
110:                     spi_error = 0b00000001;
004710  B3C014     MOV.B #0x1, W4
004712  784F04     MOV.B W4, [W14]
111:                   } 
112:                   
113:                   if (spi_error == 0) { 
004714  78421E     MOV.B [W14], W4
004716  524FE0     SUB.B W4, #0x0, [W15]
004718  3A0018     BRA NZ, 0x474A
114:                     temp = SendAndReceiveSPI(dac_array[dac_number], ptr_LTC2656->spi_port);
00471A  90026E     MOV [W14+12], W4
00471C  904A24     MOV.B [W4+10], W4
00471E  9042EE     MOV.B [W14+6], W5
004720  FB8285     ZE W5, W5
004722  428285     ADD W5, W5, W5
004724  90037E     MOV [W14+14], W6
004726  430285     ADD W6, W5, W5
004728  780295     MOV [W5], W5
00472A  784084     MOV.B W4, W1
00472C  780005     MOV W5, W0
00472E  070381     RCALL SendAndReceiveSPI
004730  BE0200     MOV.D W0, W4
004732  980744     MOV W4, [W14+8]
004734  980755     MOV W5, [W14+10]
115:                     data_word_readback = temp & 0xFFFF;
004736  90024E     MOV [W14+8], W4
004738  980724     MOV W4, [W14+4]
116:                     if (temp == 0x11110000) {
00473A  90034E     MOV [W14+8], W6
00473C  9003DE     MOV [W14+10], W7
00473E  200004     MOV #0x0, W4
004740  211115     MOV #0x1111, W5
004742  530F84     SUB W6, W4, [W15]
004744  5B8F85     SUBB W7, W5, [W15]
004746  3A0001     BRA NZ, 0x474A
117:               	spi_error |= 0b00000010;
004748  A0141E     BSET.B [W14], #1
118:                     } 
119:                   }
120:               
121:                   // Check that the command/data returned match the command/data sent out on the previous cycle
122:                   if (dac_number > 0) {
00474A  90426E     MOV.B [W14+6], W4
00474C  524FE0     SUB.B W4, #0x0, [W15]
00474E  320015     BRA Z, 0x477A
123:                     if (command_word_readback != (LTC2656_CMD_WRITE_AND_UPDATE_N | (dac_number - 1))) {
004750  90426E     MOV.B [W14+6], W4
004752  FB8204     ZE W4, W4
004754  E90284     DEC W4, W5
004756  200304     MOV #0x30, W4
004758  728204     IOR W5, W4, W4
00475A  780284     MOV W4, W5
00475C  90021E     MOV [W14+2], W4
00475E  528F84     SUB W5, W4, [W15]
004760  320001     BRA Z, 0x4764
124:               	spi_error |= 0b00000100;
004762  A0241E     BSET.B [W14], #2
125:                     }
126:                     if (data_word_readback != dac_array[dac_number-1]) {
004764  90426E     MOV.B [W14+6], W4
004766  FB8204     ZE W4, W4
004768  E90204     DEC W4, W4
00476A  420204     ADD W4, W4, W4
00476C  9002FE     MOV [W14+14], W5
00476E  428204     ADD W5, W4, W4
004770  780294     MOV [W4], W5
004772  90022E     MOV [W14+4], W4
004774  528F84     SUB W5, W4, [W15]
004776  320001     BRA Z, 0x477A
127:               	spi_error |= 0b00001000;
004778  A0341E     BSET.B [W14], #3
128:                     }   
129:                   }
130:                   
131:                   PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
00477A  90026E     MOV [W14+12], W4
00477C  780214     MOV [W4], W4
00477E  784204     MOV.B W4, W4
004780  B3C011     MOV.B #0x1, W1
004782  784004     MOV.B W4, W0
004784  070104     RCALL PinSetValue
132:                   
133:                   dac_number++;
004786  90426E     MOV.B [W14+6], W4
004788  E84204     INC.B W4, W4
00478A  984764     MOV.B W4, [W14+6]
134:                 }
135:               
136:                 // Read back the error check from the last command/data string sent out
137:                 PinSetValue(ptr_LTC2656->pin_cable_select, LTC2656_SELECT_CHIP);
004798  90026E     MOV [W14+12], W4
00479A  780214     MOV [W4], W4
00479C  784204     MOV.B W4, W4
00479E  EB4080     CLR.B W1
0047A0  784004     MOV.B W4, W0
0047A2  0700F5     RCALL PinSetValue
138:               
139:                 if (spi_error == 0) { 
0047A4  78421E     MOV.B [W14], W4
0047A6  524FE0     SUB.B W4, #0x0, [W15]
0047A8  3A0012     BRA NZ, 0x47CE
140:                   temp = SendAndReceiveSPI(LTC2656_CMD_NO_OPERATION, ptr_LTC2656->spi_port);
0047AA  90026E     MOV [W14+12], W4
0047AC  904A24     MOV.B [W4+10], W4
0047AE  784084     MOV.B W4, W1
0047B0  200F00     MOV #0xF0, W0
0047B2  07033F     RCALL SendAndReceiveSPI
0047B4  BE0200     MOV.D W0, W4
0047B6  980744     MOV W4, [W14+8]
0047B8  980755     MOV W5, [W14+10]
141:                   command_word_readback = temp & 0xFFFF;
0047BA  90024E     MOV [W14+8], W4
0047BC  980714     MOV W4, [W14+2]
142:                   if (temp == 0x11110000) {
0047BE  90034E     MOV [W14+8], W6
0047C0  9003DE     MOV [W14+10], W7
0047C2  200004     MOV #0x0, W4
0047C4  211115     MOV #0x1111, W5
0047C6  530F84     SUB W6, W4, [W15]
0047C8  5B8F85     SUBB W7, W5, [W15]
0047CA  3A0001     BRA NZ, 0x47CE
143:                     spi_error |= 0b00000001;
0047CC  A0041E     BSET.B [W14], #0
144:                   } 
145:                 }
146:               
147:                 if (spi_error == 0) { 
0047CE  78421E     MOV.B [W14], W4
0047D0  524FE0     SUB.B W4, #0x0, [W15]
0047D2  3A0012     BRA NZ, 0x47F8
148:                   temp = SendAndReceiveSPI(0, ptr_LTC2656->spi_port);
0047D4  90026E     MOV [W14+12], W4
0047D6  904A24     MOV.B [W4+10], W4
0047D8  784084     MOV.B W4, W1
0047DA  EB0000     CLR W0
0047DC  07032A     RCALL SendAndReceiveSPI
0047DE  BE0200     MOV.D W0, W4
0047E0  980744     MOV W4, [W14+8]
0047E2  980755     MOV W5, [W14+10]
149:                   data_word_readback = temp & 0xFFFF;
0047E4  90024E     MOV [W14+8], W4
0047E6  980724     MOV W4, [W14+4]
150:                   if (temp == 0x11110000) {
0047E8  90034E     MOV [W14+8], W6
0047EA  9003DE     MOV [W14+10], W7
0047EC  200004     MOV #0x0, W4
0047EE  211115     MOV #0x1111, W5
0047F0  530F84     SUB W6, W4, [W15]
0047F2  5B8F85     SUBB W7, W5, [W15]
0047F4  3A0001     BRA NZ, 0x47F8
151:                     spi_error |= 0b00000010;
0047F6  A0141E     BSET.B [W14], #1
152:                   } 
153:                 }
154:                 
155:                 PinSetValue(ptr_LTC2656->pin_cable_select, !LTC2656_SELECT_CHIP);
0047F8  90026E     MOV [W14+12], W4
0047FA  780214     MOV [W4], W4
0047FC  784204     MOV.B W4, W4
0047FE  B3C011     MOV.B #0x1, W1
004800  784004     MOV.B W4, W0
004802  0700C5     RCALL PinSetValue
156:                 
157:                 
158:                 if (command_word_readback != (LTC2656_CMD_WRITE_AND_UPDATE_N | (dac_number - 1))) {
004804  90426E     MOV.B [W14+6], W4
004806  FB8204     ZE W4, W4
004808  E90284     DEC W4, W5
00480A  200304     MOV #0x30, W4
00480C  728204     IOR W5, W4, W4
00480E  780284     MOV W4, W5
004810  90021E     MOV [W14+2], W4
004812  528F84     SUB W5, W4, [W15]
004814  320001     BRA Z, 0x4818
159:                   spi_error |= 0b00010000;
004816  A0441E     BSET.B [W14], #4
160:                 }
161:                 if (data_word_readback != dac_array[dac_number-1]) {
004818  90426E     MOV.B [W14+6], W4
00481A  FB8204     ZE W4, W4
00481C  E90204     DEC W4, W4
00481E  420204     ADD W4, W4, W4
004820  9002FE     MOV [W14+14], W5
004822  428204     ADD W5, W4, W4
004824  780294     MOV [W4], W5
004826  90022E     MOV [W14+4], W4
004828  528F84     SUB W5, W4, [W15]
00482A  320002     BRA Z, 0x4830
162:                   spi_error |= 0b00100000;
00482C  B3C204     MOV.B #0x20, W4
00482E  724F1E     IOR.B W4, [W14], [W14]
163:                 }
164:               
165:               
166:                 Nop();
004830  000000     NOP
167:                 Nop();
004832  000000     NOP
168:                 Nop();
004834  000000     NOP
169:               
170:               
171:                 return spi_error;
004836  78421E     MOV.B [W14], W4
172:               }
004838  784004     MOV.B W4, W0
00483A  FA8000     ULNK
00483C  060000     RETURN
---  C:/Users/dparker/Documents/GitHub/A36760/IOPorts.c  ------------------------------------------------
1:                 #include "IOPorts.h"
2:                 
3:                 
4:                 void PinSetTris(unsigned char pin, unsigned char tris_state) {
00483E  FA0004     LNK #0x4
004840  984720     MOV.B W0, [W14+2]
004842  984731     MOV.B W1, [W14+3]
5:                   /*
6:                     This is a very ineffecient way of setting the TRIS, but it is usefull because it 
7:                     1) Allows a framework for pins to passed to function
8:                     2) Is easy for others to use as a simple integer for the pin can be passed to functions
9:                   */
10:                  
11:                  unsigned char port;
12:                  unsigned char bit;
13:                  
14:                  port = pin & 0xF0;
004844  9042AE     MOV.B [W14+2], W5
004846  B3CF04     MOV.B #0xF0, W4
004848  62CF04     AND.B W5, W4, [W14]
15:                  bit = pin & 0x0F;
00484A  90422E     MOV.B [W14+2], W4
00484C  62426F     AND.B W4, #0xF, W4
00484E  984714     MOV.B W4, [W14+1]
16:                  
17:                  switch (port) {
004850  78429E     MOV.B [W14], W5
004852  FB8205     ZE W5, W4
004854  200B05     MOV #0xB0, W5
004856  520F85     SUB W4, W5, [W15]
004858  32002A     BRA Z, 0x48AE
00485A  200B05     MOV #0xB0, W5
00485C  520F85     SUB W4, W5, [W15]
00485E  3C0007     BRA GT, 0x486E
004860  200905     MOV #0x90, W5
004862  520F85     SUB W4, W5, [W15]
004864  32007C     BRA Z, 0x495E
004866  200A05     MOV #0xA0, W5
004868  520F85     SUB W4, W5, [W15]
00486A  32000B     BRA Z, 0x4882
00486C  37008E     BRA 0x498A
00486E  200D05     MOV #0xD0, W5
004870  520F85     SUB W4, W5, [W15]
004872  320049     BRA Z, 0x4906
004874  200F05     MOV #0xF0, W5
004876  520F85     SUB W4, W5, [W15]
004878  32005C     BRA Z, 0x4932
00487A  200C05     MOV #0xC0, W5
00487C  520F85     SUB W4, W5, [W15]
00487E  32002D     BRA Z, 0x48DA
004880  370084     BRA 0x498A
18:                    
19:                #if defined(_PORTA)
20:                  case _PORT_PORTA:
21:                    if (tris_state) {
004882  90423E     MOV.B [W14+3], W4
004884  524FE0     SUB.B W4, #0x0, [W15]
004886  320009     BRA Z, 0x489A
22:                      TRISA = TRISA | (0x01 << bit);
004888  90421E     MOV.B [W14+1], W4
00488A  FB8204     ZE W4, W4
00488C  200015     MOV #0x1, W5
00488E  DD2A04     SL W5, W4, W4
004890  780284     MOV W4, W5
004892  801604     MOV TRISA, W4
004894  728204     IOR W5, W4, W4
004896  881604     MOV W4, TRISA
23:                    } else {
24:                      TRISA = TRISA & (~(0x01 << bit));
00489A  90421E     MOV.B [W14+1], W4
00489C  FB8204     ZE W4, W4
00489E  200015     MOV #0x1, W5
0048A0  DD2A04     SL W5, W4, W4
0048A2  EA8204     COM W4, W4
0048A4  780284     MOV W4, W5
0048A6  801604     MOV TRISA, W4
0048A8  628204     AND W5, W4, W4
0048AA  881604     MOV W4, TRISA
25:                    }
26:                    break;
004898  370078     BRA 0x498A
0048AC  37006E     BRA 0x498A
27:                #endif
28:                
29:                #if defined(_PORTB)
30:                  case _PORT_PORTB:
31:                    if (tris_state) {
0048AE  90423E     MOV.B [W14+3], W4
0048B0  524FE0     SUB.B W4, #0x0, [W15]
0048B2  320009     BRA Z, 0x48C6
32:                      TRISB = TRISB | (0x01 << bit);
0048B4  90421E     MOV.B [W14+1], W4
0048B6  FB8204     ZE W4, W4
0048B8  200015     MOV #0x1, W5
0048BA  DD2A04     SL W5, W4, W4
0048BC  780284     MOV W4, W5
0048BE  801634     MOV TRISB, W4
0048C0  728204     IOR W5, W4, W4
0048C2  881634     MOV W4, TRISB
33:                    } else {
34:                      TRISB = TRISB & (~(0x01 << bit));
0048C6  90421E     MOV.B [W14+1], W4
0048C8  FB8204     ZE W4, W4
0048CA  200015     MOV #0x1, W5
0048CC  DD2A04     SL W5, W4, W4
0048CE  EA8204     COM W4, W4
0048D0  780284     MOV W4, W5
0048D2  801634     MOV TRISB, W4
0048D4  628204     AND W5, W4, W4
0048D6  881634     MOV W4, TRISB
35:                    }
36:                    break;
0048C4  370062     BRA 0x498A
0048D8  370058     BRA 0x498A
37:                #endif
38:                    
39:                #if defined(_PORTC)
40:                  case _PORT_PORTC:
41:                    if (tris_state) {
0048DA  90423E     MOV.B [W14+3], W4
0048DC  524FE0     SUB.B W4, #0x0, [W15]
0048DE  320009     BRA Z, 0x48F2
42:                      TRISC = TRISC | (0x01 << bit);
0048E0  90421E     MOV.B [W14+1], W4
0048E2  FB8204     ZE W4, W4
0048E4  200015     MOV #0x1, W5
0048E6  DD2A04     SL W5, W4, W4
0048E8  780284     MOV W4, W5
0048EA  801664     MOV TRISC, W4
0048EC  728204     IOR W5, W4, W4
0048EE  881664     MOV W4, TRISC
43:                    } else {
44:                      TRISC = TRISC & (~(0x01 << bit));
0048F2  90421E     MOV.B [W14+1], W4
0048F4  FB8204     ZE W4, W4
0048F6  200015     MOV #0x1, W5
0048F8  DD2A04     SL W5, W4, W4
0048FA  EA8204     COM W4, W4
0048FC  780284     MOV W4, W5
0048FE  801664     MOV TRISC, W4
004900  628204     AND W5, W4, W4
004902  881664     MOV W4, TRISC
45:                    }
46:                    break;
0048F0  37004C     BRA 0x498A
004904  370042     BRA 0x498A
47:                #endif
48:                
49:                #if defined(_PORTD)
50:                  case _PORT_PORTD:
51:                    if (tris_state) {
004906  90423E     MOV.B [W14+3], W4
004908  524FE0     SUB.B W4, #0x0, [W15]
00490A  320009     BRA Z, 0x491E
52:                      TRISD = TRISD | (0x01 << bit);
00490C  90421E     MOV.B [W14+1], W4
00490E  FB8204     ZE W4, W4
004910  200015     MOV #0x1, W5
004912  DD2A04     SL W5, W4, W4
004914  780284     MOV W4, W5
004916  801694     MOV TRISD, W4
004918  728204     IOR W5, W4, W4
00491A  881694     MOV W4, TRISD
53:                    } else {
54:                      TRISD = TRISD & (~(0x01 << bit));
00491E  90421E     MOV.B [W14+1], W4
004920  FB8204     ZE W4, W4
004922  200015     MOV #0x1, W5
004924  DD2A04     SL W5, W4, W4
004926  EA8204     COM W4, W4
004928  780284     MOV W4, W5
00492A  801694     MOV TRISD, W4
00492C  628204     AND W5, W4, W4
00492E  881694     MOV W4, TRISD
55:                    }
56:                    break;
00491C  370036     BRA 0x498A
004930  37002C     BRA 0x498A
57:                #endif
58:                
59:                
60:                #if defined(_PORTE)    
61:                  case _PORT_PORTE:
62:                    if (tris_state) {
63:                      TRISE = TRISE | (0x01 << bit);
64:                    } else {
65:                      TRISE = TRISE & (~(0x01 << bit));
66:                    }
67:                    break;
68:                #endif
69:                
70:                #if defined(_PORTF)    
71:                  case _PORT_PORTF:
72:                    if (tris_state) {
004932  90423E     MOV.B [W14+3], W4
004934  524FE0     SUB.B W4, #0x0, [W15]
004936  320009     BRA Z, 0x494A
73:                      TRISF = TRISF | (0x01 << bit);
004938  90421E     MOV.B [W14+1], W4
00493A  FB8204     ZE W4, W4
00493C  200015     MOV #0x1, W5
00493E  DD2A04     SL W5, W4, W4
004940  780284     MOV W4, W5
004942  8016F4     MOV TRISF, W4
004944  728204     IOR W5, W4, W4
004946  8816F4     MOV W4, TRISF
74:                    } else {
75:                      TRISF = TRISF & (~(0x01 << bit));
00494A  90421E     MOV.B [W14+1], W4
00494C  FB8204     ZE W4, W4
00494E  200015     MOV #0x1, W5
004950  DD2A04     SL W5, W4, W4
004952  EA8204     COM W4, W4
004954  780284     MOV W4, W5
004956  8016F4     MOV TRISF, W4
004958  628204     AND W5, W4, W4
00495A  8816F4     MOV W4, TRISF
76:                    }
77:                    break;
004948  370020     BRA 0x498A
00495C  370016     BRA 0x498A
78:                #endif
79:                    
80:                #if defined(_PORTG)
81:                  case _PORT_PORTG:
82:                    if (tris_state) {
00495E  90423E     MOV.B [W14+3], W4
004960  524FE0     SUB.B W4, #0x0, [W15]
004962  320009     BRA Z, 0x4976
83:                      TRISG = TRISG | (0x01 << bit);
004964  90421E     MOV.B [W14+1], W4
004966  FB8204     ZE W4, W4
004968  200015     MOV #0x1, W5
00496A  DD2A04     SL W5, W4, W4
00496C  780284     MOV W4, W5
00496E  801724     MOV TRISG, W4
004970  728204     IOR W5, W4, W4
004972  881724     MOV W4, TRISG
84:                    } else {
85:                      TRISG = TRISG & (~(0x01 << bit));
004976  90421E     MOV.B [W14+1], W4
004978  FB8204     ZE W4, W4
00497A  200015     MOV #0x1, W5
00497C  DD2A04     SL W5, W4, W4
00497E  EA8204     COM W4, W4
004980  780284     MOV W4, W5
004982  801724     MOV TRISG, W4
004984  628204     AND W5, W4, W4
004986  881724     MOV W4, TRISG
86:                    }
87:                    break;
004974  37000A     BRA 0x498A
004988  000000     NOP
88:                #endif
89:                    
90:                  }
91:                }
00498A  FA8000     ULNK
00498C  060000     RETURN
92:                
93:                void PinSetValue(unsigned char pin, unsigned char pin_value) {
00498E  FA0004     LNK #0x4
004990  984720     MOV.B W0, [W14+2]
004992  984731     MOV.B W1, [W14+3]
94:                  /*
95:                    This is a very ineffecient way of setting pins, but it is usefull because it 
96:                    1) Allows a framework for pins to passed to function
97:                    2) Is easy for others to use as a simple integer for the pin can be passed to functions
98:                    Note that is changes the LATCH registers not, the output registers.  DO NOT SET the output registers, use the Latches instead
99:                  */
100:                 
101:                 unsigned char port;
102:                 unsigned char bit;
103:                 
104:                 port = pin & 0xF0; 
004994  9042AE     MOV.B [W14+2], W5
004996  B3CF04     MOV.B #0xF0, W4
004998  62CF04     AND.B W5, W4, [W14]
105:                 bit = pin & 0x0F;
00499A  90422E     MOV.B [W14+2], W4
00499C  62426F     AND.B W4, #0xF, W4
00499E  984714     MOV.B W4, [W14+1]
106:                 
107:                 switch (port) {
0049A0  78429E     MOV.B [W14], W5
0049A2  FB8205     ZE W5, W4
0049A4  200B05     MOV #0xB0, W5
0049A6  520F85     SUB W4, W5, [W15]
0049A8  32002A     BRA Z, 0x49FE
0049AA  200B05     MOV #0xB0, W5
0049AC  520F85     SUB W4, W5, [W15]
0049AE  3C0007     BRA GT, 0x49BE
0049B0  200905     MOV #0x90, W5
0049B2  520F85     SUB W4, W5, [W15]
0049B4  32007C     BRA Z, 0x4AAE
0049B6  200A05     MOV #0xA0, W5
0049B8  520F85     SUB W4, W5, [W15]
0049BA  32000B     BRA Z, 0x49D2
0049BC  37008E     BRA 0x4ADA
0049BE  200D05     MOV #0xD0, W5
0049C0  520F85     SUB W4, W5, [W15]
0049C2  320049     BRA Z, 0x4A56
0049C4  200F05     MOV #0xF0, W5
0049C6  520F85     SUB W4, W5, [W15]
0049C8  32005C     BRA Z, 0x4A82
0049CA  200C05     MOV #0xC0, W5
0049CC  520F85     SUB W4, W5, [W15]
0049CE  32002D     BRA Z, 0x4A2A
0049D0  370084     BRA 0x4ADA
108:                
109:               #if defined(_PORTA)
110:                 case _PORT_PORTA:
111:                   if (pin_value) {
0049D2  90423E     MOV.B [W14+3], W4
0049D4  524FE0     SUB.B W4, #0x0, [W15]
0049D6  320009     BRA Z, 0x49EA
112:                     LATA = LATA | (0x01 << bit);
0049D8  90421E     MOV.B [W14+1], W4
0049DA  FB8204     ZE W4, W4
0049DC  200015     MOV #0x1, W5
0049DE  DD2A04     SL W5, W4, W4
0049E0  780284     MOV W4, W5
0049E2  801624     MOV LATA, W4
0049E4  728204     IOR W5, W4, W4
0049E6  881624     MOV W4, LATA
113:                   } else {
114:                     LATA = LATA & (~(0x01 << bit));
0049EA  90421E     MOV.B [W14+1], W4
0049EC  FB8204     ZE W4, W4
0049EE  200015     MOV #0x1, W5
0049F0  DD2A04     SL W5, W4, W4
0049F2  EA8204     COM W4, W4
0049F4  780284     MOV W4, W5
0049F6  801624     MOV LATA, W4
0049F8  628204     AND W5, W4, W4
0049FA  881624     MOV W4, LATA
115:                   }
116:                   break;
0049E8  370078     BRA 0x4ADA
0049FC  37006E     BRA 0x4ADA
117:               #endif
118:               
119:               #if defined(_PORTB)
120:                 case _PORT_PORTB:
121:                   if (pin_value) {
0049FE  90423E     MOV.B [W14+3], W4
004A00  524FE0     SUB.B W4, #0x0, [W15]
004A02  320009     BRA Z, 0x4A16
122:                     LATB = LATB | (0x01 << bit);
004A04  90421E     MOV.B [W14+1], W4
004A06  FB8204     ZE W4, W4
004A08  200015     MOV #0x1, W5
004A0A  DD2A04     SL W5, W4, W4
004A0C  780284     MOV W4, W5
004A0E  801654     MOV LATB, W4
004A10  728204     IOR W5, W4, W4
004A12  881654     MOV W4, LATB
123:                   } else {
124:                     LATB = LATB & (~(0x01 << bit));
004A16  90421E     MOV.B [W14+1], W4
004A18  FB8204     ZE W4, W4
004A1A  200015     MOV #0x1, W5
004A1C  DD2A04     SL W5, W4, W4
004A1E  EA8204     COM W4, W4
004A20  780284     MOV W4, W5
004A22  801654     MOV LATB, W4
004A24  628204     AND W5, W4, W4
004A26  881654     MOV W4, LATB
125:                   }
126:                   break;
004A14  370062     BRA 0x4ADA
004A28  370058     BRA 0x4ADA
127:               #endif
128:               
129:               #if defined(_PORTC)
130:                 case _PORT_PORTC:
131:                   if (pin_value) {
004A2A  90423E     MOV.B [W14+3], W4
004A2C  524FE0     SUB.B W4, #0x0, [W15]
004A2E  320009     BRA Z, 0x4A42
132:                     LATB = LATB | (0x01 << bit);
004A30  90421E     MOV.B [W14+1], W4
004A32  FB8204     ZE W4, W4
004A34  200015     MOV #0x1, W5
004A36  DD2A04     SL W5, W4, W4
004A38  780284     MOV W4, W5
004A3A  801654     MOV LATB, W4
004A3C  728204     IOR W5, W4, W4
004A3E  881654     MOV W4, LATB
133:                   } else {
134:                     LATB = LATB & (~(0x01 << bit));
004A42  90421E     MOV.B [W14+1], W4
004A44  FB8204     ZE W4, W4
004A46  200015     MOV #0x1, W5
004A48  DD2A04     SL W5, W4, W4
004A4A  EA8204     COM W4, W4
004A4C  780284     MOV W4, W5
004A4E  801654     MOV LATB, W4
004A50  628204     AND W5, W4, W4
004A52  881654     MOV W4, LATB
135:                   }
136:                   break;
004A40  37004C     BRA 0x4ADA
004A54  370042     BRA 0x4ADA
137:               #endif
138:               
139:               #if defined(_PORTD)
140:                 case _PORT_PORTD:
141:                   if (pin_value) {
004A56  90423E     MOV.B [W14+3], W4
004A58  524FE0     SUB.B W4, #0x0, [W15]
004A5A  320009     BRA Z, 0x4A6E
142:                     LATD = LATD | (0x01 << bit);
004A5C  90421E     MOV.B [W14+1], W4
004A5E  FB8204     ZE W4, W4
004A60  200015     MOV #0x1, W5
004A62  DD2A04     SL W5, W4, W4
004A64  780284     MOV W4, W5
004A66  8016B4     MOV LATD, W4
004A68  728204     IOR W5, W4, W4
004A6A  8816B4     MOV W4, LATD
143:                   } else {
144:                     LATD = LATD & (~(0x01 << bit));
004A6E  90421E     MOV.B [W14+1], W4
004A70  FB8204     ZE W4, W4
004A72  200015     MOV #0x1, W5
004A74  DD2A04     SL W5, W4, W4
004A76  EA8204     COM W4, W4
004A78  780284     MOV W4, W5
004A7A  8016B4     MOV LATD, W4
004A7C  628204     AND W5, W4, W4
004A7E  8816B4     MOV W4, LATD
145:                   }
146:                   break;
004A6C  370036     BRA 0x4ADA
004A80  37002C     BRA 0x4ADA
147:               #endif
148:               
149:               #if defined(_PORTE)
150:                 case _PORT_PORTE:
151:                   if (pin_value) {
152:                     LATE = LATE | (0x01 << bit);
153:                   } else {
154:                     LATE = LATE & (~(0x01 << bit));
155:                   }
156:                   break;
157:               #endif
158:               
159:               #if defined(_PORTF)
160:                 case _PORT_PORTF:
161:                   if (pin_value) {
004A82  90423E     MOV.B [W14+3], W4
004A84  524FE0     SUB.B W4, #0x0, [W15]
004A86  320009     BRA Z, 0x4A9A
162:                     LATF = LATF | (0x01 << bit);
004A88  90421E     MOV.B [W14+1], W4
004A8A  FB8204     ZE W4, W4
004A8C  200015     MOV #0x1, W5
004A8E  DD2A04     SL W5, W4, W4
004A90  780284     MOV W4, W5
004A92  801714     MOV LATF, W4
004A94  728204     IOR W5, W4, W4
004A96  881714     MOV W4, LATF
163:                   } else {
164:                     LATF = LATF & (~(0x01 << bit));
004A9A  90421E     MOV.B [W14+1], W4
004A9C  FB8204     ZE W4, W4
004A9E  200015     MOV #0x1, W5
004AA0  DD2A04     SL W5, W4, W4
004AA2  EA8204     COM W4, W4
004AA4  780284     MOV W4, W5
004AA6  801714     MOV LATF, W4
004AA8  628204     AND W5, W4, W4
004AAA  881714     MOV W4, LATF
165:                   }
166:                   break;
004A98  370020     BRA 0x4ADA
004AAC  370016     BRA 0x4ADA
167:               #endif
168:               
169:               #if defined(_PORTG)
170:                 case _PORT_PORTG:
171:                   if (pin_value) {
004AAE  90423E     MOV.B [W14+3], W4
004AB0  524FE0     SUB.B W4, #0x0, [W15]
004AB2  320009     BRA Z, 0x4AC6
172:                     LATG = LATG | (0x01 << bit);
004AB4  90421E     MOV.B [W14+1], W4
004AB6  FB8204     ZE W4, W4
004AB8  200015     MOV #0x1, W5
004ABA  DD2A04     SL W5, W4, W4
004ABC  780284     MOV W4, W5
004ABE  801744     MOV LATG, W4
004AC0  728204     IOR W5, W4, W4
004AC2  881744     MOV W4, LATG
173:                   } else {
174:                     LATG = LATG & (~(0x01 << bit));
004AC6  90421E     MOV.B [W14+1], W4
004AC8  FB8204     ZE W4, W4
004ACA  200015     MOV #0x1, W5
004ACC  DD2A04     SL W5, W4, W4
004ACE  EA8204     COM W4, W4
004AD0  780284     MOV W4, W5
004AD2  801744     MOV LATG, W4
004AD4  628204     AND W5, W4, W4
004AD6  881744     MOV W4, LATG
175:                   }
176:                   break;
004AC4  37000A     BRA 0x4ADA
004AD8  000000     NOP
177:               #endif
178:               
179:                 }
180:               }
004ADA  FA8000     ULNK
004ADC  060000     RETURN
181:               
182:               
183:               
---  C:/Users/dparker/Documents/GitHub/A36760/ETMdsp.s  -------------------------------------------------
                                                  1:     
                                                  2:     .ifdef __dsPIC30F
                                                  3:             .include "p30fxxxx.inc"
                                                  4:     .endif
                                                  5:     .ifdef __dsPIC33F
                                                  6:             .include "p33Fxxxx.inc"
                                                  7:     .endif
                                                  8:     
                                                  9:             .global  _AverageADC128
                                                  10:    
                                                  11:             .text
                                                  12:    _AverageADC128:
00519E  780200     MOV W0, W4                     13:    		mov		W0, W4		; move source address
0051A0  C30112     CLR A                          14:    		CLR		A		; 0 40 bit Acc
                                                  15:    
0051A2  09007F     REPEAT #0x7F                   16:    ACC_S:	REPEAT	#127			; add em all up
0051A4  C90234     ADD [W4++], #4, A              17:    		ADD		[W4++], #4, A ; signed 16 add to ACCA (right shift 4 bits)
                                                  18:    	                                      ; The data that we want is now stored in the 15 LSB of ACCAH and the 1 MSB of ACCAL
                                                  19:    	                                      ; If we shift the data left one bit and call SAC.R the data will be bashed because
                                                  20:    	                                      ; The accumulator will be signed.  There for we must work around this little problem 
0051A6  CC0000     SAC A, W0                      21:    		SAC		A, W0	      ; Move ACCAH to W0
0051A8  DD0041     SL W0, #1, W0                  22:    		SL		W0, #1, W0    ; Shift W0 left by one bit.  
0051AA  C8007F     SFTAC A, #-1                   23:     		SFTAC           A, #-1        ; Shift Accumulator left by one bit.
0051AC  CD0001     SAC.R A, W1                    24:    	        SAC.R           A, W1         ; Move ACCAH to W1
0051AE  B20011     AND #0x1, W1                   25:    		AND             #0x0001, W1   ; W1 &= 0x0001
0051B0  700001     IOR W0, W1, W0                 26:    	        IOR             W0, W1, W0    ; WO = WO | W1
0051B2  060000     RETURN                         27:    		return
                                                  28:    ;--------End of All Code Sections ---------------------------------------------
                                                  29:            .end                               ;End of program code in this file
                                                  30:    
                                                  31:    
                                                  32:    
---  C:/Users/dparker/Documents/GitHub/A36760/ETM_SCALE.s  ----------------------------------------------
                                                  1:     .ifdef __dsPIC30F
                                                  2:             .include "p30fxxxx.inc"
                                                  3:     .endif
                                                  4:     .ifdef __dsPIC33F
                                                  5:             .include "p33Fxxxx.inc"
                                                  6:     .endif
                                                  7:     
                                                  8:     .section .nbss, bss, near    	
                                                  9:     	_etm_scale_saturation_etmscalefactor2_count:	.space 2
                                                  10:    	.global _etm_scale_saturation_etmscalefactor2_count
                                                  11:    	_etm_scale_saturation_etmscalefactor16_count:	.space 2
                                                  12:    	.global _etm_scale_saturation_etmscalefactor16_count
                                                  13:    .text	
                                                  14:    
                                                  15:    
                                                  16:    
                                                  17:    	;; ----------------------------------------------------------
                                                  18:    
                                                  19:    	
                                                  20:    	.global  _ETMScaleFactor2
                                                  21:    	;; uses and does not restore W0->W3
                                                  22:    	.text
                                                  23:    _ETMScaleFactor2:
                                                  24:    	;; Value is stored in w0
                                                  25:    	;; Scale is stored in w1
                                                  26:    	;; Offset is stored in w2 
                                                  27:    
0050E6  E00002     CP0 W2                         28:    	CP0		W2
0050E8  3B0005     BRA NN, 0x50F4                 29:    	BRA		NN,  _ETMScaleFactor2_offset_not_negative
                                                  30:    
                                                  31:    	;; The offset is negative
0050EA  400002     ADD W0, W2, W0                 32:    	ADD             W0,W2,W0                ; Add the offset to the base value
                                                  33:    	;; Look for overflow
0050EC  310008     BRA C, 0x50FE                  34:    	BRA             C, _ETMScaleFactor2_addition_done
                                                  35:    	;; There was overflow with the negative offset
                                                  36:    	;; Increment the overflow counter and set the results to 0x0000
0050EE  200000     MOV #0x0, W0                   37:    	MOV		#0x0000, W0
0050F0  EC38D2     INC 0x18D2                     38:    	INC		_etm_scale_saturation_etmscalefactor2_count
0050F2  370005     BRA 0x50FE                     39:    	BRA             _ETMScaleFactor2_addition_done	
                                                  40:    
                                                  41:    _ETMScaleFactor2_offset_not_negative:		
0050F4  400002     ADD W0, W2, W0                 42:    	ADD             W0,W2,W0                ; Add the offset to the base value
                                                  43:    	;; Look for overflow
                                                  44:    	;; 	CP              W3,W2 ;If W3 is less than W2 then there was an overflow
0050F6  390003     BRA NC, 0x50FE                 45:    	BRA             NC, _ETMScaleFactor2_addition_done
                                                  46:    	;; There was an overflow in the addition
                                                  47:    	;; Increment the overflow counter and set the results to 0xFFFF
0050F8  2FFFF0     MOV #0xFFFF, W0                48:    	MOV		#0xFFFF, W0
0050FA  EC38D2     INC 0x18D2                     49:    	INC		_etm_scale_saturation_etmscalefactor2_count
0050FC  370000     BRA 0x50FE                     50:    	BRA             _ETMScaleFactor2_addition_done	
                                                  51:    
                                                  52:    _ETMScaleFactor2_addition_done:		
0050FE  B80101     MUL.UU W0, W1, W2              53:    	MUL.UU		W0,W1,W2 		; Multiply W0 by W1 and store in W2:W3, MSW is stored in W3
005100  B81862     MUL.UU W3, #2, W0              54:    	MUL.UU		W3,#2,W0		; Multiply W3 by 2 and store the results in W0:W1 - W0(LSW) is the result we care about
                                                  55:    						
005102  E00001     CP0 W1                         56:    	CP0		W1			; If W1 is Zero, then there was NOT an overflow
005104  320002     BRA Z, 0x510A                  57:    	BRA		Z, _ETMScaleFactor2_multiply_ok
                                                  58:    	;; There was an overflow in the multiply opertion
                                                  59:    	;; Increment the overflow counter and set the result to 0xFFFF
005106  2FFFF0     MOV #0xFFFF, W0                60:    	MOV		#0xFFFF, W0
005108  EC38D2     INC 0x18D2                     61:    	INC		_etm_scale_saturation_etmscalefactor2_count
                                                  62:    _ETMScaleFactor2_multiply_ok:	
                                                  63:    	;; OR together W0, W1 into W0 to give the final results
00510A  DE10CF     LSR W2, #15, W1                64:    	LSR		W2, #15, W1		; Take the 1 MSbits of W2 and store then as the 1 LSB of W1
00510C  700001     IOR W0, W1, W0                 65:    	IOR		W0, W1, W0		; Add W1 to W0 (using bitwise or in this case)
00510E  060000     RETURN                         66:    	RETURN
                                                  67:    
                                                  68:    
                                                  69:    
                                                  70:    
                                                  71:    	
                                                  72:    	;; ----------------------------------------------------------
                                                  73:    
                                                  74:    	
                                                  75:    	.global  _ETMScaleFactor16
                                                  76:    	;; uses and does not restore W0->W3
                                                  77:    	.text
                                                  78:    _ETMScaleFactor16:
                                                  79:    	;; Value is stored in w0
                                                  80:    	;; Scale is stored in w1
                                                  81:    	;; Offset is stored in w2 	
                                                  82:    
005110  E00002     CP0 W2                         83:    	CP0		W2
005112  3B0005     BRA NN, 0x511E                 84:    	BRA		NN,  _ETMScaleFactor16_offset_not_negative
                                                  85:    
                                                  86:    	;; The offset is negative
005114  400002     ADD W0, W2, W0                 87:    	ADD             W0,W2,W0                ; Add the offset to the base value
                                                  88:    	;; Look for overflow
005116  310008     BRA C, 0x5128                  89:    	BRA             C, _ETMScaleFactor16_addition_done
                                                  90:    	;; There was overflow with the negative offset
                                                  91:    	;; Increment the overflow counter and set the results to 0x0000
005118  200000     MOV #0x0, W0                   92:    	MOV		#0x0000, W0
00511A  EC38D4     INC 0x18D4                     93:    	INC		_etm_scale_saturation_etmscalefactor16_count
00511C  370005     BRA 0x5128                     94:    	BRA             _ETMScaleFactor16_addition_done	
                                                  95:    
                                                  96:    _ETMScaleFactor16_offset_not_negative:		
00511E  400002     ADD W0, W2, W0                 97:    	ADD             W0,W2,W0                ; Add the offset to the base value
                                                  98:    	;; Look for overflow
                                                  99:    	;; 	CP              W3,W2 ;If W3 is less than W2 then there was an overflow
005120  390003     BRA NC, 0x5128                 100:   	BRA             NC, _ETMScaleFactor16_addition_done
                                                  101:   	;; There was an overflow in the addition
                                                  102:   	;; Increment the overflow counter and set the results to 0xFFFF
005122  2FFFF0     MOV #0xFFFF, W0                103:   	MOV		#0xFFFF, W0
005124  EC38D4     INC 0x18D4                     104:   	INC		_etm_scale_saturation_etmscalefactor16_count
005126  370000     BRA 0x5128                     105:   	BRA             _ETMScaleFactor16_addition_done	
                                                  106:   
                                                  107:   _ETMScaleFactor16_addition_done:		
                                                  108:   	
005128  B80101     MUL.UU W0, W1, W2              109:   	MUL.UU		W0,W1,W2 		; Multiply W0 by W1 and store in W2:W3, MSW is stored in W3
00512A  B81870     MUL.UU W3, #16, W0             110:   	MUL.UU		W3,#16,W0		; Multiply W3 by 16 and store the results in W0:W1 - W0(LSW) is the result we care about
                                                  111:   						
00512C  E00001     CP0 W1                         112:   	CP0		W1			; If W1 is Zero, then there was NOT an overflow
00512E  320002     BRA Z, 0x5134                  113:   	BRA		Z, _ETMScaleFactor16_no_overflow
                                                  114:   	;; There was an overflow in the multiply opertion
                                                  115:   	;; Increment the overflow counter and set the result to 0xFFFF
005130  2FFFF0     MOV #0xFFFF, W0                116:   	MOV		#0xFFFF, W0
005132  EC38D4     INC 0x18D4                     117:   	INC		_etm_scale_saturation_etmscalefactor16_count
                                                  118:   _ETMScaleFactor16_no_overflow:	
                                                  119:   	;; OR together W0, W1 into W0 to give the final results
005134  DE10CC     LSR W2, #12, W1                120:   	LSR		W2, #12, W1		; Take the 4 MSbits of W2 and store then as the 4 LSB of W1
005136  700001     IOR W0, W1, W0                 121:   	IOR		W0, W1, W0		; Add W1 to W0 (using bitwise or in this case)
005138  060000     RETURN                         122:   	RETURN
                                                  123:   
                                                  124:   	
---  C:/Users/dparker/Documents/GitHub/A36760/ETMSPI.c  -------------------------------------------------
1:                 #include "ETMSPI.h"
2:                 
3:                 
4:                 unsigned long SendAndReceiveSPI(unsigned int data_word, unsigned char spi_port) {
004E32  FA0008     LNK #0x8
004E34  980720     MOV W0, [W14+4]
004E36  984761     MOV.B W1, [W14+6]
5:                   unsigned char spi_bus_status;
6:                   unsigned int return_data;
7:                 
8:                   spi_bus_status = SPI_BUS_ACTIVE;
004E38  EB4200     CLR.B W4
004E3A  784F04     MOV.B W4, [W14]
9:                   SPI_TIMER_REGISTER = 0;
004E3C  EB0200     CLR W4
004E3E  8808A4     MOV W4, TMR4
10:                  SPI_TIMER_PERIOD = SPI_TIMEOUT_CYCLES;
004E40  20FA04     MOV #0xFA0, W4
004E42  8808D4     MOV W4, PR4
11:                  SPI_TIMER_INT_FLAG = 0;
004E44  A9A086     BCLR IFS1, #5
12:                  SPI_TIMER_CON_BITS.TON = 1;
004E46  A8E11F     BSET 0x11F, #7
13:                  SPI_TIMER_CON_BITS.TCKPS = SPI_TIMER_PRESCALE_1_1;
004E48  8008F4     MOV T4CON, W4
004E4A  A14004     BCLR W4, #4
004E4C  A15004     BCLR W4, #5
004E4E  8808F4     MOV W4, T4CON
14:                  
15:                
16:                #if defined(_SPIIF)
17:                  if ((spi_port == 0) || (spi_port == 1)) {
18:                    _SPIIF = 0;
19:                    SPIBUF = data_word;
20:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
21:                      if (SPI_TIMER_INT_FLAG) {
22:                	// There was a timeout of the data read, this is effectivly a fault
23:                	spi_bus_status = SPI_BUS_TIMEOUT;
24:                      }
25:                      if (SPISTATbits.SPIROV) {
26:                	// There was a data overflow in the buffer, this is a fault
27:                	spi_bus_status = SPI_BUS_OVERFLOW;
28:                      }
29:                      if (!SPISTATbits.SPITBF) {
30:                	spi_bus_status = SPI_DATA_SENT;
31:                      }
32:                    }
33:                    
34:                    while(spi_bus_status == SPI_DATA_SENT) {
35:                      if (SPI_TIMER_INT_FLAG) {
36:                	// There was a timeout of the data read, this is effectivly a fault
37:                	spi_bus_status = SPI_BUS_TIMEOUT;
38:                      }
39:                      if (SPISTATbits.SPIROV) {
40:                	// There was a data overflow in the buffer, this is a fault
41:                	spi_bus_status = SPI_BUS_OVERFLOW;
42:                      }
43:                      if (_SPIIF) {
44:                	// Data  been recieved in the buffer, read the data from the return buffer
45:                	spi_bus_status = SPI_DATA_RECEIVED;
46:                      }    
47:                    }
48:                    return_data = SPIBUF;
49:                  }
50:                #endif
51:                
52:                
53:                #if defined(_SPI1IF)
54:                  if (spi_port == 1) {
004E50  90426E     MOV.B [W14+6], W4
004E52  524FE1     SUB.B W4, #0x1, [W15]
004E54  3A0036     BRA NZ, 0x4EC2
55:                    _SPI1IF = 0;
004E56  A90085     BCLR 0x85, #0
56:                    SPI1BUF = data_word;
004E58  90022E     MOV [W14+4], W4
004E5A  881124     MOV W4, SPI1BUF
57:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
004E5C  370014     BRA 0x4E86
004E86  78421E     MOV.B [W14], W4
004E88  524FE0     SUB.B W4, #0x0, [W15]
004E8A  32FFE9     BRA Z, 0x4E5E
58:                      if (SPI_TIMER_INT_FLAG) {
004E5E  800435     MOV IFS1, W5
004E60  200204     MOV #0x20, W4
004E62  628204     AND W5, W4, W4
004E64  520FE0     SUB W4, #0x0, [W15]
004E66  320002     BRA Z, 0x4E6C
59:                	// There was a timeout of the data read, this is effectivly a fault
60:                	spi_bus_status = SPI_BUS_TIMEOUT;
004E68  B3C034     MOV.B #0x3, W4
004E6A  784F04     MOV.B W4, [W14]
61:                      }
62:                      if (SPI1STATbits.SPIROV) {
004E6C  801105     MOV SPI1STAT, W5
004E6E  200404     MOV #0x40, W4
004E70  628204     AND W5, W4, W4
004E72  520FE0     SUB W4, #0x0, [W15]
004E74  320002     BRA Z, 0x4E7A
63:                	// There was a data overflow in the buffer, this is a fault
64:                	spi_bus_status = SPI_BUS_OVERFLOW;
004E76  B3C044     MOV.B #0x4, W4
004E78  784F04     MOV.B W4, [W14]
65:                      }
66:                      if (!SPI1STATbits.SPITBF) {
004E7A  801104     MOV SPI1STAT, W4
004E7C  620262     AND W4, #0x2, W4
004E7E  520FE0     SUB W4, #0x0, [W15]
004E80  3A0002     BRA NZ, 0x4E86
67:                	spi_bus_status = SPI_DATA_SENT;
004E82  B3C014     MOV.B #0x1, W4
004E84  784F04     MOV.B W4, [W14]
68:                      }
69:                    }
70:                    
71:                    while(spi_bus_status == SPI_DATA_SENT) {
004E8C  370015     BRA 0x4EB8
004EB8  78421E     MOV.B [W14], W4
004EBA  524FE1     SUB.B W4, #0x1, [W15]
004EBC  32FFE8     BRA Z, 0x4E8E
72:                      if (SPI_TIMER_INT_FLAG) {
004E8E  800435     MOV IFS1, W5
004E90  200204     MOV #0x20, W4
004E92  628204     AND W5, W4, W4
004E94  520FE0     SUB W4, #0x0, [W15]
004E96  320002     BRA Z, 0x4E9C
73:                	// There was a timeout of the data read, this is effectivly a fault
74:                	spi_bus_status = SPI_BUS_TIMEOUT;
004E98  B3C034     MOV.B #0x3, W4
004E9A  784F04     MOV.B W4, [W14]
75:                      }
76:                      if (SPI1STATbits.SPIROV) {
004E9C  801105     MOV SPI1STAT, W5
004E9E  200404     MOV #0x40, W4
004EA0  628204     AND W5, W4, W4
004EA2  520FE0     SUB W4, #0x0, [W15]
004EA4  320002     BRA Z, 0x4EAA
77:                	// There was a data overflow in the buffer, this is a fault
78:                	spi_bus_status = SPI_BUS_OVERFLOW;
004EA6  B3C044     MOV.B #0x4, W4
004EA8  784F04     MOV.B W4, [W14]
79:                      }
80:                      //if (SPI1STATbits.SPIRBF) {
81:                      // A byte has been recieved in the buffer, read the data from the return buffer
82:                      if (_SPI1IF) {
004EAA  800425     MOV IFS0, W5
004EAC  201004     MOV #0x100, W4
004EAE  628204     AND W5, W4, W4
004EB0  520FE0     SUB W4, #0x0, [W15]
004EB2  320002     BRA Z, 0x4EB8
83:                	// Data  been recieved in the buffer, read the data from the return buffer
84:                	spi_bus_status = SPI_DATA_RECEIVED;
004EB4  B3C024     MOV.B #0x2, W4
004EB6  784F04     MOV.B W4, [W14]
85:                      }    
86:                    }
87:                    return_data = SPI1BUF;
004EBE  801124     MOV SPI1BUF, W4
004EC0  980714     MOV W4, [W14+2]
88:                  }
89:                #endif
90:                
91:                
92:                
93:                #if defined(_SPI2IF)
94:                  if (spi_port == 2) {
004EC2  90426E     MOV.B [W14+6], W4
004EC4  524FE2     SUB.B W4, #0x2, [W15]
004EC6  3A0036     BRA NZ, 0x4F34
95:                
96:                    _SPI2IF = 0;
004EC8  A94087     BCLR 0x87, #2
97:                    SPI2BUF = data_word;
004ECA  90022E     MOV [W14+4], W4
004ECC  881154     MOV W4, SPI2BUF
98:                    while (spi_bus_status == SPI_BUS_ACTIVE) {
004ECE  370014     BRA 0x4EF8
004EF8  78421E     MOV.B [W14], W4
004EFA  524FE0     SUB.B W4, #0x0, [W15]
004EFC  32FFE9     BRA Z, 0x4ED0
99:                      if (SPI_TIMER_INT_FLAG) {
004ED0  800435     MOV IFS1, W5
004ED2  200204     MOV #0x20, W4
004ED4  628204     AND W5, W4, W4
004ED6  520FE0     SUB W4, #0x0, [W15]
004ED8  320002     BRA Z, 0x4EDE
100:               	// There was a timeout of the data read, this is effectivly a fault
101:               	spi_bus_status = SPI_BUS_TIMEOUT;
004EDA  B3C034     MOV.B #0x3, W4
004EDC  784F04     MOV.B W4, [W14]
102:                     }
103:                     if (SPI2STATbits.SPIROV) {
004EDE  801135     MOV SPI2STAT, W5
004EE0  200404     MOV #0x40, W4
004EE2  628204     AND W5, W4, W4
004EE4  520FE0     SUB W4, #0x0, [W15]
004EE6  320002     BRA Z, 0x4EEC
104:               	// There was a data overflow in the buffer, this is a fault
105:               	spi_bus_status = SPI_BUS_OVERFLOW;
004EE8  B3C044     MOV.B #0x4, W4
004EEA  784F04     MOV.B W4, [W14]
106:                     }
107:                     if (!SPI2STATbits.SPITBF) {
004EEC  801134     MOV SPI2STAT, W4
004EEE  620262     AND W4, #0x2, W4
004EF0  520FE0     SUB W4, #0x0, [W15]
004EF2  3A0002     BRA NZ, 0x4EF8
108:               	spi_bus_status = SPI_DATA_SENT;  // Data has been moved into the shift register for sending out
004EF4  B3C014     MOV.B #0x1, W4
004EF6  784F04     MOV.B W4, [W14]
109:                     }
110:                   }
111:                   
112:                   while(spi_bus_status == SPI_DATA_SENT) {
004EFE  370015     BRA 0x4F2A
004F2A  78421E     MOV.B [W14], W4
004F2C  524FE1     SUB.B W4, #0x1, [W15]
004F2E  32FFE8     BRA Z, 0x4F00
113:                     if (SPI_TIMER_INT_FLAG) {
004F00  800435     MOV IFS1, W5
004F02  200204     MOV #0x20, W4
004F04  628204     AND W5, W4, W4
004F06  520FE0     SUB W4, #0x0, [W15]
004F08  320002     BRA Z, 0x4F0E
114:               	// There was a timeout of the data read, this is effectivly a fault
115:               	spi_bus_status = SPI_BUS_TIMEOUT;
004F0A  B3C034     MOV.B #0x3, W4
004F0C  784F04     MOV.B W4, [W14]
116:                     }
117:                     if (SPI2STATbits.SPIROV) {
004F0E  801135     MOV SPI2STAT, W5
004F10  200404     MOV #0x40, W4
004F12  628204     AND W5, W4, W4
004F14  520FE0     SUB W4, #0x0, [W15]
004F16  320002     BRA Z, 0x4F1C
118:               	// There was a data overflow in the buffer, this is a fault
119:               	spi_bus_status = SPI_BUS_OVERFLOW;
004F18  B3C044     MOV.B #0x4, W4
004F1A  784F04     MOV.B W4, [W14]
120:                     }
121:                     if (_SPI2IF) {
004F1C  800435     MOV IFS1, W5
004F1E  204004     MOV #0x400, W4
004F20  628204     AND W5, W4, W4
004F22  520FE0     SUB W4, #0x0, [W15]
004F24  320002     BRA Z, 0x4F2A
122:               	// Data  been recieved in the buffer, read the data from the return buffer
123:               	spi_bus_status = SPI_DATA_RECEIVED;
004F26  B3C024     MOV.B #0x2, W4
004F28  784F04     MOV.B W4, [W14]
124:                     }    
125:                   }
126:                   return_data = SPI2BUF;
004F30  801154     MOV SPI2BUF, W4
004F32  980714     MOV W4, [W14+2]
127:                 }
128:               #endif
129:                 
130:                 if (spi_bus_status == SPI_DATA_RECEIVED) {
004F34  78421E     MOV.B [W14], W4
004F36  524FE2     SUB.B W4, #0x2, [W15]
004F38  3A0003     BRA NZ, 0x4F40
131:                   return (0x0000FFFF & return_data);
004F3A  90021E     MOV [W14+2], W4
004F3C  200005     MOV #0x0, W5
004F3E  370002     BRA 0x4F44
132:                 } else {
133:                   return (0x11110000);
004F40  200004     MOV #0x0, W4
004F42  211115     MOV #0x1111, W5
134:                 }
135:               }
004F44  BE0004     MOV.D W4, W0
004F46  FA8000     ULNK
004F48  060000     RETURN
---  C:/Users/dparker/Documents/GitHub/A36760/ETMI2C.c  -------------------------------------------------
1:                 #include "ETMI2C.h"
2:                 
3:                 
4:                 unsigned int WaitForI2CBusIdle(unsigned char i2c_port) {
004ADE  FA0002     LNK #0x2
004AE0  784F00     MOV.B W0, [W14]
5:                   
6:                   I2C_TIMER_REGISTER = 0;
004AE2  EB0200     CLR W4
004AE4  8808A4     MOV W4, TMR4
7:                   I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004AE6  23E804     MOV #0x3E80, W4
004AE8  8808D4     MOV W4, PR4
8:                   I2C_TIMER_INT_FLAG = 0;
004AEA  A9A086     BCLR IFS1, #5
9:                   I2C_TIMER_CON_BITS.TON = 1;
004AEC  A8E11F     BSET 0x11F, #7
10:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
004AEE  8008F4     MOV T4CON, W4
004AF0  A14004     BCLR W4, #4
004AF2  A15004     BCLR W4, #5
004AF4  8808F4     MOV W4, T4CON
11:                  
12:                #if defined(_I2CMD)
13:                  if ((i2c_port == 0) || (i2c_port == 1)) {
004AF6  78421E     MOV.B [W14], W4
004AF8  524FE0     SUB.B W4, #0x0, [W15]
004AFA  320004     BRA Z, 0x4B04
004AFC  78421E     MOV.B [W14], W4
004AFE  524FE1     SUB.B W4, #0x1, [W15]
004B00  3A000C     BRA NZ, 0x4B1A
14:                    while (I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
004B02  370001     BRA 0x4B06
004B04  000000     NOP
004B06  801045     MOV I2CSTAT, W5
004B08  240004     MOV #0x4000, W4
004B0A  628204     AND W5, W4, W4
004B0C  520FE0     SUB W4, #0x0, [W15]
004B0E  320005     BRA Z, 0x4B1A
004B10  800435     MOV IFS1, W5
004B12  200204     MOV #0x20, W4
004B14  628204     AND W5, W4, W4
004B16  520FE0     SUB W4, #0x0, [W15]
004B18  32FFF6     BRA Z, 0x4B06
15:                  }
16:                #endif
17:                
18:                #if defined(_I2C1MD)
19:                  if (i2c_port == 1) {
20:                    while (I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
21:                  }
22:                #endif
23:                
24:                #if defined(_I2C2MD)
25:                  if (i2c_port == 2) {
26:                    while (I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);		                 //Wait for bus Idle
27:                  }
28:                #endif
29:                    
30:                  if (I2C_TIMER_INT_FLAG) {
004B1A  800435     MOV IFS1, W5
004B1C  200204     MOV #0x20, W4
004B1E  628204     AND W5, W4, W4
004B20  520FE0     SUB W4, #0x0, [W15]
004B22  320002     BRA Z, 0x4B28
31:                    return 0xFA00;
004B24  2FA004     MOV #0xFA00, W4
004B26  370001     BRA 0x4B2A
32:                  } else {
33:                    return 0x0000;
004B28  EB0200     CLR W4
34:                  }
35:                }
004B2A  780004     MOV W4, W0
004B2C  FA8000     ULNK
004B2E  060000     RETURN
36:                  
37:                
38:                
39:                
40:                
41:                unsigned int GenerateI2CStart(unsigned char i2c_port) {
004B30  FA0002     LNK #0x2
004B32  784F00     MOV.B W0, [W14]
42:                  I2C_TIMER_REGISTER = 0;
004B34  EB0200     CLR W4
004B36  8808A4     MOV W4, TMR4
43:                  I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004B38  23E804     MOV #0x3E80, W4
004B3A  8808D4     MOV W4, PR4
44:                  I2C_TIMER_INT_FLAG = 0;
004B3C  A9A086     BCLR IFS1, #5
45:                  I2C_TIMER_CON_BITS.TON = 1;
004B3E  A8E11F     BSET 0x11F, #7
46:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
004B40  8008F4     MOV T4CON, W4
004B42  A14004     BCLR W4, #4
004B44  A15004     BCLR W4, #5
004B46  8808F4     MOV W4, T4CON
47:                  
48:                #if defined(_I2CMD)
49:                  if ((i2c_port == 0) || (i2c_port == 1)) {
004B48  78421E     MOV.B [W14], W4
004B4A  524FE0     SUB.B W4, #0x0, [W15]
004B4C  320003     BRA Z, 0x4B54
004B4E  78421E     MOV.B [W14], W4
004B50  524FE1     SUB.B W4, #0x1, [W15]
004B52  3A000B     BRA NZ, 0x4B6A
50:                    I2CCONbits.SEN = 1;		                         //Generate Start COndition
004B54  A80206     BSET I2CCON, #0
51:                    while (I2CCONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
004B56  000000     NOP
004B58  801034     MOV I2CCON, W4
004B5A  620261     AND W4, #0x1, W4
004B5C  520FE0     SUB W4, #0x0, [W15]
004B5E  320005     BRA Z, 0x4B6A
004B60  800435     MOV IFS1, W5
004B62  200204     MOV #0x20, W4
004B64  628204     AND W5, W4, W4
004B66  520FE0     SUB W4, #0x0, [W15]
004B68  32FFF7     BRA Z, 0x4B58
52:                  }
53:                #endif
54:                
55:                #if defined(_I2C1MD)
56:                  if (i2c_port == 1) {
57:                    I2C1CONbits.SEN = 1;		                         //Generate Start COndition
58:                    while (I2C1CONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
59:                  }
60:                #endif
61:                
62:                #if defined(_I2C2MD)
63:                  if (i2c_port == 2) {
64:                    I2C2CONbits.SEN = 1;		                         //Generate Start COndition
65:                    while (I2C2CONbits.SEN && !I2C_TIMER_INT_FLAG);	 //Wait for Start COndition
66:                  }
67:                #endif
68:                    
69:                  if (I2C_TIMER_INT_FLAG) {
004B6A  800435     MOV IFS1, W5
004B6C  200204     MOV #0x20, W4
004B6E  628204     AND W5, W4, W4
004B70  520FE0     SUB W4, #0x0, [W15]
004B72  320002     BRA Z, 0x4B78
70:                    return 0xFA00;
004B74  2FA004     MOV #0xFA00, W4
004B76  370001     BRA 0x4B7A
71:                  } else {
72:                    return 0x0000;
004B78  EB0200     CLR W4
73:                  }
74:                }
004B7A  780004     MOV W4, W0
004B7C  FA8000     ULNK
004B7E  060000     RETURN
75:                
76:                
77:                
78:                unsigned int GenerateI2CRestart(unsigned char i2c_port) {
004B80  FA0002     LNK #0x2
004B82  784F00     MOV.B W0, [W14]
79:                  I2C_TIMER_REGISTER = 0;
004B84  EB0200     CLR W4
004B86  8808A4     MOV W4, TMR4
80:                  I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004B88  23E804     MOV #0x3E80, W4
004B8A  8808D4     MOV W4, PR4
81:                  I2C_TIMER_INT_FLAG = 0;
004B8C  A9A086     BCLR IFS1, #5
82:                  I2C_TIMER_CON_BITS.TON = 1;
004B8E  A8E11F     BSET 0x11F, #7
83:                  I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
004B90  8008F4     MOV T4CON, W4
004B92  A14004     BCLR W4, #4
004B94  A15004     BCLR W4, #5
004B96  8808F4     MOV W4, T4CON
84:                  
85:                #if defined(_I2CMD)
86:                  if ((i2c_port == 0) || (i2c_port == 1)) {
004B98  78421E     MOV.B [W14], W4
004B9A  524FE0     SUB.B W4, #0x0, [W15]
004B9C  320003     BRA Z, 0x4BA4
004B9E  78421E     MOV.B [W14], W4
004BA0  524FE1     SUB.B W4, #0x1, [W15]
004BA2  3A000B     BRA NZ, 0x4BBA
87:                    I2CCONbits.RSEN = 1;	                         //Generate Re-Start COndition
004BA4  A82206     BSET I2CCON, #1
88:                    while (I2CCONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
004BA6  000000     NOP
004BA8  801034     MOV I2CCON, W4
004BAA  620262     AND W4, #0x2, W4
004BAC  520FE0     SUB W4, #0x0, [W15]
004BAE  320005     BRA Z, 0x4BBA
004BB0  800435     MOV IFS1, W5
004BB2  200204     MOV #0x20, W4
004BB4  628204     AND W5, W4, W4
004BB6  520FE0     SUB W4, #0x0, [W15]
004BB8  32FFF7     BRA Z, 0x4BA8
89:                  }
90:                #endif
91:                
92:                #if defined(_I2C1MD)
93:                  if (i2c_port == 1) {
94:                    I2C1CONbits.RSEN = 1;		                 //Generate Re-Start COndition
95:                    while (I2C1CONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
96:                  }
97:                #endif
98:                
99:                #if defined(_I2C2MD)
100:                 if (i2c_port == 2) {
101:                   I2C2CONbits.RSEN = 1;		                 //Generate Re-Start COndition
102:                   while (I2C2CONbits.RSEN && !I2C_TIMER_INT_FLAG);	 //Wait for Re-Start COndition
103:                 }
104:               #endif
105:                   
106:                 if (I2C_TIMER_INT_FLAG) {
004BBA  800435     MOV IFS1, W5
004BBC  200204     MOV #0x20, W4
004BBE  628204     AND W5, W4, W4
004BC0  520FE0     SUB W4, #0x0, [W15]
004BC2  320002     BRA Z, 0x4BC8
107:                   return 0xFA00;
004BC4  2FA004     MOV #0xFA00, W4
004BC6  370001     BRA 0x4BCA
108:                 } else {
109:                   return 0x0000;
004BC8  EB0200     CLR W4
110:                 }
111:               }
004BCA  780004     MOV W4, W0
004BCC  FA8000     ULNK
004BCE  060000     RETURN
112:               
113:               
114:               
115:               unsigned int WriteByteI2C(unsigned char data, unsigned char i2c_port) {
004BD0  FA0002     LNK #0x2
004BD2  784F00     MOV.B W0, [W14]
004BD4  984711     MOV.B W1, [W14+1]
116:                 I2C_TIMER_REGISTER = 0;
004BD6  EB0200     CLR W4
004BD8  8808A4     MOV W4, TMR4
117:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004BDA  23E804     MOV #0x3E80, W4
004BDC  8808D4     MOV W4, PR4
118:                 I2C_TIMER_INT_FLAG = 0;
004BDE  A9A086     BCLR IFS1, #5
119:                 I2C_TIMER_CON_BITS.TON = 1;
004BE0  A8E11F     BSET 0x11F, #7
120:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
004BE2  8008F4     MOV T4CON, W4
004BE4  A14004     BCLR W4, #4
004BE6  A15004     BCLR W4, #5
004BE8  8808F4     MOV W4, T4CON
121:                 
122:               #if defined(_I2CMD)
123:                 if ((i2c_port == 0) || (i2c_port == 1)) {
004BEA  90421E     MOV.B [W14+1], W4
004BEC  524FE0     SUB.B W4, #0x0, [W15]
004BEE  320003     BRA Z, 0x4BF6
004BF0  90421E     MOV.B [W14+1], W4
004BF2  524FE1     SUB.B W4, #0x1, [W15]
004BF4  3A001A     BRA NZ, 0x4C2A
124:                   I2CTRN = (data);                                            //Load data to the transmit buffer
004BF6  78429E     MOV.B [W14], W5
004BF8  FB8205     ZE W5, W4
004BFA  881014     MOV W4, I2CTRN
125:                   while (!I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);         //Set when transmit process starts
004BFC  000000     NOP
004BFE  801045     MOV I2CSTAT, W5
004C00  240004     MOV #0x4000, W4
004C02  628204     AND W5, W4, W4
004C04  520FE0     SUB W4, #0x0, [W15]
004C06  3A0006     BRA NZ, 0x4C14
004C08  800435     MOV IFS1, W5
004C0A  200204     MOV #0x20, W4
004C0C  628204     AND W5, W4, W4
004C0E  520FE0     SUB W4, #0x0, [W15]
004C10  32FFF6     BRA Z, 0x4BFE
126:                   while (I2CSTATbits.TRSTAT && !I2C_TIMER_INT_FLAG);          //Cleared at end of Slave ACK
004C12  370001     BRA 0x4C16
004C14  000000     NOP
004C16  801045     MOV I2CSTAT, W5
004C18  240004     MOV #0x4000, W4
004C1A  628204     AND W5, W4, W4
004C1C  520FE0     SUB W4, #0x0, [W15]
004C1E  320005     BRA Z, 0x4C2A
004C20  800435     MOV IFS1, W5
004C22  200204     MOV #0x20, W4
004C24  628204     AND W5, W4, W4
004C26  520FE0     SUB W4, #0x0, [W15]
004C28  32FFF6     BRA Z, 0x4C16
127:                 }
128:               #endif
129:               
130:               #if defined(_I2C1MD)
131:                 if (i2c_port == 1) {
132:                   I2C1TRN = (data);                                           //Load data to the transmit buffer
133:                   while (!I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);        //Set when transmit process starts
134:                   while (I2C1STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);	        //Cleared at end of Slave ACK
135:                 }
136:               #endif
137:               
138:               #if defined(_I2C2MD)
139:                 if (i2c_port == 2) {
140:                   I2C2TRN = (data);                                           //Load data to the transmit buffer
141:                   while (!I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);        //Set when transmit process starts
142:                   while (I2C2STATbits.TRSTAT && !I2C_TIMER_INT_FLAG);	        //Cleared at end of Slave ACK
143:                 }
144:               #endif
145:                   
146:                 if (I2C_TIMER_INT_FLAG) {
004C2A  800435     MOV IFS1, W5
004C2C  200204     MOV #0x20, W4
004C2E  628204     AND W5, W4, W4
004C30  520FE0     SUB W4, #0x0, [W15]
004C32  320002     BRA Z, 0x4C38
147:                   return 0xFA00;
004C34  2FA004     MOV #0xFA00, W4
004C36  370001     BRA 0x4C3A
148:                 } else {
149:                   return 0x0000;
004C38  EB0200     CLR W4
150:                 }
151:               }
004C3A  780004     MOV W4, W0
004C3C  FA8000     ULNK
004C3E  060000     RETURN
152:               
153:               unsigned int ReadByteI2C(unsigned char i2c_port) {
004C40  FA0004     LNK #0x4
004C42  984720     MOV.B W0, [W14+2]
154:                 unsigned char return_data;
155:               
156:                 I2C_TIMER_REGISTER = 0;
004C44  EB0200     CLR W4
004C46  8808A4     MOV W4, TMR4
157:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004C48  23E804     MOV #0x3E80, W4
004C4A  8808D4     MOV W4, PR4
158:                 I2C_TIMER_INT_FLAG = 0;
004C4C  A9A086     BCLR IFS1, #5
159:                 I2C_TIMER_CON_BITS.TON = 1;
004C4E  A8E11F     BSET 0x11F, #7
160:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
004C50  8008F4     MOV T4CON, W4
004C52  A14004     BCLR W4, #4
004C54  A15004     BCLR W4, #5
004C56  8808F4     MOV W4, T4CON
161:                 
162:               #if defined(_I2CMD)
163:                 if ((i2c_port == 0) || (i2c_port == 1)) {
004C58  90422E     MOV.B [W14+2], W4
004C5A  524FE0     SUB.B W4, #0x0, [W15]
004C5C  320003     BRA Z, 0x4C64
004C5E  90422E     MOV.B [W14+2], W4
004C60  524FE1     SUB.B W4, #0x1, [W15]
004C62  3A0018     BRA NZ, 0x4C94
164:                   I2CCONbits.RCEN = 1;			                 //Start Master receive
004C64  A86206     BSET I2CCON, #3
165:                   while(I2CCONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
004C66  000000     NOP
004C68  801034     MOV I2CCON, W4
004C6A  620268     AND W4, #0x8, W4
004C6C  520FE0     SUB W4, #0x0, [W15]
004C6E  320006     BRA Z, 0x4C7C
004C70  800435     MOV IFS1, W5
004C72  200204     MOV #0x20, W4
004C74  628204     AND W5, W4, W4
004C76  520FE0     SUB W4, #0x0, [W15]
004C78  32FFF7     BRA Z, 0x4C68
166:                   while(!I2CSTATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
004C7A  370001     BRA 0x4C7E
004C7C  000000     NOP
004C7E  801044     MOV I2CSTAT, W4
004C80  620262     AND W4, #0x2, W4
004C82  520FE0     SUB W4, #0x0, [W15]
004C84  3A0005     BRA NZ, 0x4C90
004C86  800435     MOV IFS1, W5
004C88  200204     MOV #0x20, W4
004C8A  628204     AND W5, W4, W4
004C8C  520FE0     SUB W4, #0x0, [W15]
004C8E  32FFF7     BRA Z, 0x4C7E
167:                   return_data = I2CRCV;
004C90  801004     MOV I2CRCV, W4
004C92  784F04     MOV.B W4, [W14]
168:                 }
169:               #endif
170:               
171:               #if defined(_I2C1MD)
172:                 if (i2c_port == 1) {
173:                   I2C1CONbits.RCEN = 1;			                 //Start Master receive
174:                   while(I2C1CONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
175:                   while(!I2C1STATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
176:                   return_data = I2C1RCV;
177:                 }
178:               #endif
179:               
180:               #if defined(_I2C2MD)
181:                 if (i2c_port == 2) {
182:                   I2C2CONbits.RCEN = 1;			                 //Start Master receive
183:                   while(I2C2CONbits.RCEN && !I2C_TIMER_INT_FLAG);               //Wait for data transfer
184:                   while(!I2C2STATbits.RBF && !I2C_TIMER_INT_FLAG);              //Wait for receive bufer to be full
185:                   return_data = I2C2RCV;
186:                 }
187:               #endif
188:                   
189:                 if (I2C_TIMER_INT_FLAG) {
004C94  800435     MOV IFS1, W5
004C96  200204     MOV #0x20, W4
004C98  628204     AND W5, W4, W4
004C9A  520FE0     SUB W4, #0x0, [W15]
004C9C  320002     BRA Z, 0x4CA2
190:                   return 0xFA00;
004C9E  2FA004     MOV #0xFA00, W4
004CA0  370002     BRA 0x4CA6
191:                 } else {
192:                   return (return_data & 0x00FF);
004CA2  78429E     MOV.B [W14], W5
004CA4  FB8205     ZE W5, W4
193:                 }
194:               }
004CA6  780004     MOV W4, W0
004CA8  FA8000     ULNK
004CAA  060000     RETURN
195:               
196:               
197:               
198:               unsigned int GenerateI2CStop(unsigned char i2c_port) {
004CAC  FA0002     LNK #0x2
004CAE  784F00     MOV.B W0, [W14]
199:                 I2C_TIMER_REGISTER = 0;
004CB0  EB0200     CLR W4
004CB2  8808A4     MOV W4, TMR4
200:                 I2C_TIMER_PERIOD = I2C_TIMEOUT_CYCLES;
004CB4  23E804     MOV #0x3E80, W4
004CB6  8808D4     MOV W4, PR4
201:                 I2C_TIMER_INT_FLAG = 0;
004CB8  A9A086     BCLR IFS1, #5
202:                 I2C_TIMER_CON_BITS.TON = 1;
004CBA  A8E11F     BSET 0x11F, #7
203:                 I2C_TIMER_CON_BITS.TCKPS = I2C_TIMER_PRESCALE_1_1;
004CBC  8008F4     MOV T4CON, W4
004CBE  A14004     BCLR W4, #4
004CC0  A15004     BCLR W4, #5
004CC2  8808F4     MOV W4, T4CON
204:                 
205:               #if defined(_I2CMD)
206:                 if ((i2c_port == 0) || (i2c_port == 1)) {
004CC4  78421E     MOV.B [W14], W4
004CC6  524FE0     SUB.B W4, #0x0, [W15]
004CC8  320003     BRA Z, 0x4CD0
004CCA  78421E     MOV.B [W14], W4
004CCC  524FE1     SUB.B W4, #0x1, [W15]
004CCE  3A000B     BRA NZ, 0x4CE6
207:                   I2CCONbits.PEN = 1;	                                 //Generate Stop COndition
004CD0  A84206     BSET I2CCON, #2
208:                   while (I2CCONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for Stop COndition
004CD2  000000     NOP
004CD4  801034     MOV I2CCON, W4
004CD6  620264     AND W4, #0x4, W4
004CD8  520FE0     SUB W4, #0x0, [W15]
004CDA  320005     BRA Z, 0x4CE6
004CDC  800435     MOV IFS1, W5
004CDE  200204     MOV #0x20, W4
004CE0  628204     AND W5, W4, W4
004CE2  520FE0     SUB W4, #0x0, [W15]
004CE4  32FFF7     BRA Z, 0x4CD4
209:                 }
210:               #endif
211:               
212:               #if defined(_I2C1MD)
213:                 if (i2c_port == 1) {
214:                   I2C1CONbits.PEN = 1;		                 //Generate stop COndition
215:                   while (I2C1CONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for stop COndition
216:                 }
217:               #endif
218:               
219:               #if defined(_I2C2MD)
220:                 if (i2c_port == 2) {
221:                   I2C2CONbits.PEN = 1;		                 //Generate stop COndition
222:                   while (I2C2CONbits.PEN && !I2C_TIMER_INT_FLAG);	 //Wait for stop COndition
223:                 }
224:               #endif
225:                   
226:                 if (I2C_TIMER_INT_FLAG) {
004CE6  800435     MOV IFS1, W5
004CE8  200204     MOV #0x20, W4
004CEA  628204     AND W5, W4, W4
004CEC  520FE0     SUB W4, #0x0, [W15]
004CEE  320002     BRA Z, 0x4CF4
227:                   return 0xFA00;
004CF0  2FA004     MOV #0xFA00, W4
004CF2  370001     BRA 0x4CF6
228:                 } else {
229:                   return 0x0000;
004CF4  EB0200     CLR W4
230:                 }
231:               }
004CF6  780004     MOV W4, W0
004CF8  FA8000     ULNK
004CFA  060000     RETURN
232:               
233:               
---  C:/Users/dparker/Documents/GitHub/A36760/Buffer64.c  -----------------------------------------------
1:                 #include "Buffer64.h"
2:                 
3:                 void Buffer64WriteByte(BUFFER64BYTE* ptr, unsigned char value) {
00502E  FA0004     LNK #0x4
005030  780F00     MOV W0, [W14]
005032  984721     MOV.B W1, [W14+2]
4:                   ptr->data[ptr->write_location] = value;
005034  78021E     MOV [W14], W4
005036  90C204     MOV.B [W4+64], W4
005038  FB8204     ZE W4, W4
00503A  78029E     MOV [W14], W5
00503C  90432E     MOV.B [W14+2], W6
00503E  7A7286     MOV.B W6, [W5+W4]
5:                   ptr->write_location += 1;
005040  78021E     MOV [W14], W4
005042  90C204     MOV.B [W4+64], W4
005044  E84204     INC.B W4, W4
005046  78029E     MOV [W14], W5
005048  98C284     MOV.B W4, [W5+64]
6:                   ptr->write_location &= Buffer64Mask;
00504A  78021E     MOV [W14], W4
00504C  90C204     MOV.B [W4+64], W4
00504E  B243F4     AND.B #0x3F, W4
005050  78029E     MOV [W14], W5
005052  98C284     MOV.B W4, [W5+64]
7:                   if (ptr->write_location == ptr->read_location) {
005054  78021E     MOV [W14], W4
005056  90C284     MOV.B [W4+64], W5
005058  78021E     MOV [W14], W4
00505A  90C214     MOV.B [W4+65], W4
00505C  52CF84     SUB.B W5, W4, [W15]
00505E  3A000A     BRA NZ, 0x5074
8:                     ptr->read_location += 1;
005060  78021E     MOV [W14], W4
005062  90C214     MOV.B [W4+65], W4
005064  E84204     INC.B W4, W4
005066  78029E     MOV [W14], W5
005068  98C294     MOV.B W4, [W5+65]
9:                     ptr->read_location &= Buffer64Mask;
00506A  78021E     MOV [W14], W4
00506C  90C214     MOV.B [W4+65], W4
00506E  B243F4     AND.B #0x3F, W4
005070  78029E     MOV [W14], W5
005072  98C294     MOV.B W4, [W5+65]
10:                  }
11:                }
005074  FA8000     ULNK
005076  060000     RETURN
12:                
13:                unsigned char Buffer64ReadByte(BUFFER64BYTE* ptr) {
005078  FA0004     LNK #0x4
00507A  980710     MOV W0, [W14+2]
14:                  unsigned char local_read_location;
15:                  unsigned char return_data;
16:                						
17:                  local_read_location = ptr->read_location;
00507C  90021E     MOV [W14+2], W4
00507E  90C294     MOV.B [W4+65], W5
005080  984715     MOV.B W5, [W14+1]
18:                  if (local_read_location != ptr->write_location) {
005082  90021E     MOV [W14+2], W4
005084  90C284     MOV.B [W4+64], W5
005086  90421E     MOV.B [W14+1], W4
005088  52CF84     SUB.B W5, W4, [W15]
00508A  32000E     BRA Z, 0x50A8
19:                    // the buffer is not empty
20:                    return_data = ptr->data[local_read_location];
00508C  90421E     MOV.B [W14+1], W4
00508E  FB8204     ZE W4, W4
005090  90029E     MOV [W14+2], W5
005092  7A4F65     MOV.B [W5+W4], [W14]
21:                    local_read_location += 1;
005094  90421E     MOV.B [W14+1], W4
005096  E84204     INC.B W4, W4
005098  984714     MOV.B W4, [W14+1]
22:                    local_read_location &= Buffer64Mask; 
00509A  90421E     MOV.B [W14+1], W4
00509C  B243F4     AND.B #0x3F, W4
00509E  984714     MOV.B W4, [W14+1]
23:                    ptr->read_location = local_read_location;
0050A0  90021E     MOV [W14+2], W4
0050A2  90429E     MOV.B [W14+1], W5
0050A4  98C215     MOV.B W5, [W4+65]
0050A6  370002     BRA 0x50AC
24:                  } else {
25:                    // the buffer was empty
26:                    // return zero and do not increment the read_location
27:                    return_data = 0;
0050A8  EB4200     CLR.B W4
0050AA  784F04     MOV.B W4, [W14]
28:                  }
29:                  return return_data;
0050AC  78421E     MOV.B [W14], W4
30:                }
0050AE  784004     MOV.B W4, W0
0050B0  FA8000     ULNK
0050B2  060000     RETURN
31:                
32:                unsigned char Buffer64BytesInBuffer(BUFFER64BYTE* ptr) {
0050B4  FA0002     LNK #0x2
0050B6  780F00     MOV W0, [W14]
33:                  return ((ptr->write_location - ptr->read_location) & Buffer64Mask);
0050B8  78021E     MOV [W14], W4
0050BA  90C284     MOV.B [W4+64], W5
0050BC  78021E     MOV [W14], W4
0050BE  90C214     MOV.B [W4+65], W4
0050C0  52C204     SUB.B W5, W4, W4
0050C2  B243F4     AND.B #0x3F, W4
34:                }
0050C4  784004     MOV.B W4, W0
0050C6  FA8000     ULNK
0050C8  060000     RETURN
35:                
36:                unsigned char Buffer64IsNotEmpty(BUFFER64BYTE* ptr) {
0050CA  FA0002     LNK #0x2
0050CC  780F00     MOV W0, [W14]
37:                  if (ptr->write_location == ptr->read_location) {
0050CE  78021E     MOV [W14], W4
0050D0  90C284     MOV.B [W4+64], W5
0050D2  78021E     MOV [W14], W4
0050D4  90C214     MOV.B [W4+65], W4
0050D6  52CF84     SUB.B W5, W4, [W15]
0050D8  3A0002     BRA NZ, 0x50DE
38:                    return 0;
0050DA  EB4200     CLR.B W4
0050DC  370001     BRA 0x50E0
39:                  } else {
40:                    return 1;
0050DE  B3C014     MOV.B #0x1, W4
41:                  }
42:                }
0050E0  784004     MOV.B W4, W0
0050E2  FA8000     ULNK
0050E4  060000     RETURN
43:                
44:                
45:                
---  C:/Users/dparker/Documents/GitHub/A36760/A34760.c  -------------------------------------------------
1:                 #include "A34760.h"
2:                 #include "faults.h"
3:                 #include "Serial.h"
4:                 #include "A34760_PINS.h"
5:                 #include "Buffer64.h"
6:                 #include "LTC2656.h"
7:                 #include "IOPorts.h"
8:                 #include "MCP23017.h"
9:                 #include "faults.h"
10:                #include <libpic30.h>
11:                #include "ETMdsp.h"
12:                #include "Config.h"
13:                #include "ETM_Scale.h"
14:                
15:                #define FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG7095_NEW_ROLLOFF 100,100,99,99,99,98,98,97,97,96,96,95,95,94,94,93,93,92,91,91,90,89,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,60,59,58,57,56,54,53,52,51,49,48
16:                
17:                #define FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG7095 100,99,99,98,98,97,96,95,94,94,93,92,91,90,89,88,87,86,84,83,82,81,79,78,77,75,74,72,71,69,67,66,64,62,61,59,57,55,53,51,49,47,45,43,41,39,37,35,32,30,28,25,23,21,18,16,13,10,8,5,3,0,0,0
18:                
19:                #define FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG5193 100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,97,94,91,88,84,81,78,75,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
20:                
21:                #ifdef __MG7095
22:                const unsigned int FilamentLookUpTable[64] = {FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG7095_NEW_ROLLOFF};
23:                #else
24:                const unsigned int FilamentLookUpTable[64] = {FILAMENT_LOOK_UP_TABLE_VALUES_FOR_MG5193};
25:                #endif
26:                
27:                unsigned int arc_detected;
28:                
29:                unsigned long low_energy_target_current_set_point_derived; 
30:                
31:                signed int look_up_offset;
32:                
33:                unsigned int default_pac_2_adc_reading;
34:                
35:                unsigned int max_low_energy_target_current_startup_adjust_initital_value = 300;
36:                unsigned int low_energy_target_current_startup_max_cooldown = 12000;
37:                unsigned int low_energy_target_current_startup_adjust_initital_value = 0;
38:                unsigned int low_energy_target_current_startup_adjust_decay_time_pulses = 1200;
39:                unsigned int low_energy_target_current_startup_adjust_direction_positive = 0;
40:                unsigned int low_energy_target_current_startup_adjust;
41:                
42:                unsigned int pulse_off_time_10_ms_units;
43:                
44:                unsigned int linac_high_energy_target_current_adc_reading;
45:                unsigned int linac_high_energy_target_current_set_point;
46:                
47:                unsigned int linac_low_energy_target_current_adc_reading;
48:                unsigned int linac_low_energy_target_current_set_point;
49:                unsigned int linac_low_energy_target_current_set_point_portal_mode;
50:                unsigned int linac_low_energy_target_current_set_point_gantry_mode;
51:                
52:                
53:                
54:                signed int linac_high_energy_program_offset;
55:                signed int linac_low_energy_program_offset;
56:                unsigned char fast_ratio_mode;
57:                
58:                unsigned int pulse_counter_this_run;   // This counts the number of pulses in the current "run".  This will be reset to 0 if there are no triggers for 100mS or more.
59:                
60:                  
61:                
62:                unsigned int false_trigger;
63:                
64:                unsigned int last_period = 62501;
65:                unsigned int prf_deciherz = 0;
66:                
67:                void ReadADCtoPACArray(void);
68:                
69:                volatile unsigned int timing_error_int1_count = 0;
70:                
71:                unsigned int software_skip_warmup = 0;
72:                
73:                unsigned char ram_config_set_magnetron_magnet_current_from_GUI;
74:                
75:                volatile unsigned int _PERSISTENT last_known_action;
76:                volatile unsigned int _PERSISTENT last_osccon;
77:                
78:                unsigned int _PERSISTENT processor_crash_count;
79:                
80:                unsigned int previous_last_action;
81:                
82:                volatile unsigned int lvdinterrupt_counter = 0;
83:                
84:                unsigned int MakeScale(unsigned int num, unsigned int den);
85:                
86:                unsigned int start_reset_process;
87:                
88:                void SavePulseCountersToEEPROM(void);
89:                
90:                void UpdateIOExpanderOutputs(void);
91:                
92:                unsigned char slow_down_thyratron_pid_counter;
93:                
94:                
95:                unsigned int average_energy_per_pulse_milli_joules;
96:                unsigned int average_output_power_watts;
97:                unsigned int average_pulse_repetition_frequency_deci_herz;
98:                unsigned int prf_pulse_counter;
99:                
100:               
101:               unsigned char control_state;
102:               
103:               unsigned int pac_1_adc_reading;
104:               unsigned int pac_2_adc_reading;
105:               
106:               
107:               unsigned int fast_reset_counter_persistent;
108:               unsigned long _PERSISTENT arc_counter_persistent;
109:               unsigned int arc_counter_consecutive;
110:               unsigned int _PERSISTENT arc_counter_this_hv_on;
111:               unsigned long _PERSISTENT pulse_counter_this_hv_on;
112:               unsigned long long _PERSISTENT pulse_counter_persistent;
113:               unsigned int arc_counter_fast;
114:               unsigned int arc_counter_slow;
115:               unsigned int pulse_counter_fast;
116:               unsigned int pulse_counter_slow;
117:               
118:               unsigned int led_pulse_count;
119:               
120:               
121:               
122:               unsigned int pulse_magnetron_current_adc_reading;
123:               unsigned int pulse_magnetron_voltage_adc_reading;
124:               
125:               
126:               // Control structers for the thyratron heater PID loops
127:               tPID thyratron_reservoir_heater_PID;
128:               fractional pid_thyratron_reservoir_heater_controlHistory[3] __attribute__ ((section (".ybss, bss, ymemory")));
129:               fractional pid_thyratron_reservoir_heater_abcCoefficient[3] __attribute__ ((section (".xbss, bss, xmemory")));
130:               fractional pid_thyratron_reservoir_heater_kCoeffs[] = {0,0,0};
131:               
132:               tPID thyratron_cathode_heater_PID;
133:               fractional pid_thyratron_cathode_heater_controlHistory[3] __attribute__ ((section (".ybss, bss, ymemory")));
134:               fractional pid_thyratron_cathode_heater_abcCoefficient[3] __attribute__ ((section (".xbss, bss, xmemory")));
135:               fractional pid_thyratron_cathode_heater_kCoeffs[] = {0,0,0};
136:               
137:               
138:               
139:               
140:               BUFFER64BYTE uart1_input_buffer;
141:               BUFFER64BYTE uart1_output_buffer;
142:               
143:               LTC2656 U44_LTC2656;
144:               MCP23017 U64_MCP23017;
145:               
146:               POWERSUPPLY ps_hv_lambda_mode_A;
147:               POWERSUPPLY ps_magnetron_mode_A;
148:               POWERSUPPLY ps_hv_lambda_mode_B;
149:               POWERSUPPLY ps_magnetron_mode_B;
150:               POWERSUPPLY ps_magnet;
151:               POWERSUPPLY ps_filament;
152:               POWERSUPPLY ps_thyr_cathode_htr;
153:               POWERSUPPLY ps_thyr_reservoir_htr;
154:               
155:               
156:               volatile unsigned char adc_result_index;
157:               
158:               unsigned int pfn_rev_current_array[128];
159:               
160:               unsigned int pac_1_array[128];
161:               unsigned int pac_2_array[128];
162:               
163:               unsigned int thyratron_cathode_heater_voltage_array[128];
164:               unsigned int thyratron_reservoir_heater_voltage_array[128];
165:               
166:               unsigned int magnetron_magnet_current_array[128];
167:               unsigned int magnetron_magnet_voltage_array[128];
168:               
169:               unsigned int magnetron_filament_current_array[128];
170:               unsigned int magnetron_filament_voltage_array[128];
171:               
172:               unsigned int lambda_vpeak_array[128];
173:               unsigned int lambda_vmon_array[128];
174:               
175:               
176:               volatile unsigned char global_run_post_pulse_process;
177:               volatile unsigned char global_adc_ignore_this_sample;
178:               
179:               
180:               
181:               unsigned char a_b_selected_mode;
182:               volatile unsigned char next_pulse_a_b_selected_mode;
183:               
184:               
185:               unsigned int operation_mode;
186:               unsigned int scale_interleaved;
187:               unsigned int scale_low_energy;
188:               
189:               
190:               
191:               void DoA34760StartUpCommon(void);
192:               void DoA34760StartUpNormalProcess(void);
193:               void DoA34760StartUpFastProcess(void);
194:               void DoA34760StartUpCommonPostProcess(void);
195:               
196:               
197:               
198:               void CalcPowerSupplySettings(POWERSUPPLY* ptr_ps);
199:               void UpdateDacAll(void);
200:               void Do10msTicToc(void);
201:               void DoThyratronPIDs(void);
202:               void DoMagnetronFilamentAdjust(void);
203:               void ReadIsolatedAdcToRam(void);
204:               void FilterADCs(void);
205:               void FastReadAndFilterFeedbacks(void);
206:               void FastReadAndFilterPACInputs(void);
207:               void ExitHvOnState(void);
208:               void DoColdShutDown(void);
209:               void DoWarmShutDown(void);
210:               void StartWarmUp(void);
211:               
212:               void ScalePowerSupply(POWERSUPPLY* ptr_ps, unsigned int num, unsigned int den);
213:               
214:               void EnableMagnetronFilamentSupply(void);
215:               void DisableMagnetronFilamentSupply(void);
216:               void EnableMagnetronMagnetSupply(void);
217:               void DisableMagnetronMagnetSupply(void);
218:               void DisableHVLambdaSupply(void);
219:               void HVLambdaStartCharging(void);
220:               
221:               unsigned int CalculatePoly(unsigned int set_point);
222:               
223:               //unsigned int RCFilter256Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
224:               //unsigned int RCFilter64Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
225:               //unsigned int RCFilter16Tau(unsigned int previous_value, unsigned int current_reading); moved to .h
226:               
227:               
228:               unsigned int mode_A_pulse_magnetron_current_adc_reading_filtered;
229:               unsigned int mode_B_pulse_magnetron_current_adc_reading_filtered;
230:               
231:               unsigned int mode_A_pulse_magnetron_voltage_adc_reading_filtered;
232:               unsigned int mode_B_pulse_magnetron_voltage_adc_reading_filtered;
233:               
234:               unsigned int mode_A_pulse_magnetron_current_adc_reading_max;
235:               unsigned int mode_A_pulse_magnetron_current_adc_reading_min;
236:               
237:               unsigned int mode_B_pulse_magnetron_current_adc_reading_max;
238:               unsigned int mode_B_pulse_magnetron_current_adc_reading_min;
239:               
240:               unsigned int mode_A_pulse_magnetron_voltage_adc_reading_filtered;
241:               unsigned int mode_B_pulse_magnetron_voltage_adc_reading_filtered;
242:               
243:               
244:               
245:               
246:               
247:               void DoStateMachine(void) {
000338  FA0008     LNK #0x8
248:                 unsigned int warmup_counter;
249:                 unsigned int lambda_supply_startup_counter;
250:                 unsigned int vtemp;
251:                 
252:                 unsigned long temp_long;
253:               	  
254:               
255:               
256:                 switch(control_state) {
00033A  208404     MOV #0x840, W4
00033C  784214     MOV.B [W4], W4
00033E  FB8204     ZE W4, W4
000340  200345     MOV #0x34, W5
000342  520F85     SUB W4, W5, [W15]
000344  320114     BRA Z, 0x56E
000346  200345     MOV #0x34, W5
000348  520F85     SUB W4, W5, [W15]
00034A  3C000D     BRA GT, 0x366
00034C  520FE6     SUB W4, #0x6, [W15]
00034E  32002E     BRA Z, 0x3AC
000350  520FE6     SUB W4, #0x6, [W15]
000352  3C0003     BRA GT, 0x35A
000354  520FE4     SUB W4, #0x4, [W15]
000356  32001B     BRA Z, 0x38E
000358  370316     BRA 0x986
00035A  520FF4     SUB W4, #0x14, [W15]
00035C  320076     BRA Z, 0x44A
00035E  200245     MOV #0x24, W5
000360  520F85     SUB W4, W5, [W15]
000362  32008C     BRA Z, 0x47C
000364  370310     BRA 0x986
000366  200A05     MOV #0xA0, W5
000368  520F85     SUB W4, W5, [W15]
00036A  32030A     BRA Z, 0x980
00036C  200A05     MOV #0xA0, W5
00036E  520F85     SUB W4, W5, [W15]
000370  3C0007     BRA GT, 0x380
000372  200355     MOV #0x35, W5
000374  520F85     SUB W4, W5, [W15]
000376  320136     BRA Z, 0x5E4
000378  200445     MOV #0x44, W5
00037A  520F85     SUB W4, W5, [W15]
00037C  32016A     BRA Z, 0x652
00037E  370303     BRA 0x986
000380  200A45     MOV #0xA4, W5
000382  520F85     SUB W4, W5, [W15]
000384  3202CA     BRA Z, 0x91A
000386  200A85     MOV #0xA8, W5
000388  520F85     SUB W4, W5, [W15]
00038A  3202D8     BRA Z, 0x93C
00038C  3702FC     BRA 0x986
257:                   
258:                 case STATE_START_UP:
259:                   DoA34760StartUpCommon();
00038E  070301     RCALL DoA34760StartUpCommon
260:                   DoA34760StartUpNormalProcess();
000390  07075C     RCALL DoA34760StartUpNormalProcess
261:                   DoA34760StartUpCommonPostProcess();
000392  070860     RCALL DoA34760StartUpCommonPostProcess
262:                   
263:                   if (CheckStartupFailed()) {
000394  072012     RCALL CheckStartupFailed
000396  780200     MOV W0, W4
000398  520FE0     SUB W4, #0x0, [W15]
00039A  320004     BRA Z, 0x3A4
264:                     control_state = STATE_FAULT_MCU_CORE_FAULT;
00039C  B3CA04     MOV.B #0xA0, W4
00039E  784004     MOV.B W4, W0
0003A0  B7E840     MOV.B WREG, control_state
265:                   } else {
266:                     control_state = STATE_SYSTEM_COLD_READY;
0003A4  B3C144     MOV.B #0x14, W4
0003A6  784004     MOV.B W4, W0
0003A8  B7E840     MOV.B WREG, control_state
267:                   }
268:                   break;
0003A2  3702F5     BRA 0x98E
0003AA  3702F1     BRA 0x98E
269:                   
270:                 case STATE_FAST_RECOVERY_START_UP:
271:               
272:                   // It takes a 360uS to get to here (really just to read flash)
273:               
274:                   PIN_UART2_TX = !PIN_UART2_TX;
0003AC  801655     MOV LATB, W5
0003AE  200404     MOV #0x40, W4
0003B0  628204     AND W5, W4, W4
0003B2  A7F004     BTSC W4, #15
0003B4  EA0204     NEG W4, W4
0003B6  E90204     DEC W4, W4
0003B8  DE224F     LSR W4, #15, W4
0003BA  784204     MOV.B W4, W4
0003BC  FB8204     ZE W4, W4
0003BE  620261     AND W4, #0x1, W4
0003C0  DD2246     SL W4, #6, W4
0003C2  801656     MOV LATB, W6
0003C4  2FFBF5     MOV #0xFFBF, W5
0003C6  630285     AND W6, W5, W5
0003C8  728204     IOR W5, W4, W4
0003CA  881654     MOV W4, LATB
275:                   DoA34760StartUpCommon();  // This Takes 4.6ms (4.55 ms of this is loading and intialization of Power Supply Structures)
0003CC  0702E2     RCALL DoA34760StartUpCommon
276:                   PIN_UART2_TX = !PIN_UART2_TX;
0003CE  801655     MOV LATB, W5
0003D0  200404     MOV #0x40, W4
0003D2  628204     AND W5, W4, W4
0003D4  A7F004     BTSC W4, #15
0003D6  EA0204     NEG W4, W4
0003D8  E90204     DEC W4, W4
0003DA  DE224F     LSR W4, #15, W4
0003DC  784204     MOV.B W4, W4
0003DE  FB8204     ZE W4, W4
0003E0  620261     AND W4, #0x1, W4
0003E2  DD2246     SL W4, #6, W4
0003E4  801656     MOV LATB, W6
0003E6  2FFBF5     MOV #0xFFBF, W5
0003E8  630285     AND W6, W5, W5
0003EA  728204     IOR W5, W4, W4
0003EC  881654     MOV W4, LATB
277:                   DoA34760StartUpFastProcess(); // This takes 4.3mS 
0003EE  07079B     RCALL DoA34760StartUpFastProcess
278:                   PIN_UART2_TX = !PIN_UART2_TX;
0003F0  801655     MOV LATB, W5
0003F2  200404     MOV #0x40, W4
0003F4  628204     AND W5, W4, W4
0003F6  A7F004     BTSC W4, #15
0003F8  EA0204     NEG W4, W4
0003FA  E90204     DEC W4, W4
0003FC  DE224F     LSR W4, #15, W4
0003FE  784204     MOV.B W4, W4
000400  FB8204     ZE W4, W4
000402  620261     AND W4, #0x1, W4
000404  DD2246     SL W4, #6, W4
000406  801656     MOV LATB, W6
000408  2FFBF5     MOV #0xFFBF, W5
00040A  630285     AND W6, W5, W5
00040C  728204     IOR W5, W4, W4
00040E  881654     MOV W4, LATB
279:                   DoA34760StartUpCommonPostProcess(); // This takes 60uS
000410  070821     RCALL DoA34760StartUpCommonPostProcess
280:                   PIN_UART2_TX = !PIN_UART2_TX;
000412  801655     MOV LATB, W5
000414  200404     MOV #0x40, W4
000416  628204     AND W5, W4, W4
000418  A7F004     BTSC W4, #15
00041A  EA0204     NEG W4, W4
00041C  E90204     DEC W4, W4
00041E  DE224F     LSR W4, #15, W4
000420  784204     MOV.B W4, W4
000422  FB8204     ZE W4, W4
000424  620261     AND W4, #0x1, W4
000426  DD2246     SL W4, #6, W4
000428  801656     MOV LATB, W6
00042A  2FFBF5     MOV #0xFFBF, W5
00042C  630285     AND W6, W5, W5
00042E  728204     IOR W5, W4, W4
000430  881654     MOV W4, LATB
281:                   
282:                   if (CheckStartupFailed()) {
000432  071FC3     RCALL CheckStartupFailed
000434  780200     MOV W0, W4
000436  520FE0     SUB W4, #0x0, [W15]
000438  320004     BRA Z, 0x442
283:                     control_state = STATE_FAULT_MCU_CORE_FAULT;
00043A  B3CA04     MOV.B #0xA0, W4
00043C  784004     MOV.B W4, W0
00043E  B7E840     MOV.B WREG, control_state
284:                   } else {
285:                     control_state = STATE_HV_ON;
000442  B3C444     MOV.B #0x44, W4
000444  784004     MOV.B W4, W0
000446  B7E840     MOV.B WREG, control_state
286:                   }
287:               
288:                   break;
000440  3702A6     BRA 0x98E
000448  3702A2     BRA 0x98E
289:               
290:                   
291:               
292:                 case STATE_SYSTEM_COLD_READY:
293:                   DoColdShutDown();
00044A  070E73     RCALL DoColdShutDown
294:                   while (control_state == STATE_SYSTEM_COLD_READY) {
00044C  370012     BRA 0x472
000472  208404     MOV #0x840, W4
000474  784214     MOV.B [W4], W4
000476  524FF4     SUB.B W4, #0x14, [W15]
000478  32FFEA     BRA Z, 0x44E
295:                     Do10msTicToc();  // Execute 10mS timed functions if the 10ms Timer has rolled
00044E  0709D9     RCALL Do10msTicToc
296:                     DoSerialCommand();
000450  0712CD     RCALL DoSerialCommand
297:                     if (CheckFaultActive()) {
000452  071FB8     RCALL CheckFaultActive
000454  780200     MOV W0, W4
000456  520FE0     SUB W4, #0x0, [W15]
000458  320004     BRA Z, 0x462
298:               	control_state = STATE_FAULT_COLD_FAULT;
00045A  B3CA44     MOV.B #0xA4, W4
00045C  784004     MOV.B W4, W0
00045E  B7E840     MOV.B WREG, control_state
000460  370008     BRA 0x472
299:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == ILL_MODULATOR_ENABLED) {
000462  801615     MOV PORTA, W5
000464  240004     MOV #0x4000, W4
000466  628204     AND W5, W4, W4
000468  520FE0     SUB W4, #0x0, [W15]
00046A  3A0003     BRA NZ, 0x472
300:               	control_state = STATE_WARM_UP;
00046C  B3C244     MOV.B #0x24, W4
00046E  784004     MOV.B W4, W0
000470  B7E840     MOV.B WREG, control_state
301:                     }
302:                   }
303:                   break;
00047A  370289     BRA 0x98E
304:                   
305:                 case STATE_WARM_UP:
306:                   StartWarmUp();
00047C  070E8C     RCALL StartWarmUp
307:                   warmup_counter = 0;
00047E  EB0200     CLR W4
000480  780F04     MOV W4, [W14]
308:                   software_skip_warmup = 0;
000482  EB0200     CLR W4
000484  88C564     MOV W4, 0x18AC
309:                   while (control_state == STATE_WARM_UP) {
000486  37006D     BRA 0x562
000562  208405     MOV #0x840, W5
000564  784295     MOV.B [W5], W5
000566  B3C244     MOV.B #0x24, W4
000568  52CF84     SUB.B W5, W4, [W15]
00056A  32FF8E     BRA Z, 0x488
310:                     Do10msTicToc();
000488  0709BC     RCALL Do10msTicToc
311:                     DoSerialCommand();
00048A  0712B0     RCALL DoSerialCommand
312:                     Nop();
00048C  000000     NOP
313:                     Nop();
00048E  000000     NOP
314:                     Nop();
000490  000000     NOP
315:                     if (_T2IF) {
000492  800425     MOV IFS0, W5
000494  200404     MOV #0x40, W4
000496  628204     AND W5, W4, W4
000498  520FE0     SUB W4, #0x0, [W15]
00049A  32002F     BRA Z, 0x4FA
316:               	warmup_counter++;
00049C  E80F1E     INC [W14], [W14]
317:               	_T2IF = 0;
00049E  A9C084     BCLR IFS0, #6
318:               	if ((PIN_FP_FAST_RESTART == ILL_FAST_RESTART) || (software_skip_warmup == 1)) {
0004A0  801735     MOV PORTG, W5
0004A2  210004     MOV #0x1000, W4
0004A4  628204     AND W5, W4, W4
0004A6  520FE0     SUB W4, #0x0, [W15]
0004A8  320003     BRA Z, 0x4B0
0004AA  80C564     MOV 0x18AC, W4
0004AC  520FE1     SUB W4, #0x1, [W15]
0004AE  3A0011     BRA NZ, 0x4D2
319:               	  ScalePowerSupply(&ps_filament, warmup_counter, 10);
0004B0  2000A2     MOV #0xA, W2
0004B2  78009E     MOV [W14], W1
0004B4  20ACA0     MOV #0xACA, W0
0004B6  07081F     RCALL ScalePowerSupply
320:               	  ScalePowerSupply(&ps_magnet, warmup_counter, 10);
0004B8  2000A2     MOV #0xA, W2
0004BA  78009E     MOV [W14], W1
0004BC  20A700     MOV #0xA70, W0
0004BE  07081B     RCALL ScalePowerSupply
321:               	  ScalePowerSupply(&ps_thyr_cathode_htr, warmup_counter, 10);
0004C0  2000A2     MOV #0xA, W2
0004C2  78009E     MOV [W14], W1
0004C4  20B240     MOV #0xB24, W0
0004C6  070817     RCALL ScalePowerSupply
322:               	  ScalePowerSupply(&ps_thyr_reservoir_htr, warmup_counter, 10);
0004C8  2000A2     MOV #0xA, W2
0004CA  78009E     MOV [W14], W1
0004CC  20B7E0     MOV #0xB7E, W0
0004CE  070813     RCALL ScalePowerSupply
0004D0  370014     BRA 0x4FA
323:               	} else {
324:               	  ScalePowerSupply(&ps_filament, warmup_counter, ps_filament.warmup_ramp_time);
0004D2  805654     MOV ps_filament, W4
0004D4  780104     MOV W4, W2
0004D6  78009E     MOV [W14], W1
0004D8  20ACA0     MOV #0xACA, W0
0004DA  07080D     RCALL ScalePowerSupply
325:               	  ScalePowerSupply(&ps_magnet, warmup_counter, ps_magnet.warmup_ramp_time);
0004DC  805384     MOV ps_magnet, W4
0004DE  780104     MOV W4, W2
0004E0  78009E     MOV [W14], W1
0004E2  20A700     MOV #0xA70, W0
0004E4  070808     RCALL ScalePowerSupply
326:               	  ScalePowerSupply(&ps_thyr_cathode_htr, warmup_counter, ps_thyr_cathode_htr.warmup_ramp_time);
0004E6  805924     MOV ps_thyr_cathode_htr, W4
0004E8  780104     MOV W4, W2
0004EA  78009E     MOV [W14], W1
0004EC  20B240     MOV #0xB24, W0
0004EE  070803     RCALL ScalePowerSupply
327:               	  ScalePowerSupply(&ps_thyr_reservoir_htr, warmup_counter, ps_thyr_reservoir_htr.warmup_ramp_time);
0004F0  805BF4     MOV ps_thyr_reservoir_htr, W4
0004F2  780104     MOV W4, W2
0004F4  78009E     MOV [W14], W1
0004F6  20B7E0     MOV #0xB7E, W0
0004F8  0707FE     RCALL ScalePowerSupply
328:               	}
329:                     }
330:                     if (CheckFaultActive()) {
0004FA  071F64     RCALL CheckFaultActive
0004FC  780200     MOV W0, W4
0004FE  520FE0     SUB W4, #0x0, [W15]
000500  320004     BRA Z, 0x50A
331:               	control_state = STATE_FAULT_COLD_FAULT;
000502  B3CA44     MOV.B #0xA4, W4
000504  784004     MOV.B W4, W0
000506  B7E840     MOV.B WREG, control_state
000508  37002C     BRA 0x562
332:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
00050A  801615     MOV PORTA, W5
00050C  240004     MOV #0x4000, W4
00050E  628204     AND W5, W4, W4
000510  520FE0     SUB W4, #0x0, [W15]
000512  320004     BRA Z, 0x51C
333:               	control_state = STATE_SYSTEM_COLD_READY;
000514  B3C144     MOV.B #0x14, W4
000516  784004     MOV.B W4, W0
000518  B7E840     MOV.B WREG, control_state
00051A  370023     BRA 0x562
334:                     } else if (warmup_counter > SYSTEM_WARM_UP_TIME) {
00051C  207084     MOV #0x708, W4
00051E  78029E     MOV [W14], W5
000520  528F84     SUB W5, W4, [W15]
000522  360007     BRA LEU, 0x532
335:               	ResetHWLatches();
000524  071CD6     RCALL ResetHWLatches
336:               	control_state = STATE_SYSTEM_WARM_READY;
000526  B3C344     MOV.B #0x34, W4
000528  784004     MOV.B W4, W0
00052A  B7E840     MOV.B WREG, control_state
337:               	software_skip_warmup = 0;
00052C  EB0200     CLR W4
00052E  88C564     MOV W4, 0x18AC
000530  370018     BRA 0x562
338:                     } else if ((PIN_FP_FAST_RESTART == ILL_FAST_RESTART) && (warmup_counter > 20)) {
000532  801735     MOV PORTG, W5
000534  210004     MOV #0x1000, W4
000536  628204     AND W5, W4, W4
000538  520FE0     SUB W4, #0x0, [W15]
00053A  3A000A     BRA NZ, 0x550
00053C  78021E     MOV [W14], W4
00053E  520FF4     SUB W4, #0x14, [W15]
000540  360007     BRA LEU, 0x550
339:               	ResetHWLatches();
000542  071CC7     RCALL ResetHWLatches
340:               	control_state = STATE_SYSTEM_WARM_READY;
000544  B3C344     MOV.B #0x34, W4
000546  784004     MOV.B W4, W0
000548  B7E840     MOV.B WREG, control_state
341:               	software_skip_warmup = 0;
00054A  EB0200     CLR W4
00054C  88C564     MOV W4, 0x18AC
00054E  370009     BRA 0x562
342:                     } else if (software_skip_warmup == 1) {
000550  80C564     MOV 0x18AC, W4
000552  520FE1     SUB W4, #0x1, [W15]
000554  3A0006     BRA NZ, 0x562
343:               	ResetHWLatches();
000556  071CBD     RCALL ResetHWLatches
344:               	control_state = STATE_SYSTEM_WARM_READY;
000558  B3C344     MOV.B #0x34, W4
00055A  784004     MOV.B W4, W0
00055C  B7E840     MOV.B WREG, control_state
345:               	software_skip_warmup = 0;
00055E  EB0200     CLR W4
000560  88C564     MOV W4, 0x18AC
346:                     }
347:                   }
348:                   break;
00056C  370210     BRA 0x98E
349:                   
350:                 case STATE_SYSTEM_WARM_READY:
351:                   // DPARKER SaveDataToEEPROM(); -- New Commands to deal with EEPROM access and storage
352:                   DoWarmShutDown();
00056E  070E09     RCALL DoWarmShutDown
353:                   ScalePowerSupply(&ps_hv_lambda_mode_A,100,100);
000570  200642     MOV #0x64, W2
000572  200641     MOV #0x64, W1
000574  209080     MOV #0x908, W0
000576  0707BF     RCALL ScalePowerSupply
354:                   ScalePowerSupply(&ps_hv_lambda_mode_B,100,100);
000578  200642     MOV #0x64, W2
00057A  200641     MOV #0x64, W1
00057C  209BC0     MOV #0x9BC, W0
00057E  0707BB     RCALL ScalePowerSupply
355:                   ScalePowerSupply(&ps_filament,100,100);
000580  200642     MOV #0x64, W2
000582  200641     MOV #0x64, W1
000584  20ACA0     MOV #0xACA, W0
000586  0707B7     RCALL ScalePowerSupply
356:                   ScalePowerSupply(&ps_magnet,100,100);
000588  200642     MOV #0x64, W2
00058A  200641     MOV #0x64, W1
00058C  20A700     MOV #0xA70, W0
00058E  0707B3     RCALL ScalePowerSupply
357:                   ScalePowerSupply(&ps_thyr_reservoir_htr,100,100);
000590  200642     MOV #0x64, W2
000592  200641     MOV #0x64, W1
000594  20B7E0     MOV #0xB7E, W0
000596  0707AF     RCALL ScalePowerSupply
358:                   ScalePowerSupply(&ps_thyr_cathode_htr,100,100);
000598  200642     MOV #0x64, W2
00059A  200641     MOV #0x64, W1
00059C  20B240     MOV #0xB24, W0
00059E  0707AB     RCALL ScalePowerSupply
359:                   while (control_state == STATE_SYSTEM_WARM_READY) {
0005A0  37001B     BRA 0x5D8
0005D8  208405     MOV #0x840, W5
0005DA  784295     MOV.B [W5], W5
0005DC  B3C344     MOV.B #0x34, W4
0005DE  52CF84     SUB.B W5, W4, [W15]
0005E0  32FFE0     BRA Z, 0x5A2
360:                     Do10msTicToc();
0005A2  07092F     RCALL Do10msTicToc
361:                     DoSerialCommand();
0005A4  071223     RCALL DoSerialCommand
362:                     if (CheckFaultActive()) {
0005A6  071F0E     RCALL CheckFaultActive
0005A8  780200     MOV W0, W4
0005AA  520FE0     SUB W4, #0x0, [W15]
0005AC  320004     BRA Z, 0x5B6
363:               	control_state = STATE_FAULT_WARM_FAULT;
0005AE  B3CA84     MOV.B #0xA8, W4
0005B0  784004     MOV.B W4, W0
0005B2  B7E840     MOV.B WREG, control_state
0005B4  370011     BRA 0x5D8
364:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
0005B6  801615     MOV PORTA, W5
0005B8  240004     MOV #0x4000, W4
0005BA  628204     AND W5, W4, W4
0005BC  520FE0     SUB W4, #0x0, [W15]
0005BE  320004     BRA Z, 0x5C8
365:               	control_state = STATE_SYSTEM_COLD_READY;
0005C0  B3C144     MOV.B #0x14, W4
0005C2  784004     MOV.B W4, W0
0005C4  B7E840     MOV.B WREG, control_state
0005C6  370008     BRA 0x5D8
366:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == ILL_MODULATOR_HV_ON) {
0005C8  801615     MOV PORTA, W5
0005CA  280004     MOV #0x8000, W4
0005CC  628204     AND W5, W4, W4
0005CE  520FE0     SUB W4, #0x0, [W15]
0005D0  3A0003     BRA NZ, 0x5D8
367:               	control_state = STATE_HV_STARTUP;
0005D2  B3C354     MOV.B #0x35, W4
0005D4  784004     MOV.B W4, W0
0005D6  B7E840     MOV.B WREG, control_state
368:                     }
369:                   }
370:                   break;
0005E2  3701D5     BRA 0x98E
371:                   
372:                 case STATE_HV_STARTUP:
373:                   // THIS STATE uses the same faults as STATE_SYSTEM_WARM_READY
374:               
375:               #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
376:                   
377:                   vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
378:                   SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp , 0);
379:                   
380:                   vtemp = Scale16Bit(pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
381:                   SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
382:               #endif
383:               
384:               
385:                   lambda_supply_startup_counter = 0;
0005E4  EB0200     CLR W4
0005E6  980714     MOV W4, [W14+2]
386:                   PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART;
0005E8  A9E2CB     BCLR 0x2CB, #7
387:                   while (control_state == STATE_HV_STARTUP) {
0005EA  37002D     BRA 0x646
000646  208405     MOV #0x840, W5
000648  784295     MOV.B [W5], W5
00064A  B3C354     MOV.B #0x35, W4
00064C  52CF84     SUB.B W5, W4, [W15]
00064E  32FFCE     BRA Z, 0x5EC
388:                     Do10msTicToc();
0005EC  07090A     RCALL Do10msTicToc
389:                     DoSerialCommand();
0005EE  0711FE     RCALL DoSerialCommand
390:                     if (_T2IF) {
0005F0  800425     MOV IFS0, W5
0005F2  200404     MOV #0x40, W4
0005F4  628204     AND W5, W4, W4
0005F6  520FE0     SUB W4, #0x0, [W15]
0005F8  320004     BRA Z, 0x602
391:               	// 100ms Timer over flow 
392:               	_T2IF = 0;
0005FA  A9C084     BCLR IFS0, #6
393:               	lambda_supply_startup_counter++;
0005FC  90021E     MOV [W14+2], W4
0005FE  E80204     INC W4, W4
000600  980714     MOV W4, [W14+2]
394:                     }
395:                     if (CheckFaultActive()) {
000602  071EE0     RCALL CheckFaultActive
000604  780200     MOV W0, W4
000606  520FE0     SUB W4, #0x0, [W15]
000608  320004     BRA Z, 0x612
396:               	control_state = STATE_FAULT_WARM_FAULT;
00060A  B3CA84     MOV.B #0xA8, W4
00060C  784004     MOV.B W4, W0
00060E  B7E840     MOV.B WREG, control_state
000610  37001A     BRA 0x646
397:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000612  801615     MOV PORTA, W5
000614  240004     MOV #0x4000, W4
000616  628204     AND W5, W4, W4
000618  520FE0     SUB W4, #0x0, [W15]
00061A  320004     BRA Z, 0x624
398:               	control_state = STATE_SYSTEM_COLD_READY;
00061C  B3C144     MOV.B #0x14, W4
00061E  784004     MOV.B W4, W0
000620  B7E840     MOV.B WREG, control_state
000622  370011     BRA 0x646
399:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == !ILL_MODULATOR_HV_ON) {
000624  801615     MOV PORTA, W5
000626  280004     MOV #0x8000, W4
000628  628204     AND W5, W4, W4
00062A  520FE0     SUB W4, #0x0, [W15]
00062C  320004     BRA Z, 0x636
400:               	control_state = STATE_SYSTEM_WARM_READY;
00062E  B3C344     MOV.B #0x34, W4
000630  784004     MOV.B W4, W0
000632  B7E840     MOV.B WREG, control_state
000634  370008     BRA 0x646
401:                     } else if (lambda_supply_startup_counter >= LAMBDA_SUPPLY_STARTUP_DELAY) {
000636  90029E     MOV [W14+2], W5
000638  200314     MOV #0x31, W4
00063A  528F84     SUB W5, W4, [W15]
00063C  360004     BRA LEU, 0x646
402:               	control_state = STATE_HV_ON;
00063E  B3C444     MOV.B #0x44, W4
000640  784004     MOV.B W4, W0
000642  B7E840     MOV.B WREG, control_state
403:               	HVLambdaStartCharging();
000644  070E75     RCALL HVLambdaStartCharging
404:                     }
405:                   }
406:                   break;
000650  37019E     BRA 0x98E
407:               
408:                   
409:                 case STATE_HV_ON:
410:                   arc_counter_consecutive = 0;
000652  EB0200     CLR W4
000654  884244     MOV W4, arc_counter_consecutive
411:                   arc_counter_slow = 0;
000656  EB0200     CLR W4
000658  884264     MOV W4, arc_counter_slow
412:                   arc_counter_fast = 0;
00065A  EB0200     CLR W4
00065C  884254     MOV W4, arc_counter_fast
413:                   arc_counter_this_hv_on = 0;
00065E  EB0200     CLR W4
000660  88C6E4     MOV W4, arc_counter_this_hv_on
414:                   pulse_counter_this_hv_on = 0;
000662  B82260     MUL.UU W4, #0, W4
000664  88C674     MOV W4, pulse_counter_this_hv_on
000666  88C685     MOV W5, 0x18D0
415:                   global_run_post_pulse_process = 0;
000668  EB4200     CLR.B W4
00066A  784004     MOV.B W4, W0
00066C  B7F6DA     MOV.B WREG, global_run_post_pulse_process
416:                   // PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART; // THIS is a redundent command and should be removed 
417:               
418:                   _T1IE = 1; // This is added for the fast restart process.  Normally _T1IE is set in HVLambdaStartCharging(), but the fast restart clears this bit temporarily
00066E  A8608C     BSET IEC0, #3
419:                       
420:                   while (control_state == STATE_HV_ON) {
000670  37014E     BRA 0x90E
00090E  208405     MOV #0x840, W5
000910  784295     MOV.B [W5], W5
000912  B3C444     MOV.B #0x44, W4
000914  52CF84     SUB.B W5, W4, [W15]
000916  32FEAD     BRA Z, 0x672
421:                     last_known_action = LAST_ACTION_HV_ON_LOOP;
000672  2000C4     MOV #0xC, W4
000674  88C6B4     MOV W4, last_known_action
422:                     Do10msTicToc();
000676  0708C5     RCALL Do10msTicToc
423:                     DoSerialCommand();
000678  0711B9     RCALL DoSerialCommand
424:               
425:                     if (PIN_GANTRY_PORTAL_SELECT == ILL_GANTRY_MODE) {
00067A  801735     MOV PORTG, W5
00067C  280004     MOV #0x8000, W4
00067E  628204     AND W5, W4, W4
000680  520FE0     SUB W4, #0x0, [W15]
000682  3A0003     BRA NZ, 0x68A
426:               	linac_low_energy_target_current_set_point = linac_low_energy_target_current_set_point_gantry_mode;
000684  804124     MOV linac_low_energy_target_current_set_point_gantry_mode, W4
000686  884104     MOV W4, linac_low_energy_target_current_set_point
000688  370002     BRA 0x68E
427:                     } else {
428:               	linac_low_energy_target_current_set_point = linac_low_energy_target_current_set_point_portal_mode;
00068A  804114     MOV linac_low_energy_target_current_set_point_portal_mode, W4
00068C  884104     MOV W4, linac_low_energy_target_current_set_point
429:                     }
430:               
431:               
432:                     if (global_run_post_pulse_process) {
00068E  216DA4     MOV #0x16DA, W4
000690  784214     MOV.B [W4], W4
000692  524FE0     SUB.B W4, #0x0, [W15]
000694  320120     BRA Z, 0x8D6
433:               	if (false_trigger) {
000696  804174     MOV false_trigger, W4
000698  520FE0     SUB W4, #0x0, [W15]
00069A  320002     BRA Z, 0x6A0
434:               	  RecordThisThyratronFault(FAULT_THYR_FALSE_TRIGGER);
00069C  204000     MOV #0x400, W0
00069E  071E50     RCALL RecordThisThyratronFault
435:               	}
436:               	last_known_action = LAST_ACTION_POST_PULSE_PROC;
0006A0  2000B4     MOV #0xB, W4
0006A2  88C6B4     MOV W4, last_known_action
437:               	// The Pulse Interrupt sets this Flag - And this sequence runs only once
438:               	// Update all the pulse data
439:               	if (pulse_counter_this_run <= 0xFF00) {
0006A4  804165     MOV pulse_counter_this_run, W5
0006A6  2FF004     MOV #0xFF00, W4
0006A8  528F84     SUB W5, W4, [W15]
0006AA  3E0003     BRA GTU, 0x6B2
440:               	  pulse_counter_this_run++;
0006AC  804164     MOV pulse_counter_this_run, W4
0006AE  E80204     INC W4, W4
0006B0  884164     MOV W4, pulse_counter_this_run
441:               	}
442:               	pulse_counter_this_hv_on++;
0006B2  80C674     MOV pulse_counter_this_hv_on, W4
0006B4  80C685     MOV 0x18D0, W5
0006B6  420261     ADD W4, #0x1, W4
0006B8  4A82E0     ADDC W5, #0x0, W5
0006BA  88C674     MOV W4, pulse_counter_this_hv_on
0006BC  88C685     MOV W5, 0x18D0
443:               	pulse_counter_persistent++;
0006BE  218BC4     MOV #0x18BC, W4
0006C0  BE0034     MOV.D [W4++], W0
0006C2  BE0124     MOV.D [W4--], W2
0006C4  200014     MOV #0x1, W4
0006C6  200005     MOV #0x0, W5
0006C8  B83360     MUL.UU W6, #0, W6
0006CA  420200     ADD W4, W0, W4
0006CC  4A8281     ADDC W5, W1, W5
0006CE  4B0302     ADDC W6, W2, W6
0006D0  4B8383     ADDC W7, W3, W7
0006D2  218BC0     MOV #0x18BC, W0
0006D4  BE9804     MOV.D W4, [W0++]
0006D6  BE9006     MOV.D W6, [W0--]
444:               	prf_pulse_counter++;
0006D8  8041F4     MOV prf_pulse_counter, W4
0006DA  E80204     INC W4, W4
0006DC  8841F4     MOV W4, prf_pulse_counter
445:               
446:               	ReadIsolatedAdcToRam(); // Durring the pulse interrupt, the magnetron voltage and current was sampled.  Read back that data here
0006DE  070AC0     RCALL ReadIsolatedAdcToRam
447:               	UpdatePulseData(a_b_selected_mode);      // Run filtering/error detection on pulse data
0006E0  216DC4     MOV #0x16DC, W4
0006E2  784214     MOV.B [W4], W4
0006E4  784004     MOV.B W4, W0
0006E6  071C11     RCALL UpdatePulseData
448:               	if (next_pulse_a_b_selected_mode != a_b_selected_mode) {
0006E8  216DD5     MOV #0x16DD, W5
0006EA  784295     MOV.B [W5], W5
0006EC  216DC4     MOV #0x16DC, W4
0006EE  784214     MOV.B [W4], W4
0006F0  52CF84     SUB.B W5, W4, [W15]
0006F2  32000A     BRA Z, 0x708
449:               	  if (ps_hv_lambda_mode_A.v_command_set_point < 17500) {
0006F4  804855     MOV 0x90A, W5
0006F6  2445B4     MOV #0x445B, W4
0006F8  528F84     SUB W5, W4, [W15]
0006FA  3E0003     BRA GTU, 0x702
450:               	    operation_mode = MODE_ULTRA_LOW_DOSE_INTERLEAVED;
0006FC  210304     MOV #0x1030, W4
0006FE  88B6F4     MOV W4, operation_mode
000700  37001A     BRA 0x736
451:               	  } else {
452:               	    operation_mode = MODE_PORTAL_GANTRY_INTERLEAVED;
000702  200304     MOV #0x30, W4
000704  88B6F4     MOV W4, operation_mode
000706  370017     BRA 0x736
453:               	  }
454:               	} else {
455:               	  if (next_pulse_a_b_selected_mode == PULSE_MODE_A) {
000708  216DD4     MOV #0x16DD, W4
00070A  784214     MOV.B [W4], W4
00070C  524FE0     SUB.B W4, #0x0, [W15]
00070E  3A000A     BRA NZ, 0x724
456:               	    if (ps_hv_lambda_mode_A.v_command_set_point < 17500) {
000710  804855     MOV 0x90A, W5
000712  2445B4     MOV #0x445B, W4
000714  528F84     SUB W5, W4, [W15]
000716  3E0003     BRA GTU, 0x71E
457:               	      operation_mode = MODE_ULTRA_LOW_DOSE_HIGH_ENERGY;
000718  210404     MOV #0x1040, W4
00071A  88B6F4     MOV W4, operation_mode
00071C  37000C     BRA 0x736
458:               	    } else {
459:               	      operation_mode = MODE_PORTAL_GANTRY_HIGH_ENERGY;
00071E  200404     MOV #0x40, W4
000720  88B6F4     MOV W4, operation_mode
000722  370009     BRA 0x736
460:               	    }
461:               	  } else {
462:               	    if (ps_hv_lambda_mode_A.v_command_set_point < 17500) {
000724  804855     MOV 0x90A, W5
000726  2445B4     MOV #0x445B, W4
000728  528F84     SUB W5, W4, [W15]
00072A  3E0003     BRA GTU, 0x732
463:               	      operation_mode = MODE_ULTRA_LOW_DOSE_LOW_ENERGY;
00072C  210204     MOV #0x1020, W4
00072E  88B6F4     MOV W4, operation_mode
000730  370002     BRA 0x736
464:               	    } else {
465:               	      operation_mode = MODE_PORTAL_GANTRY_LOW_ENERGY;
000732  200204     MOV #0x20, W4
000734  88B6F4     MOV W4, operation_mode
466:               	    }
467:               	  }
468:               	}
469:               
470:               
471:               	a_b_selected_mode = next_pulse_a_b_selected_mode;
000736  216DD4     MOV #0x16DD, W4
000738  784214     MOV.B [W4], W4
00073A  784004     MOV.B W4, W0
00073C  B7F6DC     MOV.B WREG, a_b_selected_mode
472:               	
473:               	// DPARKER impliment and test a current control PID LOOP
474:               	linac_low_energy_target_current_adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
00073E  20EDA0     MOV #0xEDA, W0
000740  07252E     RCALL _AverageADC128
000742  780200     MOV W0, W4
000744  8840F4     MOV W4, linac_low_energy_target_current_adc_reading
475:               	linac_high_energy_target_current_adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
000746  20FDA0     MOV #0xFDA, W0
000748  07252A     RCALL _AverageADC128
00074A  780200     MOV W0, W4
00074C  8840D4     MOV W4, linac_high_energy_target_current_adc_reading
476:               	//linac_low_energy_target_current_adc_reading = RCFilter64Tau(linac_low_energy_target_current_adc_reading, AverageADC128(thyratron_cathode_heater_voltage_array));
477:               	//linac_high_energy_target_current_adc_reading = RCFilter64Tau(linac_high_energy_target_current_adc_reading, AverageADC128(thyratron_reservoir_heater_voltage_array));
478:               
479:               	if (pulse_counter_this_run < 30) {
00074E  804164     MOV pulse_counter_this_run, W4
000750  520FFD     SUB W4, #0x1D, [W15]
000752  3E0008     BRA GTU, 0x764
480:               	  linac_low_energy_program_offset = 0;
000754  EB0200     CLR W4
000756  884144     MOV W4, linac_low_energy_program_offset
481:               	  linac_high_energy_program_offset = 0;
000758  EB0200     CLR W4
00075A  884134     MOV W4, linac_high_energy_program_offset
482:               	  fast_ratio_mode = 1;
00075C  B3C014     MOV.B #0x1, W4
00075E  784004     MOV.B W4, W0
000760  B7E82A     MOV.B WREG, fast_ratio_mode
000762  3700B1     BRA 0x8C6
483:               	} else {
484:               	  // There have been enough pulses for the sample and hold to return valid readins.  Start to close the loop around the measured target current
485:               	  // DPARKER - write the algorythim to take linac_target_current_high_energy_mode and linac_high_energy_target_current_set_point
486:               	
487:               
488:               	  low_energy_target_current_startup_adjust = 0;
000764  EB0200     CLR W4
000766  8840B4     MOV W4, low_energy_target_current_startup_adjust
489:               #ifdef __STARTUP_TARGET_CURRENT_ADJUST
490:               	  if (pulse_counter_this_run < low_energy_target_current_startup_adjust_decay_time_pulses) {
000768  804165     MOV pulse_counter_this_run, W5
00076A  80C514     MOV 0x18A2, W4
00076C  528F84     SUB W5, W4, [W15]
00076E  310023     BRA C, 0x7B6
491:               	    temp_long = low_energy_target_current_startup_adjust_initital_value;
000770  80C504     MOV 0x18A0, W4
000772  200005     MOV #0x0, W5
000774  980724     MOV W4, [W14+4]
000776  980735     MOV W5, [W14+6]
492:               	    temp_long *= (low_energy_target_current_startup_adjust_decay_time_pulses - pulse_counter_this_run);
000778  80C515     MOV 0x18A2, W5
00077A  804164     MOV pulse_counter_this_run, W4
00077C  528204     SUB W5, W4, W4
00077E  200005     MOV #0x0, W5
000780  90033E     MOV [W14+6], W6
000782  B9B304     MUL.SS W6, W4, W6
000784  780306     MOV W6, W6
000786  9003AE     MOV [W14+4], W7
000788  B9B805     MUL.SS W7, W5, W0
00078A  780380     MOV W0, W7
00078C  430307     ADD W6, W7, W6
00078E  9003AE     MOV [W14+4], W7
000790  780204     MOV W4, W4
000792  B82207     MUL.UU W4, W7, W4
000794  430305     ADD W6, W5, W6
000796  780286     MOV W6, W5
000798  980724     MOV W4, [W14+4]
00079A  980735     MOV W5, [W14+6]
00079C  980724     MOV W4, [W14+4]
00079E  980735     MOV W5, [W14+6]
493:               	    temp_long /= low_energy_target_current_startup_adjust_decay_time_pulses;
0007A0  80C514     MOV 0x18A2, W4
0007A2  200005     MOV #0x0, W5
0007A4  BE0104     MOV.D W4, W2
0007A6  90002E     MOV [W14+4], W0
0007A8  9000BE     MOV [W14+6], W1
0007AA  07FD76     RCALL ___udivsi3
0007AC  BE0200     MOV.D W0, W4
0007AE  980724     MOV W4, [W14+4]
0007B0  980735     MOV W5, [W14+6]
494:               	    low_energy_target_current_startup_adjust = temp_long;
0007B2  90022E     MOV [W14+4], W4
0007B4  8840B4     MOV W4, low_energy_target_current_startup_adjust
495:               	  }
496:               #endif
497:               	  
498:               
499:                 
500:               #ifdef __RATIO_CONTROL_MODE    
501:               	  
502:               	  low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point;
503:               	  low_energy_target_current_set_point_derived *= linac_high_energy_target_current_adc_reading;
504:               	  low_energy_target_current_set_point_derived /= linac_high_energy_target_current_set_point;
505:               	  
506:               
507:               	  if (fast_ratio_mode) {
508:               	    if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
509:               	      linac_low_energy_program_offset -= 9*LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
510:               	    } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
511:               	      linac_low_energy_program_offset += 9*LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
512:               	    } else {
513:               	      fast_ratio_mode = 0;
514:               	    }
515:               	  } else {
516:               	    if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
517:               	      linac_low_energy_program_offset -= LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
518:               	    } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
519:               	      linac_low_energy_program_offset += LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
520:               	    }
521:               	  }
522:               #else
523:               		  
524:               	  if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
0007B6  801735     MOV PORTG, W5
0007B8  240004     MOV #0x4000, W4
0007BA  628204     AND W5, W4, W4
0007BC  520FE0     SUB W4, #0x0, [W15]
0007BE  3A0011     BRA NZ, 0x7E2
525:               	    if (low_energy_target_current_startup_adjust_direction_positive) {
0007C0  80C524     MOV 0x18A4, W4
0007C2  520FE0     SUB W4, #0x0, [W15]
0007C4  320007     BRA Z, 0x7D4
526:               	      low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point + low_energy_target_current_startup_adjust;
0007C6  804105     MOV linac_low_energy_target_current_set_point, W5
0007C8  8040B4     MOV low_energy_target_current_startup_adjust, W4
0007CA  428204     ADD W5, W4, W4
0007CC  200005     MOV #0x0, W5
0007CE  884074     MOV W4, low_energy_target_current_set_point_derived
0007D0  884085     MOV W5, 0x810
0007D2  370031     BRA 0x836
527:               	    } else {
528:               	      low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point - low_energy_target_current_startup_adjust;
0007D4  804105     MOV linac_low_energy_target_current_set_point, W5
0007D6  8040B4     MOV low_energy_target_current_startup_adjust, W4
0007D8  528204     SUB W5, W4, W4
0007DA  200005     MOV #0x0, W5
0007DC  884074     MOV W4, low_energy_target_current_set_point_derived
0007DE  884085     MOV W5, 0x810
0007E0  37002A     BRA 0x836
529:               	    }
530:               	  } else {
531:               	    if (low_energy_target_current_startup_adjust_direction_positive) {
0007E2  80C524     MOV 0x18A4, W4
0007E4  520FE0     SUB W4, #0x0, [W15]
0007E6  320007     BRA Z, 0x7F6
532:               	      low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point + low_energy_target_current_startup_adjust;
0007E8  804105     MOV linac_low_energy_target_current_set_point, W5
0007EA  8040B4     MOV low_energy_target_current_startup_adjust, W4
0007EC  428204     ADD W5, W4, W4
0007EE  200005     MOV #0x0, W5
0007F0  884074     MOV W4, low_energy_target_current_set_point_derived
0007F2  884085     MOV W5, 0x810
0007F4  370006     BRA 0x802
533:               	    } else {
534:               	      low_energy_target_current_set_point_derived = linac_low_energy_target_current_set_point - low_energy_target_current_startup_adjust;
0007F6  804105     MOV linac_low_energy_target_current_set_point, W5
0007F8  8040B4     MOV low_energy_target_current_startup_adjust, W4
0007FA  528204     SUB W5, W4, W4
0007FC  200005     MOV #0x0, W5
0007FE  884074     MOV W4, low_energy_target_current_set_point_derived
000800  884085     MOV W5, 0x810
535:               	    }	    
536:               	    low_energy_target_current_set_point_derived *= pac_2_adc_reading;
000802  804224     MOV pac_2_adc_reading, W4
000804  B82361     MUL.UU W4, #1, W6
000806  804074     MOV low_energy_target_current_set_point_derived, W4
000808  804085     MOV 0x810, W5
00080A  B9B804     MUL.SS W7, W4, W0
00080C  780000     MOV W0, W0
00080E  B9A906     MUL.SS W5, W6, W2
000810  780082     MOV W2, W1
000812  400001     ADD W0, W1, W0
000814  780306     MOV W6, W6
000816  780204     MOV W4, W4
000818  B83204     MUL.UU W6, W4, W4
00081A  400005     ADD W0, W5, W0
00081C  780280     MOV W0, W5
00081E  884074     MOV W4, low_energy_target_current_set_point_derived
000820  884085     MOV W5, 0x810
537:               	    low_energy_target_current_set_point_derived /= default_pac_2_adc_reading;
000822  804076     MOV low_energy_target_current_set_point_derived, W6
000824  804087     MOV 0x810, W7
000826  8040A4     MOV default_pac_2_adc_reading, W4
000828  200005     MOV #0x0, W5
00082A  BE0104     MOV.D W4, W2
00082C  BE0006     MOV.D W6, W0
00082E  07FD34     RCALL ___udivsi3
000830  BE0200     MOV.D W0, W4
000832  884074     MOV W4, low_energy_target_current_set_point_derived
000834  884085     MOV W5, 0x810
538:               	  }
539:               	  
540:               	  if (linac_low_energy_target_current_adc_reading >= (low_energy_target_current_set_point_derived + LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
000836  8040F4     MOV linac_low_energy_target_current_adc_reading, W4
000838  B82361     MUL.UU W4, #1, W6
00083A  804074     MOV low_energy_target_current_set_point_derived, W4
00083C  804085     MOV 0x810, W5
00083E  B00324     ADD #0x32, W4
000840  B08005     ADDC #0x0, W5
000842  530F84     SUB W6, W4, [W15]
000844  5B8F85     SUBB W7, W5, [W15]
000846  390004     BRA NC, 0x850
541:               	    linac_low_energy_program_offset -= LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
000848  804144     MOV linac_low_energy_program_offset, W4
00084A  E90204     DEC W4, W4
00084C  884144     MOV W4, linac_low_energy_program_offset
00084E  37000E     BRA 0x86C
542:               	  } else if (linac_low_energy_target_current_adc_reading <= (low_energy_target_current_set_point_derived - LINAC_TARGET_CURRENT_LOW_ENERGY_MINIMUM_ERROR)) {
000850  8040F4     MOV linac_low_energy_target_current_adc_reading, W4
000852  B82361     MUL.UU W4, #1, W6
000854  804070     MOV low_energy_target_current_set_point_derived, W0
000856  804081     MOV 0x810, W1
000858  2FFCE4     MOV #0xFFCE, W4
00085A  2FFFF5     MOV #0xFFFF, W5
00085C  420200     ADD W4, W0, W4
00085E  4A8281     ADDC W5, W1, W5
000860  530F84     SUB W6, W4, [W15]
000862  5B8F85     SUBB W7, W5, [W15]
000864  3E0003     BRA GTU, 0x86C
543:               	    linac_low_energy_program_offset += LINAC_TARGET_CURRENT_LOW_ENERGY_STEP_SIZE;
000866  804144     MOV linac_low_energy_program_offset, W4
000868  E80204     INC W4, W4
00086A  884144     MOV W4, linac_low_energy_program_offset
544:               	  }
545:               
546:               	  if (linac_high_energy_target_current_adc_reading > (linac_high_energy_target_current_set_point + LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR)) {
00086C  8040E4     MOV linac_high_energy_target_current_set_point, W4
00086E  200325     MOV #0x32, W5
000870  428284     ADD W5, W4, W5
000872  8040D4     MOV linac_high_energy_target_current_adc_reading, W4
000874  528F84     SUB W5, W4, [W15]
000876  310004     BRA C, 0x880
547:               	    linac_high_energy_program_offset -= LINAC_TARGET_CURRENT_HIGH_ENERGY_STEP_SIZE;
000878  804134     MOV linac_high_energy_program_offset, W4
00087A  520263     SUB W4, #0x3, W4
00087C  884134     MOV W4, linac_high_energy_program_offset
00087E  370009     BRA 0x892
548:               	  } else if (linac_high_energy_target_current_adc_reading < (linac_high_energy_target_current_set_point - LINAC_TARGET_CURRENT_HIGH_ENERGY_MINIMUM_ERROR)) {
000880  8040E4     MOV linac_high_energy_target_current_set_point, W4
000882  2FFCE5     MOV #0xFFCE, W5
000884  428284     ADD W5, W4, W5
000886  8040D4     MOV linac_high_energy_target_current_adc_reading, W4
000888  528F84     SUB W5, W4, [W15]
00088A  360003     BRA LEU, 0x892
549:               	    linac_high_energy_program_offset += LINAC_TARGET_CURRENT_HIGH_ENERGY_STEP_SIZE;
00088C  804134     MOV linac_high_energy_program_offset, W4
00088E  420263     ADD W4, #0x3, W4
000890  884134     MOV W4, linac_high_energy_program_offset
550:               	  }
551:               	  
552:               #endif
553:               	  
554:               	  if (linac_low_energy_program_offset > LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET) {
000892  804145     MOV linac_low_energy_program_offset, W5
000894  206404     MOV #0x640, W4
000896  528F84     SUB W5, W4, [W15]
000898  340003     BRA LE, 0x8A0
555:               	    linac_low_energy_program_offset = LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET;
00089A  206404     MOV #0x640, W4
00089C  884144     MOV W4, linac_low_energy_program_offset
00089E  370006     BRA 0x8AC
556:               	  } else if (linac_low_energy_program_offset < -LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET) {
0008A0  804145     MOV linac_low_energy_program_offset, W5
0008A2  2F9C04     MOV #0xF9C0, W4
0008A4  528F84     SUB W5, W4, [W15]
0008A6  3D0002     BRA GE, 0x8AC
557:               	    linac_low_energy_program_offset = -LINAC_TARGET_CURRENT_LOW_ENERGY_PROGRAM_MAX_OFFSET;
0008A8  2F9C04     MOV #0xF9C0, W4
0008AA  884144     MOV W4, linac_low_energy_program_offset
558:               	  }
559:               
560:               	  if (linac_high_energy_program_offset > LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET) {
0008AC  804135     MOV linac_high_energy_program_offset, W5
0008AE  202584     MOV #0x258, W4
0008B0  528F84     SUB W5, W4, [W15]
0008B2  340003     BRA LE, 0x8BA
561:               	    linac_high_energy_program_offset = LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET;
0008B4  202584     MOV #0x258, W4
0008B6  884134     MOV W4, linac_high_energy_program_offset
0008B8  370006     BRA 0x8C6
562:               	  } else if (linac_high_energy_program_offset < -LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET) {
0008BA  804135     MOV linac_high_energy_program_offset, W5
0008BC  2FDA84     MOV #0xFDA8, W4
0008BE  528F84     SUB W5, W4, [W15]
0008C0  3D0002     BRA GE, 0x8C6
563:               	    linac_high_energy_program_offset = -LINAC_TARGET_CURRENT_HIGH_ENERGY_PROGRAM_MAX_OFFSET;
0008C2  2FDA84     MOV #0xFDA8, W4
0008C4  884134     MOV W4, linac_high_energy_program_offset
564:               	  }
565:               	  	  
566:               	} 
567:               	
568:               #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
569:               	
570:               	vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
571:               	if (linac_high_energy_target_current_set_point >= 1000) {
572:               	  vtemp += linac_high_energy_program_offset;
573:               	}
574:               	SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp , 0);
575:               	
576:               	vtemp = Scale16Bit(default_pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
577:               	if (linac_low_energy_target_current_set_point >= 1000) {
578:               	  vtemp += linac_low_energy_program_offset;
579:               	}
580:               	SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
581:               	
582:               #endif
583:               
584:               
585:               
586:               	
587:               	
588:               	UpdateDacAll();                          // We want to Execute DAC update after a pulse so that a pulse does not corrupt the SPI data
0008C6  070761     RCALL UpdateDacAll
589:               	//UpdateIOExpanderOutputs();               // DPAKRER is this needed here?  The io expander outputs should never change in state HV on!!!!
590:               	
591:               	// Set up the 100ms Timer that will roll if there is not another pulse in the next 100mS
592:               	TMR2 = 0;
0008C8  EB0200     CLR W4
0008CA  880834     MOV W4, TMR2
593:               	_T2IF = 0;          
0008CC  A9C084     BCLR IFS0, #6
594:               	global_run_post_pulse_process = 0;	
0008CE  EB4200     CLR.B W4
0008D0  784004     MOV.B W4, W0
0008D2  B7F6DA     MOV.B WREG, global_run_post_pulse_process
595:               	SendLoggingDataToUart();
0008D4  0710EA     RCALL SendLoggingDataToUart
596:                     }
597:                     
598:                     // DPARKER need to write new timing diagram - should be simplier
599:                     
600:                     if (CheckFaultActive()) {
0008D6  071D76     RCALL CheckFaultActive
0008D8  780200     MOV W0, W4
0008DA  520FE0     SUB W4, #0x0, [W15]
0008DC  320005     BRA Z, 0x8E8
601:               	ExitHvOnState();
0008DE  070BD7     RCALL ExitHvOnState
602:               	control_state = STATE_FAULT_WARM_FAULT;
0008E0  B3CA84     MOV.B #0xA8, W4
0008E2  784004     MOV.B W4, W0
0008E4  B7E840     MOV.B WREG, control_state
0008E6  370013     BRA 0x90E
603:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
0008E8  801615     MOV PORTA, W5
0008EA  240004     MOV #0x4000, W4
0008EC  628204     AND W5, W4, W4
0008EE  520FE0     SUB W4, #0x0, [W15]
0008F0  320005     BRA Z, 0x8FC
604:               	ExitHvOnState();
0008F2  070BCD     RCALL ExitHvOnState
605:               	control_state = STATE_SYSTEM_COLD_READY;
0008F4  B3C144     MOV.B #0x14, W4
0008F6  784004     MOV.B W4, W0
0008F8  B7E840     MOV.B WREG, control_state
0008FA  370009     BRA 0x90E
606:                     } else if (PIN_FP_MODULATOR_HV_ON_INPUT == !ILL_MODULATOR_HV_ON) {
0008FC  801615     MOV PORTA, W5
0008FE  280004     MOV #0x8000, W4
000900  628204     AND W5, W4, W4
000902  520FE0     SUB W4, #0x0, [W15]
000904  320004     BRA Z, 0x90E
607:               	ExitHvOnState();
000906  070BC3     RCALL ExitHvOnState
608:               	control_state = STATE_SYSTEM_WARM_READY;
000908  B3C344     MOV.B #0x34, W4
00090A  784004     MOV.B W4, W0
00090C  B7E840     MOV.B WREG, control_state
609:                     }
610:                   }
611:                   break;
000918  37003A     BRA 0x98E
612:                   
613:                 case STATE_FAULT_COLD_FAULT:
614:                   DoColdShutDown();
00091A  070C0B     RCALL DoColdShutDown
615:                   // SaveDataToEEPROM(); DPARKER use better functions
616:                   while (control_state == STATE_FAULT_COLD_FAULT) {
00091C  370009     BRA 0x930
000930  208405     MOV #0x840, W5
000932  784295     MOV.B [W5], W5
000934  B3CA44     MOV.B #0xA4, W4
000936  52CF84     SUB.B W5, W4, [W15]
000938  32FFF2     BRA Z, 0x91E
617:                     Do10msTicToc();
00091E  070771     RCALL Do10msTicToc
618:                     DoSerialCommand();
000920  071065     RCALL DoSerialCommand
619:                     if (CheckFaultActive() == 0) {
000922  071D50     RCALL CheckFaultActive
000924  780200     MOV W0, W4
000926  520FE0     SUB W4, #0x0, [W15]
000928  3A0003     BRA NZ, 0x930
620:               	control_state = STATE_SYSTEM_COLD_READY;
00092A  B3C144     MOV.B #0x14, W4
00092C  784004     MOV.B W4, W0
00092E  B7E840     MOV.B WREG, control_state
621:                     }
622:                   }
623:                   break;
00093A  370029     BRA 0x98E
624:                   
625:                 case STATE_FAULT_WARM_FAULT:
626:                   DoWarmShutDown();
00093C  070C22     RCALL DoWarmShutDown
627:                   // DPARKER SaveDataToEEPROM();
628:                   while (control_state == STATE_FAULT_WARM_FAULT) {
00093E  37001A     BRA 0x974
000974  208405     MOV #0x840, W5
000976  784295     MOV.B [W5], W5
000978  B3CA84     MOV.B #0xA8, W4
00097A  52CF84     SUB.B W5, W4, [W15]
00097C  32FFE1     BRA Z, 0x940
629:                     Do10msTicToc();
000940  070760     RCALL Do10msTicToc
630:                     DoSerialCommand();
000942  071054     RCALL DoSerialCommand
631:                     if (CheckColdFaultActive()) {
000944  071D4A     RCALL CheckColdFaultActive
000946  780200     MOV W0, W4
000948  520FE0     SUB W4, #0x0, [W15]
00094A  320004     BRA Z, 0x954
632:               	control_state = STATE_FAULT_COLD_FAULT;
00094C  B3CA44     MOV.B #0xA4, W4
00094E  784004     MOV.B W4, W0
000950  B7E840     MOV.B WREG, control_state
000952  370010     BRA 0x974
633:                     } else if (PIN_FP_MODULATOR_ENABLE_INPUT == !ILL_MODULATOR_ENABLED) {
000954  801615     MOV PORTA, W5
000956  240004     MOV #0x4000, W4
000958  628204     AND W5, W4, W4
00095A  520FE0     SUB W4, #0x0, [W15]
00095C  320004     BRA Z, 0x966
634:               	control_state = STATE_FAULT_COLD_FAULT;
00095E  B3CA44     MOV.B #0xA4, W4
000960  784004     MOV.B W4, W0
000962  B7E840     MOV.B WREG, control_state
000964  370007     BRA 0x974
635:                     } else if (CheckFaultActive() == 0) {
000966  071D2E     RCALL CheckFaultActive
000968  780200     MOV W0, W4
00096A  520FE0     SUB W4, #0x0, [W15]
00096C  3A0003     BRA NZ, 0x974
636:               	control_state = STATE_SYSTEM_WARM_READY;
00096E  B3C344     MOV.B #0x34, W4
000970  784004     MOV.B W4, W0
000972  B7E840     MOV.B WREG, control_state
637:                     }
638:                   }
639:                   break;
00097E  370007     BRA 0x98E
640:                   
641:                 case STATE_FAULT_MCU_CORE_FAULT:
642:                   // DPARKER DO SOMETHING!!!!!!
643:                   // Maybe flash some LEDs, go home
644:                   // your're fracked.  Just hang out here till you get reset
645:                   while (1) {
646:                     Do10msTicToc();
000980  070740     RCALL Do10msTicToc
647:                     DoSerialCommand();
000982  071034     RCALL DoSerialCommand
648:                   }
000984  37FFFD     BRA 0x980
649:                   break;
650:               
651:                 default:
652:                   // DPARKER throw an ERROR
653:                   control_state = STATE_FAULT_MCU_CORE_FAULT;
000986  B3CA04     MOV.B #0xA0, W4
000988  784004     MOV.B W4, W0
00098A  B7E840     MOV.B WREG, control_state
654:                   break;
00098C  000000     NOP
655:                 }
656:               }
00098E  FA8000     ULNK
000990  060000     RETURN
657:               
658:               void DoA34760StartUpCommon(void) {
000992  FA0002     LNK #0x2
659:                 unsigned int *unsigned_int_ptr;  
660:               
661:                 // This is debugging info info  If the processor reset, a code that indicates the last major point that the processor entered should be held in RAM at last_known_action
662:                 previous_last_action = last_known_action;
000994  80C6B4     MOV last_known_action, W4
000996  884194     MOV W4, previous_last_action
663:                 last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
000998  EB0200     CLR W4
00099A  88C6B4     MOV W4, last_known_action
664:               
665:                 // Figure out why the processor restarted and save to the debug status register
666:                 debug_status_register = 0;
00099C  EB0200     CLR W4
00099E  88C394     MOV W4, debug_status_register
667:                 if (_POR) {
0009A0  803A04     MOV RCON, W4
0009A2  620261     AND W4, #0x1, W4
0009A4  520FE0     SUB W4, #0x0, [W15]
0009A6  320003     BRA Z, 0x9AE
668:                   debug_status_register |= STATUS_POR_RESET;
0009A8  80C394     MOV debug_status_register, W4
0009AA  A04004     BSET W4, #4
0009AC  88C394     MOV W4, debug_status_register
669:                   // _POR = 0;
670:                 }
671:                 if (_EXTR) {
0009AE  803A05     MOV RCON, W5
0009B0  200804     MOV #0x80, W4
0009B2  628204     AND W5, W4, W4
0009B4  520FE0     SUB W4, #0x0, [W15]
0009B6  320004     BRA Z, 0x9C0
672:                   debug_status_register |= STATUS_EXTERNAL_RESET;
0009B8  80C395     MOV debug_status_register, W5
0009BA  200204     MOV #0x20, W4
0009BC  728204     IOR W5, W4, W4
0009BE  88C394     MOV W4, debug_status_register
673:                   //_EXTR = 0;
674:                 }
675:                 if (_SWR) {
0009C0  803A05     MOV RCON, W5
0009C2  200404     MOV #0x40, W4
0009C4  628204     AND W5, W4, W4
0009C6  520FE0     SUB W4, #0x0, [W15]
0009C8  320004     BRA Z, 0x9D2
676:                   debug_status_register |= STATUS_SOFTARE_RESET;
0009CA  80C395     MOV debug_status_register, W5
0009CC  200404     MOV #0x40, W4
0009CE  728204     IOR W5, W4, W4
0009D0  88C394     MOV W4, debug_status_register
677:                   //_SWR = 0;
678:                 }
679:                 if (_BOR) {
0009D2  803A04     MOV RCON, W4
0009D4  620262     AND W4, #0x2, W4
0009D6  520FE0     SUB W4, #0x0, [W15]
0009D8  320003     BRA Z, 0x9E0
680:                   debug_status_register |= STATUS_BOR_RESET;
0009DA  80C394     MOV debug_status_register, W4
0009DC  A00004     BSET W4, #0
0009DE  88C394     MOV W4, debug_status_register
681:                   //_BOR = 0;
682:                 }
683:                 if (_TRAPR) {
0009E0  803A05     MOV RCON, W5
0009E2  280004     MOV #0x8000, W4
0009E4  628204     AND W5, W4, W4
0009E6  520FE0     SUB W4, #0x0, [W15]
0009E8  320003     BRA Z, 0x9F0
684:                   debug_status_register |= STATUS_TRAPR_RESET;
0009EA  80C394     MOV debug_status_register, W4
0009EC  A01004     BSET W4, #1
0009EE  88C394     MOV W4, debug_status_register
685:                   //_TRAPR = 0;
686:                 }
687:                 if (_WDTO) {
0009F0  803A04     MOV RCON, W4
0009F2  620270     AND W4, #0x10, W4
0009F4  520FE0     SUB W4, #0x0, [W15]
0009F6  320003     BRA Z, 0x9FE
688:                   debug_status_register |= STATUS_WDT_RESET;
0009F8  80C394     MOV debug_status_register, W4
0009FA  A02004     BSET W4, #2
0009FC  88C394     MOV W4, debug_status_register
689:                   // _WDTO = 0;
690:                 }
691:                 if (_IOPUWR) {
0009FE  803A05     MOV RCON, W5
000A00  240004     MOV #0x4000, W4
000A02  628204     AND W5, W4, W4
000A04  520FE0     SUB W4, #0x0, [W15]
000A06  320003     BRA Z, 0xA0E
692:                   debug_status_register |= STATUS_IOPUWR_RESET;
000A08  80C394     MOV debug_status_register, W4
000A0A  A03004     BSET W4, #3
000A0C  88C394     MOV W4, debug_status_register
693:                   //_IOPUWR = 0;
694:                 }
695:               
696:                 
697:                 // Debug Counter Initializations
698:                 global_debug_counter.magnetron_current_adc_glitch = 0;
000A0E  EB0200     CLR W4
000A10  88C2E4     MOV W4, global_debug_counter
699:                 global_debug_counter.magnetron_voltage_adc_glitch = 0;
000A12  EB0200     CLR W4
000A14  88C2F4     MOV W4, 0x185E
700:                 global_debug_counter.i2c_bus_error = 0;
000A16  EB0200     CLR W4
000A18  88C304     MOV W4, 0x1860
701:                 global_debug_counter.spi1_bus_error = 0;
000A1A  EB0200     CLR W4
000A1C  88C314     MOV W4, 0x1862
702:                 global_debug_counter.spi2_bus_error = 0;
000A1E  EB0200     CLR W4
000A20  88C324     MOV W4, 0x1864
703:                 global_debug_counter.external_adc_false_trigger = 0;
000A22  EB0200     CLR W4
000A24  88C334     MOV W4, 0x1866
704:                 global_debug_counter.LTC2656_write_error = 0;
000A26  EB0200     CLR W4
000A28  88C344     MOV W4, 0x1868
705:                 global_debug_counter.setpoint_not_valid = 0;
000A2A  EB0200     CLR W4
000A2C  88C354     MOV W4, 0x186A
706:                 global_debug_counter.scale16bit_saturation = 0;
000A2E  EB0200     CLR W4
000A30  88C364     MOV W4, 0x186C
707:                 global_debug_counter.reversescale16bit_saturation = 0;
000A32  EB0200     CLR W4
000A34  88C374     MOV W4, 0x186E
708:               
709:               
710:                 linac_high_energy_target_current_set_point = control_loop_cal_data_ram_copy[EEPROM_CNTRL_HIGH_ENERGY_TARGET];
000A36  80C214     MOV 0x1842, W4
000A38  8840E4     MOV W4, linac_high_energy_target_current_set_point
711:               
712:                 
713:                 linac_low_energy_target_current_set_point_gantry_mode = control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_GANTRY_TARGET];
000A3A  80C224     MOV 0x1844, W4
000A3C  884124     MOV W4, linac_low_energy_target_current_set_point_gantry_mode
714:                 linac_low_energy_target_current_set_point_portal_mode = control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_PORTAL_TARGET];
000A3E  80C264     MOV 0x184C, W4
000A40  884114     MOV W4, linac_low_energy_target_current_set_point_portal_mode
715:                 low_energy_target_current_startup_adjust_decay_time_pulses =  control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_STARTUP_PULSES];
000A42  80C234     MOV 0x1846, W4
000A44  88C514     MOV W4, 0x18A2
716:                 max_low_energy_target_current_startup_adjust_initital_value = control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_MAX_MAGNITUDE];
000A46  80C244     MOV 0x1848, W4
000A48  88C4E4     MOV W4, 0x189C
717:                 low_energy_target_current_startup_max_cooldown = control_loop_cal_data_ram_copy[EEPROM_CNTRL_TARGET_MAX_COOLDOWN];
000A4A  80C254     MOV 0x184A, W4
000A4C  88C4F4     MOV W4, 0x189E
718:                 
719:               
720:                 scale_interleaved = control_loop_cal_data_ram_copy[EEPROM_CNTRL_INTERLEAVED_POWER_SCALE];
000A4E  80C274     MOV 0x184E, W4
000A50  88B704     MOV W4, scale_interleaved
721:                 scale_low_energy  = control_loop_cal_data_ram_copy[EEPROM_CNTRL_LOW_ENERGY_POWER_SCALE];
000A52  80C284     MOV 0x1850, W4
000A54  88B714     MOV W4, scale_low_energy
722:               
723:               
724:               
725:                 /*
726:                   Initialize the thyratron heater PID structure
727:                   DPARKER add these values to H file
728:                 */
729:                 thyratron_cathode_heater_PID.abcCoefficients = &pid_thyratron_cathode_heater_abcCoefficient[0];    /*Set up pointer to derived coefficients */
000A56  208064     MOV #0x806, W4
000A58  884314     MOV W4, thyratron_cathode_heater_PID
730:                 
731:                 thyratron_cathode_heater_PID.controlHistory = &pid_thyratron_cathode_heater_controlHistory[0];     /*Set up pointer to controller history samples */
000A5A  21FFA4     MOV #0x1FFA, W4
000A5C  884324     MOV W4, 0x864
732:                 PIDInit(&thyratron_cathode_heater_PID);                                                    /*Clear the controler history and the controller output */
000A5E  208620     MOV #0x862, W0
000A60  07FBB5     RCALL _PIDInit
733:                 pid_thyratron_cathode_heater_kCoeffs[0] = Q15(0.02);
000A62  2028F4     MOV #0x28F, W4
000A64  88C5B4     MOV W4, 0x18B6
734:                 pid_thyratron_cathode_heater_kCoeffs[1] = Q15(0.08);
000A66  20A3D4     MOV #0xA3D, W4
000A68  88C5C4     MOV W4, 0x18B8
735:                 pid_thyratron_cathode_heater_kCoeffs[2] = Q15(0.08);
000A6A  20A3D4     MOV #0xA3D, W4
000A6C  88C5D4     MOV W4, 0x18BA
736:                 PIDCoeffCalc(&pid_thyratron_cathode_heater_kCoeffs[0], &thyratron_cathode_heater_PID);             /*Derive the a,b, & c coefficients from the Kp, Ki & Kd */
000A6E  208621     MOV #0x862, W1
000A70  218B60     MOV #0x18B6, W0
000A72  07FBB7     RCALL _PIDCoeffCalc
737:                 
738:                 thyratron_reservoir_heater_PID.abcCoefficients = &pid_thyratron_reservoir_heater_abcCoefficient[0];    /*Set up pointer to derived coefficients */
000A74  208004     MOV #0x800, W4
000A76  8842C4     MOV W4, thyratron_reservoir_heater_PID
739:                 thyratron_reservoir_heater_PID.controlHistory = &pid_thyratron_reservoir_heater_controlHistory[0];     /*Set up pointer to controller history samples */
000A78  21FF44     MOV #0x1FF4, W4
000A7A  8842D4     MOV W4, 0x85A
740:                 PIDInit(&thyratron_reservoir_heater_PID);                                          /*Clear the controler history and the controller output */
000A7C  208580     MOV #0x858, W0
000A7E  07FBA6     RCALL _PIDInit
741:                 pid_thyratron_reservoir_heater_kCoeffs[0] = Q15(0.02);
000A80  2028F4     MOV #0x28F, W4
000A82  88C584     MOV W4, 0x18B0
742:                 pid_thyratron_reservoir_heater_kCoeffs[1] = Q15(0.08);
000A84  20A3D4     MOV #0xA3D, W4
000A86  88C594     MOV W4, 0x18B2
743:                 pid_thyratron_reservoir_heater_kCoeffs[2] = Q15(0.08);
000A88  20A3D4     MOV #0xA3D, W4
000A8A  88C5A4     MOV W4, 0x18B4
744:                 PIDCoeffCalc(&pid_thyratron_reservoir_heater_kCoeffs[0], &thyratron_reservoir_heater_PID); /*Derive the a,b, & c coefficients from the Kp, Ki & Kd */
000A8C  208581     MOV #0x858, W1
000A8E  218B00     MOV #0x18B0, W0
000A90  07FBA8     RCALL _PIDCoeffCalc
745:                 ClrWdt();
000A92  FE6000     CLRWDT
746:               
747:                 
748:                   
749:                 // --- ps_magnet initialization ---
750:               
751:                 ps_magnet.warmup_ramp_time     = MAGNET_SUPPLY_WARMUP_RAMP_TIME;
000A94  200644     MOV #0x64, W4
000A96  885384     MOV W4, ps_magnet
752:                 
753:                 ps_magnet.v_max_set_point      = MAX_MAGNET_SUPPLY_VOLTAGE_SET_POINT;
000A98  27D004     MOV #0x7D00, W4
000A9A  8853B4     MOV W4, 0xA76
754:                 
755:                 ps_magnet.v_dac_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
000A9C  EB8080     SETM W1
000A9E  EB8000     SETM W0
000AA0  070C65     RCALL MakeScale
000AA2  780200     MOV W0, W4
000AA4  8853D4     MOV W4, 0xA7A
756:                 ps_magnet.v_dac_cal_gain       = ps_magnet_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000AA6  80B7D4     MOV 0x16FA, W4
000AA8  8853E4     MOV W4, 0xA7C
757:                 ps_magnet.v_dac_cal_offset     = ps_magnet_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000AAA  80B7E4     MOV 0x16FC, W4
000AAC  8853F4     MOV W4, 0xA7E
758:                 
759:                 ps_magnet.v_adc_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_VADC_INPUT_AT_0xFFFF);
000AAE  292AA1     MOV #0x92AA, W1
000AB0  EB8000     SETM W0
000AB2  070C5C     RCALL MakeScale
000AB4  780200     MOV W0, W4
000AB6  885414     MOV W4, 0xA82
760:                 ps_magnet.v_adc_cal_gain       = ps_magnet_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000AB8  80B7F4     MOV 0x16FE, W4
000ABA  885424     MOV W4, 0xA84
761:                 ps_magnet.v_adc_cal_offset     = ps_magnet_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000ABC  80B804     MOV 0x1700, W4
000ABE  885434     MOV W4, 0xA86
762:                 ps_magnet.v_adc_over_abs       = Scale16Bit(MAGNET_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_magnet.v_adc_scale);
000AC0  805414     MOV 0xA82, W4
000AC2  780084     MOV W4, W1
000AC4  275300     MOV #0x7530, W0
000AC6  070C8D     RCALL Scale16Bit
000AC8  780200     MOV W0, W4
000ACA  885444     MOV W4, 0xA88
763:                 ps_magnet.v_adc_over_scale     = MakeScale(MAGNET_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000ACC  220001     MOV #0x2000, W1
000ACE  228000     MOV #0x2800, W0
000AD0  070C4D     RCALL MakeScale
000AD2  780200     MOV W0, W4
000AD4  885474     MOV W4, 0xA8E
764:                 ps_magnet.v_adc_under_scale    = MakeScale(MAGNET_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000AD6  220001     MOV #0x2000, W1
000AD8  210000     MOV #0x1000, W0
000ADA  070C48     RCALL MakeScale
000ADC  780200     MOV W0, W4
000ADE  885484     MOV W4, 0xA90
765:                 ps_magnet.v_adc_over_min_value = MAGNET_SUPPLY_VADC_MIN_OVER_VOLTAGE;
000AE0  203E84     MOV #0x3E8, W4
000AE2  885494     MOV W4, 0xA92
766:                 ps_magnet.v_adc_max_oor        = MAGNET_SUPPLY_VADC_MAX_OUT_OT_RANGE;
000AE4  200324     MOV #0x32, W4
000AE6  8854A4     MOV W4, 0xA94
767:                 
768:                 ps_magnet.i_max_set_point      = MAX_MAGNET_SUPPLY_CURRENT_SET_POINT;
000AE8  261A84     MOV #0x61A8, W4
000AEA  885514     MOV W4, 0xAA2
769:                 
770:                 ps_magnet.i_dac_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
000AEC  291E31     MOV #0x91E3, W1
000AEE  EB8000     SETM W0
000AF0  070C3D     RCALL MakeScale
000AF2  780200     MOV W0, W4
000AF4  885534     MOV W4, 0xAA6
771:                 ps_magnet.i_dac_cal_gain       = ps_magnet_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000AF6  80B824     MOV 0x1704, W4
000AF8  885544     MOV W4, 0xAA8
772:                 ps_magnet.i_dac_cal_offset     = ps_magnet_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000AFA  80B834     MOV 0x1706, W4
000AFC  885554     MOV W4, 0xAAA
773:                 
774:                 ps_magnet.i_adc_scale          = MakeScale(0xFFFF, MAGNET_SUPPLY_IADC_INPUT_AT_0xFFFF);
000AFE  2AB511     MOV #0xAB51, W1
000B00  EB8000     SETM W0
000B02  070C34     RCALL MakeScale
000B04  780200     MOV W0, W4
000B06  885574     MOV W4, 0xAAE
775:                 ps_magnet.i_adc_cal_gain       = ps_magnet_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000B08  80B844     MOV 0x1708, W4
000B0A  885584     MOV W4, 0xAB0
776:                 ps_magnet.i_adc_cal_offset     = ps_magnet_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000B0C  80B854     MOV 0x170A, W4
000B0E  885594     MOV W4, 0xAB2
777:                 ps_magnet.i_adc_over_abs       = Scale16Bit(MAGNET_SUPPLY_IADC_OVER_CURRENT_HARD, ps_magnet.i_adc_scale);
000B10  805574     MOV 0xAAE, W4
000B12  780084     MOV W4, W1
000B14  265900     MOV #0x6590, W0
000B16  070C65     RCALL Scale16Bit
000B18  780200     MOV W0, W4
000B1A  8855A4     MOV W4, 0xAB4
778:                 ps_magnet.i_adc_over_scale     = MakeScale(MAGNET_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
000B1C  220001     MOV #0x2000, W1
000B1E  223330     MOV #0x2333, W0
000B20  070C25     RCALL MakeScale
000B22  780200     MOV W0, W4
000B24  8855D4     MOV W4, 0xABA
779:                 ps_magnet.i_adc_under_scale    = MakeScale(MAGNET_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000B26  220001     MOV #0x2000, W1
000B28  21CCC0     MOV #0x1CCC, W0
000B2A  070C20     RCALL MakeScale
000B2C  780200     MOV W0, W4
000B2E  8855E4     MOV W4, 0xABC
780:                 ps_magnet.i_adc_over_min_value = MAGNET_SUPPLY_IADC_MIN_OVER_CURRENT;
000B30  20FA04     MOV #0xFA0, W4
000B32  8855F4     MOV W4, 0xABE
781:                 ps_magnet.i_adc_max_oor        = MAGNET_SUPPLY_IADC_MAX_OUT_OT_RANGE;
000B34  200324     MOV #0x32, W4
000B36  885604     MOV W4, 0xAC0
782:               
783:                 SetPowerSupplyTarget(&ps_magnet, ps_magnet_config_ram_copy[EEPROM_V_SET_POINT], ps_magnet_config_ram_copy[EEPROM_I_SET_POINT]);
000B38  80B814     MOV 0x1702, W4
000B3A  780284     MOV W4, W5
000B3C  80B7C4     MOV ps_magnet_config_ram_copy, W4
000B3E  780105     MOV W5, W2
000B40  780084     MOV W4, W1
000B42  20A700     MOV #0xA70, W0
000B44  0704A6     RCALL SetPowerSupplyTarget
784:                 
785:               
786:               
787:                 // --- ps_filament initialization ---
788:               
789:                 ps_filament.warmup_ramp_time     = FILAMENT_SUPPLY_WARMUP_RAMP_TIME;
000B46  202584     MOV #0x258, W4
000B48  885654     MOV W4, ps_filament
790:                 
791:                 ps_filament.v_max_set_point      = MAX_FILAMENT_SUPPLY_VOLTAGE_SET_POINT;
000B4A  25DC04     MOV #0x5DC0, W4
000B4C  885684     MOV W4, 0xAD0
792:                 
793:                 ps_filament.v_dac_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
000B4E  EB8080     SETM W1
000B50  EB8000     SETM W0
000B52  070C0C     RCALL MakeScale
000B54  780200     MOV W0, W4
000B56  8856A4     MOV W4, 0xAD4
794:                 ps_filament.v_dac_cal_gain       = ps_filament_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000B58  80B8F4     MOV 0x171E, W4
000B5A  8856B4     MOV W4, 0xAD6
795:                 ps_filament.v_dac_cal_offset     = ps_filament_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000B5C  80B904     MOV 0x1720, W4
000B5E  8856C4     MOV W4, 0xAD8
796:                 
797:                 ps_filament.v_adc_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_VADC_INPUT_AT_0xFFFF);
000B60  292AA1     MOV #0x92AA, W1
000B62  EB8000     SETM W0
000B64  070C03     RCALL MakeScale
000B66  780200     MOV W0, W4
000B68  8856E4     MOV W4, 0xADC
798:                 ps_filament.v_adc_cal_gain       = ps_filament_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000B6A  80B914     MOV 0x1722, W4
000B6C  8856F4     MOV W4, 0xADE
799:                 ps_filament.v_adc_cal_offset     = ps_filament_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000B6E  80B924     MOV 0x1724, W4
000B70  885704     MOV W4, 0xAE0
800:                 ps_filament.v_adc_over_abs       = Scale16Bit(FILAMENT_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_filament.v_adc_scale);
000B72  8056E4     MOV 0xADC, W4
000B74  780084     MOV W4, W1
000B76  261A80     MOV #0x61A8, W0
000B78  070C34     RCALL Scale16Bit
000B7A  780200     MOV W0, W4
000B7C  885714     MOV W4, 0xAE2
801:                 ps_filament.v_adc_over_scale     = MakeScale(FILAMENT_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000B7E  220001     MOV #0x2000, W1
000B80  240000     MOV #0x4000, W0
000B82  070BF4     RCALL MakeScale
000B84  780200     MOV W0, W4
000B86  885744     MOV W4, 0xAE8
802:                 ps_filament.v_adc_under_scale    = MakeScale(FILAMENT_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000B88  220001     MOV #0x2000, W1
000B8A  210000     MOV #0x1000, W0
000B8C  070BEF     RCALL MakeScale
000B8E  780200     MOV W0, W4
000B90  885754     MOV W4, 0xAEA
803:                 ps_filament.v_adc_over_min_value = FILAMENT_SUPPLY_VADC_MIN_OVER_VOLTAGE;
000B92  20FA04     MOV #0xFA0, W4
000B94  885764     MOV W4, 0xAEC
804:                 ps_filament.v_adc_max_oor        = FILAMENT_SUPPLY_VADC_MAX_OUT_OT_RANGE;
000B96  200C84     MOV #0xC8, W4
000B98  885774     MOV W4, 0xAEE
805:                 
806:                 ps_filament.i_max_set_point      = MAX_FILAMENT_SUPPLY_CURRENT_SET_POINT;
000B9A  25DC04     MOV #0x5DC0, W4
000B9C  8857E4     MOV W4, 0xAFC
807:                 
808:                 ps_filament.i_dac_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
000B9E  291E21     MOV #0x91E2, W1
000BA0  EB8000     SETM W0
000BA2  070BE4     RCALL MakeScale
000BA4  780200     MOV W0, W4
000BA6  885804     MOV W4, 0xB00
809:                 ps_filament.i_dac_cal_gain       = ps_filament_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000BA8  80B944     MOV 0x1728, W4
000BAA  885814     MOV W4, 0xB02
810:                 ps_filament.i_dac_cal_offset     = ps_filament_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000BAC  80B954     MOV 0x172A, W4
000BAE  885824     MOV W4, 0xB04
811:                 
812:                 ps_filament.i_adc_scale          = MakeScale(0xFFFF, FILAMENT_SUPPLY_IADC_INPUT_AT_0xFFFF);
000BB0  2AB511     MOV #0xAB51, W1
000BB2  EB8000     SETM W0
000BB4  070BDB     RCALL MakeScale
000BB6  780200     MOV W0, W4
000BB8  885844     MOV W4, 0xB08
813:                 ps_filament.i_adc_cal_gain       = ps_filament_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000BBA  80B964     MOV 0x172C, W4
000BBC  885854     MOV W4, 0xB0A
814:                 ps_filament.i_adc_cal_offset     = ps_filament_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000BBE  80B974     MOV 0x172E, W4
000BC0  885864     MOV W4, 0xB0C
815:                 ps_filament.i_adc_over_abs       = Scale16Bit(FILAMENT_SUPPLY_IADC_OVER_CURRENT_HARD, ps_filament.i_adc_scale);
000BC2  805844     MOV 0xB08, W4
000BC4  780084     MOV W4, W1
000BC6  232C80     MOV #0x32C8, W0
000BC8  070C0C     RCALL Scale16Bit
000BCA  780200     MOV W0, W4
000BCC  885874     MOV W4, 0xB0E
816:                 ps_filament.i_adc_over_scale     = MakeScale(FILAMENT_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
000BCE  220001     MOV #0x2000, W1
000BD0  228000     MOV #0x2800, W0
000BD2  070BCC     RCALL MakeScale
000BD4  780200     MOV W0, W4
000BD6  8858A4     MOV W4, 0xB14
817:                 ps_filament.i_adc_under_scale    = MakeScale(FILAMENT_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000BD8  220001     MOV #0x2000, W1
000BDA  218000     MOV #0x1800, W0
000BDC  070BC7     RCALL MakeScale
000BDE  780200     MOV W0, W4
000BE0  8858B4     MOV W4, 0xB16
818:                 ps_filament.i_adc_over_min_value = FILAMENT_SUPPLY_IADC_MIN_OVER_CURRENT;
000BE2  20FA04     MOV #0xFA0, W4
000BE4  8858C4     MOV W4, 0xB18
819:                 ps_filament.i_adc_max_oor        = FILAMENT_SUPPLY_IADC_MAX_OUT_OT_RANGE;
000BE6  200C84     MOV #0xC8, W4
000BE8  8858D4     MOV W4, 0xB1A
820:               
821:                 SetPowerSupplyTarget(&ps_filament, ps_filament_config_ram_copy[EEPROM_V_SET_POINT], ps_filament_config_ram_copy[EEPROM_I_SET_POINT]);
000BEA  80B934     MOV 0x1726, W4
000BEC  780284     MOV W4, W5
000BEE  80B8E4     MOV ps_filament_config_ram_copy, W4
000BF0  780105     MOV W5, W2
000BF2  780084     MOV W4, W1
000BF4  20ACA0     MOV #0xACA, W0
000BF6  07044D     RCALL SetPowerSupplyTarget
822:                 
823:               
824:               
825:                 // --- ps_thyr_cathode_htr initialization ---
826:               
827:                 ps_thyr_cathode_htr.warmup_ramp_time     = THYR_CATH_HTR_SUPPLY_WARMUP_RAMP_TIME;
000BF8  207084     MOV #0x708, W4
000BFA  885924     MOV W4, ps_thyr_cathode_htr
828:                 
829:                 ps_thyr_cathode_htr.v_max_set_point      = MAX_THYR_CATH_HTR_SUPPLY_VOLTAGE_SET_POINT;
000BFC  21A2C4     MOV #0x1A2C, W4
000BFE  885954     MOV W4, 0xB2A
830:                 
831:                 ps_thyr_cathode_htr.v_dac_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
000C00  EB0080     CLR W1
000C02  EB8000     SETM W0
000C04  070BB3     RCALL MakeScale
000C06  780200     MOV W0, W4
000C08  885974     MOV W4, 0xB2E
832:                 ps_thyr_cathode_htr.v_dac_cal_gain       = ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000C0A  80BA14     MOV 0x1742, W4
000C0C  885984     MOV W4, 0xB30
833:                 ps_thyr_cathode_htr.v_dac_cal_offset     = ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000C0E  80BA24     MOV 0x1744, W4
000C10  885994     MOV W4, 0xB32
834:                 
835:                 ps_thyr_cathode_htr.v_adc_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_VADC_INPUT_AT_0xFFFF);
000C12  295E21     MOV #0x95E2, W1
000C14  EB8000     SETM W0
000C16  070BAA     RCALL MakeScale
000C18  780200     MOV W0, W4
000C1A  8859B4     MOV W4, 0xB36
836:                 ps_thyr_cathode_htr.v_adc_cal_gain       = ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000C1C  80BA34     MOV 0x1746, W4
000C1E  8859C4     MOV W4, 0xB38
837:                 ps_thyr_cathode_htr.v_adc_cal_offset     = ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000C20  80BA44     MOV 0x1748, W4
000C22  8859D4     MOV W4, 0xB3A
838:                 ps_thyr_cathode_htr.v_adc_over_abs       = Scale16Bit(THYR_CATH_HTR_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_thyr_cathode_htr.v_adc_scale);
000C24  8059B4     MOV 0xB36, W4
000C26  780084     MOV W4, W1
000C28  21C200     MOV #0x1C20, W0
000C2A  070BDB     RCALL Scale16Bit
000C2C  780200     MOV W0, W4
000C2E  8859E4     MOV W4, 0xB3C
839:                 ps_thyr_cathode_htr.v_adc_over_scale     = MakeScale(THYR_CATH_HTR_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000C30  220001     MOV #0x2000, W1
000C32  221990     MOV #0x2199, W0
000C34  070B9B     RCALL MakeScale
000C36  780200     MOV W0, W4
000C38  885A14     MOV W4, 0xB42
840:                 ps_thyr_cathode_htr.v_adc_under_scale    = MakeScale(THYR_CATH_HTR_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000C3A  220001     MOV #0x2000, W1
000C3C  21E660     MOV #0x1E66, W0
000C3E  070B96     RCALL MakeScale
000C40  780200     MOV W0, W4
000C42  885A24     MOV W4, 0xB44
841:                 ps_thyr_cathode_htr.v_adc_over_min_value = THYR_CATH_HTR_SUPPLY_VADC_MIN_OVER_VOLTAGE;
000C44  203E84     MOV #0x3E8, W4
000C46  885A34     MOV W4, 0xB46
842:                 ps_thyr_cathode_htr.v_adc_max_oor        = THYR_CATH_HTR_SUPPLY_VADC_MAX_OUT_OT_RANGE;
000C48  201F44     MOV #0x1F4, W4
000C4A  885A44     MOV W4, 0xB48
843:                 
844:                 ps_thyr_cathode_htr.i_max_set_point      = MAX_THYR_CATH_HTR_SUPPLY_CURRENT_SET_POINT;
000C4C  EB0200     CLR W4
000C4E  885AB4     MOV W4, 0xB56
845:                 
846:                 ps_thyr_cathode_htr.i_dac_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
000C50  EB0080     CLR W1
000C52  EB8000     SETM W0
000C54  070B8B     RCALL MakeScale
000C56  780200     MOV W0, W4
000C58  885AD4     MOV W4, 0xB5A
847:                 ps_thyr_cathode_htr.i_dac_cal_gain       = ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000C5A  80BA64     MOV 0x174C, W4
000C5C  885AE4     MOV W4, 0xB5C
848:                 ps_thyr_cathode_htr.i_dac_cal_offset     = ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000C5E  80BA74     MOV 0x174E, W4
000C60  885AF4     MOV W4, 0xB5E
849:                 
850:                 ps_thyr_cathode_htr.i_adc_scale          = MakeScale(0xFFFF, THYR_CATH_HTR_SUPPLY_IADC_INPUT_AT_0xFFFF);
000C62  EB0080     CLR W1
000C64  EB8000     SETM W0
000C66  070B82     RCALL MakeScale
000C68  780200     MOV W0, W4
000C6A  885B14     MOV W4, 0xB62
851:                 ps_thyr_cathode_htr.i_adc_cal_gain       = ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000C6C  80BA84     MOV 0x1750, W4
000C6E  885B24     MOV W4, 0xB64
852:                 ps_thyr_cathode_htr.i_adc_cal_offset     = ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000C70  80BA94     MOV 0x1752, W4
000C72  885B34     MOV W4, 0xB66
853:                 ps_thyr_cathode_htr.i_adc_over_abs       = Scale16Bit(THYR_CATH_HTR_SUPPLY_IADC_OVER_CURRENT_HARD, ps_thyr_cathode_htr.i_adc_scale);
000C74  805B14     MOV 0xB62, W4
000C76  780084     MOV W4, W1
000C78  EB0000     CLR W0
000C7A  070BB3     RCALL Scale16Bit
000C7C  780200     MOV W0, W4
000C7E  885B44     MOV W4, 0xB68
854:                 ps_thyr_cathode_htr.i_adc_over_scale     = MakeScale(THYR_CATH_HTR_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
000C80  220001     MOV #0x2000, W1
000C82  EB0000     CLR W0
000C84  070B73     RCALL MakeScale
000C86  780200     MOV W0, W4
000C88  885B74     MOV W4, 0xB6E
855:                 ps_thyr_cathode_htr.i_adc_under_scale    = MakeScale(THYR_CATH_HTR_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000C8A  220001     MOV #0x2000, W1
000C8C  EB0000     CLR W0
000C8E  070B6E     RCALL MakeScale
000C90  780200     MOV W0, W4
000C92  885B84     MOV W4, 0xB70
856:                 ps_thyr_cathode_htr.i_adc_over_min_value = THYR_CATH_HTR_SUPPLY_IADC_MIN_OVER_CURRENT;
000C94  EB0200     CLR W4
000C96  885B94     MOV W4, 0xB72
857:                 ps_thyr_cathode_htr.i_adc_max_oor        = THYR_CATH_HTR_SUPPLY_IADC_MAX_OUT_OT_RANGE;
000C98  EB0200     CLR W4
000C9A  885BA4     MOV W4, 0xB74
858:               
859:                 SetPowerSupplyTarget(&ps_thyr_cathode_htr, ps_thyr_cathode_htr_config_ram_copy[EEPROM_V_SET_POINT], ps_thyr_cathode_htr_config_ram_copy[EEPROM_I_SET_POINT]);
000C9C  80BA54     MOV 0x174A, W4
000C9E  780284     MOV W4, W5
000CA0  80BA04     MOV ps_thyr_cathode_htr_config_ram_copy, W4
000CA2  780105     MOV W5, W2
000CA4  780084     MOV W4, W1
000CA6  20B240     MOV #0xB24, W0
000CA8  0703F4     RCALL SetPowerSupplyTarget
860:                 
861:               
862:               
863:                 // --- ps_thyr_reservoir_htr initialization ---
864:               
865:                 ps_thyr_reservoir_htr.warmup_ramp_time     = THYR_RESER_HTR_SUPPLY_WARMUP_RAMP_TIME;
000CAA  207084     MOV #0x708, W4
000CAC  885BF4     MOV W4, ps_thyr_reservoir_htr
866:                 
867:                 ps_thyr_reservoir_htr.v_max_set_point      = MAX_THYR_RESER_HTR_SUPPLY_VOLTAGE_SET_POINT;
000CAE  217704     MOV #0x1770, W4
000CB0  885C24     MOV W4, 0xB84
868:                 
869:                 ps_thyr_reservoir_htr.v_dac_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_VDAC_OUTPUT_AT_0xFFFF);
000CB2  EB0080     CLR W1
000CB4  EB8000     SETM W0
000CB6  070B5A     RCALL MakeScale
000CB8  780200     MOV W0, W4
000CBA  885C44     MOV W4, 0xB88
870:                 ps_thyr_reservoir_htr.v_dac_cal_gain       = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000CBC  80BB34     MOV 0x1766, W4
000CBE  885C54     MOV W4, 0xB8A
871:                 ps_thyr_reservoir_htr.v_dac_cal_offset     = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000CC0  80BB44     MOV 0x1768, W4
000CC2  885C64     MOV W4, 0xB8C
872:                 
873:                 ps_thyr_reservoir_htr.v_adc_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_VADC_INPUT_AT_0xFFFF);
000CC4  295E21     MOV #0x95E2, W1
000CC6  EB8000     SETM W0
000CC8  070B51     RCALL MakeScale
000CCA  780200     MOV W0, W4
000CCC  885C84     MOV W4, 0xB90
874:                 ps_thyr_reservoir_htr.v_adc_cal_gain       = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000CCE  80BB54     MOV 0x176A, W4
000CD0  885C94     MOV W4, 0xB92
875:                 ps_thyr_reservoir_htr.v_adc_cal_offset     = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000CD2  80BB64     MOV 0x176C, W4
000CD4  885CA4     MOV W4, 0xB94
876:                 ps_thyr_reservoir_htr.v_adc_over_abs       = Scale16Bit(THYR_RESER_HTR_SUPPLY_VADC_OVER_VOLTAGE_HARD, ps_thyr_reservoir_htr.v_adc_scale);
000CD6  805C84     MOV 0xB90, W4
000CD8  780084     MOV W4, W1
000CDA  2186A0     MOV #0x186A, W0
000CDC  070B82     RCALL Scale16Bit
000CDE  780200     MOV W0, W4
000CE0  885CB4     MOV W4, 0xB96
877:                 ps_thyr_reservoir_htr.v_adc_over_scale     = MakeScale(THYR_RESER_HTR_SUPPLY_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000CE2  220001     MOV #0x2000, W1
000CE4  221990     MOV #0x2199, W0
000CE6  070B42     RCALL MakeScale
000CE8  780200     MOV W0, W4
000CEA  885CE4     MOV W4, 0xB9C
878:                 ps_thyr_reservoir_htr.v_adc_under_scale    = MakeScale(THYR_RESER_HTR_SUPPLY_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000CEC  220001     MOV #0x2000, W1
000CEE  21E660     MOV #0x1E66, W0
000CF0  070B3D     RCALL MakeScale
000CF2  780200     MOV W0, W4
000CF4  885CF4     MOV W4, 0xB9E
879:                 ps_thyr_reservoir_htr.v_adc_over_min_value = THYR_RESER_HTR_SUPPLY_VADC_MIN_OVER_VOLTAGE;
000CF6  203E84     MOV #0x3E8, W4
000CF8  885D04     MOV W4, 0xBA0
880:                 ps_thyr_reservoir_htr.v_adc_max_oor        = THYR_RESER_HTR_SUPPLY_VADC_MAX_OUT_OT_RANGE;
000CFA  201F44     MOV #0x1F4, W4
000CFC  885D14     MOV W4, 0xBA2
881:                 
882:                 ps_thyr_reservoir_htr.i_max_set_point      = MAX_THYR_RESER_HTR_SUPPLY_CURRENT_SET_POINT;
000CFE  EB0200     CLR W4
000D00  885D84     MOV W4, 0xBB0
883:                 
884:                 ps_thyr_reservoir_htr.i_dac_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_IDAC_OUTPUT_AT_0xFFFF);
000D02  EB0080     CLR W1
000D04  EB8000     SETM W0
000D06  070B32     RCALL MakeScale
000D08  780200     MOV W0, W4
000D0A  885DA4     MOV W4, 0xBB4
885:                 ps_thyr_reservoir_htr.i_dac_cal_gain       = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000D0C  80BB84     MOV 0x1770, W4
000D0E  885DB4     MOV W4, 0xBB6
886:                 ps_thyr_reservoir_htr.i_dac_cal_offset     = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000D10  80BB94     MOV 0x1772, W4
000D12  885DC4     MOV W4, 0xBB8
887:                 
888:                 ps_thyr_reservoir_htr.i_adc_scale          = MakeScale(0xFFFF, THYR_RESER_HTR_SUPPLY_IADC_INPUT_AT_0xFFFF);
000D14  EB0080     CLR W1
000D16  EB8000     SETM W0
000D18  070B29     RCALL MakeScale
000D1A  780200     MOV W0, W4
000D1C  885DE4     MOV W4, 0xBBC
889:                 ps_thyr_reservoir_htr.i_adc_cal_gain       = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000D1E  80BBA4     MOV 0x1774, W4
000D20  885DF4     MOV W4, 0xBBE
890:                 ps_thyr_reservoir_htr.i_adc_cal_offset     = ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000D22  80BBB4     MOV 0x1776, W4
000D24  885E04     MOV W4, 0xBC0
891:                 ps_thyr_reservoir_htr.i_adc_over_abs       = Scale16Bit(THYR_RESER_HTR_SUPPLY_IADC_OVER_CURRENT_HARD, ps_thyr_reservoir_htr.i_adc_scale);
000D26  805DE4     MOV 0xBBC, W4
000D28  780084     MOV W4, W1
000D2A  EB0000     CLR W0
000D2C  070B5A     RCALL Scale16Bit
000D2E  780200     MOV W0, W4
000D30  885E14     MOV W4, 0xBC2
892:                 ps_thyr_reservoir_htr.i_adc_over_scale     = MakeScale(THYR_RESER_HTR_SUPPLY_IADC_OVER_CURRENT_SCALE*8192, 8192);
000D32  220001     MOV #0x2000, W1
000D34  EB0000     CLR W0
000D36  070B1A     RCALL MakeScale
000D38  780200     MOV W0, W4
000D3A  885E44     MOV W4, 0xBC8
893:                 ps_thyr_reservoir_htr.i_adc_under_scale    = MakeScale(THYR_RESER_HTR_SUPPLY_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000D3C  220001     MOV #0x2000, W1
000D3E  EB0000     CLR W0
000D40  070B15     RCALL MakeScale
000D42  780200     MOV W0, W4
000D44  885E54     MOV W4, 0xBCA
894:                 ps_thyr_reservoir_htr.i_adc_over_min_value = THYR_RESER_HTR_SUPPLY_IADC_MIN_OVER_CURRENT;
000D46  EB0200     CLR W4
000D48  885E64     MOV W4, 0xBCC
895:                 ps_thyr_reservoir_htr.i_adc_max_oor        = THYR_RESER_HTR_SUPPLY_IADC_MAX_OUT_OT_RANGE;
000D4A  EB0200     CLR W4
000D4C  885E74     MOV W4, 0xBCE
896:               
897:                 SetPowerSupplyTarget(&ps_thyr_reservoir_htr, ps_thyr_reservoir_htr_config_ram_copy[EEPROM_V_SET_POINT], ps_thyr_reservoir_htr_config_ram_copy[EEPROM_I_SET_POINT]);
000D4E  80BB74     MOV 0x176E, W4
000D50  780284     MOV W4, W5
000D52  80BB24     MOV ps_thyr_reservoir_htr_config_ram_copy, W4
000D54  780105     MOV W5, W2
000D56  780084     MOV W4, W1
000D58  20B7E0     MOV #0xB7E, W0
000D5A  07039B     RCALL SetPowerSupplyTarget
898:                 
899:               
900:               
901:                 // --- ps_hv_lambda_mode_A initialization ---
902:               
903:                 ps_hv_lambda_mode_A.warmup_ramp_time     = HV_LAMBDA_MODE_A_WARMUP_RAMP_TIME;
000D5C  EB0200     CLR W4
000D5E  884844     MOV W4, ps_hv_lambda_mode_A
904:                 
905:                 ps_hv_lambda_mode_A.v_max_set_point      = MAX_HV_LAMBDA_MODE_A_VOLTAGE_SET_POINT;
000D60  24E204     MOV #0x4E20, W4
000D62  884874     MOV W4, 0x90E
906:                 
907:                 ps_hv_lambda_mode_A.v_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_VDAC_OUTPUT_AT_0xFFFF);
000D64  257151     MOV #0x5715, W1
000D66  EB8000     SETM W0
000D68  070B01     RCALL MakeScale
000D6A  780200     MOV W0, W4
000D6C  884894     MOV W4, 0x912
908:                 ps_hv_lambda_mode_A.v_dac_cal_gain       = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000D6E  80BC54     MOV _UpdateDacAll, W4
000D70  8848A4     MOV W4, 0x914
909:                 ps_hv_lambda_mode_A.v_dac_cal_offset     = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000D72  80BC64     MOV 0x178C, W4
000D74  8848B4     MOV W4, 0x916
910:                 
911:                 ps_hv_lambda_mode_A.v_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_VADC_INPUT_AT_0xFFFF);
000D76  261A81     MOV #0x61A8, W1
000D78  EB8000     SETM W0
000D7A  070AF8     RCALL MakeScale
000D7C  780200     MOV W0, W4
000D7E  8848D4     MOV W4, 0x91A
912:                 ps_hv_lambda_mode_A.v_adc_cal_gain       = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000D80  80BC74     MOV 0x178E, W4
000D82  8848E4     MOV W4, 0x91C
913:                 ps_hv_lambda_mode_A.v_adc_cal_offset     = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000D84  80BC84     MOV 0x1790, W4
000D86  8848F4     MOV W4, 0x91E
914:                 ps_hv_lambda_mode_A.v_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_A_VADC_OVER_VOLTAGE_HARD, ps_hv_lambda_mode_A.v_adc_scale);
000D88  8048D4     MOV 0x91A, W4
000D8A  780084     MOV W4, W1
000D8C  24C2C0     MOV #0x4C2C, W0
000D8E  070B29     RCALL Scale16Bit
000D90  780200     MOV W0, W4
000D92  884904     MOV W4, 0x920
915:                 ps_hv_lambda_mode_A.v_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_A_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000D94  220001     MOV #0x2000, W1
000D96  EB0000     CLR W0
000D98  070AE9     RCALL MakeScale
000D9A  780200     MOV W0, W4
000D9C  884934     MOV W4, 0x926
916:                 ps_hv_lambda_mode_A.v_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_A_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000D9E  220001     MOV #0x2000, W1
000DA0  EB0000     CLR W0
000DA2  070AE4     RCALL MakeScale
000DA4  780200     MOV W0, W4
000DA6  884944     MOV W4, 0x928
917:                 ps_hv_lambda_mode_A.v_adc_over_min_value = HV_LAMBDA_MODE_A_VADC_MIN_OVER_VOLTAGE;
000DA8  EB0200     CLR W4
000DAA  884954     MOV W4, 0x92A
918:                 ps_hv_lambda_mode_A.v_adc_max_oor        = HV_LAMBDA_MODE_A_VADC_MAX_OUT_OT_RANGE;
000DAC  EB0200     CLR W4
000DAE  884964     MOV W4, 0x92C
919:                 
920:                 ps_hv_lambda_mode_A.i_max_set_point      = MAX_HV_LAMBDA_MODE_A_CURRENT_SET_POINT;
000DB0  EB0200     CLR W4
000DB2  8849D4     MOV W4, 0x93A
921:                 
922:                 ps_hv_lambda_mode_A.i_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_IDAC_OUTPUT_AT_0xFFFF);
000DB4  EB0080     CLR W1
000DB6  EB8000     SETM W0
000DB8  070AD9     RCALL MakeScale
000DBA  780200     MOV W0, W4
000DBC  8849F4     MOV W4, 0x93E
923:                 ps_hv_lambda_mode_A.i_dac_cal_gain       = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000DBE  80BCA4     MOV 0x1794, W4
000DC0  884A04     MOV W4, 0x940
924:                 ps_hv_lambda_mode_A.i_dac_cal_offset     = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000DC2  80BCB4     MOV 0x1796, W4
000DC4  884A14     MOV W4, 0x942
925:                 
926:                 ps_hv_lambda_mode_A.i_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_A_IADC_INPUT_AT_0xFFFF);
000DC6  EB0080     CLR W1
000DC8  EB8000     SETM W0
000DCA  070AD0     RCALL MakeScale
000DCC  780200     MOV W0, W4
000DCE  884A34     MOV W4, 0x946
927:                 ps_hv_lambda_mode_A.i_adc_cal_gain       = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000DD0  80BCC4     MOV 0x1798, W4
000DD2  884A44     MOV W4, 0x948
928:                 ps_hv_lambda_mode_A.i_adc_cal_offset     = ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000DD4  80BCD4     MOV 0x179A, W4
000DD6  884A54     MOV W4, 0x94A
929:                 ps_hv_lambda_mode_A.i_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_A_IADC_OVER_CURRENT_HARD, ps_hv_lambda_mode_A.i_adc_scale);
000DD8  804A34     MOV 0x946, W4
000DDA  780084     MOV W4, W1
000DDC  EB0000     CLR W0
000DDE  070B01     RCALL Scale16Bit
000DE0  780200     MOV W0, W4
000DE2  884A64     MOV W4, 0x94C
930:                 ps_hv_lambda_mode_A.i_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_A_IADC_OVER_CURRENT_SCALE*8192, 8192);
000DE4  220001     MOV #0x2000, W1
000DE6  EB0000     CLR W0
000DE8  070AC1     RCALL MakeScale
000DEA  780200     MOV W0, W4
000DEC  884A94     MOV W4, 0x952
931:                 ps_hv_lambda_mode_A.i_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_A_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000DEE  220001     MOV #0x2000, W1
000DF0  EB0000     CLR W0
000DF2  070ABC     RCALL MakeScale
000DF4  780200     MOV W0, W4
000DF6  884AA4     MOV W4, 0x954
932:                 ps_hv_lambda_mode_A.i_adc_over_min_value = HV_LAMBDA_MODE_A_IADC_MIN_OVER_CURRENT;
000DF8  EB0200     CLR W4
000DFA  884AB4     MOV W4, 0x956
933:                 ps_hv_lambda_mode_A.i_adc_max_oor        = HV_LAMBDA_MODE_A_IADC_MAX_OUT_OT_RANGE;
000DFC  EB0200     CLR W4
000DFE  884AC4     MOV W4, 0x958
934:               
935:                 SetPowerSupplyTarget(&ps_hv_lambda_mode_A, ps_hv_lambda_mode_A_config_ram_copy[EEPROM_V_SET_POINT], ps_hv_lambda_mode_A_config_ram_copy[EEPROM_I_SET_POINT]);
000E00  80BC94     MOV 0x1792, W4
000E02  780284     MOV W4, W5
000E04  80BC44     MOV ps_hv_lambda_mode_A_config_ram_copy, W4
000E06  780105     MOV W5, W2
000E08  780084     MOV W4, W1
000E0A  209080     MOV #0x908, W0
000E0C  070342     RCALL SetPowerSupplyTarget
936:                 
937:               
938:               
939:                 // --- ps_hv_lambda_mode_B initialization ---
940:               
941:                 ps_hv_lambda_mode_B.warmup_ramp_time     = HV_LAMBDA_MODE_B_WARMUP_RAMP_TIME;
000E0E  EB0200     CLR W4
000E10  884DE4     MOV W4, ps_hv_lambda_mode_B
942:                 
943:                 ps_hv_lambda_mode_B.v_max_set_point      = MAX_HV_LAMBDA_MODE_B_VOLTAGE_SET_POINT;
000E12  24A384     MOV #0x4A38, W4
000E14  884E14     MOV W4, 0x9C2
944:                 
945:                 ps_hv_lambda_mode_B.v_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_VDAC_OUTPUT_AT_0xFFFF);
000E16  257151     MOV #0x5715, W1
000E18  EB8000     SETM W0
000E1A  070AA8     RCALL MakeScale
000E1C  780200     MOV W0, W4
000E1E  884E34     MOV W4, 0x9C6
946:                 ps_hv_lambda_mode_B.v_dac_cal_gain       = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000E20  80BD74     MOV 0x17AE, W4
000E22  884E44     MOV W4, 0x9C8
947:                 ps_hv_lambda_mode_B.v_dac_cal_offset     = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000E24  80BD84     MOV 0x17B0, W4
000E26  884E54     MOV W4, 0x9CA
948:                 
949:                 ps_hv_lambda_mode_B.v_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_VADC_INPUT_AT_0xFFFF);
000E28  261A81     MOV #0x61A8, W1
000E2A  EB8000     SETM W0
000E2C  070A9F     RCALL MakeScale
000E2E  780200     MOV W0, W4
000E30  884E74     MOV W4, 0x9CE
950:                 ps_hv_lambda_mode_B.v_adc_cal_gain       = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000E32  80BD94     MOV 0x17B2, W4
000E34  884E84     MOV W4, 0x9D0
951:                 ps_hv_lambda_mode_B.v_adc_cal_offset     = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000E36  80BDA4     MOV 0x17B4, W4
000E38  884E94     MOV W4, 0x9D2
952:                 ps_hv_lambda_mode_B.v_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_B_VADC_OVER_VOLTAGE_HARD, ps_hv_lambda_mode_B.v_adc_scale);
000E3A  804E74     MOV 0x9CE, W4
000E3C  780084     MOV W4, W1
000E3E  24C2C0     MOV #0x4C2C, W0
000E40  070AD0     RCALL Scale16Bit
000E42  780200     MOV W0, W4
000E44  884EA4     MOV W4, 0x9D4
953:                 ps_hv_lambda_mode_B.v_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_B_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000E46  220001     MOV #0x2000, W1
000E48  EB0000     CLR W0
000E4A  070A90     RCALL MakeScale
000E4C  780200     MOV W0, W4
000E4E  884ED4     MOV W4, 0x9DA
954:                 ps_hv_lambda_mode_B.v_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_B_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000E50  220001     MOV #0x2000, W1
000E52  EB0000     CLR W0
000E54  070A8B     RCALL MakeScale
000E56  780200     MOV W0, W4
000E58  884EE4     MOV W4, 0x9DC
955:                 ps_hv_lambda_mode_B.v_adc_over_min_value = HV_LAMBDA_MODE_B_VADC_MIN_OVER_VOLTAGE;
000E5A  EB0200     CLR W4
000E5C  884EF4     MOV W4, 0x9DE
956:                 ps_hv_lambda_mode_B.v_adc_max_oor        = HV_LAMBDA_MODE_B_VADC_MAX_OUT_OT_RANGE;
000E5E  EB0200     CLR W4
000E60  884F04     MOV W4, 0x9E0
957:                 
958:                 ps_hv_lambda_mode_B.i_max_set_point      = MAX_HV_LAMBDA_MODE_B_CURRENT_SET_POINT;
000E62  EB0200     CLR W4
000E64  884F74     MOV W4, 0x9EE
959:                 
960:                 ps_hv_lambda_mode_B.i_dac_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_IDAC_OUTPUT_AT_0xFFFF);
000E66  EB0080     CLR W1
000E68  EB8000     SETM W0
000E6A  070A80     RCALL MakeScale
000E6C  780200     MOV W0, W4
000E6E  884F94     MOV W4, 0x9F2
961:                 ps_hv_lambda_mode_B.i_dac_cal_gain       = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000E70  80BDC4     MOV 0x17B8, W4
000E72  884FA4     MOV W4, 0x9F4
962:                 ps_hv_lambda_mode_B.i_dac_cal_offset     = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000E74  80BDD4     MOV 0x17BA, W4
000E76  884FB4     MOV W4, 0x9F6
963:                 
964:                 ps_hv_lambda_mode_B.i_adc_scale          = MakeScale(0xFFFF, HV_LAMBDA_MODE_B_IADC_INPUT_AT_0xFFFF);
000E78  EB0080     CLR W1
000E7A  EB8000     SETM W0
000E7C  070A77     RCALL MakeScale
000E7E  780200     MOV W0, W4
000E80  884FD4     MOV W4, 0x9FA
965:                 ps_hv_lambda_mode_B.i_adc_cal_gain       = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000E82  80BDE4     MOV 0x17BC, W4
000E84  884FE4     MOV W4, 0x9FC
966:                 ps_hv_lambda_mode_B.i_adc_cal_offset     = ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000E86  80BDF4     MOV 0x17BE, W4
000E88  884FF4     MOV W4, 0x9FE
967:                 ps_hv_lambda_mode_B.i_adc_over_abs       = Scale16Bit(HV_LAMBDA_MODE_B_IADC_OVER_CURRENT_HARD, ps_hv_lambda_mode_B.i_adc_scale);
000E8A  804FD4     MOV 0x9FA, W4
000E8C  780084     MOV W4, W1
000E8E  EB0000     CLR W0
000E90  070AA8     RCALL Scale16Bit
000E92  780200     MOV W0, W4
000E94  885004     MOV W4, 0xA00
968:                 ps_hv_lambda_mode_B.i_adc_over_scale     = MakeScale(HV_LAMBDA_MODE_B_IADC_OVER_CURRENT_SCALE*8192, 8192);
000E96  220001     MOV #0x2000, W1
000E98  EB0000     CLR W0
000E9A  070A68     RCALL MakeScale
000E9C  780200     MOV W0, W4
000E9E  885034     MOV W4, 0xA06
969:                 ps_hv_lambda_mode_B.i_adc_under_scale    = MakeScale(HV_LAMBDA_MODE_B_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000EA0  220001     MOV #0x2000, W1
000EA2  EB0000     CLR W0
000EA4  070A63     RCALL MakeScale
000EA6  780200     MOV W0, W4
000EA8  885044     MOV W4, 0xA08
970:                 ps_hv_lambda_mode_B.i_adc_over_min_value = HV_LAMBDA_MODE_B_IADC_MIN_OVER_CURRENT;
000EAA  EB0200     CLR W4
000EAC  885054     MOV W4, 0xA0A
971:                 ps_hv_lambda_mode_B.i_adc_max_oor        = HV_LAMBDA_MODE_B_IADC_MAX_OUT_OT_RANGE;
000EAE  EB0200     CLR W4
000EB0  885064     MOV W4, 0xA0C
972:               
973:               
974:                 SetPowerSupplyTarget(&ps_hv_lambda_mode_B, ps_hv_lambda_mode_B_config_ram_copy[EEPROM_V_SET_POINT], ps_hv_lambda_mode_B_config_ram_copy[EEPROM_I_SET_POINT]);
000EB2  80BDB4     MOV 0x17B6, W4
000EB4  780284     MOV W4, W5
000EB6  80BD64     MOV ps_hv_lambda_mode_B_config_ram_copy, W4
000EB8  780105     MOV W5, W2
000EBA  780084     MOV W4, W1
000EBC  209BC0     MOV #0x9BC, W0
000EBE  0702E9     RCALL SetPowerSupplyTarget
975:                 
976:               
977:               
978:                 // --- ps_magnetron_mode_A initialization ---
979:               
980:                 ps_magnetron_mode_A.warmup_ramp_time     = MAGNETRON_MODE_A_WARMUP_RAMP_TIME;
000EC0  EB0200     CLR W4
000EC2  884B14     MOV W4, ps_magnetron_mode_A
981:                 
982:                 ps_magnetron_mode_A.v_max_set_point      = MAX_MAGNETRON_MODE_A_VOLTAGE_SET_POINT;
000EC4  2D6D84     MOV #0xD6D8, W4
000EC6  884B44     MOV W4, 0x968
983:                 
984:                 ps_magnetron_mode_A.v_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_VDAC_OUTPUT_AT_0xFFFF);
000EC8  EB0080     CLR W1
000ECA  EB8000     SETM W0
000ECC  070A4F     RCALL MakeScale
000ECE  780200     MOV W0, W4
000ED0  884B64     MOV W4, 0x96C
985:                 ps_magnetron_mode_A.v_dac_cal_gain       = ps_magnetron_mode_A_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000ED2  80BE94     MOV 0x17D2, W4
000ED4  884B74     MOV W4, 0x96E
986:                 ps_magnetron_mode_A.v_dac_cal_offset     = ps_magnetron_mode_A_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000ED6  80BEA4     MOV 0x17D4, W4
000ED8  884B84     MOV W4, 0x970
987:                 
988:                 ps_magnetron_mode_A.v_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_VADC_INPUT_AT_0xFFFF);
000EDA  2D8A11     MOV #0xD8A1, W1
000EDC  EB8000     SETM W0
000EDE  070A46     RCALL MakeScale
000EE0  780200     MOV W0, W4
000EE2  884BA4     MOV W4, 0x974
989:                 ps_magnetron_mode_A.v_adc_cal_gain       = ps_magnetron_mode_A_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000EE4  80BEB4     MOV 0x17D6, W4
000EE6  884BB4     MOV W4, 0x976
990:                 ps_magnetron_mode_A.v_adc_cal_offset     = ps_magnetron_mode_A_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000EE8  80BEC4     MOV 0x17D8, W4
000EEA  884BC4     MOV W4, 0x978
991:                 ps_magnetron_mode_A.v_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_A_VADC_OVER_VOLTAGE_HARD, ps_magnetron_mode_A.v_adc_scale);
000EEC  804BA4     MOV 0x974, W4
000EEE  780084     MOV W4, W1
000EF0  2CB200     MOV #0xCB20, W0
000EF2  070A77     RCALL Scale16Bit
000EF4  780200     MOV W0, W4
000EF6  884BD4     MOV W4, 0x97A
992:                 ps_magnetron_mode_A.v_adc_over_scale     = MakeScale(MAGNETRON_MODE_A_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000EF8  220001     MOV #0x2000, W1
000EFA  228000     MOV #0x2800, W0
000EFC  070A37     RCALL MakeScale
000EFE  780200     MOV W0, W4
000F00  884C04     MOV W4, 0x980
993:                 ps_magnetron_mode_A.v_adc_under_scale    = MakeScale(MAGNETRON_MODE_A_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000F02  220001     MOV #0x2000, W1
000F04  219990     MOV #0x1999, W0
000F06  070A32     RCALL MakeScale
000F08  780200     MOV W0, W4
000F0A  884C14     MOV W4, 0x982
994:                 ps_magnetron_mode_A.v_adc_over_min_value = MAGNETRON_MODE_A_VADC_MIN_OVER_VOLTAGE;
000F0C  203E84     MOV #0x3E8, W4
000F0E  884C24     MOV W4, 0x984
995:                 ps_magnetron_mode_A.v_adc_max_oor        = MAGNETRON_MODE_A_VADC_MAX_OUT_OT_RANGE;
000F10  200144     MOV #0x14, W4
000F12  884C34     MOV W4, 0x986
996:                 
997:                 ps_magnetron_mode_A.i_max_set_point      = MAX_MAGNETRON_MODE_A_CURRENT_SET_POINT;
000F14  22CEC4     MOV #0x2CEC, W4
000F16  884CA4     MOV W4, 0x994
998:                 
999:                 ps_magnetron_mode_A.i_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_IDAC_OUTPUT_AT_0xFFFF);
000F18  EB0080     CLR W1
000F1A  EB8000     SETM W0
000F1C  070A27     RCALL MakeScale
000F1E  780200     MOV W0, W4
000F20  884CC4     MOV W4, 0x998
1000:                ps_magnetron_mode_A.i_dac_cal_gain       = ps_magnetron_mode_A_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000F22  80BEE4     MOV 0x17DC, W4
000F24  884CD4     MOV W4, 0x99A
1001:                ps_magnetron_mode_A.i_dac_cal_offset     = ps_magnetron_mode_A_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000F26  80BEF4     MOV 0x17DE, W4
000F28  884CE4     MOV W4, 0x99C
1002:                
1003:                ps_magnetron_mode_A.i_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_A_IADC_INPUT_AT_0xFFFF);
000F2A  2411B1     MOV #0x411B, W1
000F2C  EB8000     SETM W0
000F2E  070A1E     RCALL MakeScale
000F30  780200     MOV W0, W4
000F32  884D04     MOV W4, 0x9A0
1004:                ps_magnetron_mode_A.i_adc_cal_gain       = ps_magnetron_mode_A_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000F34  80BF04     MOV 0x17E0, W4
000F36  884D14     MOV W4, 0x9A2
1005:                ps_magnetron_mode_A.i_adc_cal_offset     = ps_magnetron_mode_A_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000F38  80BF14     MOV 0x17E2, W4
000F3A  884D24     MOV W4, 0x9A4
1006:                ps_magnetron_mode_A.i_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_A_IADC_OVER_CURRENT_HARD, ps_magnetron_mode_A.i_adc_scale);
000F3C  804D04     MOV 0x9A0, W4
000F3E  780084     MOV W4, W1
000F40  230D40     MOV #0x30D4, W0
000F42  070A4F     RCALL Scale16Bit
000F44  780200     MOV W0, W4
000F46  884D34     MOV W4, 0x9A6
1007:                ps_magnetron_mode_A.i_adc_over_scale     = MakeScale(MAGNETRON_MODE_A_IADC_OVER_CURRENT_SCALE*8192, 8192);
000F48  220001     MOV #0x2000, W1
000F4A  221990     MOV #0x2199, W0
000F4C  070A0F     RCALL MakeScale
000F4E  780200     MOV W0, W4
000F50  884D64     MOV W4, 0x9AC
1008:                ps_magnetron_mode_A.i_adc_under_scale    = MakeScale(MAGNETRON_MODE_A_IADC_UNDER_CURRENT_SCALE*8192, 8192);
000F52  220001     MOV #0x2000, W1
000F54  21E660     MOV #0x1E66, W0
000F56  070A0A     RCALL MakeScale
000F58  780200     MOV W0, W4
000F5A  884D74     MOV W4, 0x9AE
1009:                ps_magnetron_mode_A.i_adc_over_min_value = MAGNETRON_MODE_A_IADC_MIN_OVER_CURRENT;
000F5C  203E84     MOV #0x3E8, W4
000F5E  884D84     MOV W4, 0x9B0
1010:                ps_magnetron_mode_A.i_adc_max_oor        = MAGNETRON_MODE_A_IADC_MAX_OUT_OT_RANGE;
000F60  200144     MOV #0x14, W4
000F62  884D94     MOV W4, 0x9B2
1011:              
1012:                ps_magnetron_mode_A.i_adc_max_reading    = 0;
000F64  EB0200     CLR W4
000F66  884DC4     MOV W4, 0x9B8
1013:                ps_magnetron_mode_A.i_adc_min_reading    = 0xFFFF;
000F68  EB8200     SETM W4
000F6A  884DD4     MOV W4, 0x9BA
1014:                ps_magnetron_mode_A.v_adc_max_reading    = 0;
000F6C  EB0200     CLR W4
000F6E  884C64     MOV W4, 0x98C
1015:                ps_magnetron_mode_A.v_adc_min_reading    = 0xFFFF;
000F70  EB8200     SETM W4
000F72  884C74     MOV W4, 0x98E
1016:              
1017:                SetPowerSupplyTarget(&ps_magnetron_mode_A, ps_magnetron_mode_A_config_ram_copy[EEPROM_V_SET_POINT], ps_magnetron_mode_A_config_ram_copy[EEPROM_I_SET_POINT]);
000F74  80BED4     MOV 0x17DA, W4
000F76  780284     MOV W4, W5
000F78  80BE84     MOV ps_magnetron_mode_A_config_ram_copy, W4
000F7A  780105     MOV W5, W2
000F7C  780084     MOV W4, W1
000F7E  209620     MOV #0x962, W0
000F80  070288     RCALL SetPowerSupplyTarget
1018:                
1019:              
1020:              
1021:                // --- ps_magnetron_mode_B initialization ---
1022:              
1023:                ps_magnetron_mode_B.warmup_ramp_time     = MAGNETRON_MODE_B_WARMUP_RAMP_TIME;
000F82  EB0200     CLR W4
000F84  8850B4     MOV W4, ps_magnetron_mode_B
1024:                
1025:                ps_magnetron_mode_B.v_max_set_point      = MAX_MAGNETRON_MODE_B_VOLTAGE_SET_POINT;
000F86  2D6D84     MOV #0xD6D8, W4
000F88  8850E4     MOV W4, 0xA1C
1026:                
1027:                ps_magnetron_mode_B.v_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_VDAC_OUTPUT_AT_0xFFFF);
000F8A  EB0080     CLR W1
000F8C  EB8000     SETM W0
000F8E  0709EE     RCALL MakeScale
000F90  780200     MOV W0, W4
000F92  885104     MOV W4, 0xA20
1028:                ps_magnetron_mode_B.v_dac_cal_gain       = ps_magnetron_mode_B_config_ram_copy[EEPROM_V_DAC_CAL_GAIN];
000F94  80BFB4     MOV 0x17F6, W4
000F96  885114     MOV W4, 0xA22
1029:                ps_magnetron_mode_B.v_dac_cal_offset     = ps_magnetron_mode_B_config_ram_copy[EEPROM_V_DAC_CAL_OFFSET]; 
000F98  80BFC4     MOV 0x17F8, W4
000F9A  885124     MOV W4, 0xA24
1030:                
1031:                ps_magnetron_mode_B.v_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_VADC_INPUT_AT_0xFFFF);
000F9C  2D8A11     MOV #0xD8A1, W1
000F9E  EB8000     SETM W0
000FA0  0709E5     RCALL MakeScale
000FA2  780200     MOV W0, W4
000FA4  885144     MOV W4, 0xA28
1032:                ps_magnetron_mode_B.v_adc_cal_gain       = ps_magnetron_mode_B_config_ram_copy[EEPROM_V_ADC_CAL_GAIN];
000FA6  80BFD4     MOV 0x17FA, W4
000FA8  885154     MOV W4, 0xA2A
1033:                ps_magnetron_mode_B.v_adc_cal_offset     = ps_magnetron_mode_B_config_ram_copy[EEPROM_V_ADC_CAL_OFFSET];
000FAA  80BFE4     MOV 0x17FC, W4
000FAC  885164     MOV W4, 0xA2C
1034:                ps_magnetron_mode_B.v_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_B_VADC_OVER_VOLTAGE_HARD, ps_magnetron_mode_B.v_adc_scale);
000FAE  805144     MOV 0xA28, W4
000FB0  780084     MOV W4, W1
000FB2  2CB200     MOV #0xCB20, W0
000FB4  070A16     RCALL Scale16Bit
000FB6  780200     MOV W0, W4
000FB8  885174     MOV W4, 0xA2E
1035:                ps_magnetron_mode_B.v_adc_over_scale     = MakeScale(MAGNETRON_MODE_B_VADC_OVER_VOLTAGE_SCALE*8192, 8192);
000FBA  220001     MOV #0x2000, W1
000FBC  228000     MOV #0x2800, W0
000FBE  0709D6     RCALL MakeScale
000FC0  780200     MOV W0, W4
000FC2  8851A4     MOV W4, 0xA34
1036:                ps_magnetron_mode_B.v_adc_under_scale    = MakeScale(MAGNETRON_MODE_B_VADC_UNDER_VOLTAGE_SCALE*8192, 8192);
000FC4  220001     MOV #0x2000, W1
000FC6  219990     MOV #0x1999, W0
000FC8  0709D1     RCALL MakeScale
000FCA  780200     MOV W0, W4
000FCC  8851B4     MOV W4, 0xA36
1037:                ps_magnetron_mode_B.v_adc_over_min_value = MAGNETRON_MODE_B_VADC_MIN_OVER_VOLTAGE;
000FCE  203E84     MOV #0x3E8, W4
000FD0  8851C4     MOV W4, 0xA38
1038:                ps_magnetron_mode_B.v_adc_max_oor        = MAGNETRON_MODE_B_VADC_MAX_OUT_OT_RANGE;
000FD2  200144     MOV #0x14, W4
000FD4  8851D4     MOV W4, 0xA3A
1039:                
1040:                ps_magnetron_mode_B.i_max_set_point      = MAX_MAGNETRON_MODE_B_CURRENT_SET_POINT;
000FD6  22CEC4     MOV #0x2CEC, W4
000FD8  885244     MOV W4, 0xA48
1041:                
1042:                ps_magnetron_mode_B.i_dac_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_IDAC_OUTPUT_AT_0xFFFF);
000FDA  EB0080     CLR W1
000FDC  EB8000     SETM W0
000FDE  0709C6     RCALL MakeScale
000FE0  780200     MOV W0, W4
000FE2  885264     MOV W4, 0xA4C
1043:                ps_magnetron_mode_B.i_dac_cal_gain       = ps_magnetron_mode_B_config_ram_copy[EEPROM_I_DAC_CAL_GAIN];
000FE4  80C004     MOV 0x1800, W4
000FE6  885274     MOV W4, 0xA4E
1044:                ps_magnetron_mode_B.i_dac_cal_offset     = ps_magnetron_mode_B_config_ram_copy[EEPROM_I_DAC_CAL_OFFSET]; 
000FE8  80C014     MOV _Do10msTicToc, W4
000FEA  885284     MOV W4, 0xA50
1045:                
1046:                ps_magnetron_mode_B.i_adc_scale          = MakeScale(0xFFFF, MAGNETRON_MODE_B_IADC_INPUT_AT_0xFFFF);
000FEC  2411B1     MOV #0x411B, W1
000FEE  EB8000     SETM W0
000FF0  0709BD     RCALL MakeScale
000FF2  780200     MOV W0, W4
000FF4  8852A4     MOV W4, 0xA54
1047:                ps_magnetron_mode_B.i_adc_cal_gain       = ps_magnetron_mode_B_config_ram_copy[EEPROM_I_ADC_CAL_GAIN];
000FF6  80C024     MOV 0x1804, W4
000FF8  8852B4     MOV W4, 0xA56
1048:                ps_magnetron_mode_B.i_adc_cal_offset     = ps_magnetron_mode_B_config_ram_copy[EEPROM_I_ADC_CAL_OFFSET];
000FFA  80C034     MOV 0x1806, W4
000FFC  8852C4     MOV W4, 0xA58
1049:                ps_magnetron_mode_B.i_adc_over_abs       = Scale16Bit(MAGNETRON_MODE_B_IADC_OVER_CURRENT_HARD, ps_magnetron_mode_B.i_adc_scale);
000FFE  8052A4     MOV 0xA54, W4
001000  780084     MOV W4, W1
001002  230D40     MOV #0x30D4, W0
001004  0709EE     RCALL Scale16Bit
001006  780200     MOV W0, W4
001008  8852D4     MOV W4, 0xA5A
1050:                ps_magnetron_mode_B.i_adc_over_scale     = MakeScale(MAGNETRON_MODE_B_IADC_OVER_CURRENT_SCALE*8192, 8192);
00100A  220001     MOV #0x2000, W1
00100C  221990     MOV #0x2199, W0
00100E  0709AE     RCALL MakeScale
001010  780200     MOV W0, W4
001012  885304     MOV W4, 0xA60
1051:                ps_magnetron_mode_B.i_adc_under_scale    = MakeScale(MAGNETRON_MODE_B_IADC_UNDER_CURRENT_SCALE*8192, 8192);
001014  220001     MOV #0x2000, W1
001016  21E660     MOV #0x1E66, W0
001018  0709A9     RCALL MakeScale
00101A  780200     MOV W0, W4
00101C  885314     MOV W4, 0xA62
1052:                ps_magnetron_mode_B.i_adc_over_min_value = MAGNETRON_MODE_B_IADC_MIN_OVER_CURRENT;
00101E  203E84     MOV #0x3E8, W4
001020  885324     MOV W4, 0xA64
1053:                ps_magnetron_mode_B.i_adc_max_oor        = MAGNETRON_MODE_B_IADC_MAX_OUT_OT_RANGE;
001022  200144     MOV #0x14, W4
001024  885334     MOV W4, 0xA66
1054:              
1055:                ps_magnetron_mode_B.i_adc_max_reading    = 0;
001026  EB0200     CLR W4
001028  885364     MOV W4, 0xA6C
1056:                ps_magnetron_mode_B.i_adc_min_reading    = 0xFFFF;
00102A  EB8200     SETM W4
00102C  885374     MOV W4, 0xA6E
1057:                ps_magnetron_mode_B.v_adc_max_reading    = 0;
00102E  EB0200     CLR W4
001030  885204     MOV W4, 0xA40
1058:                ps_magnetron_mode_B.v_adc_min_reading    = 0xFFFF;
001032  EB8200     SETM W4
001034  885214     MOV W4, 0xA42
1059:              
1060:                SetPowerSupplyTarget(&ps_magnetron_mode_B, ps_magnetron_mode_B_config_ram_copy[EEPROM_V_SET_POINT], ps_magnetron_mode_B_config_ram_copy[EEPROM_I_SET_POINT]);
001036  80BFF4     MOV 0x17FE, W4
001038  780284     MOV W4, W5
00103A  80BFA4     MOV ps_magnetron_mode_B_config_ram_copy, W4
00103C  780105     MOV W5, W2
00103E  780084     MOV W4, W1
001040  20A160     MOV #0xA16, W0
001042  070227     RCALL SetPowerSupplyTarget
1061:                
1062:              
1063:              
1064:                PIN_UART2_TX = !PIN_UART2_TX;
001044  801655     MOV LATB, W5
001046  200404     MOV #0x40, W4
001048  628204     AND W5, W4, W4
00104A  A7F004     BTSC W4, #15
00104C  EA0204     NEG W4, W4
00104E  E90204     DEC W4, W4
001050  DE224F     LSR W4, #15, W4
001052  784204     MOV.B W4, W4
001054  FB8204     ZE W4, W4
001056  620261     AND W4, #0x1, W4
001058  DD2246     SL W4, #6, W4
00105A  801656     MOV LATB, W6
00105C  2FFBF5     MOV #0xFFBF, W5
00105E  630285     AND W6, W5, W5
001060  728204     IOR W5, W4, W4
001062  881654     MOV W4, LATB
1065:              
1066:                // --------- BEGIN IO PIN CONFIGURATION ------------------
1067:                
1068:                
1069:                // Initialize Ouput Pin Latches BEFORE setting the pins to Output
1070:                PIN_HV_LAMBDA_ENABLE = !OLL_HV_LAMBDA_ENABLED;
001064  A962D7     BCLR 0x2D7, #3
1071:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;
001066  A802D6     BSET LATD, #0
1072:              
1073:                //PIN_MAGNETRON_MAGNET_ENABLE = !OLL_MAGNETRON_MAGNET_ENABLED;
1074:                PIN_MAGNETRON_MAGNET_SO = OLL_MAGNETRON_MAGNET_OUTPUT_SHUT_OFF;
001068  A942D7     BCLR 0x2D7, #2
1075:                PIN_MAGNETRON_FILAMENT_ENABLE = !OLL_MAGNETRON_FILAMENT_ENABLED;
00106A  A902D7     BCLR 0x2D7, #0
1076:                
1077:                PIN_SUM_FAULT_FIBER = !OLL_SUM_FAULT_FIBER_FAULT;
00106C  A8E2C4     BSET LATA, #7
1078:                //DPARKER PIN REPURPOSED PIN_UART2_TX = !OLL_SPARE_OPTICAL_OUT_LIGHT_ON;
1079:                PIN_UART2_TX = !OLL_PIN_UART2_TX_LIGHT_ON;
00106E  A9C2CA     BCLR LATB, #6
1080:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;
001070  A8E2CB     BSET 0x2CB, #7
1081:              
1082:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
001072  A9C2C4     BCLR LATA, #6
1083:                PIN_SUM_FAULT_COPPER = !OLL_SUM_FAULT_COPPER_FAULT;
001074  A842D0     BSET LATC, #2
1084:                PIN_LATCH_RESET = !OLL_RESET_LATCH;
001076  A862D6     BSET LATD, #3
1085:                PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
001078  A8A2E2     BSET LATF, #5
1086:                PIN_MAIN_CONTACTOR_CLOSE = !OLL_MAIN_CONTACTOR_CLOSED;
00107A  A9E2CA     BCLR LATB, #7
1087:                PIN_SAMPLE_PFN_IREV = !OLL_SAMPLE_PFN_IREV_TRIGGER;
00107C  A942CA     BCLR LATB, #2
1088:                PIN_RS422_DE = OLL_RS422_DE_ENABLE_RS422_DRIVER;
00107E  A882E2     BSET LATF, #4
1089:                // DPARKER PIN_MCU_CLOCK_OUT_TEST_POINT = 0;
1090:                PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
001080  A9C2CB     BCLR 0x2CB, #6
1091:              
1092:              
1093:                // External 16 bit ADC control pins
1094:                PIN_PULSE_IMON_CS = !OLL_SELECT_PULSE_IMON_ADC;
001082  A8C2D6     BSET LATD, #6
1095:                PIN_PULSE_VMON_CS = !OLL_SELECT_PULSE_VMON_ADC;
001084  A8A2D6     BSET LATD, #5
1096:                PIN_PULSE_ADC_TRIGGER = !OLL_TRIGGER_PULSE_ADCS;
001086  A922C5     BCLR 0x2C5, #1
1097:              
1098:                
1099:                // HV Lambda IO Pins
1100:                TRIS_PIN_HV_LAMBDA_ENABLE = TRIS_OUTPUT_MODE;
001088  A962D3     BCLR 0x2D3, #3
1101:                TRIS_PIN_HV_LAMBDA_INHIBIT = TRIS_OUTPUT_MODE;
00108A  A902D2     BCLR TRISD, #0
1102:              
1103:                TRIS_PIN_HV_LAMBDA_EOC_INPUT = TRIS_INPUT_MODE;
00108C  A842D2     BSET TRISD, #2
1104:                TRIS_PIN_HV_LAMBDA_SUM_FAULT = TRIS_INPUT_MODE;
00108E  A8C2CD     BSET 0x2CD, #6
1105:                TRIS_PIN_HV_LAMBDA_HV_ON_READBACK = TRIS_INPUT_MODE;
001090  A8A2CD     BSET 0x2CD, #5
1106:                TRIS_PIN_HV_LAMBDA_POWER_UP = TRIS_INPUT_MODE;
001092  A822D2     BSET TRISD, #1
1107:                
1108:              
1109:                // Magnetron Filament/Magnet Supply
1110:                TRIS_PIN_MAGNETRON_MAGNET_ENABLE = TRIS_OUTPUT_MODE;
001094  A922D3     BCLR 0x2D3, #1
1111:                TRIS_PIN_MAGNETRON_MAGNET_SO = TRIS_OUTPUT_MODE;
001096  A942D3     BCLR 0x2D3, #2
1112:                TRIS_PIN_MAGNETRON_FILAMENT_ENABLE = TRIS_OUTPUT_MODE;
001098  A902D3     BCLR 0x2D3, #0
1113:              
1114:              
1115:                // Optical Input Pins
1116:                TRIS_PIN_MODULATOR_DRIVE_INPUT = TRIS_INPUT_MODE;
00109A  A882C1     BSET 0x2C1, #4
1117:                TRIS_PIN_A_B_MODE_SELECT = TRIS_INPUT_MODE;
00109C  A8A2C1     BSET 0x2C1, #5
1118:              
1119:                // Optical Output PIns
1120:                TRIS_PIN_SUM_FAULT_FIBER = TRIS_OUTPUT_MODE;
00109E  A9E2C0     BCLR TRISA, #7
1121:                //DPARKER PIN REPURPOSED TRIS_PIN_SPARE_OPTICAL_OUT = TRIS_OUTPUT_MODE;
1122:                TRIS_PIN_UART2_TX = TRIS_OUTPUT_MODE;
0010A0  A9C2C6     BCLR TRISB, #6
1123:                TRIS_PIN_FAST_RESTART_STORAGE_CAP = TRIS_OUTPUT_MODE;
0010A2  A9E2C7     BCLR 0x2C7, #7
1124:              
1125:              
1126:                // Digital Control Input Pins
1127:                TRIS_FP_PIN_MODULATOR_ENABLE_INPUT = TRIS_INPUT_MODE;
0010A4  A8C2C1     BSET 0x2C1, #6
1128:                TRIS_FP_PIN_MODULATOR_HV_ON_INPUT = TRIS_INPUT_MODE;
0010A6  A8E2C1     BSET 0x2C1, #7
1129:                TRIS_FP_PIN_MODULATOR_RESET = TRIS_INPUT_MODE;
0010A8  A8A2E5     BSET 0x2E5, #5
1130:                TRIS_FP_PIN_FAST_RESTART = TRIS_INPUT_MODE;
0010AA  A882E5     BSET 0x2E5, #4
1131:                TRIS_FP_PIN_SPARE_2_SAMPLE_VPROG_INPUT = TRIS_INPUT_MODE;
0010AC  A8C2E5     BSET 0x2E5, #6
1132:                TRIS_PIN_GANTRY_PORTAL_SELECT = TRIS_INPUT_MODE;
0010AE  A8E2E5     BSET 0x2E5, #7
1133:              
1134:              
1135:                // Analog Compartor/Latch Input Pins
1136:                TRIS_PIN_PULSE_OVER_CUR_LATCH = TRIS_INPUT_MODE;
0010B0  A882D2     BSET TRISD, #4
1137:                TRIS_PIN_PULSE_MIN_CUR_LATCH = TRIS_INPUT_MODE;
0010B2  A8E2D2     BSET TRISD, #7
1138:                TRIS_PIN_MAGNET_CURRENT_OOR_LATCH = TRIS_INPUT_MODE;
0010B4  A882D3     BSET 0x2D3, #4
1139:                TRIS_PIN_FILAMENT_OV_LATCH = TRIS_INPUT_MODE;
0010B6  A8A2D3     BSET 0x2D3, #5
1140:                
1141:                // Interlock Inputs
1142:                TRIS_PIN_INTERLOCK_1 = TRIS_INPUT_MODE;
0010B8  A862CC     BSET TRISC, #3
1143:                TRIS_PIN_INTERLOCK_2 = TRIS_INPUT_MODE;
0010BA  A882CC     BSET TRISC, #4
1144:                TRIS_PIN_INTERLOCK_3 = TRIS_INPUT_MODE;
0010BC  A802E5     BSET 0x2E5, #0
1145:                TRIS_PIN_INTERLOCK_4 = TRIS_INPUT_MODE;
0010BE  A822E5     BSET 0x2E5, #1
1146:                TRIS_PIN_4_20_DRVR_FLT = TRIS_INPUT_MODE;
0010C0  A842C1     BSET 0x2C1, #2
1147:              
1148:                // Digital Output Pins
1149:                TRIS_PIN_THYRATRON_TRIGGER_ENABLE = TRIS_OUTPUT_MODE;
0010C2  A9C2C0     BCLR TRISA, #6
1150:                TRIS_PIN_SUM_FAULT_COPPER = TRIS_OUTPUT_MODE;
0010C4  A942CC     BCLR TRISC, #2
1151:                TRIS_PIN_LATCH_RESET = TRIS_OUTPUT_MODE;
0010C6  A962D2     BCLR TRISD, #3
1152:                TRIS_PIN_PULSE_LATCH_RESET = TRIS_OUTPUT_MODE;
0010C8  A9A2DE     BCLR TRISF, #5
1153:                TRIS_PIN_MAIN_CONTACTOR_CLOSE = TRIS_OUTPUT_MODE;
0010CA  A9E2C6     BCLR TRISB, #7
1154:                TRIS_PIN_SAMPLE_PFN_IREV = TRIS_OUTPUT_MODE;
0010CC  A942C6     BCLR TRISB, #2
1155:                TRIS_PIN_RS422_DE = TRIS_OUTPUT_MODE;
0010CE  A982DE     BCLR TRISF, #4
1156:                TRIS_PIN_MCU_CLOCK_OUT_TEST_POINT = TRIS_OUTPUT_MODE;
0010D0  A9E2CD     BCLR 0x2CD, #7
1157:                TRIS_PIN_LAMBDA_VOLTAGE_SELECT = TRIS_OUTPUT_MODE;
0010D2  A9C2C7     BCLR 0x2C7, #6
1158:                TRIS_PIN_PULSE_IMON_CS = TRIS_OUTPUT_MODE;
0010D4  A9C2D2     BCLR TRISD, #6
1159:                TRIS_PIN_PULSE_VMON_CS = TRIS_OUTPUT_MODE;
0010D6  A9A2D2     BCLR TRISD, #5
1160:                TRIS_PIN_PULSE_ADC_TRIGGER = TRIS_OUTPUT_MODE;
0010D8  A922C1     BCLR 0x2C1, #1
1161:              
1162:              
1163:              
1164:                // ----------- Configure Interupts -------------- //
1165:              
1166:              
1167:                // Configure INT1 Interrupt
1168:                _INT1IE = 0; // Disable Interrupt
0010DA  A9008E     BCLR IEC1, #0
1169:                _INT1IF = 0; // Clear Interrupt Flag  
0010DC  A90086     BCLR IFS1, #0
1170:                _INT1IP = 6; // Highest Priority
0010DE  8004E4     MOV IPC4, W4
0010E0  A10004     BCLR W4, #0
0010E2  A01004     BSET W4, #1
0010E4  A02004     BSET W4, #2
0010E6  8804E4     MOV W4, IPC4
1171:                _INT1EP = 0; // Positive Transition Trigger
0010E8  A92082     BCLR INTCON2, #1
1172:              
1173:                // Configure T1 Interrupt
1174:                _T1IE = 0;  // Disable Interrupt
0010EA  A9608C     BCLR IEC0, #3
1175:                _T1IF = 0;  // Clear Interrupt Flag  
0010EC  A96084     BCLR IFS0, #3
1176:                _T1IP = 5;  // Lower Priority than INT1, Higher than everything else  
0010EE  8004A4     MOV IPC0, W4
0010F0  A0C004     BSET W4, #12
0010F2  A1D004     BCLR W4, #13
0010F4  A0E004     BSET W4, #14
0010F6  8804A4     MOV W4, IPC0
1177:              
1178:                // Configure ADC Interrupt
1179:                _ADIE = 0;
0010F8  A9608D     BCLR 0x8D, #3
1180:                _ADIF = 0;
0010FA  A96085     BCLR 0x85, #3
1181:                _ADIP = 3;
0010FC  8004C4     MOV IPC2, W4
0010FE  A0C004     BSET W4, #12
001100  A0D004     BSET W4, #13
001102  A1E004     BCLR W4, #14
001104  8804C4     MOV W4, IPC2
1182:              
1183:              
1184:                // Configure Change Notification Interrupt
1185:                _CNIF = 0;
001106  A9E085     BCLR 0x85, #7
1186:                _CN16IE = 1;  // Allow Change notification on CN16 (PULSE MINIMUM CURRENT LATCH)
001108  A800C2     BSET CNEN2, #0
1187:                _CNIE = 1;
00110A  A8E08D     BSET 0x8D, #7
1188:                _CNIP = 4;
00110C  8004D4     MOV IPC3, W4
00110E  A1C004     BCLR W4, #12
001110  A1D004     BCLR W4, #13
001112  A0E004     BSET W4, #14
001114  8804D4     MOV W4, IPC3
1189:                
1190:              
1191:              
1192:                // Configure UART Interrupts
1193:                _U1RXIE = 0;
001116  A9208D     BCLR 0x8D, #1
1194:                _U1RXIP = 5;
001118  8004C4     MOV IPC2, W4
00111A  A04004     BSET W4, #4
00111C  A15004     BCLR W4, #5
00111E  A06004     BSET W4, #6
001120  8804C4     MOV W4, IPC2
1195:                
1196:                _U1TXIE = 0;
001122  A9408D     BCLR 0x8D, #2
1197:                _U1RXIP = 5;
001124  8004C4     MOV IPC2, W4
001126  A04004     BSET W4, #4
001128  A15004     BCLR W4, #5
00112A  A06004     BSET W4, #6
00112C  8804C4     MOV W4, IPC2
1198:              
1199:              
1200:                // Configure LVD Interrupt
1201:                _LVDIF = 0;
00112E  A94089     BCLR 0x89, #2
1202:                _LVDIE = 0;
001130  A94091     BCLR 0x91, #2
1203:                _LVDIP = 7;
001132  800544     MOV IPC10, W4
001134  A08004     BSET W4, #8
001136  A09004     BSET W4, #9
001138  A0A004     BSET W4, #10
00113A  880544     MOV W4, IPC10
1204:                _LVDL = 0b1100;  //DPARKER LVDL should trigger at 4.1 Volts
00113C  803A04     MOV RCON, W4
00113E  A18004     BCLR W4, #8
001140  A19004     BCLR W4, #9
001142  A0A004     BSET W4, #10
001144  A0B004     BSET W4, #11
001146  883A04     MOV W4, RCON
1205:              
1206:                
1207:              
1208:                // --------- CONFIGURATION FOR THE I2C BUS ---------------- //
1209:                I2CCON = I2CCON_SETUP;
001148  2F00F4     MOV #0xF00F, W4
00114A  881034     MOV W4, I2CCON
1210:                I2CBRG = I2C_BAUD_RATE_GENERATOR;  // Configure I2C bus based on H file parameters
00114C  200614     MOV #0x61, W4
00114E  881024     MOV W4, I2CBRG
1211:              
1212:              
1213:              
1214:                // --------- CONFIGURATION FOR THE SPI BUSSES ---------------- //
1215:                OpenSPI1((A34760_SPI1CON_VALUE & A34760_SPI1CON_CLOCK), A34760_SPI1STAT_VALUE);  // Configure SPI bus 1 based on H file parameters
001150  2DFBF1     MOV #0xDFBF, W1
001152  2B53B0     MOV #0xB53B, W0
001154  07F858     RCALL _OpenSPI1
1216:                OpenSPI2((A34760_SPI2CON_VALUE & A34760_SPI2CON_CLOCK), A34760_SPI2STAT_VALUE);  // Configure SPI bus 2 based on H file parameters
001156  2DFBF1     MOV #0xDFBF, W1
001158  2BF3A0     MOV #0xBF3A, W0
00115A  07F858     RCALL _OpenSPI2
1217:                
1218:              
1219:                // ------ CONFIGURE the CAN Modules to be OFF -------------- //
1220:                C1CTRL = 0b0000000100000000;
00115C  201004     MOV #0x100, W4
00115E  881C84     MOV W4, C1CTRL
1221:                C2CTRL = 0b0000000100000000;
001160  201004     MOV #0x100, W4
001162  882284     MOV W4, C2CTRL
1222:                
1223:              
1224:                // ----------------- UART #1 Setup and Data Buffer -------------------------//
1225:                // Setup the UART input and output buffers
1226:                uart1_input_buffer.write_location = 0;  
001164  EB4200     CLR.B W4
001166  784004     MOV.B W4, W0
001168  B7E8AC     MOV.B WREG, 0x8AC
1227:                uart1_input_buffer.read_location = 0;
00116A  EB4200     CLR.B W4
00116C  784004     MOV.B W4, W0
00116E  B7E8AD     MOV.B WREG, 0x8AD
1228:                uart1_output_buffer.write_location = 0;
001170  EB4200     CLR.B W4
001172  784004     MOV.B W4, W0
001174  B7E8EE     MOV.B WREG, 0x8EE
1229:                uart1_output_buffer.read_location = 0;
001176  EB4200     CLR.B W4
001178  784004     MOV.B W4, W0
00117A  B7E8EF     MOV.B WREG, 0x8EF
1230:              
1231:                U1MODE = A34760_U1MODE_VALUE;
00117C  2FF004     MOV #0xFF00, W4
00117E  881064     MOV W4, U1MODE
1232:                U1BRG = A34760_U1BRG_VALUE;
001180  200044     MOV #0x4, W4
001182  8810A4     MOV W4, U1BRG
1233:                U1STA = A34760_U1STA_VALUE;
001184  2775F4     MOV #0x775F, W4
001186  881074     MOV W4, U1STA
1234:                
1235:              
1236:              
1237:               // ---------- Configure Timers ----------------- //
1238:              
1239:              
1240:                // Configure TMR1
1241:                T1CON = A34760_T1CON_VALUE;
001188  25FAD4     MOV #0x5FAD, W4
00118A  880824     MOV W4, T1CON
1242:              
1243:              
1244:                // Configure TMR2
1245:                T2CON = A34760_T2CON_VALUE;
00118C  25FA54     MOV #0x5FA5, W4
00118E  880884     MOV W4, T2CON
1246:                PR2 = A34760_PR2_VALUE;  
001190  23D094     MOV #0x3D09, W4
001192  880864     MOV W4, PR2
1247:                TMR2 = 0;
001194  EB0200     CLR W4
001196  880834     MOV W4, TMR2
1248:                _T2IF = 0;
001198  A9C084     BCLR IFS0, #6
1249:              
1250:                
1251:                // Configure TMR3
1252:                // Setup Timer 3 to measure interpulse period.
1253:                T3CON = (T3_ON & T3_IDLE_CON & T3_GATE_OFF & T3_PS_1_64 & T3_SOURCE_INT);
00119A  2DFAD4     MOV #0xDFAD, W4
00119C  880894     MOV W4, T3CON
1254:                PR3 = 62500;  // 400mS
00119E  2F4244     MOV #0xF424, W4
0011A0  880874     MOV W4, PR3
1255:              
1256:              
1257:                // Configure TMR4
1258:                T4CON = A34760_T4CON_VALUE;
0011A2  25F854     MOV #0x5F85, W4
0011A4  8808F4     MOV W4, T4CON
1259:              
1260:              
1261:                // Configure TMR5
1262:                T5CON = A34760_T5CON_VALUE;
0011A6  25F9D4     MOV #0x5F9D, W4
0011A8  880904     MOV W4, T5CON
1263:                TMR5 = 0;
0011AA  EB0200     CLR W4
0011AC  8808C4     MOV W4, TMR5
1264:                _T5IF = 0;
0011AE  A9C086     BCLR IFS1, #6
1265:                PR5 = A34760_PR5_VALUE; 
0011B0  230D44     MOV #0x30D4, W4
0011B2  8808E4     MOV W4, PR5
1266:              
1267:              
1268:              
1269:              
1270:              
1271:                // --------------- Initialize U44 - LTC2656 ------------------------- //
1272:                U44_LTC2656.pin_cable_select = _PIN_RD15;
0011B4  200DF4     MOV #0xDF, W4
0011B6  884784     MOV W4, U44_LTC2656
1273:                U44_LTC2656.pin_load_dac = _PIN_RD14;
0011B8  200DE4     MOV #0xDE, W4
0011BA  8847A4     MOV W4, 0x8F4
1274:                U44_LTC2656.pin_por_select = _PIN_NOT_CONNECTED;
0011BC  200204     MOV #0x20, W4
0011BE  8847B4     MOV W4, 0x8F6
1275:                U44_LTC2656.por_select_value = 0;
0011C0  EB0200     CLR W4
0011C2  8847C4     MOV W4, 0x8F8
1276:                U44_LTC2656.spi_port = SPI_PORT_1;
0011C4  B3C014     MOV.B #0x1, W4
0011C6  784004     MOV.B W4, W0
0011C8  B7E8FA     MOV.B WREG, 0x8FA
1277:              #ifndef __A36760
1278:                U44_LTC2656.pin_dac_clear = _PIN_RB15;
1279:              #else
1280:                U44_LTC2656.pin_dac_clear = _PIN_NOT_CONNECTED;
0011CA  200204     MOV #0x20, W4
0011CC  884794     MOV W4, 0x8F2
1281:              #endif
1282:              
1283:              
1284:                SetupLTC2656(&U44_LTC2656);
0011CE  208F00     MOV #0x8F0, W0
0011D0  0719B9     RCALL SetupLTC2656
1285:                
1286:              
1287:                // ---------------- Initialize U64 - MCP23017 ----------------//
1288:              
1289:                U64_MCP23017.address = MCP23017_ADDRESS_0;
0011D2  B3C404     MOV.B #0x40, W4
0011D4  784004     MOV.B W4, W0
0011D6  B7E902     MOV.B WREG, 0x902
1290:                U64_MCP23017.i2c_port = I2C_PORT;
0011D8  EB4200     CLR.B W4
0011DA  784004     MOV.B W4, W0
0011DC  B7E903     MOV.B WREG, 0x903
1291:                U64_MCP23017.pin_reset = _PIN_NOT_CONNECTED;
0011DE  200204     MOV #0x20, W4
0011E0  8847E4     MOV W4, U64_MCP23017
1292:                U64_MCP23017.pin_int_a = _PIN_NOT_CONNECTED;
0011E2  200204     MOV #0x20, W4
0011E4  8847F4     MOV W4, 0x8FE
1293:                U64_MCP23017.pin_int_b = _PIN_NOT_CONNECTED;
0011E6  200204     MOV #0x20, W4
0011E8  884804     MOV W4, 0x900
1294:                U64_MCP23017.output_latch_a_in_ram = MCP23017_U64_LATA_INITIAL;
0011EA  EBC200     SETM.B W4
0011EC  784004     MOV.B W4, W0
0011EE  B7E904     MOV.B WREG, 0x904
1295:                U64_MCP23017.output_latch_b_in_ram = MCP23017_U64_LATB_INITIAL;
0011F0  EBC200     SETM.B W4
0011F2  784004     MOV.B W4, W0
0011F4  B7E905     MOV.B WREG, 0x905
1296:              
1297:              
1298:                ResetAllFaults();
0011F6  071675     RCALL ResetAllFaults
1299:              
1300:              
1301:                // DPARKER - At some point want to recover the pulse and arc counter from RAM
1302:                // ------------ Load the pulse and arc counters ---------------- //
1303:                unsigned_int_ptr = &pulse_counter_persistent;              //unsigned_int_ptr now points to the Least Significant word of pulse_counter_persistent
0011F8  218BC4     MOV #0x18BC, W4
0011FA  780F04     MOV W4, [W14]
1304:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[3];
0011FC  80C0F4     MOV 0x181E, W4
0011FE  780284     MOV W4, W5
001200  78021E     MOV [W14], W4
001202  780A05     MOV W5, [W4]
1305:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
001204  E88F1E     INC2 [W14], [W14]
1306:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[2];
001206  80C0E4     MOV 0x181C, W4
001208  780284     MOV W4, W5
00120A  78021E     MOV [W14], W4
00120C  780A05     MOV W5, [W4]
1307:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
00120E  E88F1E     INC2 [W14], [W14]
1308:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[1];
001210  80C0D4     MOV 0x181A, W4
001212  780284     MOV W4, W5
001214  78021E     MOV [W14], W4
001216  780A05     MOV W5, [W4]
1309:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of pulse_counter_persistent
001218  E88F1E     INC2 [W14], [W14]
1310:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[0];
00121A  80C0C4     MOV pulse_counter_repository_ram_copy, W4
00121C  780284     MOV W4, W5
00121E  78021E     MOV [W14], W4
001220  780A05     MOV W5, [W4]
1311:              
1312:              
1313:                unsigned_int_ptr = &arc_counter_persistent;                //unsigned_int_ptr now points to the Least Significant word of arc_counter_persistent
001222  218CA4     MOV #0x18CA, W4
001224  780F04     MOV W4, [W14]
1314:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[5];
001226  80C114     MOV 0x1822, W4
001228  780284     MOV W4, W5
00122A  78021E     MOV [W14], W4
00122C  780A05     MOV W5, [W4]
1315:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of arc_counter_persistent
00122E  E88F1E     INC2 [W14], [W14]
1316:                *unsigned_int_ptr = pulse_counter_repository_ram_copy[4];
001230  80C104     MOV 0x1820, W4
001232  780284     MOV W4, W5
001234  78021E     MOV [W14], W4
001236  780A05     MOV W5, [W4]
1317:                
1318:                arc_counter_this_hv_on = 0;
001238  EB0200     CLR W4
00123A  88C6E4     MOV W4, arc_counter_this_hv_on
1319:                pulse_counter_this_hv_on = 0;
00123C  B82260     MUL.UU W4, #0, W4
00123E  88C674     MOV W4, pulse_counter_this_hv_on
001240  88C685     MOV W5, 0x18D0
1320:               
1321:                fast_reset_counter_persistent = pulse_counter_repository_ram_copy[6];
001242  80C124     MOV 0x1824, W4
001244  884234     MOV W4, fast_reset_counter_persistent
1322:                
1323:                /*
1324:                  Check to See if this was a faulty processor Reset.
1325:                  If it was a faulty processor Reset, the following must occur
1326:                  * Durring warmup, if the Fast Restart Pin is set, the warmup will be truncated to 2 seconds
1327:                  
1328:                  * Read persistent RAM values and save to EEPROM as nessesary
1329:                  1) When the processor restarts, copy the persistent counters to a new RAM locations
1330:                  2) Load values from EEPROM
1331:                  3) The following statement *should* be true
1332:                  4) pulse_counter_persistent(from_before_arc) = pulse_counter_persistent(stored_in_EEPROM) + pulse_counter_this_hv_on(from_before_arc)
1333:                  4a) If that math works out, save the pulse information.  If that math does not work out, throw away pre-arc data and just reload from EEPROM
1334:                */
1335:                /*
1336:                pulse_counter_persistent_store = pulse_counter_persistent;
1337:                pulse_counter_this_hv_on_store = pulse_counter_this_hv_on;
1338:                arc_counter_persistent_store = arc_counter_persistent;
1339:                arc_counter_this_hv_on_store = arc_counter_this_hv_on;
1340:              
1341:              
1342:                if (PIN_FP_FAST_RESTART == ILL_FAST_RESTART) {
1343:                  if (pulse_counter_persistent_store > 5) {
1344:                    pulse_counter_persistent_store -= 5;
1345:                  }
1346:                  if ((pulse_counter_persistent + pulse_counter_this_hv_on_store) > pulse_counter_persistent_store) {
1347:                    if ((pulse_counter_persistent + pulse_counter_this_hv_on_store) < (pulse_counter_persistent_store + 10)) {
1348:              	pulse_counter_persistent = pulse_counter_persistent_store + 5;
1349:                    }
1350:                  }
1351:                  
1352:                  if (arc_counter_persistent_store > 5) {
1353:                    arc_counter_persistent_store -= 5;
1354:                  }
1355:                  if ((arc_counter_persistent + arc_counter_this_hv_on_store) > arc_counter_persistent_store) {
1356:                    if ((arc_counter_persistent + arc_counter_this_hv_on_store) < (arc_counter_persistent_store + 10)) {
1357:              	arc_counter_persistent = arc_counter_persistent_store + 5;
1358:                    }
1359:                  }
1360:                  
1361:                  SavePulseCountersToEEPROM();
1362:                  }
1363:                */   
1364:              
1365:              
1366:               
1367:              }
001246  FA8000     ULNK
001248  060000     RETURN
1368:              
1369:              
1370:              
1371:              void DoA34760StartUpNormalProcess(void) {
00124A  FA0002     LNK #0x2
1372:                unsigned int i2c_test = 0;
00124C  EB0200     CLR W4
00124E  780F04     MOV W4, [W14]
1373:              
1374:                // This was a not a reset from a fast crash so clear the reset data
1375:                debug_status_register = 0;
001250  EB0200     CLR W4
001252  88C394     MOV W4, debug_status_register
1376:                _POR = 0;
001254  A90740     BCLR RCON, #0
1377:                _EXTR = 0;
001256  A9E740     BCLR RCON, #7
1378:                _SWR = 0;
001258  A9C740     BCLR RCON, #6
1379:                _BOR = 0;
00125A  A92740     BCLR RCON, #1
1380:                _TRAPR = 0;
00125C  A9E741     BCLR 0x741, #7
1381:                _WDTO = 0;
00125E  A98740     BCLR RCON, #4
1382:                _IOPUWR = 0;
001260  A9C741     BCLR 0x741, #6
1383:                last_known_action = LAST_ACTION_CLEAR_LAST_ACTION;
001262  EB0200     CLR W4
001264  88C6B4     MOV W4, last_known_action
1384:                processor_crash_count = 0;
001266  EB0200     CLR W4
001268  88C6D4     MOV W4, processor_crash_count
1385:                
1386:                ClearOutputsLTC2656(&U44_LTC2656);
00126A  208F00     MOV #0x8F0, W0
00126C  0719A2     RCALL ClearOutputsLTC2656
1387:                
1388:                // Test U64 - MCP23017
1389:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
00126E  EB4100     CLR.B W2
001270  B3C0A1     MOV.B #0xA, W1
001272  208FC0     MOV #0x8FC, W0
001274  071E6A     RCALL MCP23017WriteSingleByte
001276  780200     MOV W0, W4
001278  720F1E     IOR W4, [W14], [W14]
1390:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
00127A  EB4100     CLR.B W2
00127C  B3C0A1     MOV.B #0xA, W1
00127E  208FC0     MOV #0x8FC, W0
001280  071E64     RCALL MCP23017WriteSingleByte
001282  780200     MOV W0, W4
001284  720F1E     IOR W4, [W14], [W14]
1391:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IOCON, MCP23017_DEFAULT_IOCON);
001286  EB4100     CLR.B W2
001288  B3C0A1     MOV.B #0xA, W1
00128A  208FC0     MOV #0x8FC, W0
00128C  071E5E     RCALL MCP23017WriteSingleByte
00128E  780200     MOV W0, W4
001290  720F1E     IOR W4, [W14], [W14]
1392:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATA, U64_MCP23017.output_latch_a_in_ram);
001292  209044     MOV #0x904, W4
001294  784214     MOV.B [W4], W4
001296  784104     MOV.B W4, W2
001298  B3C141     MOV.B #0x14, W1
00129A  208FC0     MOV #0x8FC, W0
00129C  071E56     RCALL MCP23017WriteSingleByte
00129E  780200     MOV W0, W4
0012A0  720F1E     IOR W4, [W14], [W14]
1393:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATB, U64_MCP23017.output_latch_b_in_ram);
0012A2  209054     MOV #0x905, W4
0012A4  784214     MOV.B [W4], W4
0012A6  784104     MOV.B W4, W2
0012A8  B3C151     MOV.B #0x15, W1
0012AA  208FC0     MOV #0x8FC, W0
0012AC  071E4E     RCALL MCP23017WriteSingleByte
0012AE  780200     MOV W0, W4
0012B0  720F1E     IOR W4, [W14], [W14]
1394:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRA, MCP23017_U64_IODIRA_VALUE);
0012B2  B3CF82     MOV.B #0xF8, W2
0012B4  EB4080     CLR.B W1
0012B6  208FC0     MOV #0x8FC, W0
0012B8  071E48     RCALL MCP23017WriteSingleByte
0012BA  780200     MOV W0, W4
0012BC  720F1E     IOR W4, [W14], [W14]
1395:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRB, MCP23017_U64_IODIRB_VALUE);
0012BE  EB4100     CLR.B W2
0012C0  B3C011     MOV.B #0x1, W1
0012C2  208FC0     MOV #0x8FC, W0
0012C4  071E42     RCALL MCP23017WriteSingleByte
0012C6  780200     MOV W0, W4
0012C8  720F1E     IOR W4, [W14], [W14]
1396:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IPOLA, MCP23017_U64_IPOLA_VALUE);
0012CA  EB4100     CLR.B W2
0012CC  B3C021     MOV.B #0x2, W1
0012CE  208FC0     MOV #0x8FC, W0
0012D0  071E3C     RCALL MCP23017WriteSingleByte
0012D2  780200     MOV W0, W4
0012D4  720F1E     IOR W4, [W14], [W14]
1397:                i2c_test |= MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_IPOLB, MCP23017_U64_IPOLB_VALUE);
0012D6  EB4100     CLR.B W2
0012D8  B3C031     MOV.B #0x3, W1
0012DA  208FC0     MOV #0x8FC, W0
0012DC  071E36     RCALL MCP23017WriteSingleByte
0012DE  780200     MOV W0, W4
0012E0  720F1E     IOR W4, [W14], [W14]
1398:                  
1399:                if ((i2c_test & 0xFF00) == 0xFA00) {
0012E2  2FF004     MOV #0xFF00, W4
0012E4  62029E     AND W4, [W14], W5
0012E6  2FA004     MOV #0xFA00, W4
0012E8  528F84     SUB W5, W4, [W15]
0012EA  3A0007     BRA NZ, 0x12FA
1400:                  // There was a fault on the i2c bus, the MCP23017 did not initialize properly
1401:                  debug_status_register |= STATUS_DIGITAL_IO_EXP_ERROR;
0012EC  80C395     MOV debug_status_register, W5
0012EE  200804     MOV #0x80, W4
0012F0  728204     IOR W5, W4, W4
0012F2  88C394     MOV W4, debug_status_register
1402:                  global_debug_counter.i2c_bus_error++;
0012F4  80C304     MOV 0x1860, W4
0012F6  E80204     INC W4, W4
0012F8  88C304     MOV W4, 0x1860
1403:                }
1404:                
1405:                i2c_test = MCP23017ReadSingleByte(&U64_MCP23017, MCP23017_REGISTER_IODIRA);
0012FA  EB4080     CLR.B W1
0012FC  208FC0     MOV #0x8FC, W0
0012FE  071E57     RCALL MCP23017ReadSingleByte
001300  780200     MOV W0, W4
001302  780F04     MOV W4, [W14]
1406:                if ((i2c_test & 0x00FF) != MCP23017_U64_IODIRA_VALUE) {
001304  200FF4     MOV #0xFF, W4
001306  62029E     AND W4, [W14], W5
001308  200F84     MOV #0xF8, W4
00130A  528F84     SUB W5, W4, [W15]
00130C  320007     BRA Z, 0x131C
1407:                  // The MCP Write/Read operation failed
1408:                  debug_status_register |= STATUS_DIGITAL_IO_EXP_ERROR;
00130E  80C395     MOV debug_status_register, W5
001310  200804     MOV #0x80, W4
001312  728204     IOR W5, W4, W4
001314  88C394     MOV W4, debug_status_register
1409:                  global_debug_counter.i2c_bus_error++;
001316  80C304     MOV 0x1860, W4
001318  E80204     INC W4, W4
00131A  88C304     MOV W4, 0x1860
1410:                }
1411:               
1412:                DisableMagnetronFilamentSupply();
00131C  07075C     RCALL DisableMagnetronFilamentSupply
1413:                DisableMagnetronMagnetSupply();
00131E  070763     RCALL DisableMagnetronMagnetSupply
1414:                DisableHVLambdaSupply();
001320  070766     RCALL DisableHVLambdaSupply
1415:              }
001322  FA8000     ULNK
001324  060000     RETURN
1416:              
1417:              
1418:              
1419:              
1420:              
1421:              
1422:              void DoA34760StartUpFastProcess(void) {
001326  FA0004     LNK #0x4
1423:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
1424:                unsigned int vtemp;
1425:              #endif
1426:                
1427:                unsigned int vtemp_2;
1428:                unsigned int itemp_2;
1429:              
1430:                processor_crash_count++;
001328  80C6D4     MOV processor_crash_count, W4
00132A  E80204     INC W4, W4
00132C  88C6D4     MOV W4, processor_crash_count
1431:              
1432:                fast_reset_counter_persistent++;
00132E  804234     MOV fast_reset_counter_persistent, W4
001330  E80204     INC W4, W4
001332  884234     MOV W4, fast_reset_counter_persistent
1433:                pulse_counter_repository_ram_copy[6] = fast_reset_counter_persistent;
001334  804234     MOV fast_reset_counter_persistent, W4
001336  88C124     MOV W4, 0x1824
1434:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = OLL_DO_FAST_RESTART;
001338  A9E2CB     BCLR 0x2CB, #7
1435:              
1436:                // Taken from StartWarmUp(); & the start of State Warm Ready
1437:                PIDInit(&thyratron_reservoir_heater_PID);
00133A  208580     MOV #0x858, W0
00133C  07F747     RCALL _PIDInit
1438:                PIDInit(&thyratron_cathode_heater_PID);
00133E  208620     MOV #0x862, W0
001340  07F745     RCALL _PIDInit
1439:              
1440:                // DPARKER, there are a lot more power supply configuration calls going on here than are needed, that is a lot of wasted CPU cycles as these are complex math operations
1441:                ScalePowerSupply(&ps_hv_lambda_mode_A,100,100);   // DPARKER this may be re-adjusted below
001342  200642     MOV #0x64, W2
001344  200641     MOV #0x64, W1
001346  209080     MOV #0x908, W0
001348  0700D6     RCALL ScalePowerSupply
1442:                ScalePowerSupply(&ps_hv_lambda_mode_B,100,100);   // DPARKER this may be re-adjusted below
00134A  200642     MOV #0x64, W2
00134C  200641     MOV #0x64, W1
00134E  209BC0     MOV #0x9BC, W0
001350  0700D2     RCALL ScalePowerSupply
1443:                ScalePowerSupply(&ps_filament,100,100);           // DPARKER this may be re-adjusted below
001352  200642     MOV #0x64, W2
001354  200641     MOV #0x64, W1
001356  20ACA0     MOV #0xACA, W0
001358  0700CE     RCALL ScalePowerSupply
1444:                ScalePowerSupply(&ps_magnet,100,100);             // DPARKER this may be re-adjusted below
00135A  200642     MOV #0x64, W2
00135C  200641     MOV #0x64, W1
00135E  20A700     MOV #0xA70, W0
001360  0700CA     RCALL ScalePowerSupply
1445:                ScalePowerSupply(&ps_thyr_reservoir_htr,100,100); // DPARKER this is not actually being used
001362  200642     MOV #0x64, W2
001364  200641     MOV #0x64, W1
001366  20B7E0     MOV #0xB7E, W0
001368  0700C6     RCALL ScalePowerSupply
1446:                ScalePowerSupply(&ps_thyr_cathode_htr,100,100);   // DPARKER this is not actually being used
00136A  200642     MOV #0x64, W2
00136C  200641     MOV #0x64, W1
00136E  20B240     MOV #0xB24, W0
001370  0700C2     RCALL ScalePowerSupply
1447:              
1448:                EnableMagnetronMagnetSupply();
001372  070735     RCALL EnableMagnetronMagnetSupply
1449:                EnableMagnetronFilamentSupply();
001374  07072C     RCALL EnableMagnetronFilamentSupply
1450:                HVLambdaStartCharging();  // DPARKER TMR1 and TMR2 must be initialized and ready to go before this call. DPARKER T1 Interrupt must also be ready to go
001376  0707DC     RCALL HVLambdaStartCharging
1451:                _T1IE = 0;  // We don't want to enter the interrupt until we get to STATE_HV_ON
001378  A9608C     BCLR IEC0, #3
1452:              
1453:                PIN_UART2_TX = !PIN_UART2_TX;
00137A  801655     MOV LATB, W5
00137C  200404     MOV #0x40, W4
00137E  628204     AND W5, W4, W4
001380  A7F004     BTSC W4, #15
001382  EA0204     NEG W4, W4
001384  E90204     DEC W4, W4
001386  DE224F     LSR W4, #15, W4
001388  784204     MOV.B W4, W4
00138A  FB8204     ZE W4, W4
00138C  620261     AND W4, #0x1, W4
00138E  DD2246     SL W4, #6, W4
001390  801656     MOV LATB, W6
001392  2FFBF5     MOV #0xFFBF, W5
001394  630285     AND W6, W5, W5
001396  728204     IOR W5, W4, W4
001398  881654     MOV W4, LATB
1454:                // Setup the ADC to read PAC and save to RAM as appropriate
1455:                FastReadAndFilterPACInputs();
00139A  0705CF     RCALL FastReadAndFilterPACInputs
1456:                PIN_UART2_TX = !PIN_UART2_TX;
00139C  801655     MOV LATB, W5
00139E  200404     MOV #0x40, W4
0013A0  628204     AND W5, W4, W4
0013A2  A7F004     BTSC W4, #15
0013A4  EA0204     NEG W4, W4
0013A6  E90204     DEC W4, W4
0013A8  DE224F     LSR W4, #15, W4
0013AA  784204     MOV.B W4, W4
0013AC  FB8204     ZE W4, W4
0013AE  620261     AND W4, #0x1, W4
0013B0  DD2246     SL W4, #6, W4
0013B2  801656     MOV LATB, W6
0013B4  2FFBF5     MOV #0xFFBF, W5
0013B6  630285     AND W6, W5, W5
0013B8  728204     IOR W5, W4, W4
0013BA  881654     MOV W4, LATB
1457:              
1458:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
1459:                if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
1460:                  vtemp = Scale16Bit(pac_1_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
1461:                  SetPowerSupplyTarget(&ps_hv_lambda_mode_A, vtemp, 0);
1462:                  
1463:                  vtemp = Scale16Bit(pac_2_adc_reading, DIRECT_LAMBDA_INPUT_SCALE);
1464:                  SetPowerSupplyTarget(&ps_hv_lambda_mode_B, vtemp, 0);
1465:                }
1466:              #endif
1467:                
1468:                if (!ram_config_set_magnetron_magnet_current_from_GUI) {
0013BC  208304     MOV #0x830, W4
0013BE  784214     MOV.B [W4], W4
0013C0  524FE0     SUB.B W4, #0x0, [W15]
0013C2  3A000D     BRA NZ, 0x13DE
1469:                  // The Magnet Current is calculated from Mode A program voltage
1470:                  itemp_2 = CalculatePoly(ps_hv_lambda_mode_A.v_command_set_point);
0013C4  804854     MOV 0x90A, W4
0013C6  780004     MOV W4, W0
0013C8  070AA7     RCALL CalculatePoly
0013CA  780200     MOV W0, W4
0013CC  780F04     MOV W4, [W14]
1471:                  vtemp_2 = GenerateMagnetVprog(itemp_2);
0013CE  78001E     MOV [W14], W0
0013D0  0713A9     RCALL GenerateMagnetVprog
0013D2  780200     MOV W0, W4
0013D4  980714     MOV W4, [W14+2]
1472:                  SetPowerSupplyTarget(&ps_magnet, vtemp_2, itemp_2);
0013D6  78011E     MOV [W14], W2
0013D8  90009E     MOV [W14+2], W1
0013DA  20A700     MOV #0xA70, W0
0013DC  07005A     RCALL SetPowerSupplyTarget
1473:                }
1474:                  
1475:                // DPARKER Calculate and Setup Magnetron Filament Power
1476:                // DoMagnetronFilamentAdjust();  
1477:                PIN_UART2_TX = !PIN_UART2_TX;
0013DE  801655     MOV LATB, W5
0013E0  200404     MOV #0x40, W4
0013E2  628204     AND W5, W4, W4
0013E4  A7F004     BTSC W4, #15
0013E6  EA0204     NEG W4, W4
0013E8  E90204     DEC W4, W4
0013EA  DE224F     LSR W4, #15, W4
0013EC  784204     MOV.B W4, W4
0013EE  FB8204     ZE W4, W4
0013F0  620261     AND W4, #0x1, W4
0013F2  DD2246     SL W4, #6, W4
0013F4  801656     MOV LATB, W6
0013F6  2FFBF5     MOV #0xFFBF, W5
0013F8  630285     AND W6, W5, W5
0013FA  728204     IOR W5, W4, W4
0013FC  881654     MOV W4, LATB
1478:                UpdateDacAll();
0013FE  0701C5     RCALL UpdateDacAll
1479:              
1480:              
1481:                PIN_UART2_TX = !PIN_UART2_TX;
001400  801655     MOV LATB, W5
001402  200404     MOV #0x40, W4
001404  628204     AND W5, W4, W4
001406  A7F004     BTSC W4, #15
001408  EA0204     NEG W4, W4
00140A  E90204     DEC W4, W4
00140C  DE224F     LSR W4, #15, W4
00140E  784204     MOV.B W4, W4
001410  FB8204     ZE W4, W4
001412  620261     AND W4, #0x1, W4
001414  DD2246     SL W4, #6, W4
001416  801656     MOV LATB, W6
001418  2FFBF5     MOV #0xFFBF, W5
00141A  630285     AND W6, W5, W5
00141C  728204     IOR W5, W4, W4
00141E  881654     MOV W4, LATB
1482:                FastReadAndFilterFeedbacks(); // DPARKER - Move this to as late as possible (want time to feedbacks to get as stable as possible before reading)
001420  0704C4     RCALL FastReadAndFilterFeedbacks
1483:                PIN_UART2_TX = !PIN_UART2_TX;
001422  801655     MOV LATB, W5
001424  200404     MOV #0x40, W4
001426  628204     AND W5, W4, W4
001428  A7F004     BTSC W4, #15
00142A  EA0204     NEG W4, W4
00142C  E90204     DEC W4, W4
00142E  DE224F     LSR W4, #15, W4
001430  784204     MOV.B W4, W4
001432  FB8204     ZE W4, W4
001434  620261     AND W4, #0x1, W4
001436  DD2246     SL W4, #6, W4
001438  801656     MOV LATB, W6
00143A  2FFBF5     MOV #0xFFBF, W5
00143C  630285     AND W6, W5, W5
00143E  728204     IOR W5, W4, W4
001440  881654     MOV W4, LATB
1484:              
1485:                // DPARKER - convert filament voltage readback to the program that will the exact same value.  Scale the filament to that value.  Do all this before you program the DAC
1486:              
1487:                control_state = STATE_HV_ON;  //  Want to check the faults based on STATE_HV_ON
001442  B3C444     MOV.B #0x44, W4
001444  784004     MOV.B W4, W0
001446  B7E840     MOV.B WREG, control_state
1488:                UpdateFaults();
001448  07142E     RCALL UpdateFaults
1489:                control_state = STATE_FAST_RECOVERY_START_UP;
00144A  B3C064     MOV.B #0x6, W4
00144C  784004     MOV.B W4, W0
00144E  B7E840     MOV.B WREG, control_state
1490:                
1491:                // DPARKER - NO CONFIG/CHANGES to the I/O Expander for NOW
1492:              }
001450  FA8000     ULNK
001452  060000     RETURN
1493:              
1494:              
1495:              
1496:              
1497:              void DoA34760StartUpCommonPostProcess(void) {
001454  FA0000     LNK #0x0
1498:                
1499:                T2CONbits.TON = 1;
001456  A8E111     BSET 0x111, #7
1500:                T5CONbits.TON = 1;
001458  A8E121     BSET 0x121, #7
1501:                
1502:                // ---- Configure the dsPIC ADC Module ------------ //
1503:                ADCON1 = A34760_ADCON1_VALUE;             // Configure the high speed ADC module based on H file parameters
00145A  27CFF4     MOV #0x7CFF, W4
00145C  881504     MOV W4, ADCON1
1504:                ADCON2 = A34760_ADCON2_VALUE;             // Configure the high speed ADC module based on H file parameters
00145E  20FE84     MOV #0xFE8, W4
001460  881514     MOV W4, ADCON2
1505:                ADCON3 = A34760_ADCON3_VALUE;             // Configure the high speed ADC module based on H file parameters
001462  2E3464     MOV #0xE346, W4
001464  881524     MOV W4, ADCON3
1506:                ADCHS  = A34760_ADCHS_VALUE;              // Configure the high speed ADC module based on H file parameters
001466  2EFE34     MOV #0xEFE3, W4
001468  881534     MOV W4, ADCHS
1507:              
1508:                ADPCFG = A34760_ADPCFG_VALUE;             // Set which pins are analog and which are digital I/O
00146A  2C0074     MOV #0xC007, W4
00146C  881544     MOV W4, ADPCFG
1509:                ADCSSL = A34760_ADCSSL_VALUE;             // Set which analog pins are scanned
00146E  23FF84     MOV #0x3FF8, W4
001470  881554     MOV W4, ADCSSL
1510:                ADCON1bits.ADON = 1;
001472  A8E2A1     BSET 0x2A1, #7
1511:                _ADIF = 0;
001474  A96085     BCLR 0x85, #3
1512:                _ADIE = 1;
001476  A8608D     BSET 0x8D, #3
1513:               
1514:                
1515:                // Begin UART operation
1516:                _U1TXIF = 0;	// Clear the Transmit Interrupt Flag
001478  A94085     BCLR 0x85, #2
1517:                _U1TXIE = 1;	// Enable Transmit Interrupts
00147A  A8408D     BSET 0x8D, #2
1518:                _U1RXIF = 0;	// Clear the Recieve Interrupt Flag
00147C  A92085     BCLR 0x85, #1
1519:                _U1RXIE = 1;	// Enable Recieve Interrupts
00147E  A8208D     BSET 0x8D, #1
1520:                
1521:                U1MODEbits.UARTEN = 1;	// And turn the peripheral on
001480  A8E20D     BSET 0x20D, #7
1522:                PIN_RS422_DE = OLL_RS422_DE_ENABLE_RS422_DRIVER;  // Enable the U69-RS422 Driver output (The reciever is always enabled)
001482  A882E2     BSET LATF, #4
1523:                command_string.data_state = COMMAND_BUFFER_EMPTY;  // The command buffer is empty
001484  EB4200     CLR.B W4
001486  784004     MOV.B W4, W0
001488  B7F8C8     MOV.B WREG, 0x18C8
1524:               
1525:                ResetHWLatches();
00148A  071523     RCALL ResetHWLatches
1526:                ClrWdt();
00148C  FE6000     CLRWDT
1527:                // PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;  DPARKER THIS DOES NOT BELONG HERE
1528:              
1529:              }
00148E  FA8000     ULNK
001490  060000     RETURN
1530:              
1531:              
1532:              
1533:              
1534:              
1535:              void SetPowerSupplyTarget(POWERSUPPLY* ptr_ps, unsigned int v_command, unsigned int i_command) {
001492  FA0006     LNK #0x6
001494  780F00     MOV W0, [W14]
001496  980711     MOV W1, [W14+2]
001498  980722     MOV W2, [W14+4]
1536:                /*
1537:                  ptr_ps - Pointer to the power supply that is having it's set point updated
1538:                  v_command - the new voltage command Set point
1539:                  i_command - the new current command set point
1540:                */
1541:              
1542:                
1543:                if (v_command > ptr_ps->v_max_set_point) {
00149A  78021E     MOV [W14], W4
00149C  9002B4     MOV [W4+6], W5
00149E  90021E     MOV [W14+2], W4
0014A0  528F84     SUB W5, W4, [W15]
0014A2  310008     BRA C, 0x14B4
1544:                  ptr_ps->v_command_set_point = ptr_ps->v_max_set_point;
0014A4  78021E     MOV [W14], W4
0014A6  9002B4     MOV [W4+6], W5
0014A8  78021E     MOV [W14], W4
0014AA  980215     MOV W5, [W4+2]
1545:                  global_debug_counter.setpoint_not_valid++;
0014AC  80C354     MOV 0x186A, W4
0014AE  E80204     INC W4, W4
0014B0  88C354     MOV W4, 0x186A
0014B2  370003     BRA 0x14BA
1546:                } else {
1547:                  ptr_ps->v_command_set_point = v_command;
0014B4  78021E     MOV [W14], W4
0014B6  90029E     MOV [W14+2], W5
0014B8  980215     MOV W5, [W4+2]
1548:                }
1549:                
1550:                if (i_command > ptr_ps->i_max_set_point) {
0014BA  78021E     MOV [W14], W4
0014BC  901A94     MOV [W4+50], W5
0014BE  90022E     MOV [W14+4], W4
0014C0  528F84     SUB W5, W4, [W15]
0014C2  310008     BRA C, 0x14D4
1551:                  ptr_ps->i_command_set_point = ptr_ps->i_max_set_point;
0014C4  78021E     MOV [W14], W4
0014C6  901A94     MOV [W4+50], W5
0014C8  78021E     MOV [W14], W4
0014CA  981275     MOV W5, [W4+46]
1552:                  global_debug_counter.setpoint_not_valid++;
0014CC  80C354     MOV 0x186A, W4
0014CE  E80204     INC W4, W4
0014D0  88C354     MOV W4, 0x186A
0014D2  370003     BRA 0x14DA
1553:                } else {
1554:                  ptr_ps->i_command_set_point = i_command;
0014D4  78021E     MOV [W14], W4
0014D6  9002AE     MOV [W14+4], W5
0014D8  981275     MOV W5, [W4+46]
1555:                }
1556:                
1557:                if (control_state != STATE_WARM_UP) {
0014DA  208405     MOV #0x840, W5
0014DC  784295     MOV.B [W5], W5
0014DE  B3C244     MOV.B #0x24, W4
0014E0  52CF84     SUB.B W5, W4, [W15]
0014E2  320004     BRA Z, 0x14EC
1558:                  ScalePowerSupply(ptr_ps,100,100);
0014E4  200642     MOV #0x64, W2
0014E6  200641     MOV #0x64, W1
0014E8  78001E     MOV [W14], W0
0014EA  070005     RCALL ScalePowerSupply
1559:                }
1560:                CalcPowerSupplySettings(ptr_ps);  // DPARKER is this call redundant since ScalePowerSupply also calls ScalePowerSupply
0014EC  78001E     MOV [W14], W0
0014EE  070054     RCALL CalcPowerSupplySettings
1561:              
1562:                ClrWdt();
0014F0  FE6000     CLRWDT
1563:              
1564:                // DPARKER need to figure out how to combine ScalePowerSupply & SetPowerSupplyTarget & CalcPowerSupplySettings
1565:                
1566:                
1567:                // DPARKER Record Saturation Errors for each supply???
1568:              }
0014F2  FA8000     ULNK
0014F4  060000     RETURN
1569:              
1570:              
1571:              
1572:              void ScalePowerSupply(POWERSUPPLY* ptr_ps, unsigned int num, unsigned int den) {
0014F6  FA000A     LNK #0xA
0014F8  980720     MOV W0, [W14+4]
0014FA  980731     MOV W1, [W14+6]
0014FC  980742     MOV W2, [W14+8]
1573:              
1574:                unsigned long temp_32_bit;
1575:              
1576:                if (num >= den) {
0014FE  9002BE     MOV [W14+6], W5
001500  90024E     MOV [W14+8], W4
001502  528F84     SUB W5, W4, [W15]
001504  390009     BRA NC, 0x1518
1577:                  // Power supply can not be scalled above the set point.
1578:                  // Set the scaled_set_point to the command_set_point
1579:                  ptr_ps->v_scaled_set_point = ptr_ps->v_command_set_point;
001506  90022E     MOV [W14+4], W4
001508  900294     MOV [W4+2], W5
00150A  90022E     MOV [W14+4], W4
00150C  980225     MOV W5, [W4+4]
1580:                  ptr_ps->i_scaled_set_point = ptr_ps->i_command_set_point;
00150E  90022E     MOV [W14+4], W4
001510  9012F4     MOV [W4+46], W5
001512  90022E     MOV [W14+4], W4
001514  981A05     MOV W5, [W4+48]
001516  37003C     BRA 0x1590
1581:                } else {
1582:                  // Scale v_set_point by num/den
1583:                  temp_32_bit = ptr_ps->v_command_set_point;
001518  90022E     MOV [W14+4], W4
00151A  900214     MOV [W4+2], W4
00151C  200005     MOV #0x0, W5
00151E  BE8F04     MOV.D W4, [W14]
1584:                  temp_32_bit *= num;
001520  90023E     MOV [W14+6], W4
001522  200005     MOV #0x0, W5
001524  90031E     MOV [W14+2], W6
001526  B9B304     MUL.SS W6, W4, W6
001528  780306     MOV W6, W6
00152A  78039E     MOV [W14], W7
00152C  B9B805     MUL.SS W7, W5, W0
00152E  780380     MOV W0, W7
001530  430307     ADD W6, W7, W6
001532  78039E     MOV [W14], W7
001534  780204     MOV W4, W4
001536  B82207     MUL.UU W4, W7, W4
001538  430305     ADD W6, W5, W6
00153A  780286     MOV W6, W5
00153C  BE8F04     MOV.D W4, [W14]
00153E  BE8F04     MOV.D W4, [W14]
1585:                  temp_32_bit /= den;
001540  90024E     MOV [W14+8], W4
001542  200005     MOV #0x0, W5
001544  BE0104     MOV.D W4, W2
001546  BE001E     MOV.D [W14], W0
001548  07F6A7     RCALL ___udivsi3
00154A  BE0200     MOV.D W0, W4
00154C  BE8F04     MOV.D W4, [W14]
1586:                  ptr_ps->v_scaled_set_point = temp_32_bit & 0x0000FFFF;
00154E  78029E     MOV [W14], W5
001550  90022E     MOV [W14+4], W4
001552  980225     MOV W5, [W4+4]
1587:                  
1588:                  // Scale i_set_point by num/den
1589:                  temp_32_bit = ptr_ps->i_command_set_point;
001554  90022E     MOV [W14+4], W4
001556  901274     MOV [W4+46], W4
001558  200005     MOV #0x0, W5
00155A  BE8F04     MOV.D W4, [W14]
1590:                  temp_32_bit *= num;
00155C  90023E     MOV [W14+6], W4
00155E  200005     MOV #0x0, W5
001560  90031E     MOV [W14+2], W6
001562  B9B304     MUL.SS W6, W4, W6
001564  780306     MOV W6, W6
001566  78039E     MOV [W14], W7
001568  B9B805     MUL.SS W7, W5, W0
00156A  780380     MOV W0, W7
00156C  430307     ADD W6, W7, W6
00156E  78039E     MOV [W14], W7
001570  780204     MOV W4, W4
001572  B82207     MUL.UU W4, W7, W4
001574  430305     ADD W6, W5, W6
001576  780286     MOV W6, W5
001578  BE8F04     MOV.D W4, [W14]
00157A  BE8F04     MOV.D W4, [W14]
1591:                  temp_32_bit /= den;
00157C  90024E     MOV [W14+8], W4
00157E  200005     MOV #0x0, W5
001580  BE0104     MOV.D W4, W2
001582  BE001E     MOV.D [W14], W0
001584  07F689     RCALL ___udivsi3
001586  BE0200     MOV.D W0, W4
001588  BE8F04     MOV.D W4, [W14]
1592:                  ptr_ps->i_scaled_set_point = temp_32_bit & 0x0000FFFF;
00158A  78029E     MOV [W14], W5
00158C  90022E     MOV [W14+4], W4
00158E  981A05     MOV W5, [W4+48]
1593:              
1594:                }
1595:                // Send these scaled values to the DAC and Under/Over setting registers
1596:                CalcPowerSupplySettings(ptr_ps);
001590  90002E     MOV [W14+4], W0
001592  070002     RCALL CalcPowerSupplySettings
1597:              }
001594  FA8000     ULNK
001596  060000     RETURN
1598:              
1599:              
1600:              
1601:              void CalcPowerSupplySettings(POWERSUPPLY* ptr_ps) {
001598  FA0006     LNK #0x6
00159A  980720     MOV W0, [W14+4]
1602:                unsigned int v_temp;
1603:                unsigned int i_temp;
1604:                // This function generates DAC settings and ADC trip points based on the passed voltage and current set point
1605:                
1606:                // Generate the DAC Values associated with the set points
1607:                v_temp = Scale16Bit(ptr_ps->v_scaled_set_point, ptr_ps->v_dac_scale);
00159C  90022E     MOV [W14+4], W4
00159E  9002D4     MOV [W4+10], W5
0015A0  90022E     MOV [W14+4], W4
0015A2  900224     MOV [W4+4], W4
0015A4  780085     MOV W5, W1
0015A6  780004     MOV W4, W0
0015A8  07071C     RCALL Scale16Bit
0015AA  780200     MOV W0, W4
0015AC  780F04     MOV W4, [W14]
1608:                v_temp = Scale16Bit(v_temp, ptr_ps->v_dac_cal_gain);
0015AE  90022E     MOV [W14+4], W4
0015B0  900264     MOV [W4+12], W4
0015B2  780084     MOV W4, W1
0015B4  78001E     MOV [W14], W0
0015B6  070715     RCALL Scale16Bit
0015B8  780200     MOV W0, W4
0015BA  780F04     MOV W4, [W14]
1609:                if (ptr_ps->v_dac_cal_offset > 0) {
0015BC  90022E     MOV [W14+4], W4
0015BE  900274     MOV [W4+14], W4
0015C0  520FE0     SUB W4, #0x0, [W15]
0015C2  34000C     BRA LE, 0x15DC
1610:                  // the offset is positive check for overflow above 0xFFFF
1611:                  if ((0xFFFF-ptr_ps->v_dac_cal_offset) < v_temp) {
0015C4  90022E     MOV [W14+4], W4
0015C6  900274     MOV [W4+14], W4
0015C8  EA8204     COM W4, W4
0015CA  520F9E     SUB W4, [W14], [W15]
0015CC  310003     BRA C, 0x15D4
1612:                    v_temp = 0xFFFF;
0015CE  EB8200     SETM W4
0015D0  780F04     MOV W4, [W14]
0015D2  37000F     BRA 0x15F2
1613:                  } else {
1614:                    v_temp = v_temp + ptr_ps->v_dac_cal_offset;
0015D4  90022E     MOV [W14+4], W4
0015D6  900274     MOV [W4+14], W4
0015D8  420F1E     ADD W4, [W14], [W14]
0015DA  37000B     BRA 0x15F2
1615:                  }
1616:                } else {
1617:                  // the offset is negative check for overflow below 0x0000
1618:                  if ((0-ptr_ps->v_dac_cal_offset) > v_temp) {
0015DC  90022E     MOV [W14+4], W4
0015DE  900274     MOV [W4+14], W4
0015E0  EA0204     NEG W4, W4
0015E2  520F9E     SUB W4, [W14], [W15]
0015E4  360003     BRA LEU, 0x15EC
1619:                    v_temp = 0x0000;
0015E6  EB0200     CLR W4
0015E8  780F04     MOV W4, [W14]
0015EA  370003     BRA 0x15F2
1620:                  } else {
1621:                    v_temp = v_temp + ptr_ps->v_dac_cal_offset;
0015EC  90022E     MOV [W14+4], W4
0015EE  900274     MOV [W4+14], W4
0015F0  420F1E     ADD W4, [W14], [W14]
1622:                  }
1623:                }
1624:                ptr_ps->v_dac_set_point = v_temp;
0015F2  90022E     MOV [W14+4], W4
0015F4  78029E     MOV [W14], W5
0015F6  980245     MOV W5, [W4+8]
1625:                
1626:                i_temp = Scale16Bit(ptr_ps->i_scaled_set_point, ptr_ps->i_dac_scale);
0015F8  90022E     MOV [W14+4], W4
0015FA  901AB4     MOV [W4+54], W5
0015FC  90022E     MOV [W14+4], W4
0015FE  901A04     MOV [W4+48], W4
001600  780085     MOV W5, W1
001602  780004     MOV W4, W0
001604  0706EE     RCALL Scale16Bit
001606  780200     MOV W0, W4
001608  980714     MOV W4, [W14+2]
1627:                i_temp = Scale16Bit(i_temp, ptr_ps->i_dac_cal_gain);
00160A  90022E     MOV [W14+4], W4
00160C  901A44     MOV [W4+56], W4
00160E  780084     MOV W4, W1
001610  90001E     MOV [W14+2], W0
001612  0706E7     RCALL Scale16Bit
001614  780200     MOV W0, W4
001616  980714     MOV W4, [W14+2]
1628:                if (ptr_ps->i_dac_cal_offset > 0) {
001618  90022E     MOV [W14+4], W4
00161A  901A54     MOV [W4+58], W4
00161C  520FE0     SUB W4, #0x0, [W15]
00161E  34000F     BRA LE, 0x163E
1629:                  // the offset is positive check for overflow above 0xFFFF
1630:                  if ((0xFFFF-ptr_ps->i_dac_cal_offset) < i_temp) {
001620  90022E     MOV [W14+4], W4
001622  901A54     MOV [W4+58], W4
001624  EA8284     COM W4, W5
001626  90021E     MOV [W14+2], W4
001628  528F84     SUB W5, W4, [W15]
00162A  310003     BRA C, 0x1632
1631:                    i_temp = 0xFFFF;
00162C  EB8200     SETM W4
00162E  980714     MOV W4, [W14+2]
001630  370015     BRA 0x165C
1632:                  } else {
1633:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
001632  90022E     MOV [W14+4], W4
001634  901A54     MOV [W4+58], W4
001636  90029E     MOV [W14+2], W5
001638  428204     ADD W5, W4, W4
00163A  980714     MOV W4, [W14+2]
00163C  37000F     BRA 0x165C
1634:                  }
1635:                } else {
1636:                  // the offset is negative check for overflow below 0x0000
1637:                  if ((0-ptr_ps->i_dac_cal_offset) > i_temp) {
00163E  90022E     MOV [W14+4], W4
001640  901A54     MOV [W4+58], W4
001642  EA0204     NEG W4, W4
001644  780284     MOV W4, W5
001646  90021E     MOV [W14+2], W4
001648  528F84     SUB W5, W4, [W15]
00164A  360003     BRA LEU, 0x1652
1638:                    i_temp = 0x0000;
00164C  EB0200     CLR W4
00164E  980714     MOV W4, [W14+2]
001650  370005     BRA 0x165C
1639:                  } else {
1640:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
001652  90022E     MOV [W14+4], W4
001654  901A54     MOV [W4+58], W4
001656  90029E     MOV [W14+2], W5
001658  428204     ADD W5, W4, W4
00165A  980714     MOV W4, [W14+2]
1641:                  }
1642:                }
1643:                ptr_ps->i_dac_set_point = i_temp;
00165C  90022E     MOV [W14+4], W4
00165E  90029E     MOV [W14+2], W5
001660  981A25     MOV W5, [W4+52]
1644:                
1645:                
1646:                // Set all of the over/under trip points based on the set point
1647:                v_temp = Scale16Bit(ptr_ps->v_scaled_set_point, ptr_ps->v_adc_scale);
001662  90022E     MOV [W14+4], W4
001664  900A94     MOV [W4+18], W5
001666  90022E     MOV [W14+4], W4
001668  900224     MOV [W4+4], W4
00166A  780085     MOV W5, W1
00166C  780004     MOV W4, W0
00166E  0706B9     RCALL Scale16Bit
001670  780200     MOV W0, W4
001672  780F04     MOV W4, [W14]
1648:                v_temp = Scale16Bit(v_temp, ptr_ps->v_adc_cal_gain);
001674  90022E     MOV [W14+4], W4
001676  900A24     MOV [W4+20], W4
001678  780084     MOV W4, W1
00167A  78001E     MOV [W14], W0
00167C  0706B2     RCALL Scale16Bit
00167E  780200     MOV W0, W4
001680  780F04     MOV W4, [W14]
1649:                if (ptr_ps->v_adc_cal_offset > 0) {
001682  90022E     MOV [W14+4], W4
001684  900A34     MOV [W4+22], W4
001686  520FE0     SUB W4, #0x0, [W15]
001688  34000C     BRA LE, 0x16A2
1650:                  // the offset is positive check for overflow above 0xFFFF
1651:                  if ((0xFFFF-ptr_ps->v_adc_cal_offset) < v_temp) {
00168A  90022E     MOV [W14+4], W4
00168C  900A34     MOV [W4+22], W4
00168E  EA8204     COM W4, W4
001690  520F9E     SUB W4, [W14], [W15]
001692  310003     BRA C, 0x169A
1652:                    v_temp = 0xFFFF;
001694  EB8200     SETM W4
001696  780F04     MOV W4, [W14]
001698  37000F     BRA 0x16B8
1653:                  } else {
1654:                    v_temp = v_temp + ptr_ps->v_adc_cal_offset;
00169A  90022E     MOV [W14+4], W4
00169C  900A34     MOV [W4+22], W4
00169E  420F1E     ADD W4, [W14], [W14]
0016A0  37000B     BRA 0x16B8
1655:                  }
1656:                } else {
1657:                  // the offset is negative check for overflow below 0x0000
1658:                  if ((0-ptr_ps->v_adc_cal_offset) > v_temp) {
0016A2  90022E     MOV [W14+4], W4
0016A4  900A34     MOV [W4+22], W4
0016A6  EA0204     NEG W4, W4
0016A8  520F9E     SUB W4, [W14], [W15]
0016AA  360003     BRA LEU, 0x16B2
1659:                    v_temp = 0x0000;
0016AC  EB0200     CLR W4
0016AE  780F04     MOV W4, [W14]
0016B0  370003     BRA 0x16B8
1660:                  } else {
1661:                    v_temp = v_temp + ptr_ps->v_adc_cal_offset;
0016B2  90022E     MOV [W14+4], W4
0016B4  900A34     MOV [W4+22], W4
0016B6  420F1E     ADD W4, [W14], [W14]
1662:                  }
1663:                }
1664:              
1665:                ptr_ps->v_adc_over_rel = Scale16Bit(v_temp, ptr_ps->v_adc_over_scale);
0016B8  90022E     MOV [W14+4], W4
0016BA  900A74     MOV [W4+30], W4
0016BC  780084     MOV W4, W1
0016BE  78001E     MOV [W14], W0
0016C0  070690     RCALL Scale16Bit
0016C2  780200     MOV W0, W4
0016C4  9002AE     MOV [W14+4], W5
0016C6  980AD4     MOV W4, [W5+26]
1666:                ptr_ps->v_adc_under_rel = Scale16Bit(v_temp,ptr_ps-> v_adc_under_scale);
0016C8  90022E     MOV [W14+4], W4
0016CA  901204     MOV [W4+32], W4
0016CC  780084     MOV W4, W1
0016CE  78001E     MOV [W14], W0
0016D0  070688     RCALL Scale16Bit
0016D2  780200     MOV W0, W4
0016D4  9002AE     MOV [W14+4], W5
0016D6  980AE4     MOV W4, [W5+28]
1667:                if (ptr_ps->v_adc_over_rel < ptr_ps->v_adc_over_min_value) {
0016D8  90022E     MOV [W14+4], W4
0016DA  900AD4     MOV [W4+26], W5
0016DC  90022E     MOV [W14+4], W4
0016DE  901214     MOV [W4+34], W4
0016E0  528F84     SUB W5, W4, [W15]
0016E2  310004     BRA C, 0x16EC
1668:                  ptr_ps->v_adc_over_rel = ptr_ps->v_adc_over_min_value;
0016E4  90022E     MOV [W14+4], W4
0016E6  901294     MOV [W4+34], W5
0016E8  90022E     MOV [W14+4], W4
0016EA  980A55     MOV W5, [W4+26]
1669:                }
1670:                
1671:                i_temp = Scale16Bit(ptr_ps->i_scaled_set_point, ptr_ps->i_adc_scale);
0016EC  90022E     MOV [W14+4], W4
0016EE  901AF4     MOV [W4+62], W5
0016F0  90022E     MOV [W14+4], W4
0016F2  901A04     MOV [W4+48], W4
0016F4  780085     MOV W5, W1
0016F6  780004     MOV W4, W0
0016F8  070674     RCALL Scale16Bit
0016FA  780200     MOV W0, W4
0016FC  980714     MOV W4, [W14+2]
1672:                i_temp = Scale16Bit(i_temp, ptr_ps->i_adc_cal_gain);
0016FE  90022E     MOV [W14+4], W4
001700  902204     MOV [W4+64], W4
001702  780084     MOV W4, W1
001704  90001E     MOV [W14+2], W0
001706  07066D     RCALL Scale16Bit
001708  780200     MOV W0, W4
00170A  980714     MOV W4, [W14+2]
1673:                if (ptr_ps->i_adc_cal_offset > 0) {
00170C  90022E     MOV [W14+4], W4
00170E  902214     MOV [W4+66], W4
001710  520FE0     SUB W4, #0x0, [W15]
001712  34000F     BRA LE, 0x1732
1674:                  // the offset is positive check for overflow above 0xFFFF
1675:                  if ((0xFFFF-ptr_ps->i_adc_cal_offset) < i_temp) {
001714  90022E     MOV [W14+4], W4
001716  902214     MOV [W4+66], W4
001718  EA8284     COM W4, W5
00171A  90021E     MOV [W14+2], W4
00171C  528F84     SUB W5, W4, [W15]
00171E  310003     BRA C, 0x1726
1676:                    i_temp = 0xFFFF;
001720  EB8200     SETM W4
001722  980714     MOV W4, [W14+2]
001724  370015     BRA 0x1750
1677:                  } else {
1678:                    i_temp = i_temp + ptr_ps->i_dac_cal_offset;
001726  90022E     MOV [W14+4], W4
001728  901A54     MOV [W4+58], W4
00172A  90029E     MOV [W14+2], W5
00172C  428204     ADD W5, W4, W4
00172E  980714     MOV W4, [W14+2]
001730  37000F     BRA 0x1750
1679:                  }
1680:                } else {
1681:                  // the offset is negative check for overflow below 0x0000
1682:                  if ((0-ptr_ps->i_adc_cal_offset) > i_temp) {
001732  90022E     MOV [W14+4], W4
001734  902214     MOV [W4+66], W4
001736  EA0204     NEG W4, W4
001738  780284     MOV W4, W5
00173A  90021E     MOV [W14+2], W4
00173C  528F84     SUB W5, W4, [W15]
00173E  360003     BRA LEU, 0x1746
1683:                    i_temp = 0x0000;
001740  EB0200     CLR W4
001742  980714     MOV W4, [W14+2]
001744  370005     BRA 0x1750
1684:                  } else {
1685:                    i_temp = i_temp + ptr_ps->i_adc_cal_offset;
001746  90022E     MOV [W14+4], W4
001748  902214     MOV [W4+66], W4
00174A  90029E     MOV [W14+2], W5
00174C  428204     ADD W5, W4, W4
00174E  980714     MOV W4, [W14+2]
1686:                  }
1687:                }
1688:              
1689:                /*
1690:                //  DPARKER NEED TO ADJUST THE OVER/UNDER SCALE SUCH THAT IT IS SET TO X Percent of MAX VALUE.  NOT PROGRAMED VALUE
1691:                //  This will overwrite the values calculated above
1692:                
1693:                
1694:                #define DPARKER_SCALE_5_PERCENT (410)  // This will be 5%
1695:                dan_temp = Scale16Bit(ptr_ps->v_max_set_point, DPARKER_SCALE_5_PERCENT);
1696:                
1697:                ptr_ps->v_adc_over_rel = v_temp + dan_temp;
1698:              
1699:                if (v_temp > dan_temp) {
1700:                  ptr_ps->v_adc_under_rel = v_temp - dan_temp;
1701:                } else {
1702:                  ptr_ps->v_adc_under_rel = 0;
1703:                }
1704:                
1705:              					       
1706:                // End New code to adjust the over scaling
1707:              
1708:                */
1709:              
1710:              
1711:              
1712:              
1713:                
1714:                ptr_ps->i_adc_over_rel = Scale16Bit(i_temp, ptr_ps->i_adc_over_scale);
001750  90022E     MOV [W14+4], W4
001752  902254     MOV [W4+74], W4
001754  780084     MOV W4, W1
001756  90001E     MOV [W14+2], W0
001758  070644     RCALL Scale16Bit
00175A  780200     MOV W0, W4
00175C  9002AE     MOV [W14+4], W5
00175E  9822B4     MOV W4, [W5+70]
1715:                ptr_ps->i_adc_under_rel = Scale16Bit(i_temp, ptr_ps->i_adc_under_scale);
001760  90022E     MOV [W14+4], W4
001762  902264     MOV [W4+76], W4
001764  780084     MOV W4, W1
001766  90001E     MOV [W14+2], W0
001768  07063C     RCALL Scale16Bit
00176A  780200     MOV W0, W4
00176C  9002AE     MOV [W14+4], W5
00176E  9822C4     MOV W4, [W5+72]
1716:                if (ptr_ps->i_adc_over_rel < ptr_ps->i_adc_over_min_value) {
001770  90022E     MOV [W14+4], W4
001772  9022B4     MOV [W4+70], W5
001774  90022E     MOV [W14+4], W4
001776  902274     MOV [W4+78], W4
001778  528F84     SUB W5, W4, [W15]
00177A  310004     BRA C, 0x1784
1717:                  ptr_ps->i_adc_over_rel = ptr_ps->i_adc_over_min_value;
00177C  90022E     MOV [W14+4], W4
00177E  9022F4     MOV [W4+78], W5
001780  90022E     MOV [W14+4], W4
001782  982235     MOV W5, [W4+70]
1718:                }
1719:                ClrWdt();
001784  FE6000     CLRWDT
1720:              }
001786  FA8000     ULNK
001788  060000     RETURN
1721:              
1722:              
1723:              
1724:              
1725:              void UpdateDacAll(void) {
00178A  FA0012     LNK #0x12
1726:                unsigned int dac_value_array[8];
1727:                unsigned char dac_write_failed;
1728:                unsigned char number_tries;
1729:              
1730:                last_known_action = LAST_ACTION_UPDATE_DAC_ALL;
00178C  2000A4     MOV #0xA, W4
00178E  88C6B4     MOV W4, last_known_action
1731:              
1732:                dac_value_array[0] = ps_thyr_reservoir_htr.v_dac_set_point;
001790  805C34     MOV 0xB86, W4
001792  980714     MOV W4, [W14+2]
1733:                dac_value_array[1] = ps_thyr_cathode_htr.v_dac_set_point;
001794  805964     MOV 0xB2C, W4
001796  980724     MOV W4, [W14+4]
1734:                dac_value_array[2] = ps_magnet.v_dac_set_point;
001798  8053C4     MOV 0xA78, W4
00179A  980734     MOV W4, [W14+6]
1735:                dac_value_array[3] = ps_magnet.i_dac_set_point;
00179C  805524     MOV 0xAA4, W4
00179E  980744     MOV W4, [W14+8]
1736:                dac_value_array[4] = ps_filament.v_dac_set_point;
0017A0  805694     MOV 0xAD2, W4
0017A2  980754     MOV W4, [W14+10]
1737:                dac_value_array[5] = ps_filament.i_dac_set_point;
0017A4  8057F4     MOV 0xAFE, W4
0017A6  980764     MOV W4, [W14+12]
1738:                dac_value_array[6] = ps_hv_lambda_mode_A.v_dac_set_point;
0017A8  804884     MOV 0x910, W4
0017AA  980774     MOV W4, [W14+14]
1739:                dac_value_array[7] = ps_hv_lambda_mode_B.v_dac_set_point;
0017AC  804E24     MOV 0x9C4, W4
0017AE  980F04     MOV W4, [W14+16]
1740:              
1741:                dac_write_failed = 1;
0017B0  B3C014     MOV.B #0x1, W4
0017B2  784F04     MOV.B W4, [W14]
1742:                number_tries = 0;
0017B4  EB4200     CLR.B W4
0017B6  984714     MOV.B W4, [W14+1]
1743:                while ((dac_write_failed != 0) & (number_tries < 20)) {
0017B8  370010     BRA 0x17DA
0017DA  78429E     MOV.B [W14], W5
0017DC  FB8205     ZE W5, W4
0017DE  EA0204     NEG W4, W4
0017E0  DE224F     LSR W4, #15, W4
0017E2  784284     MOV.B W4, W5
0017E4  B3C014     MOV.B #0x1, W4
0017E6  90431E     MOV.B [W14+1], W6
0017E8  534FF3     SUB.B W6, #0x13, [W15]
0017EA  360001     BRA LEU, 0x17EE
0017EC  EB4200     CLR.B W4
0017EE  62C204     AND.B W5, W4, W4
0017F0  524FE0     SUB.B W4, #0x0, [W15]
0017F2  3AFFE3     BRA NZ, 0x17BA
1744:                  dac_write_failed = WriteLTC2656AllDacChannels(&U44_LTC2656, dac_value_array);
0017BA  E8820E     INC2 W14, W4
0017BC  780084     MOV W4, W1
0017BE  208F00     MOV #0x8F0, W0
0017C0  071784     RCALL WriteLTC2656AllDacChannels
0017C2  784200     MOV.B W0, W4
0017C4  784F04     MOV.B W4, [W14]
1745:                  number_tries++;
0017C6  90421E     MOV.B [W14+1], W4
0017C8  E84204     INC.B W4, W4
0017CA  984714     MOV.B W4, [W14+1]
1746:                  if (dac_write_failed) {
0017CC  78421E     MOV.B [W14], W4
0017CE  524FE0     SUB.B W4, #0x0, [W15]
0017D0  320003     BRA Z, 0x17D8
1747:                    global_debug_counter.LTC2656_write_error++;
0017D2  80C344     MOV 0x1868, W4
0017D4  E80204     INC W4, W4
0017D6  88C344     MOV W4, 0x1868
1748:                  }
1749:                  ClrWdt();
0017D8  FE6000     CLRWDT
1750:                }
1751:                if (number_tries >= 20) {
0017F4  90421E     MOV.B [W14+1], W4
0017F6  524FF3     SUB.B W4, #0x13, [W15]
0017F8  360002     BRA LEU, 0x17FE
1752:                  RecordThisControlBoardFault(FAULT_CB_SPI_UNRECOVERABLE_ERROR);
0017FA  200200     MOV #0x20, W0
0017FC  0715BD     RCALL RecordThisControlBoardFault
1753:                }
1754:              }
0017FE  FA8000     ULNK
001800  060000     RETURN
1755:              
1756:              
1757:              
1758:              
1759:              void Do10msTicToc(void) {
001802  FA000C     LNK #0xC
1760:                /*
1761:                  Certain functions need to happen at regular interval for the system to work
1762:              
1763:                  Thyratron PIDs - The gain and phase of the PID control loop is a function of it's execution frequency therefor it must be updated at a regular interval
1764:                  Analog Filters - The filter response is function of the execution frequency so they must be executed at a regular interval
1765:              
1766:                  DAC updates - The DAC must be regularly.  Durring HV ON this should happen AFTER a pulse so that the SPI bus is not corrupted by EMI
1767:                  If the state is not in HV_ON or the system is pulsing at a very low freqeuncy, DAC updates must be handeled by this function.
1768:                  
1769:                  Calculating the PRF
1770:              
1771:                  Other timing functions like flashing LEDs
1772:                */
1773:              
1774:                unsigned int vtemp;
1775:                unsigned int itemp;
1776:                unsigned long long_math_value;
1777:                unsigned long temp32;
1778:              
1779:                last_known_action = LAST_ACTION_DO_10MS;
001804  200094     MOV #0x9, W4
001806  88C6B4     MOV W4, last_known_action
1780:                
1781:                if (_POR) {
001808  803A04     MOV RCON, W4
00180A  620261     AND W4, #0x1, W4
00180C  520FE0     SUB W4, #0x0, [W15]
00180E  320003     BRA Z, 0x1816
1782:                  debug_status_register |= STATUS_POR_RESET;
001810  80C394     MOV debug_status_register, W4
001812  A04004     BSET W4, #4
001814  88C394     MOV W4, debug_status_register
1783:                  // _POR = 0;
1784:                }
1785:                if (_EXTR) {
001816  803A05     MOV RCON, W5
001818  200804     MOV #0x80, W4
00181A  628204     AND W5, W4, W4
00181C  520FE0     SUB W4, #0x0, [W15]
00181E  320004     BRA Z, 0x1828
1786:                  debug_status_register |= STATUS_EXTERNAL_RESET;
001820  80C395     MOV debug_status_register, W5
001822  200204     MOV #0x20, W4
001824  728204     IOR W5, W4, W4
001826  88C394     MOV W4, debug_status_register
1787:                  //_EXTR = 0;
1788:                }
1789:                if (_SWR) {
001828  803A05     MOV RCON, W5
00182A  200404     MOV #0x40, W4
00182C  628204     AND W5, W4, W4
00182E  520FE0     SUB W4, #0x0, [W15]
001830  320004     BRA Z, 0x183A
1790:                  debug_status_register |= STATUS_SOFTARE_RESET;
001832  80C395     MOV debug_status_register, W5
001834  200404     MOV #0x40, W4
001836  728204     IOR W5, W4, W4
001838  88C394     MOV W4, debug_status_register
1791:                  //_SWR = 0;
1792:                }
1793:                if (_BOR) {
00183A  803A04     MOV RCON, W4
00183C  620262     AND W4, #0x2, W4
00183E  520FE0     SUB W4, #0x0, [W15]
001840  320003     BRA Z, 0x1848
1794:                  debug_status_register |= STATUS_BOR_RESET;
001842  80C394     MOV debug_status_register, W4
001844  A00004     BSET W4, #0
001846  88C394     MOV W4, debug_status_register
1795:                  //_BOR = 0;
1796:                }
1797:                if (_TRAPR) {
001848  803A05     MOV RCON, W5
00184A  280004     MOV #0x8000, W4
00184C  628204     AND W5, W4, W4
00184E  520FE0     SUB W4, #0x0, [W15]
001850  320003     BRA Z, 0x1858
1798:                  debug_status_register |= STATUS_TRAPR_RESET;
001852  80C394     MOV debug_status_register, W4
001854  A01004     BSET W4, #1
001856  88C394     MOV W4, debug_status_register
1799:                  //_TRAPR = 0;
1800:                }
1801:                if (_WDTO) {
001858  803A04     MOV RCON, W4
00185A  620270     AND W4, #0x10, W4
00185C  520FE0     SUB W4, #0x0, [W15]
00185E  320003     BRA Z, 0x1866
1802:                  debug_status_register |= STATUS_WDT_RESET;
001860  80C394     MOV debug_status_register, W4
001862  A02004     BSET W4, #2
001864  88C394     MOV W4, debug_status_register
1803:                  // _WDTO = 0;
1804:                }
1805:                if (_IOPUWR) {
001866  803A05     MOV RCON, W5
001868  240004     MOV #0x4000, W4
00186A  628204     AND W5, W4, W4
00186C  520FE0     SUB W4, #0x0, [W15]
00186E  320003     BRA Z, 0x1876
1806:                  debug_status_register |= STATUS_IOPUWR_RESET;
001870  80C394     MOV debug_status_register, W4
001872  A03004     BSET W4, #3
001874  88C394     MOV W4, debug_status_register
1807:                  //_IOPUWR = 0;
1808:                }
1809:              
1810:              
1811:                ClrWdt();
001876  FE6000     CLRWDT
1812:                if (_T5IF) {
001878  800435     MOV IFS1, W5
00187A  200404     MOV #0x40, W4
00187C  628204     AND W5, W4, W4
00187E  520FE0     SUB W4, #0x0, [W15]
001880  3200D4     BRA Z, 0x1A2A
1813:                  _T5IF = 0;
001882  A9C086     BCLR IFS1, #6
1814:                  //10ms roll has occured
1815:                  
1816:                  led_pulse_count = ((led_pulse_count + 1) & 0b00001111);
001884  804294     MOV led_pulse_count, W4
001886  E80204     INC W4, W4
001888  62026F     AND W4, #0xF, W4
00188A  884294     MOV W4, led_pulse_count
1817:                  if (led_pulse_count == 0) {
00188C  804294     MOV led_pulse_count, W4
00188E  520FE0     SUB W4, #0x0, [W15]
001890  3A0015     BRA NZ, 0x18BC
1818:                    // 10ms * 16 counter has ocurred
1819:                    // Flash the LED - NOTE "PIN_MAIN_CONTACTOR_CLOSE = !PIN_MAIN_CONTACTOR_CLOSE" was causing any changes made in Port F durring interrupt to be overwritten
1820:                    if (PIN_MAIN_CONTACTOR_CLOSE) {
001892  801655     MOV LATB, W5
001894  200804     MOV #0x80, W4
001896  628204     AND W5, W4, W4
001898  520FE0     SUB W4, #0x0, [W15]
00189A  320002     BRA Z, 0x18A0
1821:              	PIN_MAIN_CONTACTOR_CLOSE = 0;
00189C  A9E2CA     BCLR LATB, #7
00189E  370001     BRA 0x18A2
1822:                    } else {
1823:              	PIN_MAIN_CONTACTOR_CLOSE = 1;
0018A0  A8E2CA     BSET LATB, #7
1824:                    }  
1825:                    
1826:                    average_pulse_repetition_frequency_deci_herz = RCFilter16Tau(average_pulse_repetition_frequency_deci_herz, ((prf_pulse_counter*125)>>1));
0018A2  8041F5     MOV prf_pulse_counter, W5
0018A4  2007D4     MOV #0x7D, W4
0018A6  B9AA04     MUL.SS W5, W4, W4
0018A8  780204     MOV W4, W4
0018AA  D10284     LSR W4, W5
0018AC  8041E4     MOV average_pulse_repetition_frequency_deci_herz, W4
0018AE  780085     MOV W5, W1
0018B0  780004     MOV W4, W0
0018B2  07063D     RCALL RCFilter16Tau
0018B4  780200     MOV W0, W4
0018B6  8841E4     MOV W4, average_pulse_repetition_frequency_deci_herz
1827:                    prf_pulse_counter = 0;  
0018B8  EB0200     CLR W4
0018BA  8841F4     MOV W4, prf_pulse_counter
1828:                  }
1829:                  
1830:                  temp32 = 1562500;
0018BC  2D7844     MOV #0xD784, W4
0018BE  200175     MOV #0x17, W5
0018C0  BE8F04     MOV.D W4, [W14]
1831:                  if (last_period < 100) {
0018C2  80C535     MOV 0x18A6, W5
0018C4  200634     MOV #0x63, W4
0018C6  528F84     SUB W5, W4, [W15]
0018C8  3E0002     BRA GTU, 0x18CE
1832:                    last_period = 100;
0018CA  200644     MOV #0x64, W4
0018CC  88C534     MOV W4, 0x18A6
1833:                  }
1834:                  temp32 /= last_period;
0018CE  80C534     MOV 0x18A6, W4
0018D0  200005     MOV #0x0, W5
0018D2  BE0104     MOV.D W4, W2
0018D4  BE001E     MOV.D [W14], W0
0018D6  07F4E0     RCALL ___udivsi3
0018D8  BE0200     MOV.D W0, W4
0018DA  BE8F04     MOV.D W4, [W14]
1835:                  prf_deciherz = temp32;
0018DC  78021E     MOV [W14], W4
0018DE  88C544     MOV W4, 0x18A8
1836:                  if (_T3IF) {
0018E0  800425     MOV IFS0, W5
0018E2  200804     MOV #0x80, W4
0018E4  628204     AND W5, W4, W4
0018E6  520FE0     SUB W4, #0x0, [W15]
0018E8  320002     BRA Z, 0x18EE
1837:                    // We are pulsing at less than 2.5Hz
1838:                    // Set the rep rate to zero
1839:                    prf_deciherz = 0;
0018EA  EB0200     CLR W4
0018EC  88C544     MOV W4, 0x18A8
1840:                  }
1841:                  
1842:                  
1843:                  if ((PIN_FP_MODULATOR_RESET == !ILL_MODULATOR_RESET) && (start_reset_process)) {
0018EE  801735     MOV PORTG, W5
0018F0  220004     MOV #0x2000, W4
0018F2  628204     AND W5, W4, W4
0018F4  520FE0     SUB W4, #0x0, [W15]
0018F6  320006     BRA Z, 0x1904
0018F8  8041A4     MOV start_reset_process, W4
0018FA  520FE0     SUB W4, #0x0, [W15]
0018FC  320003     BRA Z, 0x1904
1844:                    ResetAllFaults();
0018FE  0712F1     RCALL ResetAllFaults
1845:                    ResetHWLatches(); // Clear the hardware Latches
001900  0712E8     RCALL ResetHWLatches
1846:                    ResetPulseLatches();
001902  0712DF     RCALL ResetPulseLatches
1847:                  }
1848:                  
1849:                  if (PIN_FP_MODULATOR_RESET == ILL_MODULATOR_RESET) {
001904  801735     MOV PORTG, W5
001906  220004     MOV #0x2000, W4
001908  628204     AND W5, W4, W4
00190A  520FE0     SUB W4, #0x0, [W15]
00190C  3A0003     BRA NZ, 0x1914
1850:                    // Start the Reset Process
1851:                    start_reset_process = 1;
00190E  200014     MOV #0x1, W4
001910  8841A4     MOV W4, start_reset_process
001912  370002     BRA 0x1918
1852:                  } else {
1853:                    start_reset_process = 0;
001914  EB0200     CLR W4
001916  8841A4     MOV W4, start_reset_process
1854:                  }
1855:                      
1856:                  // ResetSPI1(); // ResetSPI(2) // DPARKER - This may be requried to fix bit errors in the SPI bus
1857:                  
1858:                  
1859:                  FilterADCs();  // Read Data from the DAC arrays, average, and filter
001918  0701EC     RCALL FilterADCs
1860:                  
1861:                  // If the magnet current is based on mode A program voltage (instead of from GUI), set the magnet current based on mode A program voltage
1862:                  if (!ram_config_set_magnetron_magnet_current_from_GUI) {
00191A  208304     MOV #0x830, W4
00191C  784214     MOV.B [W4], W4
00191E  524FE0     SUB.B W4, #0x0, [W15]
001920  3A000D     BRA NZ, 0x193C
1863:                    // The Magnet Current is calculated from Mode A program voltage
1864:                    itemp = CalculatePoly(ps_hv_lambda_mode_A.v_command_set_point);
001922  804854     MOV 0x90A, W4
001924  780004     MOV W4, W0
001926  0707F8     RCALL CalculatePoly
001928  780200     MOV W0, W4
00192A  980724     MOV W4, [W14+4]
1865:                    vtemp = GenerateMagnetVprog(itemp);
00192C  90002E     MOV [W14+4], W0
00192E  0710FA     RCALL GenerateMagnetVprog
001930  780200     MOV W0, W4
001932  980734     MOV W4, [W14+6]
1866:                    SetPowerSupplyTarget(&ps_magnet, vtemp, itemp);
001934  90012E     MOV [W14+4], W2
001936  9000BE     MOV [W14+6], W1
001938  20A700     MOV #0xA70, W0
00193A  07FDAB     RCALL SetPowerSupplyTarget
1867:                  }
1868:                
1869:                  if ((control_state == STATE_SYSTEM_COLD_READY) || (control_state == STATE_FAULT_COLD_FAULT)) {
00193C  208404     MOV #0x840, W4
00193E  784214     MOV.B [W4], W4
001940  524FF4     SUB.B W4, #0x14, [W15]
001942  320005     BRA Z, 0x194E
001944  208405     MOV #0x840, W5
001946  784295     MOV.B [W5], W5
001948  B3CA44     MOV.B #0xA4, W4
00194A  52CF84     SUB.B W5, W4, [W15]
00194C  3A0018     BRA NZ, 0x197E
1870:                    ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
00194E  200642     MOV #0x64, W2
001950  EB0080     CLR W1
001952  209080     MOV #0x908, W0
001954  07FDD0     RCALL ScalePowerSupply
1871:                    ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
001956  200642     MOV #0x64, W2
001958  EB0080     CLR W1
00195A  209080     MOV #0x908, W0
00195C  07FDCC     RCALL ScalePowerSupply
1872:                    ScalePowerSupply(&ps_filament,0,100);
00195E  200642     MOV #0x64, W2
001960  EB0080     CLR W1
001962  20ACA0     MOV #0xACA, W0
001964  07FDC8     RCALL ScalePowerSupply
1873:                    ScalePowerSupply(&ps_magnet,0,100);
001966  200642     MOV #0x64, W2
001968  EB0080     CLR W1
00196A  20A700     MOV #0xA70, W0
00196C  07FDC4     RCALL ScalePowerSupply
1874:                    ScalePowerSupply(&ps_thyr_reservoir_htr,0,100);
00196E  200642     MOV #0x64, W2
001970  EB0080     CLR W1
001972  20B7E0     MOV #0xB7E, W0
001974  07FDC0     RCALL ScalePowerSupply
1875:                    ScalePowerSupply(&ps_thyr_cathode_htr,0,100);
001976  200642     MOV #0x64, W2
001978  EB0080     CLR W1
00197A  20B240     MOV #0xB24, W0
00197C  07FDBC     RCALL ScalePowerSupply
1876:                  }
1877:              
1878:              
1879:              
1880:              
1881:                  UpdateFaults();  // Update all the fault registers.  Note this must only happen once every 10ms because some faults are timed
00197E  071193     RCALL UpdateFaults
1882:                  //  DPARKER figure out some better way to timer certain faults
1883:                
1884:                  // Update the sum fault outputs (copper and fiber)
1885:                  if (CheckFaultActive()) {
001980  071521     RCALL CheckFaultActive
001982  780200     MOV W0, W4
001984  520FE0     SUB W4, #0x0, [W15]
001986  320003     BRA Z, 0x198E
1886:                    PIN_SUM_FAULT_FIBER = OLL_SUM_FAULT_FIBER_FAULT;
001988  A9E2C4     BCLR LATA, #7
1887:                    PIN_SUM_FAULT_COPPER = OLL_SUM_FAULT_COPPER_FAULT;
00198A  A942D0     BCLR LATC, #2
00198C  370002     BRA 0x1992
1888:                  } else {
1889:                    PIN_SUM_FAULT_FIBER = !OLL_SUM_FAULT_FIBER_FAULT;
00198E  A8E2C4     BSET LATA, #7
1890:                    PIN_SUM_FAULT_COPPER = !OLL_SUM_FAULT_COPPER_FAULT;
001990  A842D0     BSET LATC, #2
1891:                  }
1892:                  
1893:                  slow_down_thyratron_pid_counter++;
001992  208364     MOV #0x836, W4
001994  784214     MOV.B [W4], W4
001996  E84204     INC.B W4, W4
001998  784004     MOV.B W4, W0
00199A  B7E836     MOV.B WREG, slow_down_thyratron_pid_counter
1894:                  slow_down_thyratron_pid_counter &= 0b00001111;
00199C  208364     MOV #0x836, W4
00199E  784214     MOV.B [W4], W4
0019A0  62426F     AND.B W4, #0xF, W4
0019A2  784004     MOV.B W4, W0
0019A4  B7E836     MOV.B WREG, slow_down_thyratron_pid_counter
1895:                  if (slow_down_thyratron_pid_counter == 0) {
0019A6  208364     MOV #0x836, W4
0019A8  784214     MOV.B [W4], W4
0019AA  524FE0     SUB.B W4, #0x0, [W15]
0019AC  3A0001     BRA NZ, 0x19B0
1896:                    //execute PID loop once every 160ms
1897:                    DoThyratronPIDs();
0019AE  07003F     RCALL DoThyratronPIDs
1898:                  }
1899:                  
1900:              
1901:                  // The system is configured to adjust the filament power based on magnetron power.  Otherwise the filament power will be maxed at all times
1902:                  DoMagnetronFilamentAdjust();
0019B0  0700A1     RCALL DoMagnetronFilamentAdjust
1903:              
1904:              
1905:              
1906:                  if ((control_state != STATE_HV_ON) || (_T2IF)) {
0019B2  208405     MOV #0x840, W5
0019B4  784295     MOV.B [W5], W5
0019B6  B3C444     MOV.B #0x44, W4
0019B8  52CF84     SUB.B W5, W4, [W15]
0019BA  3A0005     BRA NZ, 0x19C6
0019BC  800425     MOV IFS0, W5
0019BE  200404     MOV #0x40, W4
0019C0  628204     AND W5, W4, W4
0019C2  520FE0     SUB W4, #0x0, [W15]
0019C4  320004     BRA Z, 0x19CE
1907:                    // Do10msTicToc needs to be responsible for updating the DAC
1908:                    UpdateDacAll();
0019C6  07FEE1     RCALL UpdateDacAll
1909:                    UpdateIOExpanderOutputs();
0019C8  070417     RCALL UpdateIOExpanderOutputs
1910:                    pulse_counter_this_run = 0;
0019CA  EB0200     CLR W4
0019CC  884164     MOV W4, pulse_counter_this_run
1911:                  } 
1912:                  if (pulse_counter_this_run == 0) {
0019CE  804164     MOV pulse_counter_this_run, W4
0019D0  520FE0     SUB W4, #0x0, [W15]
0019D2  3A0029     BRA NZ, 0x1A26
1913:                    if (pulse_off_time_10_ms_units < low_energy_target_current_startup_max_cooldown) {
0019D4  8040C5     MOV pulse_off_time_10_ms_units, W5
0019D6  80C4F4     MOV 0x189E, W4
0019D8  528F84     SUB W5, W4, [W15]
0019DA  310003     BRA C, 0x19E2
1914:              	pulse_off_time_10_ms_units++;
0019DC  8040C4     MOV pulse_off_time_10_ms_units, W4
0019DE  E80204     INC W4, W4
0019E0  8840C4     MOV W4, pulse_off_time_10_ms_units
1915:                    }
1916:                    long_math_value = max_low_energy_target_current_startup_adjust_initital_value;
0019E2  80C4E4     MOV 0x189C, W4
0019E4  200005     MOV #0x0, W5
0019E6  980744     MOV W4, [W14+8]
0019E8  980755     MOV W5, [W14+10]
1917:                    long_math_value *= pulse_off_time_10_ms_units;
0019EA  8040C4     MOV pulse_off_time_10_ms_units, W4
0019EC  200005     MOV #0x0, W5
0019EE  90035E     MOV [W14+10], W6
0019F0  B9B304     MUL.SS W6, W4, W6
0019F2  780306     MOV W6, W6
0019F4  9003CE     MOV [W14+8], W7
0019F6  B9B805     MUL.SS W7, W5, W0
0019F8  780380     MOV W0, W7
0019FA  430307     ADD W6, W7, W6
0019FC  9003CE     MOV [W14+8], W7
0019FE  780204     MOV W4, W4
001A00  B82207     MUL.UU W4, W7, W4
001A02  430305     ADD W6, W5, W6
001A04  780286     MOV W6, W5
001A06  980744     MOV W4, [W14+8]
001A08  980755     MOV W5, [W14+10]
001A0A  980744     MOV W4, [W14+8]
001A0C  980755     MOV W5, [W14+10]
1918:                    long_math_value /= low_energy_target_current_startup_max_cooldown;
001A0E  80C4F4     MOV 0x189E, W4
001A10  200005     MOV #0x0, W5
001A12  BE0104     MOV.D W4, W2
001A14  90004E     MOV [W14+8], W0
001A16  9000DE     MOV [W14+10], W1
001A18  07F43F     RCALL ___udivsi3
001A1A  BE0200     MOV.D W0, W4
001A1C  980744     MOV W4, [W14+8]
001A1E  980755     MOV W5, [W14+10]
1919:                    low_energy_target_current_startup_adjust_initital_value = long_math_value;
001A20  90024E     MOV [W14+8], W4
001A22  88C504     MOV W4, 0x18A0
001A24  370002     BRA 0x1A2A
1920:                  } else {
1921:                    pulse_off_time_10_ms_units = 0;
001A26  EB0200     CLR W4
001A28  8840C4     MOV W4, pulse_off_time_10_ms_units
1922:                  }
1923:                } 
1924:              }
001A2A  FA8000     ULNK
001A2C  060000     RETURN
1925:              
1926:              
1927:              
1928:              
1929:              
1930:              void DoThyratronPIDs(void) {
001A2E  FA0002     LNK #0x2
1931:                /*
1932:                  The pid functions provided by dsp.h use Q15 fractional data.
1933:                  This represents fractional inputs/outputs from -1 to 1.
1934:                  Our inputs to the PID come from an unipolar ADC.
1935:                  The control output of the PID goes directly to a DAC.
1936:                  In order for the PID control to work with our unsigned 16 bit data two changed must be made.
1937:                  (1) Measured output must be converted from 16 bit data to Q(15).  This is easily done by shifting one bit to the right.
1938:                      From to PIDs point of view we are just decreasing our resolution by 1 bit, not a problem here.
1939:                  (2) Control output must be convereted so that it can iterface to our DAC.
1940:                      The control output ranges from -1 to 1.  so perform the following logic.
1941:              	If (control_output < 0) then (control_output = 0).
1942:              	Multiply control_output by 2 (shift left 1 bit) to use the full range of the DAC.
1943:              	NOTE: You must perform the math like this we because the PID will set the output to Zero at start.
1944:              	If you shift the entire 16 bits to unsinged interger, 0 will become 0x7FFF and your control_output will start at 50%, not zero!!!!
1945:                  (3) In order to set the DAC the control output "is moved" to v_dac_set_point register by setting v_dac_scale to zero, v_dac_cal_gain to zero
1946:                      and setting v_dac_cal_offset to 0x1000 "zero level" + the output of the PID loop (which ranges from zero to 0xFFFF)
1947:                  (4) If the DAC setting exceeds an output program of 2V (32000 or 0x7D00) , then we have saturated the output.  Throw some faults
1948:                */
1949:              
1950:                unsigned int temp;
1951:              
1952:                last_known_action = LAST_ACTION_DO_THYRATRON_PID;
001A30  200084     MOV #0x8, W4
001A32  88C6B4     MOV W4, last_known_action
1953:              
1954:                // Run the Thyratron Heaters PID loops on the latest data
1955:                // bit shift the data 1 bit to the right because the PID loop is expecting Q15
1956:                temp = Scale16Bit(ps_thyr_reservoir_htr.v_scaled_set_point, ps_thyr_reservoir_htr.v_adc_scale);
001A34  805C85     MOV 0xB90, W5
001A36  805C14     MOV 0xB82, W4
001A38  780085     MOV W5, W1
001A3A  780004     MOV W4, W0
001A3C  0704D2     RCALL Scale16Bit
001A3E  780200     MOV W0, W4
001A40  780F04     MOV W4, [W14]
1957:                temp = Scale16Bit(temp, ps_thyr_reservoir_htr.v_adc_cal_gain);
001A42  805C94     MOV 0xB92, W4
001A44  780084     MOV W4, W1
001A46  78001E     MOV [W14], W0
001A48  0704CC     RCALL Scale16Bit
001A4A  780200     MOV W0, W4
001A4C  780F04     MOV W4, [W14]
1958:                temp = temp + ps_thyr_reservoir_htr.v_adc_cal_offset;
001A4E  805CA4     MOV 0xB94, W4
001A50  420F1E     ADD W4, [W14], [W14]
1959:                thyratron_reservoir_heater_PID.controlReference = (temp >> 1);
001A52  78021E     MOV [W14], W4
001A54  D10204     LSR W4, W4
001A56  884304     MOV W4, 0x860
1960:                thyratron_reservoir_heater_PID.measuredOutput = (ps_thyr_reservoir_htr.v_adc_reading >> 1);
001A58  805C74     MOV 0xB8E, W4
001A5A  D10204     LSR W4, W4
001A5C  8842F4     MOV W4, 0x85E
1961:                PID(&thyratron_reservoir_heater_PID);
001A5E  208580     MOV #0x858, W0
001A60  07F399     RCALL _PID
1962:              
1963:              
1964:                temp = Scale16Bit(ps_thyr_cathode_htr.v_scaled_set_point, ps_thyr_cathode_htr.v_adc_scale);
001A62  8059B5     MOV 0xB36, W5
001A64  805944     MOV 0xB28, W4
001A66  780085     MOV W5, W1
001A68  780004     MOV W4, W0
001A6A  0704BB     RCALL Scale16Bit
001A6C  780200     MOV W0, W4
001A6E  780F04     MOV W4, [W14]
1965:                temp = Scale16Bit(temp, ps_thyr_cathode_htr.v_adc_cal_gain);
001A70  8059C4     MOV 0xB38, W4
001A72  780084     MOV W4, W1
001A74  78001E     MOV [W14], W0
001A76  0704B5     RCALL Scale16Bit
001A78  780200     MOV W0, W4
001A7A  780F04     MOV W4, [W14]
1966:                temp = temp + ps_thyr_cathode_htr.v_adc_cal_offset;
001A7C  8059D4     MOV 0xB3A, W4
001A7E  420F1E     ADD W4, [W14], [W14]
1967:                thyratron_cathode_heater_PID.controlReference = (temp >> 1);
001A80  78021E     MOV [W14], W4
001A82  D10204     LSR W4, W4
001A84  884354     MOV W4, 0x86A
1968:                thyratron_cathode_heater_PID.measuredOutput = (ps_thyr_cathode_htr.v_adc_reading >> 1);
001A86  8059A4     MOV 0xB34, W4
001A88  D10204     LSR W4, W4
001A8A  884344     MOV W4, 0x868
1969:                PID(&thyratron_cathode_heater_PID);
001A8C  208620     MOV #0x862, W0
001A8E  07F382     RCALL _PID
1970:                
1971:              
1972:                // Update the DAC setting for the Reservoir Heater
1973:                // The output of the PID is Q15, convert to 16 bit unsigned for the DAC
1974:                temp = thyratron_reservoir_heater_PID.controlOutput;
001A90  8042E4     MOV 0x85C, W4
001A92  780F04     MOV W4, [W14]
1975:                if (temp & 0x8000) {
001A94  78021E     MOV [W14], W4
001A96  520FE0     SUB W4, #0x0, [W15]
001A98  3D0002     BRA GE, 0x1A9E
1976:                  temp = 0x0000;
001A9A  EB0200     CLR W4
001A9C  780F04     MOV W4, [W14]
1977:                }
1978:                temp = temp << 1;
001A9E  78021E     MOV [W14], W4
001AA0  420204     ADD W4, W4, W4
001AA2  780F04     MOV W4, [W14]
1979:                temp += 0;
1980:                if (temp > THYRATRON_DAC_SATURATED) {
001AA4  27D004     MOV #0x7D00, W4
001AA6  78029E     MOV [W14], W5
001AA8  528F84     SUB W5, W4, [W15]
001AAA  360002     BRA LEU, 0x1AB0
1981:                  // The dac output will exceed 2V (20mA from the 4-20mA driver).  Limit the output to 0x7D00
1982:                  temp = THYRATRON_DAC_SATURATED;
001AAC  27D004     MOV #0x7D00, W4
001AAE  780F04     MOV W4, [W14]
1983:                }
1984:                ps_thyr_reservoir_htr.v_dac_cal_gain = 0;
001AB0  EB0200     CLR W4
001AB2  885C54     MOV W4, 0xB8A
1985:                ps_thyr_reservoir_htr.v_dac_scale = 0;
001AB4  EB0200     CLR W4
001AB6  885C44     MOV W4, 0xB88
1986:                ps_thyr_reservoir_htr.v_dac_cal_offset = temp;
001AB8  78021E     MOV [W14], W4
001ABA  885C64     MOV W4, 0xB8C
1987:                
1988:                
1989:                // Update the DAC setting for the Cathode Heater
1990:                // The output of the PID is Q15, convert to 16 bit unsigned for the DAC
1991:                temp = thyratron_cathode_heater_PID.controlOutput;
001ABC  804334     MOV 0x866, W4
001ABE  780F04     MOV W4, [W14]
1992:                if (temp & 0x8000) {
001AC0  78021E     MOV [W14], W4
001AC2  520FE0     SUB W4, #0x0, [W15]
001AC4  3D0002     BRA GE, 0x1ACA
1993:                  temp = 0x0000;
001AC6  EB0200     CLR W4
001AC8  780F04     MOV W4, [W14]
1994:                }
1995:                temp = temp << 1;
001ACA  78021E     MOV [W14], W4
001ACC  420204     ADD W4, W4, W4
001ACE  780F04     MOV W4, [W14]
1996:                temp += 0; 
1997:                if (temp > THYRATRON_DAC_SATURATED) {
001AD0  27D004     MOV #0x7D00, W4
001AD2  78029E     MOV [W14], W5
001AD4  528F84     SUB W5, W4, [W15]
001AD6  360002     BRA LEU, 0x1ADC
1998:                  // The dac output will exceed 2V (20mA from the 4-20mA driver).  Limit the output to 0x7D00
1999:                  // DPARKER how are thyratron dac saturations detected in faults.c - confirm this works
2000:                  temp = THYRATRON_DAC_SATURATED;
001AD8  27D004     MOV #0x7D00, W4
001ADA  780F04     MOV W4, [W14]
2001:                }
2002:                ps_thyr_cathode_htr.v_dac_cal_gain = 0;
001ADC  EB0200     CLR W4
001ADE  885984     MOV W4, 0xB30
2003:                ps_thyr_cathode_htr.v_dac_scale = 0;
001AE0  EB0200     CLR W4
001AE2  885974     MOV W4, 0xB2E
2004:                ps_thyr_cathode_htr.v_dac_cal_offset = temp;
001AE4  78021E     MOV [W14], W4
001AE6  885994     MOV W4, 0xB32
2005:              
2006:                CalcPowerSupplySettings(&ps_thyr_cathode_htr);
001AE8  20B240     MOV #0xB24, W0
001AEA  07FD56     RCALL CalcPowerSupplySettings
2007:                CalcPowerSupplySettings(&ps_thyr_reservoir_htr);
001AEC  20B7E0     MOV #0xB7E, W0
001AEE  07FD54     RCALL CalcPowerSupplySettings
2008:              }
001AF0  FA8000     ULNK
001AF2  060000     RETURN
2009:              
2010:              void DoMagnetronFilamentAdjust(void) {
001AF4  FA000A     LNK #0xA
2011:                unsigned long temp32;
2012:                unsigned int look_up_position;
2013:                unsigned int filament_scale;
2014:                signed int new_position;
2015:                
2016:                temp32 = average_energy_per_pulse_milli_joules;
001AF6  8041C4     MOV average_energy_per_pulse_milli_joules, W4
001AF8  200005     MOV #0x0, W5
001AFA  BE8F04     MOV.D W4, [W14]
2017:                //temp32 *= average_pulse_repetition_frequency_deci_herz;
2018:                temp32 *= prf_deciherz;
001AFC  80C544     MOV 0x18A8, W4
001AFE  200005     MOV #0x0, W5
001B00  90031E     MOV [W14+2], W6
001B02  B9B304     MUL.SS W6, W4, W6
001B04  780306     MOV W6, W6
001B06  78039E     MOV [W14], W7
001B08  B9B805     MUL.SS W7, W5, W0
001B0A  780380     MOV W0, W7
001B0C  430307     ADD W6, W7, W6
001B0E  78039E     MOV [W14], W7
001B10  780204     MOV W4, W4
001B12  B82207     MUL.UU W4, W7, W4
001B14  430305     ADD W6, W5, W6
001B16  780286     MOV W6, W5
001B18  BE8F04     MOV.D W4, [W14]
001B1A  BE8F04     MOV.D W4, [W14]
2019:                temp32 >>= 6;
001B1C  BE021E     MOV.D [W14], W4
001B1E  DD2B4A     SL W5, #10, W6
001B20  DE2246     LSR W4, #6, W4
001B22  730204     IOR W6, W4, W4
001B24  DE2AC6     LSR W5, #6, W5
001B26  BE8F04     MOV.D W4, [W14]
2020:                temp32 *= 13;
001B28  90021E     MOV [W14+2], W4
001B2A  B9226D     MUL.SU W4, #13, W4
001B2C  780304     MOV W4, W6
001B2E  78021E     MOV [W14], W4
001B30  B92260     MUL.SU W4, #0, W4
001B32  780204     MOV W4, W4
001B34  430304     ADD W6, W4, W6
001B36  78029E     MOV [W14], W5
001B38  2000D4     MOV #0xD, W4
001B3A  B82A04     MUL.UU W5, W4, W4
001B3C  430305     ADD W6, W5, W6
001B3E  780286     MOV W6, W5
001B40  BE8F04     MOV.D W4, [W14]
001B42  BE8F04     MOV.D W4, [W14]
2021:                temp32 >>= 11;
001B44  BE021E     MOV.D [W14], W4
001B46  DD2B45     SL W5, #5, W6
001B48  DE224B     LSR W4, #11, W4
001B4A  730204     IOR W6, W4, W4
001B4C  DE2ACB     LSR W5, #11, W5
001B4E  BE8F04     MOV.D W4, [W14]
2022:              
2023:                // DPARKER this will not work at powers greater than 6.5KW because the apparent power will roll around.  This is very bad
2024:                // Need to truncate for (average output power watts) and properly handel look up position.
2025:                if (temp32 >= 0xFFFF) {
001B50  2FFFE4     MOV #0xFFFE, W4
001B52  200005     MOV #0x0, W5
001B54  BE031E     MOV.D [W14], W6
001B56  530F84     SUB W6, W4, [W15]
001B58  5B8F85     SUBB W7, W5, [W15]
001B5A  360003     BRA LEU, 0x1B62
2026:                  average_output_power_watts = 0xFFFF;
001B5C  EB8200     SETM W4
001B5E  8841D4     MOV W4, average_output_power_watts
001B60  370002     BRA 0x1B66
2027:                } else {
2028:                  average_output_power_watts = (temp32 & 0xFFFF);
001B62  78021E     MOV [W14], W4
001B64  8841D4     MOV W4, average_output_power_watts
2029:                }
2030:              
2031:                switch (operation_mode) 
001B66  80B6F4     MOV operation_mode, W4
001B68  200405     MOV #0x40, W5
001B6A  520F85     SUB W4, W5, [W15]
001B6C  320014     BRA Z, 0x1B96
001B6E  200405     MOV #0x40, W5
001B70  520F85     SUB W4, W5, [W15]
001B72  3E0007     BRA GTU, 0x1B82
001B74  200205     MOV #0x20, W5
001B76  520F85     SUB W4, W5, [W15]
001B78  32001C     BRA Z, 0x1BB2
001B7A  200305     MOV #0x30, W5
001B7C  520F85     SUB W4, W5, [W15]
001B7E  32000F     BRA Z, 0x1B9E
001B80  37002E     BRA 0x1BDE
001B82  210305     MOV #0x1030, W5
001B84  520F85     SUB W4, W5, [W15]
001B86  32001D     BRA Z, 0x1BC2
001B88  210405     MOV #0x1040, W5
001B8A  520F85     SUB W4, W5, [W15]
001B8C  320016     BRA Z, 0x1BBA
001B8E  210205     MOV #0x1020, W5
001B90  520F85     SUB W4, W5, [W15]
001B92  320021     BRA Z, 0x1BD6
001B94  370024     BRA 0x1BDE
2032:                  {
2033:                  case MODE_PORTAL_GANTRY_HIGH_ENERGY:
2034:                    temp32 = average_output_power_watts;
001B96  8041D4     MOV average_output_power_watts, W4
001B98  200005     MOV #0x0, W5
001B9A  BE8F04     MOV.D W4, [W14]
2035:                    break;
001B9C  370024     BRA 0x1BE6
2036:                  
2037:                  case MODE_PORTAL_GANTRY_INTERLEAVED:
2038:                    temp32 = ETMScaleFactor2(average_output_power_watts, scale_interleaved, 0);
001B9E  80B705     MOV scale_interleaved, W5
001BA0  8041D4     MOV average_output_power_watts, W4
001BA2  EB0100     CLR W2
001BA4  780085     MOV W5, W1
001BA6  780004     MOV W4, W0
001BA8  071A9E     RCALL _ETMScaleFactor2
001BAA  780200     MOV W0, W4
001BAC  200005     MOV #0x0, W5
001BAE  BE8F04     MOV.D W4, [W14]
2039:                    break;
001BB0  37001A     BRA 0x1BE6
2040:              
2041:                  case MODE_PORTAL_GANTRY_LOW_ENERGY:
2042:                    temp32 = average_output_power_watts;
001BB2  8041D4     MOV average_output_power_watts, W4
001BB4  200005     MOV #0x0, W5
001BB6  BE8F04     MOV.D W4, [W14]
2043:                    break;
001BB8  370016     BRA 0x1BE6
2044:                    
2045:                  case MODE_ULTRA_LOW_DOSE_HIGH_ENERGY:
2046:                    temp32 = average_output_power_watts;
001BBA  8041D4     MOV average_output_power_watts, W4
001BBC  200005     MOV #0x0, W5
001BBE  BE8F04     MOV.D W4, [W14]
2047:                    break;
001BC0  370012     BRA 0x1BE6
2048:              
2049:                  case MODE_ULTRA_LOW_DOSE_INTERLEAVED:
2050:                    temp32 = ETMScaleFactor2(average_output_power_watts, scale_low_energy, 0);
001BC2  80B715     MOV scale_low_energy, W5
001BC4  8041D4     MOV average_output_power_watts, W4
001BC6  EB0100     CLR W2
001BC8  780085     MOV W5, W1
001BCA  780004     MOV W4, W0
001BCC  071A8C     RCALL _ETMScaleFactor2
001BCE  780200     MOV W0, W4
001BD0  200005     MOV #0x0, W5
001BD2  BE8F04     MOV.D W4, [W14]
2051:                    break;
001BD4  370008     BRA 0x1BE6
2052:              
2053:                  case MODE_ULTRA_LOW_DOSE_LOW_ENERGY:
2054:                    temp32 = average_output_power_watts;
001BD6  8041D4     MOV average_output_power_watts, W4
001BD8  200005     MOV #0x0, W5
001BDA  BE8F04     MOV.D W4, [W14]
2055:                    break;
001BDC  370004     BRA 0x1BE6
2056:                    
2057:                  default:
2058:                    temp32 = average_output_power_watts;
001BDE  8041D4     MOV average_output_power_watts, W4
001BE0  200005     MOV #0x0, W5
001BE2  BE8F04     MOV.D W4, [W14]
2059:                    break;
001BE4  000000     NOP
2060:                  }
2061:                
2062:              
2063:                temp32 >>= 7;
001BE6  BE021E     MOV.D [W14], W4
001BE8  DD2B49     SL W5, #9, W6
001BEA  DE2247     LSR W4, #7, W4
001BEC  730204     IOR W6, W4, W4
001BEE  DE2AC7     LSR W5, #7, W5
001BF0  BE8F04     MOV.D W4, [W14]
2064:                look_up_position = (temp32 & 0b00111111);
001BF2  78029E     MOV [W14], W5
001BF4  2003F4     MOV #0x3F, W4
001BF6  628204     AND W5, W4, W4
001BF8  980734     MOV W4, [W14+6]
2065:                new_position = (signed int)look_up_position;
001BFA  90023E     MOV [W14+6], W4
001BFC  980724     MOV W4, [W14+4]
2066:                //new_position += look_up_offset;
2067:                if (new_position <= 0) {
001BFE  90022E     MOV [W14+4], W4
001C00  520FE0     SUB W4, #0x0, [W15]
001C02  3C0002     BRA GT, 0x1C08
2068:                  new_position = 0;
001C04  EB0200     CLR W4
001C06  980724     MOV W4, [W14+4]
2069:                }
2070:                if (new_position >= 63) {
001C08  9002AE     MOV [W14+4], W5
001C0A  2003E4     MOV #0x3E, W4
001C0C  528F84     SUB W5, W4, [W15]
001C0E  340002     BRA LE, 0x1C14
2071:                  new_position = 63;
001C10  2003F4     MOV #0x3F, W4
001C12  980724     MOV W4, [W14+4]
2072:                }
2073:                look_up_position = new_position;
001C14  9002AE     MOV [W14+4], W5
001C16  980735     MOV W5, [W14+6]
2074:                look_up_position &= 0b00111111;
001C18  9002BE     MOV [W14+6], W5
001C1A  2003F4     MOV #0x3F, W4
001C1C  628204     AND W5, W4, W4
001C1E  980734     MOV W4, [W14+6]
2075:              
2076:                if ((control_state == STATE_HV_ON) || (control_state == STATE_SYSTEM_WARM_READY)  || (control_state == STATE_HV_STARTUP) || (control_state == STATE_FAULT_WARM_FAULT)) {
001C20  208405     MOV #0x840, W5
001C22  784295     MOV.B [W5], W5
001C24  B3C444     MOV.B #0x44, W4
001C26  52CF84     SUB.B W5, W4, [W15]
001C28  32000F     BRA Z, 0x1C48
001C2A  208405     MOV #0x840, W5
001C2C  784295     MOV.B [W5], W5
001C2E  B3C344     MOV.B #0x34, W4
001C30  52CF84     SUB.B W5, W4, [W15]
001C32  32000A     BRA Z, 0x1C48
001C34  208405     MOV #0x840, W5
001C36  784295     MOV.B [W5], W5
001C38  B3C354     MOV.B #0x35, W4
001C3A  52CF84     SUB.B W5, W4, [W15]
001C3C  320005     BRA Z, 0x1C48
001C3E  208405     MOV #0x840, W5
001C40  784295     MOV.B [W5], W5
001C42  B3CA84     MOV.B #0xA8, W4
001C44  52CF84     SUB.B W5, W4, [W15]
001C46  3A000A     BRA NZ, 0x1C5C
2077:                  filament_scale = FilamentLookUpTable[look_up_position];
001C48  90023E     MOV [W14+6], W4
001C4A  420284     ADD W4, W4, W5
001C4C  282B84     MOV #0x82B8, W4
001C4E  428204     ADD W5, W4, W4
001C50  780314     MOV [W4], W6
001C52  980746     MOV W6, [W14+8]
2078:                  ScalePowerSupply(&ps_filament,filament_scale,100);
001C54  200642     MOV #0x64, W2
001C56  9000CE     MOV [W14+8], W1
001C58  20ACA0     MOV #0xACA, W0
001C5A  07FC4D     RCALL ScalePowerSupply
2079:                }  
2080:              }
001C5C  FA8000     ULNK
001C5E  060000     RETURN
2081:              
2082:              
2083:              void ReadIsolatedAdcToRam(void) {
001C60  FA0004     LNK #0x4
2084:                /*
2085:                  This function reads back data from the external AD7686.
2086:                  When this function is called, the data has already been sampled, and the conversion is complete.
2087:                  The convert pin to the two AD7686 should be active
2088:              
2089:                  DO NOT COPY THIS FUNCTION TO OTHER APPLICATIONS - IT WILL NOT WORK BECAUSE THIS DOES NOT INCLUDE TO CODE TO SAMPLE THE INPUTS
2090:                */
2091:              
2092:                // reads data into global variable 
2093:                unsigned long adc_read;
2094:              
2095:              
2096:                last_known_action = LAST_ACTION_READ_ISOLATED_ADC;
001C62  200074     MOV #0x7, W4
001C64  88C6B4     MOV W4, last_known_action
2097:              
2098:                if (PIN_PULSE_ADC_TRIGGER == OLL_TRIGGER_PULSE_ADCS) {
001C66  801625     MOV LATA, W5
001C68  202004     MOV #0x200, W4
001C6A  628204     AND W5, W4, W4
001C6C  520FE0     SUB W4, #0x0, [W15]
001C6E  320037     BRA Z, 0x1CDE
2099:                  // The convert signal is asserted like it should be
2100:              
2101:              
2102:                  // ----------  READ BACK THE CURRENT ADC CONVERSION ------------------------- //
2103:                  PIN_PULSE_IMON_CS = OLL_SELECT_PULSE_IMON_ADC;   // Select the Current Monitor ADC
001C70  A9C2D6     BCLR LATD, #6
2104:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
001C72  200C80     MOV #0xC8, W0
001C74  200001     MOV #0x0, W1
001C76  071A85     RCALL ___delay32
2105:                  adc_read = SendAndReceiveSPI(0, SPI_PORT_2);     // ReadData 16 bit value off of the Current Monitor ADC
001C78  B3C021     MOV.B #0x2, W1
001C7A  EB0000     CLR W0
001C7C  0718DA     RCALL SendAndReceiveSPI
001C7E  BE0200     MOV.D W0, W4
001C80  BE8F04     MOV.D W4, [W14]
2106:                  if (adc_read == 0x11110000) {
001C82  200004     MOV #0x0, W4
001C84  211115     MOV #0x1111, W5
001C86  BE031E     MOV.D [W14], W6
001C88  530F84     SUB W6, W4, [W15]
001C8A  5B8F85     SUBB W7, W5, [W15]
001C8C  3A0006     BRA NZ, 0x1C9A
2107:                    // THERE WAS an SPI ERROR
2108:                    pulse_magnetron_current_adc_reading = 0;
001C8E  EB0200     CLR W4
001C90  8842A4     MOV W4, pulse_magnetron_current_adc_reading
2109:                    global_debug_counter.spi2_bus_error++;
001C92  80C324     MOV 0x1864, W4
001C94  E80204     INC W4, W4
001C96  88C324     MOV W4, 0x1864
001C98  370002     BRA 0x1C9E
2110:                  } else {
2111:                    pulse_magnetron_current_adc_reading = adc_read & 0xFFFF;
001C9A  78021E     MOV [W14], W4
001C9C  8842A4     MOV W4, pulse_magnetron_current_adc_reading
2112:                  }
2113:                  PIN_PULSE_IMON_CS = !OLL_SELECT_PULSE_IMON_ADC;  // De - Select the Current Monitor ADC  
001C9E  A8C2D6     BSET LATD, #6
2114:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
001CA0  200C80     MOV #0xC8, W0
001CA2  200001     MOV #0x0, W1
001CA4  071A6E     RCALL ___delay32
2115:                  
2116:                  
2117:              
2118:                  // ----------  READ BACK THE VOLTAGE ADC CONVERSION ------------------------- //
2119:                  PIN_PULSE_VMON_CS = OLL_SELECT_PULSE_VMON_ADC;   // Select the Voltage Monitor ADC
001CA6  A9A2D6     BCLR LATD, #5
2120:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);      // Wait for the cable select signal to propagate
001CA8  200C80     MOV #0xC8, W0
001CAA  200001     MOV #0x0, W1
001CAC  071A6A     RCALL ___delay32
2121:                  adc_read = SendAndReceiveSPI(0, SPI_PORT_2);     // ReadData 16 bit value off of the Voltage Monitor ADC
001CAE  B3C021     MOV.B #0x2, W1
001CB0  EB0000     CLR W0
001CB2  0718BF     RCALL SendAndReceiveSPI
001CB4  BE0200     MOV.D W0, W4
001CB6  BE8F04     MOV.D W4, [W14]
2122:                  if (adc_read == 0x11110000) {
001CB8  200004     MOV #0x0, W4
001CBA  211115     MOV #0x1111, W5
001CBC  BE031E     MOV.D [W14], W6
001CBE  530F84     SUB W6, W4, [W15]
001CC0  5B8F85     SUBB W7, W5, [W15]
001CC2  3A0006     BRA NZ, 0x1CD0
2123:                    // THERE WAS an SPI ERROR
2124:                    pulse_magnetron_voltage_adc_reading = 0;
001CC4  EB0200     CLR W4
001CC6  8842B4     MOV W4, pulse_magnetron_voltage_adc_reading
2125:                    global_debug_counter.spi2_bus_error++;
001CC8  80C324     MOV 0x1864, W4
001CCA  E80204     INC W4, W4
001CCC  88C324     MOV W4, 0x1864
001CCE  370002     BRA 0x1CD4
2126:                  } else {
2127:                    pulse_magnetron_voltage_adc_reading = adc_read & 0xFFFF;
001CD0  78021E     MOV [W14], W4
001CD2  8842B4     MOV W4, pulse_magnetron_voltage_adc_reading
2128:                  }
2129:                  PIN_PULSE_VMON_CS = !OLL_SELECT_PULSE_VMON_ADC;  // De - Select the Current Monitor ADC  
001CD4  A8A2D6     BSET LATD, #5
2130:                  __delay32(DELAY_PULSE_CABLE_SELECT_PROP_DELAY);        // Wait for the cable select signal to propagate
001CD6  200C80     MOV #0xC8, W0
001CD8  200001     MOV #0x0, W1
001CDA  071A53     RCALL ___delay32
001CDC  370007     BRA 0x1CEC
2131:                
2132:                } else {
2133:                  // This function was called when the ADC convert signal was not asserted.  Something very bad happened 
2134:                  pulse_magnetron_voltage_adc_reading = 0;
001CDE  EB0200     CLR W4
001CE0  8842B4     MOV W4, pulse_magnetron_voltage_adc_reading
2135:                  pulse_magnetron_current_adc_reading = 0;
001CE2  EB0200     CLR W4
001CE4  8842A4     MOV W4, pulse_magnetron_current_adc_reading
2136:                  global_debug_counter.external_adc_false_trigger++;
001CE6  80C334     MOV 0x1866, W4
001CE8  E80204     INC W4, W4
001CEA  88C334     MOV W4, 0x1866
2137:                }
2138:                PIN_PULSE_ADC_TRIGGER = !OLL_TRIGGER_PULSE_ADCS;   // Clear the convert trigger signal
001CEC  A922C5     BCLR 0x2C5, #1
2139:              } 
001CEE  FA8000     ULNK
001CF0  060000     RETURN
2140:              
2141:              
2142:              
2143:              
2144:              void FilterADCs(void) {
001CF2  FA0002     LNK #0x2
2145:                /*
2146:                  This function should be called once every 10mS from Do10msTicToc()
2147:                  The ADC value array is averaged and the the result of that average is low pass filtered.
2148:              
2149:                  From Internal DAC
2150:                  AN3 -  PFN Rev Current           - Only sampled after a pulse
2151:               
2152:                  AN4 - pac_#1                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2153:                  AN5 - pac_#2                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2154:              
2155:                  AN6 - Thyratron Cathode Heater   - 160mS tau - Analog Input Bandwidth = 10 Hz
2156:                  AN7 - Thyratron Reservoir Heater - 160mS tau - Analog Input Bandwidth = 10 Hz
2157:              
2158:                  AN8  - magnet_current            - 160mS tau - Analog Input Bandwidth = 200 Hz
2159:                  AN9  - magnet_voltage            - 160mS tau - Analog Input Bandwidth = 200 Hz
2160:               
2161:                  AN10 - filament_voltage          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2162:                  AN11 - filament_current          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2163:               
2164:                  AN12 - lambda_vpeak              - 640mS tau - Analog Input Bandwidth = 200 Hz
2165:                  AN13 - lambda_vmon               - Only Sampled at EOC
2166:                */
2167:                
2168:                unsigned int adc_reading;
2169:              #if !defined(__SET_MAGNETRON_OVER_SERIAL_INTERFACE)
2170:                unsigned int vtemp;
2171:              #endif
2172:              
2173:                last_known_action = LAST_ACTION_FILTER_ADC;
001CF4  200064     MOV #0x6, W4
001CF6  88C6B4     MOV W4, last_known_action
2174:              
2175:                // AN3 -  PFN Rev Current           - Only Sampled after a pulse
2176:                // PFN Rev Current is read after a pulse
2177:              
2178:                //AN4 - pac_#1                     - 256 samples/tau - Analog Input Bandwidth = 200 Hz  
2179:                adc_reading = AverageADC128(pac_1_array);
001CF8  20CDA0     MOV #0xCDA, W0
001CFA  071A51     RCALL _AverageADC128
001CFC  780200     MOV W0, W4
001CFE  780F04     MOV W4, [W14]
2180:                pac_1_adc_reading = RCFilter16Tau(pac_1_adc_reading, adc_reading);
001D00  804214     MOV pac_1_adc_reading, W4
001D02  78009E     MOV [W14], W1
001D04  780004     MOV W4, W0
001D06  070413     RCALL RCFilter16Tau
001D08  780200     MOV W0, W4
001D0A  884214     MOV W4, pac_1_adc_reading
2181:              
2182:              
2183:                //AN5 - pac_#2                     - 256 samples/tau - Analog Input Bandwidth = 200 Hz
2184:                adc_reading = AverageADC128(pac_2_array);
001D0C  20DDA0     MOV #0xDDA, W0
001D0E  071A47     RCALL _AverageADC128
001D10  780200     MOV W0, W4
001D12  780F04     MOV W4, [W14]
2185:                pac_2_adc_reading = RCFilter16Tau(pac_2_adc_reading, adc_reading);
001D14  804224     MOV pac_2_adc_reading, W4
001D16  78009E     MOV [W14], W1
001D18  780004     MOV W4, W0
001D1A  070409     RCALL RCFilter16Tau
001D1C  780200     MOV W0, W4
001D1E  884224     MOV W4, pac_2_adc_reading
2186:                
2187:              
2188:                if (PIN_FP_SPARE_2_SAMPLE_VPROG_INPUT == ILL_SAMPLE_VPROG_INPUT) {
001D20  801735     MOV PORTG, W5
001D22  240004     MOV #0x4000, W4
001D24  628204     AND W5, W4, W4
001D26  520FE0     SUB W4, #0x0, [W15]
001D28  3A0002     BRA NZ, 0x1D2E
2189:                  default_pac_2_adc_reading = pac_2_adc_reading;
001D2A  804224     MOV pac_2_adc_reading, W4
001D2C  8840A4     MOV W4, default_pac_2_adc_reading
2190:                }
2191:              
2192:              
2193:                //AN6 - Thyratron Cathode Heater   - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2194:                //adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
2195:                //ps_thyr_cathode_htr.v_adc_reading = RCFilter16Tau(ps_thyr_cathode_htr.v_adc_reading, adc_reading);
2196:              
2197:              
2198:                //AN7 - Thyratron Reservoir Heater - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2199:                //adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
2200:                //ps_thyr_reservoir_htr.v_adc_reading = RCFilter16Tau(ps_thyr_reservoir_htr.v_adc_reading, adc_reading);
2201:              
2202:              
2203:                //AN8  - magnet_current            - 16 samples/tau - Analog Input Bandwidth = 200 Hz  
2204:                adc_reading = AverageADC128(magnetron_magnet_current_array);
001D2E  210DA0     MOV #0x10DA, W0
001D30  071A36     RCALL _AverageADC128
001D32  780200     MOV W0, W4
001D34  780F04     MOV W4, [W14]
2205:                ps_magnet.i_adc_reading = RCFilter16Tau(ps_magnet.i_adc_reading, adc_reading);
001D36  805564     MOV 0xAAC, W4
001D38  78009E     MOV [W14], W1
001D3A  780004     MOV W4, W0
001D3C  0703F8     RCALL RCFilter16Tau
001D3E  780200     MOV W0, W4
001D40  885564     MOV W4, 0xAAC
2206:              
2207:                //AN9  - magnet_voltage            - 16 samples/tau - Analog Input Bandwidth = 200 Hz
2208:                adc_reading = AverageADC128(magnetron_magnet_voltage_array);
001D42  211DA0     MOV #0x11DA, W0
001D44  071A2C     RCALL _AverageADC128
001D46  780200     MOV W0, W4
001D48  780F04     MOV W4, [W14]
2209:                ps_magnet.v_adc_reading = RCFilter16Tau(ps_magnet.v_adc_reading, adc_reading);
001D4A  805404     MOV 0xA80, W4
001D4C  78009E     MOV [W14], W1
001D4E  780004     MOV W4, W0
001D50  0703EE     RCALL RCFilter16Tau
001D52  780200     MOV W0, W4
001D54  885404     MOV W4, 0xA80
2210:               
2211:                //AN10 - filament_voltage          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2212:                adc_reading = AverageADC128(magnetron_filament_voltage_array);
001D56  213DA0     MOV #0x13DA, W0
001D58  071A22     RCALL _AverageADC128
001D5A  780200     MOV W0, W4
001D5C  780F04     MOV W4, [W14]
2213:                ps_filament.v_adc_reading = RCFilter16Tau(ps_filament.v_adc_reading, adc_reading);
001D5E  8056D4     MOV 0xADA, W4
001D60  78009E     MOV [W14], W1
001D62  780004     MOV W4, W0
001D64  0703E4     RCALL RCFilter16Tau
001D66  780200     MOV W0, W4
001D68  8856D4     MOV W4, 0xADA
2214:              
2215:                //AN11 - filament_current          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2216:                adc_reading = AverageADC128(magnetron_filament_current_array);
001D6A  212DA0     MOV #0x12DA, W0
001D6C  071A18     RCALL _AverageADC128
001D6E  780200     MOV W0, W4
001D70  780F04     MOV W4, [W14]
2217:                ps_filament.i_adc_reading = RCFilter16Tau(ps_filament.i_adc_reading, adc_reading);
001D72  805834     MOV 0xB06, W4
001D74  78009E     MOV [W14], W1
001D76  780004     MOV W4, W0
001D78  0703DA     RCALL RCFilter16Tau
001D7A  780200     MOV W0, W4
001D7C  885834     MOV W4, 0xB06
2218:              
2219:                //AN12 - lambda_vpeak              - 64 samples/tau - Analog Input Bandwidth = 200 Hz
2220:                adc_reading = AverageADC128(lambda_vpeak_array);
001D7E  214DA0     MOV #0x14DA, W0
001D80  071A0E     RCALL _AverageADC128
001D82  780200     MOV W0, W4
001D84  780F04     MOV W4, [W14]
2221:                ps_hv_lambda_mode_A.v_adc_reading = RCFilter16Tau(ps_hv_lambda_mode_A.v_adc_reading, adc_reading);
001D86  8048C4     MOV 0x918, W4
001D88  78009E     MOV [W14], W1
001D8A  780004     MOV W4, W0
001D8C  0703D0     RCALL RCFilter16Tau
001D8E  780200     MOV W0, W4
001D90  8848C4     MOV W4, 0x918
2222:              
2223:                //AN13 - lambda_vmon               - not averaged / filtered  - Analog Input Bandwidth = 200 Hz
2224:                adc_reading = AverageADC128(lambda_vmon_array);
001D92  215DA0     MOV #0x15DA, W0
001D94  071A04     RCALL _AverageADC128
001D96  780200     MOV W0, W4
001D98  780F04     MOV W4, [W14]
2225:                ps_hv_lambda_mode_B.v_adc_reading = RCFilter16Tau(ps_hv_lambda_mode_B.v_adc_reading, adc_reading);
001D9A  804E64     MOV 0x9CC, W4
001D9C  78009E     MOV [W14], W1
001D9E  780004     MOV W4, W0
001DA0  0703C6     RCALL RCFilter16Tau
001DA2  780200     MOV W0, W4
001DA4  884E64     MOV W4, 0x9CC
2226:                // lambda_vmon is read at EOC
2227:                
2228:              }
001DA6  FA8000     ULNK
001DA8  060000     RETURN
2229:              
2230:              
2231:              
2232:              
2233:              
2234:              void FastReadAndFilterFeedbacks(void) {
001DAA  FA0006     LNK #0x6
2235:                /*
2236:                  This function should be called once durring fast restart.
2237:                  The ADC value array is populated, averaged and the the result of that average used to set initial condition for RC Filter.
2238:              
2239:                  From Internal DAC
2240:                  AN3 -  PFN Rev Current           - Only sampled after a pulse 
2241:               
2242:                  AN4 - pac_#1                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2243:                  AN5 - pac_#2                     - 2.56s tau - Analog Input Bandwidth = 200 Hz
2244:              
2245:                  AN6 - Thyratron Cathode Heater   - 160mS tau - Analog Input Bandwidth = 10 Hz
2246:                  AN7 - Thyratron Reservoir Heater - 160mS tau - Analog Input Bandwidth = 10 Hz
2247:              
2248:                  AN8  - magnet_current            - 160mS tau - Analog Input Bandwidth = 200 Hz
2249:                  AN9  - magnet_voltage            - 160mS tau - Analog Input Bandwidth = 200 Hz
2250:               
2251:                  AN10 - filament_voltage          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2252:                  AN11 - filament_current          - 160mS tau - Analog Input Bandwidth = 200 Hz    
2253:               
2254:                  AN12 - lambda_vpeak              - 640mS tau - Analog Input Bandwidth = 200 Hz
2255:                  AN13 - lambda_vmon               - Only Sampled at EOC
2256:                */
2257:              
2258:              
2259:                unsigned int index;
2260:                unsigned int n;
2261:                unsigned int adc_reading;
2262:                
2263:                // Configure ADC for this particular operation
2264:                ADCON1 = A34760_ADCON1_VALUE;
001DAC  27CFF4     MOV #0x7CFF, W4
001DAE  881504     MOV W4, ADCON1
2265:                ADCON2 = (ADC_VREF_AVDD_AVSS & ADC_SCAN_ON & ADC_SAMPLES_PER_INT_8 & ADC_ALT_BUF_ON & ADC_ALT_INPUT_OFF);
001DB0  20FDE4     MOV #0xFDE, W4
001DB2  881514     MOV W4, ADCON2
2266:                ADCON3 = A34760_ADCON3_VALUE;
001DB4  2E3464     MOV #0xE346, W4
001DB6  881524     MOV W4, ADCON3
2267:                ADCHS  = A34760_ADCHS_VALUE;
001DB8  2EFE34     MOV #0xEFE3, W4
001DBA  881534     MOV W4, ADCHS
2268:                ADPCFG = A34760_ADPCFG_VALUE;
001DBC  2C0074     MOV #0xC007, W4
001DBE  881544     MOV W4, ADPCFG
2269:                ADCSSL = (SKIP_SCAN_AN0 & SKIP_SCAN_AN1 & SKIP_SCAN_AN2 & SKIP_SCAN_AN3 & SKIP_SCAN_AN4 & SKIP_SCAN_AN5 & SKIP_SCAN_AN14 & SKIP_SCAN_AN15);
001DC0  23FC04     MOV #0x3FC0, W4
001DC2  881554     MOV W4, ADCSSL
2270:                ADCON1bits.ADON = 1;
001DC4  A8E2A1     BSET 0x2A1, #7
2271:              
2272:                index = 0;
001DC6  EB0200     CLR W4
001DC8  780F04     MOV W4, [W14]
2273:                while (index < 128) {
001DCA  370080     BRA 0x1ECC
001ECC  2007F4     MOV #0x7F, W4
001ECE  78029E     MOV [W14], W5
001ED0  528F84     SUB W5, W4, [W15]
001ED2  36FF7C     BRA LEU, 0x1DCC
2274:                  while(!_BUFS);
001DCC  000000     NOP
001DCE  801515     MOV ADCON2, W5
001DD0  200804     MOV #0x80, W4
001DD2  628204     AND W5, W4, W4
001DD4  520FE0     SUB W4, #0x0, [W15]
001DD6  32FFFB     BRA Z, 0x1DCE
2275:                  // Copy each reading into 8 data readings 
2276:                  for (n = 0; n < 8; n++) {
001DD8  EB0200     CLR W4
001DDA  980714     MOV W4, [W14+2]
001DDC  370034     BRA 0x1E46
001E40  90021E     MOV [W14+2], W4
001E42  E80204     INC W4, W4
001E44  980714     MOV W4, [W14+2]
001E46  90021E     MOV [W14+2], W4
001E48  520FE7     SUB W4, #0x7, [W15]
001E4A  36FFC9     BRA LEU, 0x1DDE
2277:                    thyratron_cathode_heater_voltage_array[index] = ADCBUF0;
001DDE  801405     MOV ADCBUF0, W5
001DE0  78021E     MOV [W14], W4
001DE2  420304     ADD W4, W4, W6
001DE4  20EDA4     MOV #0xEDA, W4
001DE6  430204     ADD W6, W4, W4
001DE8  780A05     MOV W5, [W4]
2278:                    thyratron_reservoir_heater_voltage_array[index] = ADCBUF1;
001DEA  801415     MOV ADCBUF1, W5
001DEC  78021E     MOV [W14], W4
001DEE  420304     ADD W4, W4, W6
001DF0  20FDA4     MOV #0xFDA, W4
001DF2  430204     ADD W6, W4, W4
001DF4  780A05     MOV W5, [W4]
2279:                    magnetron_magnet_current_array[index] = ADCBUF2;
001DF6  801425     MOV ADCBUF2, W5
001DF8  78021E     MOV [W14], W4
001DFA  420304     ADD W4, W4, W6
001DFC  210DA4     MOV #0x10DA, W4
001DFE  430204     ADD W6, W4, W4
001E00  780A05     MOV W5, [W4]
2280:                    magnetron_magnet_voltage_array[index] = ADCBUF3;
001E02  801435     MOV ADCBUF3, W5
001E04  78021E     MOV [W14], W4
001E06  420304     ADD W4, W4, W6
001E08  211DA4     MOV #0x11DA, W4
001E0A  430204     ADD W6, W4, W4
001E0C  780A05     MOV W5, [W4]
2281:                    magnetron_filament_current_array[index] = ADCBUF4;
001E0E  801445     MOV ADCBUF4, W5
001E10  78021E     MOV [W14], W4
001E12  420304     ADD W4, W4, W6
001E14  212DA4     MOV #0x12DA, W4
001E16  430204     ADD W6, W4, W4
001E18  780A05     MOV W5, [W4]
2282:                    magnetron_filament_voltage_array[index] = ADCBUF5;
001E1A  801455     MOV ADCBUF5, W5
001E1C  78021E     MOV [W14], W4
001E1E  420304     ADD W4, W4, W6
001E20  213DA4     MOV #0x13DA, W4
001E22  430204     ADD W6, W4, W4
001E24  780A05     MOV W5, [W4]
2283:                    lambda_vpeak_array[index] = ADCBUF6;
001E26  801465     MOV ADCBUF6, W5
001E28  78021E     MOV [W14], W4
001E2A  420304     ADD W4, W4, W6
001E2C  214DA4     MOV #0x14DA, W4
001E2E  430204     ADD W6, W4, W4
001E30  780A05     MOV W5, [W4]
2284:                    lambda_vmon_array[index++] = ADCBUF7;
001E32  801475     MOV ADCBUF7, W5
001E34  78021E     MOV [W14], W4
001E36  420304     ADD W4, W4, W6
001E38  215DA4     MOV #0x15DA, W4
001E3A  430204     ADD W6, W4, W4
001E3C  780A05     MOV W5, [W4]
001E3E  E80F1E     INC [W14], [W14]
2285:                  }
2286:                  while(_BUFS);
001E4C  000000     NOP
001E4E  801515     MOV ADCON2, W5
001E50  200804     MOV #0x80, W4
001E52  628204     AND W5, W4, W4
001E54  520FE0     SUB W4, #0x0, [W15]
001E56  3AFFFB     BRA NZ, 0x1E4E
2287:                  // Copy each reading into 8 data readings 
2288:                  for (n = 0; n < 8; n++) {
001E58  EB0200     CLR W4
001E5A  980714     MOV W4, [W14+2]
001E5C  370034     BRA 0x1EC6
001EC0  90021E     MOV [W14+2], W4
001EC2  E80204     INC W4, W4
001EC4  980714     MOV W4, [W14+2]
001EC6  90021E     MOV [W14+2], W4
001EC8  520FE7     SUB W4, #0x7, [W15]
001ECA  36FFC9     BRA LEU, 0x1E5E
2289:                    thyratron_cathode_heater_voltage_array[index] = ADCBUF8;
001E5E  801485     MOV ADCBUF8, W5
001E60  78021E     MOV [W14], W4
001E62  420304     ADD W4, W4, W6
001E64  20EDA4     MOV #0xEDA, W4
001E66  430204     ADD W6, W4, W4
001E68  780A05     MOV W5, [W4]
2290:                    thyratron_reservoir_heater_voltage_array[index] = ADCBUF9;
001E6A  801495     MOV ADCBUF9, W5
001E6C  78021E     MOV [W14], W4
001E6E  420304     ADD W4, W4, W6
001E70  20FDA4     MOV #0xFDA, W4
001E72  430204     ADD W6, W4, W4
001E74  780A05     MOV W5, [W4]
2291:                    magnetron_magnet_current_array[index] = ADCBUFA;
001E76  8014A5     MOV ADCBUFA, W5
001E78  78021E     MOV [W14], W4
001E7A  420304     ADD W4, W4, W6
001E7C  210DA4     MOV #0x10DA, W4
001E7E  430204     ADD W6, W4, W4
001E80  780A05     MOV W5, [W4]
2292:                    magnetron_magnet_voltage_array[index] = ADCBUFB;
001E82  8014B5     MOV ADCBUFB, W5
001E84  78021E     MOV [W14], W4
001E86  420304     ADD W4, W4, W6
001E88  211DA4     MOV #0x11DA, W4
001E8A  430204     ADD W6, W4, W4
001E8C  780A05     MOV W5, [W4]
2293:                    magnetron_filament_current_array[index] = ADCBUFC;
001E8E  8014C5     MOV ADCBUFC, W5
001E90  78021E     MOV [W14], W4
001E92  420304     ADD W4, W4, W6
001E94  212DA4     MOV #0x12DA, W4
001E96  430204     ADD W6, W4, W4
001E98  780A05     MOV W5, [W4]
2294:                    magnetron_filament_voltage_array[index] = ADCBUFD;
001E9A  8014D5     MOV ADCBUFD, W5
001E9C  78021E     MOV [W14], W4
001E9E  420304     ADD W4, W4, W6
001EA0  213DA4     MOV #0x13DA, W4
001EA2  430204     ADD W6, W4, W4
001EA4  780A05     MOV W5, [W4]
2295:                    lambda_vpeak_array[index] = ADCBUFE;
001EA6  8014E5     MOV ADCBUFE, W5
001EA8  78021E     MOV [W14], W4
001EAA  420304     ADD W4, W4, W6
001EAC  214DA4     MOV #0x14DA, W4
001EAE  430204     ADD W6, W4, W4
001EB0  780A05     MOV W5, [W4]
2296:                    lambda_vmon_array[index++] = ADCBUFF;
001EB2  8014F5     MOV ADCBUFF, W5
001EB4  78021E     MOV [W14], W4
001EB6  420304     ADD W4, W4, W6
001EB8  215DA4     MOV #0x15DA, W4
001EBA  430204     ADD W6, W4, W4
001EBC  780A05     MOV W5, [W4]
001EBE  E80F1E     INC [W14], [W14]
2297:                  }
2298:                }
2299:                ADCON1bits.ADON = 0;
001ED4  A9E2A1     BCLR 0x2A1, #7
2300:              
2301:                //AN6 - Thyratron Cathode Heater   - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2302:                adc_reading = AverageADC128(thyratron_cathode_heater_voltage_array);
001ED6  20EDA0     MOV #0xEDA, W0
001ED8  071962     RCALL _AverageADC128
001EDA  780200     MOV W0, W4
001EDC  980724     MOV W4, [W14+4]
2303:                ps_thyr_cathode_htr.v_adc_reading = adc_reading;
001EDE  90022E     MOV [W14+4], W4
001EE0  8859A4     MOV W4, 0xB34
2304:              
2305:                //AN7 - Thyratron Reservoir Heater - 16 samples/tau - Analog Input Bandwidth = 10 Hz
2306:                adc_reading = AverageADC128(thyratron_reservoir_heater_voltage_array);
001EE2  20FDA0     MOV #0xFDA, W0
001EE4  07195C     RCALL _AverageADC128
001EE6  780200     MOV W0, W4
001EE8  980724     MOV W4, [W14+4]
2307:                ps_thyr_reservoir_htr.v_adc_reading = adc_reading;
001EEA  90022E     MOV [W14+4], W4
001EEC  885C74     MOV W4, 0xB8E
2308:              
2309:                //AN8  - magnet_current            - 16 samples/tau - Analog Input Bandwidth = 200 Hz  
2310:                adc_reading = AverageADC128(magnetron_magnet_current_array);
001EEE  210DA0     MOV #0x10DA, W0
001EF0  071956     RCALL _AverageADC128
001EF2  780200     MOV W0, W4
001EF4  980724     MOV W4, [W14+4]
2311:                ps_magnet.i_adc_reading = adc_reading;
001EF6  90022E     MOV [W14+4], W4
001EF8  885564     MOV W4, 0xAAC
2312:              
2313:                //AN9  - magnet_voltage            - 16 samples/tau - Analog Input Bandwidth = 200 Hz
2314:                adc_reading = AverageADC128(magnetron_magnet_voltage_array);
001EFA  211DA0     MOV #0x11DA, W0
001EFC  071950     RCALL _AverageADC128
001EFE  780200     MOV W0, W4
001F00  980724     MOV W4, [W14+4]
2315:                ps_magnet.v_adc_reading = adc_reading;
001F02  90022E     MOV [W14+4], W4
001F04  885404     MOV W4, 0xA80
2316:               
2317:                //AN10 - filament_voltage          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2318:                adc_reading = AverageADC128(magnetron_filament_voltage_array);
001F06  213DA0     MOV #0x13DA, W0
001F08  07194A     RCALL _AverageADC128
001F0A  780200     MOV W0, W4
001F0C  980724     MOV W4, [W14+4]
2319:                ps_filament.v_adc_reading = adc_reading;
001F0E  90022E     MOV [W14+4], W4
001F10  8856D4     MOV W4, 0xADA
2320:              
2321:                //AN11 - filament_current          - 16 samples/tau - Analog Input Bandwidth = 200 Hz    
2322:                adc_reading = AverageADC128(magnetron_filament_current_array);
001F12  212DA0     MOV #0x12DA, W0
001F14  071944     RCALL _AverageADC128
001F16  780200     MOV W0, W4
001F18  980724     MOV W4, [W14+4]
2323:                ps_filament.i_adc_reading = adc_reading;
001F1A  90022E     MOV [W14+4], W4
001F1C  885834     MOV W4, 0xB06
2324:              
2325:                //AN12 - lambda_vpeak              - 64 samples/tau - Analog Input Bandwidth = 200 Hz
2326:                adc_reading = AverageADC128(lambda_vpeak_array);
001F1E  214DA0     MOV #0x14DA, W0
001F20  07193E     RCALL _AverageADC128
001F22  780200     MOV W0, W4
001F24  980724     MOV W4, [W14+4]
2327:                ps_hv_lambda_mode_A.v_adc_reading = adc_reading;
001F26  90022E     MOV [W14+4], W4
001F28  8848C4     MOV W4, 0x918
2328:              
2329:                //AN13 - lambda_vmon               - not averaged / filtered  - Analog Input Bandwidth = 200 Hz
2330:                adc_reading = AverageADC128(lambda_vmon_array);
001F2A  215DA0     MOV #0x15DA, W0
001F2C  071938     RCALL _AverageADC128
001F2E  780200     MOV W0, W4
001F30  980724     MOV W4, [W14+4]
2331:                ps_hv_lambda_mode_B.v_adc_reading = adc_reading;
001F32  90022E     MOV [W14+4], W4
001F34  884E64     MOV W4, 0x9CC
2332:              
2333:              }
001F36  FA8000     ULNK
001F38  060000     RETURN
2334:              
2335:              
2336:              
2337:              
2338:              void FastReadAndFilterPACInputs(void) {
001F3A  FA0006     LNK #0x6
2339:                unsigned int index;
2340:                unsigned int n;
2341:                unsigned int adc_reading;
2342:                
2343:                // Configure ADC for this particular operation
2344:                ADCON1 = A34760_ADCON1_VALUE;
001F3C  27CFF4     MOV #0x7CFF, W4
001F3E  881504     MOV W4, ADCON1
2345:                ADCON2 = (ADC_VREF_AVDD_AVSS & ADC_SCAN_ON & ADC_SAMPLES_PER_INT_8 & ADC_ALT_BUF_ON & ADC_ALT_INPUT_OFF);
001F40  20FDE4     MOV #0xFDE, W4
001F42  881514     MOV W4, ADCON2
2346:                ADCON3 = A34760_ADCON3_VALUE;
001F44  2E3464     MOV #0xE346, W4
001F46  881524     MOV W4, ADCON3
2347:                ADCHS  = A34760_ADCHS_VALUE;
001F48  2EFE34     MOV #0xEFE3, W4
001F4A  881534     MOV W4, ADCHS
2348:                ADPCFG = A34760_ADPCFG_VALUE;
001F4C  2C0074     MOV #0xC007, W4
001F4E  881544     MOV W4, ADPCFG
2349:                ADCSSL = (SKIP_SCAN_AN0 & SKIP_SCAN_AN1 & SKIP_SCAN_AN2 & SKIP_SCAN_AN3 & SKIP_SCAN_AN6 & SKIP_SCAN_AN7 & SKIP_SCAN_AN8 & SKIP_SCAN_AN9 & SKIP_SCAN_AN10 & SKIP_SCAN_AN11 & SKIP_SCAN_AN12 & SKIP_SCAN_AN13 & SKIP_SCAN_AN14 & SKIP_SCAN_AN15);
001F50  200304     MOV #0x30, W4
001F52  881554     MOV W4, ADCSSL
2350:                ADCON1bits.ADON = 1;
001F54  A8E2A1     BSET 0x2A1, #7
2351:              
2352:                
2353:                // Repeate the sample sequence until we have filled up the pac arrays
2354:                index = 0;
001F56  EB0200     CLR W4
001F58  780F04     MOV W4, [W14]
2355:                while (index < 128) {
001F5A  370086     BRA 0x2068
002068  2007F4     MOV #0x7F, W4
00206A  78029E     MOV [W14], W5
00206C  528F84     SUB W5, W4, [W15]
00206E  36FF76     BRA LEU, 0x1F5C
2356:                  // wait for buffer 0-8 to fill up
2357:                  while(!_BUFS);
001F5C  000000     NOP
001F5E  801515     MOV ADCON2, W5
001F60  200804     MOV #0x80, W4
001F62  628204     AND W5, W4, W4
001F64  520FE0     SUB W4, #0x0, [W15]
001F66  32FFFB     BRA Z, 0x1F5E
2358:                  for (n = 0; n < 4; n++) {
001F68  EB0200     CLR W4
001F6A  980714     MOV W4, [W14+2]
001F6C  370037     BRA 0x1FDC
001FD6  90021E     MOV [W14+2], W4
001FD8  E80204     INC W4, W4
001FDA  980714     MOV W4, [W14+2]
001FDC  90021E     MOV [W14+2], W4
001FDE  520FE3     SUB W4, #0x3, [W15]
001FE0  36FFC6     BRA LEU, 0x1F6E
2359:                    pac_1_array[index] = ADCBUF0;
001F6E  801405     MOV ADCBUF0, W5
001F70  78021E     MOV [W14], W4
001F72  420304     ADD W4, W4, W6
001F74  20CDA4     MOV #0xCDA, W4
001F76  430204     ADD W6, W4, W4
001F78  780A05     MOV W5, [W4]
2360:                    pac_2_array[index++] = ADCBUF1;
001F7A  801415     MOV ADCBUF1, W5
001F7C  78021E     MOV [W14], W4
001F7E  420304     ADD W4, W4, W6
001F80  20DDA4     MOV #0xDDA, W4
001F82  430204     ADD W6, W4, W4
001F84  780A05     MOV W5, [W4]
001F86  E80F1E     INC [W14], [W14]
2361:                    pac_1_array[index] = ADCBUF2;
001F88  801425     MOV ADCBUF2, W5
001F8A  78021E     MOV [W14], W4
001F8C  420304     ADD W4, W4, W6
001F8E  20CDA4     MOV #0xCDA, W4
001F90  430204     ADD W6, W4, W4
001F92  780A05     MOV W5, [W4]
2362:                    pac_2_array[index++] = ADCBUF3;
001F94  801435     MOV ADCBUF3, W5
001F96  78021E     MOV [W14], W4
001F98  420304     ADD W4, W4, W6
001F9A  20DDA4     MOV #0xDDA, W4
001F9C  430204     ADD W6, W4, W4
001F9E  780A05     MOV W5, [W4]
001FA0  E80F1E     INC [W14], [W14]
2363:                    pac_1_array[index] = ADCBUF4;
001FA2  801445     MOV ADCBUF4, W5
001FA4  78021E     MOV [W14], W4
001FA6  420304     ADD W4, W4, W6
001FA8  20CDA4     MOV #0xCDA, W4
001FAA  430204     ADD W6, W4, W4
001FAC  780A05     MOV W5, [W4]
2364:                    pac_2_array[index++] = ADCBUF5;
001FAE  801455     MOV ADCBUF5, W5
001FB0  78021E     MOV [W14], W4
001FB2  420304     ADD W4, W4, W6
001FB4  20DDA4     MOV #0xDDA, W4
001FB6  430204     ADD W6, W4, W4
001FB8  780A05     MOV W5, [W4]
001FBA  E80F1E     INC [W14], [W14]
2365:                    pac_1_array[index] = ADCBUF6;
001FBC  801465     MOV ADCBUF6, W5
001FBE  78021E     MOV [W14], W4
001FC0  420304     ADD W4, W4, W6
001FC2  20CDA4     MOV #0xCDA, W4
001FC4  430204     ADD W6, W4, W4
001FC6  780A05     MOV W5, [W4]
2366:                    pac_2_array[index++] = ADCBUF7;  
001FC8  801475     MOV ADCBUF7, W5
001FCA  78021E     MOV [W14], W4
001FCC  420304     ADD W4, W4, W6
001FCE  20DDA4     MOV #0xDDA, W4
001FD0  430204     ADD W6, W4, W4
001FD2  780A05     MOV W5, [W4]
001FD4  E80F1E     INC [W14], [W14]
2367:                  }
2368:                  
2369:                  // wait for buffers 9-F to fill up
2370:                  while(_BUFS);
001FE2  000000     NOP
001FE4  801515     MOV ADCON2, W5
001FE6  200804     MOV #0x80, W4
001FE8  628204     AND W5, W4, W4
001FEA  520FE0     SUB W4, #0x0, [W15]
001FEC  3AFFFB     BRA NZ, 0x1FE4
2371:                  for (n = 0; n < 4; n++) {
001FEE  EB0200     CLR W4
001FF0  980714     MOV W4, [W14+2]
001FF2  370037     BRA 0x2062
00205C  90021E     MOV [W14+2], W4
00205E  E80204     INC W4, W4
002060  980714     MOV W4, [W14+2]
002062  90021E     MOV [W14+2], W4
002064  520FE3     SUB W4, #0x3, [W15]
002066  36FFC6     BRA LEU, 0x1FF4
2372:                    pac_1_array[index] = ADCBUF8;
001FF4  801485     MOV ADCBUF8, W5
001FF6  78021E     MOV [W14], W4
001FF8  420304     ADD W4, W4, W6
001FFA  20CDA4     MOV #0xCDA, W4
001FFC  430204     ADD W6, W4, W4
001FFE  780A05     MOV W5, [W4]
2373:                    pac_2_array[index++] = ADCBUF9;
002000  801495     MOV ADCBUF9, W5
002002  78021E     MOV [W14], W4
002004  420304     ADD W4, W4, W6
002006  20DDA4     MOV #0xDDA, W4
002008  430204     ADD W6, W4, W4
00200A  780A05     MOV W5, [W4]
00200C  E80F1E     INC [W14], [W14]
2374:                    pac_1_array[index] = ADCBUFA;
00200E  8014A5     MOV ADCBUFA, W5
002010  78021E     MOV [W14], W4
002012  420304     ADD W4, W4, W6
002014  20CDA4     MOV #0xCDA, W4
002016  430204     ADD W6, W4, W4
002018  780A05     MOV W5, [W4]
2375:                    pac_2_array[index++] = ADCBUFB;
00201A  8014B5     MOV ADCBUFB, W5
00201C  78021E     MOV [W14], W4
00201E  420304     ADD W4, W4, W6
002020  20DDA4     MOV #0xDDA, W4
002022  430204     ADD W6, W4, W4
002024  780A05     MOV W5, [W4]
002026  E80F1E     INC [W14], [W14]
2376:                    pac_1_array[index] = ADCBUFC;
002028  8014C5     MOV ADCBUFC, W5
00202A  78021E     MOV [W14], W4
00202C  420304     ADD W4, W4, W6
00202E  20CDA4     MOV #0xCDA, W4
002030  430204     ADD W6, W4, W4
002032  780A05     MOV W5, [W4]
2377:                    pac_2_array[index++] = ADCBUFD;
002034  8014D5     MOV ADCBUFD, W5
002036  78021E     MOV [W14], W4
002038  420304     ADD W4, W4, W6
00203A  20DDA4     MOV #0xDDA, W4
00203C  430204     ADD W6, W4, W4
00203E  780A05     MOV W5, [W4]
002040  E80F1E     INC [W14], [W14]
2378:                    pac_1_array[index] = ADCBUFE;
002042  8014E5     MOV ADCBUFE, W5
002044  78021E     MOV [W14], W4
002046  420304     ADD W4, W4, W6
002048  20CDA4     MOV #0xCDA, W4
00204A  430204     ADD W6, W4, W4
00204C  780A05     MOV W5, [W4]
2379:                    pac_2_array[index++] = ADCBUFF;  
00204E  8014F5     MOV ADCBUFF, W5
002050  78021E     MOV [W14], W4
002052  420304     ADD W4, W4, W6
002054  20DDA4     MOV #0xDDA, W4
002056  430204     ADD W6, W4, W4
002058  780A05     MOV W5, [W4]
00205A  E80F1E     INC [W14], [W14]
2380:                  }    
2381:                }
2382:                ADCON1bits.ADON = 0;
002070  A9E2A1     BCLR 0x2A1, #7
2383:                
2384:              
2385:                // Average Pac Array and Populte the RC Filter
2386:                // This is just copied from Filter ADCs
2387:                adc_reading = AverageADC128(pac_1_array);
002072  20CDA0     MOV #0xCDA, W0
002074  071894     RCALL _AverageADC128
002076  780200     MOV W0, W4
002078  980724     MOV W4, [W14+4]
2388:                pac_1_adc_reading = adc_reading;
00207A  90022E     MOV [W14+4], W4
00207C  884214     MOV W4, pac_1_adc_reading
2389:                
2390:                adc_reading = AverageADC128(pac_2_array);
00207E  20DDA0     MOV #0xDDA, W0
002080  07188E     RCALL _AverageADC128
002082  780200     MOV W0, W4
002084  980724     MOV W4, [W14+4]
2391:                pac_2_adc_reading = adc_reading;
002086  90022E     MOV [W14+4], W4
002088  884224     MOV W4, pac_2_adc_reading
2392:              }
00208A  FA8000     ULNK
00208C  060000     RETURN
2393:              
2394:              
2395:              
2396:              
2397:              
2398:              
2399:              void ExitHvOnState(void) {
00208E  FA0004     LNK #0x4
2400:                // this subroutine is called to properly shut down the HV on state
2401:                // This required interrupts to be disabled/cleared/ect
2402:                
2403:                SET_CPU_IPL(7); // Disable all interrupts
002090  800294     MOV DISICNT, W4
002092  780F04     MOV W4, [W14]
002094  FC3FFF     DISI #0x3FFF
002096  800214     MOV SR, W4
002098  A05004     BSET W4, #5
00209A  A06004     BSET W4, #6
00209C  A07004     BSET W4, #7
00209E  880214     MOV W4, SR
0020A0  78021E     MOV [W14], W4
0020A2  880294     MOV W4, DISICNT
0020A4  880000     MOV W0, WREG0
2404:                Nop();
0020A6  000000     NOP
2405:                Nop();
0020A8  000000     NOP
2406:                Nop();
0020AA  000000     NOP
2407:                Nop();
0020AC  000000     NOP
2408:                _T1IE = 0;      // Disable the T1 interrupt.  The T1 interrupt enables INT1 Interrupt
0020AE  A9608C     BCLR IEC0, #3
2409:                _INT1IE = 0;    // Disable the INT1 Interrupt.  INT1 enables T1 Interrupt.
0020B0  A9008E     BCLR IEC1, #0
2410:                SET_CPU_IPL(0); // Enable all interrupts
0020B2  800294     MOV DISICNT, W4
0020B4  980714     MOV W4, [W14+2]
0020B6  FC3FFF     DISI #0x3FFF
0020B8  800214     MOV SR, W4
0020BA  A15004     BCLR W4, #5
0020BC  A16004     BCLR W4, #6
0020BE  A17004     BCLR W4, #7
0020C0  880214     MOV W4, SR
0020C2  90021E     MOV [W14+2], W4
0020C4  880294     MOV W4, DISICNT
0020C6  880000     MOV W0, WREG0
2411:                SavePulseCountersToEEPROM();
0020C8  070003     RCALL SavePulseCountersToEEPROM
2412:                PIN_FAST_RESTART_STORAGE_CAP_OUTPUT = !OLL_DO_FAST_RESTART;
0020CA  A8E2CB     BSET 0x2CB, #7
2413:              }
0020CC  FA8000     ULNK
0020CE  060000     RETURN
2414:              
2415:              void SavePulseCountersToEEPROM(void) {
0020D0  FA0002     LNK #0x2
2416:                unsigned int *unsigned_int_ptr;
2417:                unsigned_int_ptr = &pulse_counter_persistent;              //unsigned_int_ptr now points to the Least Significant word of pulse_counter_persistent
0020D2  218BC4     MOV #0x18BC, W4
0020D4  780F04     MOV W4, [W14]
2418:                pulse_counter_repository_ram_copy[3] = *unsigned_int_ptr; 
0020D6  78021E     MOV [W14], W4
0020D8  780214     MOV [W4], W4
0020DA  88C0F4     MOV W4, 0x181E
2419:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
0020DC  E88F1E     INC2 [W14], [W14]
2420:                pulse_counter_repository_ram_copy[2] = *unsigned_int_ptr;
0020DE  78021E     MOV [W14], W4
0020E0  780214     MOV [W4], W4
0020E2  88C0E4     MOV W4, 0x181C
2421:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the next lest signigicant word of pulse_counter_persistent
0020E4  E88F1E     INC2 [W14], [W14]
2422:                pulse_counter_repository_ram_copy[1] = *unsigned_int_ptr;
0020E6  78021E     MOV [W14], W4
0020E8  780214     MOV [W4], W4
0020EA  88C0D4     MOV W4, 0x181A
2423:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of pulse_counter_persistent
0020EC  E88F1E     INC2 [W14], [W14]
2424:                pulse_counter_repository_ram_copy[0] = *unsigned_int_ptr;
0020EE  78021E     MOV [W14], W4
0020F0  780214     MOV [W4], W4
0020F2  88C0C4     MOV W4, pulse_counter_repository_ram_copy
2425:                
2426:                
2427:                unsigned_int_ptr = &arc_counter_persistent;                //unsigned_int_ptr now points to the Least Significant word of arc_counter_persistent
0020F4  218CA4     MOV #0x18CA, W4
0020F6  780F04     MOV W4, [W14]
2428:                pulse_counter_repository_ram_copy[5] = *unsigned_int_ptr;
0020F8  78021E     MOV [W14], W4
0020FA  780214     MOV [W4], W4
0020FC  88C114     MOV W4, 0x1822
2429:                unsigned_int_ptr++;                                        //unsigned_int_ptr now points to the most signigicant word of arc_counter_persistent
0020FE  E88F1E     INC2 [W14], [W14]
2430:                pulse_counter_repository_ram_copy[4] = *unsigned_int_ptr;
002100  78021E     MOV [W14], W4
002102  780214     MOV [W4], W4
002104  88C104     MOV W4, 0x1820
2431:              
2432:                // The values have now been saved to the array in RAM.  Save the RAM data to EEPROM
2433:                _wait_eedata();
002106  803B05     MOV NVMCON, W5
002108  280004     MOV #0x8000, W4
00210A  628204     AND W5, W4, W4
00210C  520FE0     SUB W4, #0x0, [W15]
00210E  3AFFFB     BRA NZ, 0x2106
2434:                _erase_eedata(EE_address_pulse_counter_repository_in_EEPROM, _EE_ROW);
002110  80C0A4     MOV EE_address_pulse_counter_repository_in_EEPROM, W4
002112  80C0B5     MOV 0x1816, W5
002114  200202     MOV #0x20, W2
002116  BE0004     MOV.D W4, W0
002118  07F07C     RCALL __eedata_helper1
2435:                _wait_eedata();
00211A  803B05     MOV NVMCON, W5
00211C  280004     MOV #0x8000, W4
00211E  628204     AND W5, W4, W4
002120  520FE0     SUB W4, #0x0, [W15]
002122  3AFFFB     BRA NZ, 0x211A
2436:                _write_eedata_row(EE_address_pulse_counter_repository_in_EEPROM, pulse_counter_repository_ram_copy);
002124  80C0A4     MOV EE_address_pulse_counter_repository_in_EEPROM, W4
002126  80C0B5     MOV 0x1816, W5
002128  218182     MOV #0x1818, W2
00212A  BE0004     MOV.D W4, W0
00212C  07F091     RCALL __eedata_helper4
2437:              }
00212E  FA8000     ULNK
002130  060000     RETURN
2438:              
2439:              
2440:              void DoColdShutDown(void) {
002132  FA0000     LNK #0x0
2441:                /*
2442:                  This is a function to safely move from any state to cold state
2443:              
2444:                  The following actions occur
2445:                  * The HV Lambda is disabled
2446:                  * The Filament supply is disabled
2447:                  * The magnet supply is disabled
2448:                  * The thyratron DACs are set to Zero //DPARKER how to do with without PID taking over
2449:                  
2450:                  // DPARKER when do we write values from EEPROM to RAM
2451:                  */
2452:                DisableHVLambdaSupply();
002134  07005C     RCALL DisableHVLambdaSupply
2453:                DisableMagnetronFilamentSupply();
002136  07004F     RCALL DisableMagnetronFilamentSupply
2454:                DisableMagnetronMagnetSupply();
002138  070056     RCALL DisableMagnetronMagnetSupply
2455:                ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
00213A  200642     MOV #0x64, W2
00213C  EB0080     CLR W1
00213E  209080     MOV #0x908, W0
002140  07F9DA     RCALL ScalePowerSupply
2456:                ScalePowerSupply(&ps_hv_lambda_mode_A,0,100);
002142  200642     MOV #0x64, W2
002144  EB0080     CLR W1
002146  209080     MOV #0x908, W0
002148  07F9D6     RCALL ScalePowerSupply
2457:                ScalePowerSupply(&ps_filament,0,100);
00214A  200642     MOV #0x64, W2
00214C  EB0080     CLR W1
00214E  20ACA0     MOV #0xACA, W0
002150  07F9D2     RCALL ScalePowerSupply
2458:                ScalePowerSupply(&ps_magnet,0,100);
002152  200642     MOV #0x64, W2
002154  EB0080     CLR W1
002156  20A700     MOV #0xA70, W0
002158  07F9CE     RCALL ScalePowerSupply
2459:                ScalePowerSupply(&ps_thyr_reservoir_htr,0,100);
00215A  200642     MOV #0x64, W2
00215C  EB0080     CLR W1
00215E  20B7E0     MOV #0xB7E, W0
002160  07F9CA     RCALL ScalePowerSupply
2460:                ScalePowerSupply(&ps_thyr_cathode_htr,0,100);
002162  200642     MOV #0x64, W2
002164  EB0080     CLR W1
002166  20B240     MOV #0xB24, W0
002168  07F9C6     RCALL ScalePowerSupply
2461:              
2462:                //DPARKER need to do more to shut down the PID loops
2463:                PIDInit(&thyratron_reservoir_heater_PID);
00216A  208580     MOV #0x858, W0
00216C  07F02F     RCALL _PIDInit
2464:                PIDInit(&thyratron_cathode_heater_PID);
00216E  208620     MOV #0x862, W0
002170  07F02D     RCALL _PIDInit
2465:              
2466:                T1CONbits.TON = 0;
002172  A9E105     BCLR 0x105, #7
2467:                _INT1IE = 0;
002174  A9008E     BCLR IEC1, #0
2468:                _T1IE = 0;
002176  A9608C     BCLR IEC0, #3
2469:                _INT1IF = 0;
002178  A90086     BCLR IFS1, #0
2470:                _T1IF = 0;
00217A  A96084     BCLR IFS0, #3
2471:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
00217C  A9C2C4     BCLR LATA, #6
2472:              }
00217E  FA8000     ULNK
002180  060000     RETURN
2473:              
2474:              
2475:              void DoWarmShutDown(void) {
002182  FA0000     LNK #0x0
2476:                /*
2477:                  This function is called to safely move from any warm/HV on state to, warm state
2478:              
2479:                  The Following Actions occur
2480:                  * The HV Lambda is disabled
2481:                  * Clean up Interupts associated with pulsing
2482:                  
2483:                  // DPARKER when do we write values from EEPROM TO RAM???
2484:                  */
2485:                DisableHVLambdaSupply();
002184  070034     RCALL DisableHVLambdaSupply
2486:                T1CONbits.TON = 0;
002186  A9E105     BCLR 0x105, #7
2487:                _INT1IE = 0;
002188  A9008E     BCLR IEC1, #0
2488:                _T1IE = 0;
00218A  A9608C     BCLR IEC0, #3
2489:                _INT1IF = 0;
00218C  A90086     BCLR IFS1, #0
2490:                _T1IF = 0;
00218E  A96084     BCLR IFS0, #3
2491:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;
002190  A9C2C4     BCLR LATA, #6
2492:              }
002192  FA8000     ULNK
002194  060000     RETURN
2493:              
2494:              
2495:              
2496:              
2497:              void StartWarmUp(void) {
002196  FA0000     LNK #0x0
2498:                /*
2499:                  This subroutine is called at the start of the warmup process.
2500:                  It enables the heater and magnet supplies at zero and starts the ramp process
2501:                  
2502:                  + Set all outputs to Zero
2503:                  + Setup TMR2 for 100ms Intervals
2504:                */  
2505:              
2506:                PIDInit(&thyratron_reservoir_heater_PID);
002198  208580     MOV #0x858, W0
00219A  07F018     RCALL _PIDInit
2507:                PIDInit(&thyratron_cathode_heater_PID);
00219C  208620     MOV #0x862, W0
00219E  07F016     RCALL _PIDInit
2508:              
2509:                ScalePowerSupply(&ps_magnet, 0, 100);
0021A0  200642     MOV #0x64, W2
0021A2  EB0080     CLR W1
0021A4  20A700     MOV #0xA70, W0
0021A6  07F9A7     RCALL ScalePowerSupply
2510:                ScalePowerSupply(&ps_filament, 0, 100);
0021A8  200642     MOV #0x64, W2
0021AA  EB0080     CLR W1
0021AC  20ACA0     MOV #0xACA, W0
0021AE  07F9A3     RCALL ScalePowerSupply
2511:                ScalePowerSupply(&ps_thyr_cathode_htr, 0, 100);
0021B0  200642     MOV #0x64, W2
0021B2  EB0080     CLR W1
0021B4  20B240     MOV #0xB24, W0
0021B6  07F99F     RCALL ScalePowerSupply
2512:                ScalePowerSupply(&ps_thyr_reservoir_htr, 0, 100);
0021B8  200642     MOV #0x64, W2
0021BA  EB0080     CLR W1
0021BC  20B7E0     MOV #0xB7E, W0
0021BE  07F99B     RCALL ScalePowerSupply
2513:              
2514:                EnableMagnetronMagnetSupply();
0021C0  07000E     RCALL EnableMagnetronMagnetSupply
2515:                EnableMagnetronFilamentSupply();
0021C2  070005     RCALL EnableMagnetronFilamentSupply
2516:              
2517:                TMR2 = 0;
0021C4  EB0200     CLR W4
0021C6  880834     MOV W4, TMR2
2518:                _T2IF = 0;
0021C8  A9C084     BCLR IFS0, #6
2519:              }
0021CA  FA8000     ULNK
0021CC  060000     RETURN
2520:              
2521:              
2522:              
2523:              
2524:              void EnableMagnetronFilamentSupply(void) {
0021CE  FA0000     LNK #0x0
2525:                PIN_MAGNETRON_FILAMENT_ENABLE = OLL_MAGNETRON_FILAMENT_ENABLED;
0021D0  A802D7     BSET 0x2D7, #0
2526:              }
0021D2  FA8000     ULNK
0021D4  060000     RETURN
2527:              
2528:              void DisableMagnetronFilamentSupply(void) {
0021D6  FA0000     LNK #0x0
2529:                PIN_MAGNETRON_FILAMENT_ENABLE = !OLL_MAGNETRON_FILAMENT_ENABLED;
0021D8  A902D7     BCLR 0x2D7, #0
2530:              }
0021DA  FA8000     ULNK
0021DC  060000     RETURN
2531:              
2532:              void EnableMagnetronMagnetSupply(void) {
0021DE  FA0000     LNK #0x0
2533:                PIN_MAGNETRON_MAGNET_ENABLE = OLL_MAGNETRON_MAGNET_ENABLED;
0021E0  A822D7     BSET 0x2D7, #1
2534:              }
0021E2  FA8000     ULNK
0021E4  060000     RETURN
2535:              
2536:              void DisableMagnetronMagnetSupply(void) {
0021E6  FA0000     LNK #0x0
2537:                PIN_MAGNETRON_MAGNET_ENABLE = !OLL_MAGNETRON_MAGNET_ENABLED;
0021E8  A922D7     BCLR 0x2D7, #1
2538:              }
0021EA  FA8000     ULNK
0021EC  060000     RETURN
2539:              
2540:              
2541:              void DisableHVLambdaSupply(void) {
0021EE  FA0000     LNK #0x0
2542:                PIN_HV_LAMBDA_ENABLE = !OLL_HV_LAMBDA_ENABLED;
0021F0  A962D7     BCLR 0x2D7, #3
2543:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;
0021F2  A802D6     BSET LATD, #0
2544:              }
0021F4  FA8000     ULNK
0021F6  060000     RETURN
2545:              
2546:              
2547:              void UpdateIOExpanderOutputs(void) {
0021F8  FA0004     LNK #0x4
2548:                // This updates all of the LED/Digital Outputs From the Control Board
2549:                // See 34-34357 for the configuration of the output polarities
2550:              
2551:                // All of the outputs are "Active Low"
2552:                // For Faults - The Fault state is "NOT ACTIVE" or a "high output"
2553:                // FOr HV ON - HV On is the "Not Active" state or "high otuput"
2554:              
2555:                unsigned int temp_lat_a;
2556:                unsigned int temp_lat_b;
2557:                
2558:                temp_lat_a = 0x00;
0021FA  EB0200     CLR W4
0021FC  780F04     MOV W4, [W14]
2559:                temp_lat_b = 0x00;
0021FE  EB0200     CLR W4
002200  980714     MOV W4, [W14+2]
2560:              
2561:                last_known_action = LAST_ACTION_UPDATE_IO_EXPANDER;
002202  200054     MOV #0x5, W4
002204  88C6B4     MOV W4, last_known_action
2562:                
2563:                if ((control_state == STATE_SYSTEM_WARM_READY) || (control_state == STATE_HV_ON) || (control_state == STATE_FAULT_WARM_FAULT) || (control_state == STATE_HV_STARTUP)) {
002206  208405     MOV #0x840, W5
002208  784295     MOV.B [W5], W5
00220A  B3C344     MOV.B #0x34, W4
00220C  52CF84     SUB.B W5, W4, [W15]
00220E  32000F     BRA Z, 0x222E
002210  208405     MOV #0x840, W5
002212  784295     MOV.B [W5], W5
002214  B3C444     MOV.B #0x44, W4
002216  52CF84     SUB.B W5, W4, [W15]
002218  32000A     BRA Z, 0x222E
00221A  208405     MOV #0x840, W5
00221C  784295     MOV.B [W5], W5
00221E  B3CA84     MOV.B #0xA8, W4
002220  52CF84     SUB.B W5, W4, [W15]
002222  320005     BRA Z, 0x222E
002224  208405     MOV #0x840, W5
002226  784295     MOV.B [W5], W5
002228  B3C354     MOV.B #0x35, W4
00222A  52CF84     SUB.B W5, W4, [W15]
00222C  3A0005     BRA NZ, 0x2238
2564:                  // warmup_done bit is active.  Clear this bit
2565:                  temp_lat_b &= ~BIT_OUTPUT_MODULATOR_WARMUP_DONE;
00222E  90029E     MOV [W14+2], W5
002230  2FF7F4     MOV #0xFF7F, W4
002232  628204     AND W5, W4, W4
002234  980714     MOV W4, [W14+2]
002236  370004     BRA 0x2240
2566:                } else {
2567:                  temp_lat_b |= BIT_OUTPUT_MODULATOR_WARMUP_DONE;
002238  90029E     MOV [W14+2], W5
00223A  200804     MOV #0x80, W4
00223C  728204     IOR W5, W4, W4
00223E  980714     MOV W4, [W14+2]
2568:                }
2569:              
2570:                if (faults_control_board_fault_reg) {
002240  80C444     MOV faults_control_board_fault_reg, W4
002242  520FE0     SUB W4, #0x0, [W15]
002244  320004     BRA Z, 0x224E
2571:                  temp_lat_b |= BIT_OUTPUT_CONTROL_BOARD_FAULT;   
002246  90021E     MOV [W14+2], W4
002248  A00004     BSET W4, #0
00224A  980714     MOV W4, [W14+2]
00224C  370004     BRA 0x2256
2572:                } else {
2573:                  temp_lat_b &= ~BIT_OUTPUT_CONTROL_BOARD_FAULT;
00224E  90029E     MOV [W14+2], W5
002250  2FFFE4     MOV #0xFFFE, W4
002252  628204     AND W5, W4, W4
002254  980714     MOV W4, [W14+2]
2574:                }
2575:                
2576:                if (faults_thyratron_fault_reg) {
002256  80C414     MOV faults_thyratron_fault_reg, W4
002258  520FE0     SUB W4, #0x0, [W15]
00225A  320002     BRA Z, 0x2260
2577:                  // a thyratron fault is active - Set this bit
2578:                  temp_lat_a |= BIT_OUTPUT_THYRATRON_FAULT;
00225C  A0201E     BSET [W14], #2
00225E  370002     BRA 0x2264
2579:                } else {
2580:                  temp_lat_a &= ~BIT_OUTPUT_THYRATRON_FAULT;
002260  2FFFB4     MOV #0xFFFB, W4
002262  620F1E     AND W4, [W14], [W14]
2581:                }
2582:                
2583:                if (faults_magnetron_fault_reg & 0xFF00) {
002264  80C3B5     MOV faults_magnetron_fault_reg, W5
002266  2FF004     MOV #0xFF00, W4
002268  628204     AND W5, W4, W4
00226A  520FE0     SUB W4, #0x0, [W15]
00226C  320004     BRA Z, 0x2276
2584:                  // an electromagnet fault is active - Set this bit
2585:                  temp_lat_b |= BIT_OUTPUT_ELECTROMAGNET_FAULT;
00226E  90021E     MOV [W14+2], W4
002270  A04004     BSET W4, #4
002272  980714     MOV W4, [W14+2]
002274  370004     BRA 0x227E
2586:                } else {
2587:                  temp_lat_b &= ~BIT_OUTPUT_ELECTROMAGNET_FAULT;
002276  90029E     MOV [W14+2], W5
002278  2FFEF4     MOV #0xFFEF, W4
00227A  628204     AND W5, W4, W4
00227C  980714     MOV W4, [W14+2]
2588:                }
2589:              
2590:                if (faults_magnetron_fault_reg & 0x00FF) {
00227E  80C3B5     MOV faults_magnetron_fault_reg, W5
002280  200FF4     MOV #0xFF, W4
002282  628204     AND W5, W4, W4
002284  520FE0     SUB W4, #0x0, [W15]
002286  320004     BRA Z, 0x2290
2591:                  // an magnetron filament fault is active - Set this bit
2592:                  temp_lat_b |= BIT_OUTPUT_FILAMENT_FAULT;
002288  90021E     MOV [W14+2], W4
00228A  A01004     BSET W4, #1
00228C  980714     MOV W4, [W14+2]
00228E  370004     BRA 0x2298
2593:                } else {
2594:                  temp_lat_b &= ~BIT_OUTPUT_FILAMENT_FAULT;
002290  90029E     MOV [W14+2], W5
002292  2FFFD4     MOV #0xFFFD, W4
002294  628204     AND W5, W4, W4
002296  980714     MOV W4, [W14+2]
2595:                }
2596:              
2597:                if (faults_high_voltage_fault_reg & 0xFF00) {
002298  80C3E5     MOV faults_high_voltage_fault_reg, W5
00229A  2FF004     MOV #0xFF00, W4
00229C  628204     AND W5, W4, W4
00229E  520FE0     SUB W4, #0x0, [W15]
0022A0  320002     BRA Z, 0x22A6
2598:                  // Lambda Faultis active - Set this bit
2599:                  temp_lat_a |= BIT_OUTPUT_HV_FAULT;
0022A2  A0001E     BSET [W14], #0
0022A4  370002     BRA 0x22AA
2600:                } else {
2601:                  temp_lat_a &= ~BIT_OUTPUT_HV_FAULT;
0022A6  2FFFE4     MOV #0xFFFE, W4
0022A8  620F1E     AND W4, [W14], [W14]
2602:                }
2603:              
2604:                if (faults_high_voltage_fault_reg & 0x00FF) {
0022AA  80C3E5     MOV faults_high_voltage_fault_reg, W5
0022AC  200FF4     MOV #0xFF, W4
0022AE  628204     AND W5, W4, W4
0022B0  520FE0     SUB W4, #0x0, [W15]
0022B2  320002     BRA Z, 0x22B8
2605:                  // Pulse Fault is active - Set this bit
2606:                  temp_lat_a |= BIT_OUTPUT_PULSE_FAULT;
0022B4  A0101E     BSET [W14], #1
0022B6  370002     BRA 0x22BC
2607:                } else {
2608:                  temp_lat_a &= ~BIT_OUTPUT_PULSE_FAULT;
0022B8  2FFFD4     MOV #0xFFFD, W4
0022BA  620F1E     AND W4, [W14], [W14]
2609:                }
2610:                
2611:                if (control_state == STATE_HV_ON) {
0022BC  208405     MOV #0x840, W5
0022BE  784295     MOV.B [W5], W5
0022C0  B3C444     MOV.B #0x44, W4
0022C2  52CF84     SUB.B W5, W4, [W15]
0022C4  3A0004     BRA NZ, 0x22CE
2612:                  // HV is ON - Set this bit
2613:                  temp_lat_b |= BIT_OUTPUT_HV_ON_READBACK;
0022C6  90021E     MOV [W14+2], W4
0022C8  A02004     BSET W4, #2
0022CA  980714     MOV W4, [W14+2]
0022CC  370004     BRA 0x22D6
2614:                } else {
2615:                  temp_lat_b &= ~BIT_OUTPUT_HV_ON_READBACK;
0022CE  90029E     MOV [W14+2], W5
0022D0  2FFFB4     MOV #0xFFFB, W4
0022D2  628204     AND W5, W4, W4
0022D4  980714     MOV W4, [W14+2]
2616:                }
2617:              
2618:              
2619:                // We only want to update if there is a change in state.  Otherwise we have a lot of unnessary I2C traffic
2620:                if (U64_MCP23017.output_latch_a_in_ram != temp_lat_a) {
0022D6  209044     MOV #0x904, W4
0022D8  784214     MOV.B [W4], W4
0022DA  FB8204     ZE W4, W4
0022DC  520F9E     SUB W4, [W14], [W15]
0022DE  320010     BRA Z, 0x2300
2621:                  U64_MCP23017.output_latch_a_in_ram = temp_lat_a;
0022E0  78021E     MOV [W14], W4
0022E2  784204     MOV.B W4, W4
0022E4  784004     MOV.B W4, W0
0022E6  B7E904     MOV.B WREG, 0x904
2622:                  if (MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATA, U64_MCP23017.output_latch_a_in_ram) != 0) {
0022E8  209044     MOV #0x904, W4
0022EA  784214     MOV.B [W4], W4
0022EC  784104     MOV.B W4, W2
0022EE  B3C141     MOV.B #0x14, W1
0022F0  208FC0     MOV #0x8FC, W0
0022F2  07162B     RCALL MCP23017WriteSingleByte
0022F4  780200     MOV W0, W4
0022F6  520FE0     SUB W4, #0x0, [W15]
0022F8  320003     BRA Z, 0x2300
2623:                    global_debug_counter.i2c_bus_error++;
0022FA  80C304     MOV 0x1860, W4
0022FC  E80204     INC W4, W4
0022FE  88C304     MOV W4, 0x1860
2624:                  }
2625:                }
2626:              
2627:                // We only want to update if there is a change in state.  Otherwise we have a lot of unnessary I2C traffic
2628:                if (U64_MCP23017.output_latch_b_in_ram != temp_lat_b) {
002300  209054     MOV #0x905, W4
002302  784214     MOV.B [W4], W4
002304  FB8284     ZE W4, W5
002306  90021E     MOV [W14+2], W4
002308  528F84     SUB W5, W4, [W15]
00230A  320010     BRA Z, 0x232C
2629:                  U64_MCP23017.output_latch_b_in_ram = temp_lat_b;
00230C  90021E     MOV [W14+2], W4
00230E  784204     MOV.B W4, W4
002310  784004     MOV.B W4, W0
002312  B7E905     MOV.B WREG, 0x905
2630:                  if (MCP23017WriteSingleByte(&U64_MCP23017, MCP23017_REGISTER_OLATB, U64_MCP23017.output_latch_b_in_ram) != 0) { 
002314  209054     MOV #0x905, W4
002316  784214     MOV.B [W4], W4
002318  784104     MOV.B W4, W2
00231A  B3C151     MOV.B #0x15, W1
00231C  208FC0     MOV #0x8FC, W0
00231E  071615     RCALL MCP23017WriteSingleByte
002320  780200     MOV W0, W4
002322  520FE0     SUB W4, #0x0, [W15]
002324  320003     BRA Z, 0x232C
2631:                    global_debug_counter.i2c_bus_error++;
002326  80C304     MOV 0x1860, W4
002328  E80204     INC W4, W4
00232A  88C304     MOV W4, 0x1860
2632:                  }
2633:                }
2634:              }
00232C  FA8000     ULNK
00232E  060000     RETURN
2635:              
2636:              
2637:              void HVLambdaStartCharging(void) {
002330  FA0000     LNK #0x0
2638:                /*
2639:                  This starts the charging process . . .
2640:                  The following ocurrs . . .
2641:                  * The Lamabda is enabled via the ENABLE Pin
2642:                  * The Lamabda Inhibit input is set to NOT INHIBIT
2643:                  * TMR1 is set up to time the charging process and ensure the lamabda reaches EOC before the first pulse
2644:                  * TMR2 is set up to time the 100ms Timeout for the next pulse
2645:                  * HouseKeeping - global_run_post_pulse_process is cleared
2646:                  
2647:                */
2648:              
2649:                // --------  Select A or B mode based on the input ----------- //
2650:                if (PIN_A_B_MODE_SELECT == ILL_A_MODE_SELECTED) {
002332  801615     MOV PORTA, W5
002334  220004     MOV #0x2000, W4
002336  628204     AND W5, W4, W4
002338  520FE0     SUB W4, #0x0, [W15]
00233A  320005     BRA Z, 0x2346
2651:                  a_b_selected_mode = PULSE_MODE_A;
00233C  EB4200     CLR.B W4
00233E  784004     MOV.B W4, W0
002340  B7F6DC     MOV.B WREG, a_b_selected_mode
2652:                  PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002342  A9C2CB     BCLR 0x2CB, #6
002344  370004     BRA 0x234E
2653:                } else {
2654:                  a_b_selected_mode = PULSE_MODE_B;
002346  B3C014     MOV.B #0x1, W4
002348  784004     MOV.B W4, W0
00234A  B7F6DC     MOV.B WREG, a_b_selected_mode
2655:                  PIN_LAMBDA_VOLTAGE_SELECT = !OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
00234C  A8C2CB     BSET 0x2CB, #6
2656:                }
2657:              
2658:                // Actually enable the Lambda
2659:                PIN_HV_LAMBDA_ENABLE = OLL_HV_LAMBDA_ENABLED;
00234E  A862D7     BSET 0x2D7, #3
2660:                PIN_HV_LAMBDA_INHIBIT = !OLL_HV_LAMBDA_INHIBITED;
002350  A902D6     BCLR LATD, #0
2661:                
2662:              
2663:                // Setup T1 to time to first charge
2664:                T1CONbits.TON = 0;
002352  A9E105     BCLR 0x105, #7
2665:                TMR1 = 0;
002354  EB0200     CLR W4
002356  880804     MOV W4, TMR1
2666:                _T1IF = 0;
002358  A96084     BCLR IFS0, #3
2667:                _T1IE = 1;
00235A  A8608C     BSET IEC0, #3
2668:                PR1 = (TMR1_LAMBDA_CHARGE_PERIOD);
00235C  200B34     MOV #0xB3, W4
00235E  880814     MOV W4, PR1
2669:                T1CONbits.TON = 1;
002360  A8E105     BSET 0x105, #7
2670:              
2671:                // Setup T2 to roll in 100ms if there are no pulses
2672:                TMR2 = 0;  
002362  EB0200     CLR W4
002364  880834     MOV W4, TMR2
2673:                _T2IF = 0;
002366  A9C084     BCLR IFS0, #6
2674:              }
002368  FA8000     ULNK
00236A  060000     RETURN
2675:              
2676:              
2677:              
2678:              /*
2679:                Scaling
2680:                
2681:                Scaling is up as Q13.
2682:                0x0000 = 0
2683:                0xFFFF = 7.99988
2684:                
2685:                Scaling = (num/den) * (2^13))
2686:              */
2687:              
2688:              unsigned int MakeScale(unsigned int num, unsigned int den) {
00236C  FA000A     LNK #0xA
00236E  980730     MOV W0, [W14+6]
002370  980741     MOV W1, [W14+8]
2689:                unsigned long temp;
2690:                unsigned int return_value;
2691:                
2692:                temp = num;
002372  90023E     MOV [W14+6], W4
002374  200005     MOV #0x0, W5
002376  980714     MOV W4, [W14+2]
002378  980725     MOV W5, [W14+4]
2693:                temp = temp << 16;
00237A  90021E     MOV [W14+2], W4
00237C  9002AE     MOV [W14+4], W5
00237E  DD22C0     SL W4, #0, W5
002380  200004     MOV #0x0, W4
002382  980714     MOV W4, [W14+2]
002384  980725     MOV W5, [W14+4]
2694:                temp /= den;
002386  90024E     MOV [W14+8], W4
002388  200005     MOV #0x0, W5
00238A  BE0104     MOV.D W4, W2
00238C  90001E     MOV [W14+2], W0
00238E  9000AE     MOV [W14+4], W1
002390  07EF83     RCALL ___udivsi3
002392  BE0200     MOV.D W0, W4
002394  980714     MOV W4, [W14+2]
002396  980725     MOV W5, [W14+4]
2695:                temp = temp >> 3;
002398  90021E     MOV [W14+2], W4
00239A  9002AE     MOV [W14+4], W5
00239C  DD2B4D     SL W5, #13, W6
00239E  DE2243     LSR W4, #3, W4
0023A0  730204     IOR W6, W4, W4
0023A2  DE2AC3     LSR W5, #3, W5
0023A4  980714     MOV W4, [W14+2]
0023A6  980725     MOV W5, [W14+4]
2696:                
2697:                if (temp & 0xFFFF0000) {
0023A8  90031E     MOV [W14+2], W6
0023AA  9003AE     MOV [W14+4], W7
0023AC  200004     MOV #0x0, W4
0023AE  2FFFF5     MOV #0xFFFF, W5
0023B0  780006     MOV W6, W0
0023B2  780307     MOV W7, W6
0023B4  780384     MOV W4, W7
0023B6  780205     MOV W5, W4
0023B8  600007     AND W0, W7, W0
0023BA  630204     AND W6, W4, W4
0023BC  200005     MOV #0x0, W5
0023BE  DD22C0     SL W4, #0, W5
0023C0  200004     MOV #0x0, W4
0023C2  BE0304     MOV.D W4, W6
0023C4  B80261     MUL.UU W0, #1, W4
0023C6  730304     IOR W6, W4, W6
0023C8  738385     IOR W7, W5, W7
0023CA  530FE0     SUB W6, #0x0, [W15]
0023CC  5B8FE0     SUBB W7, #0x0, [W15]
0023CE  320003     BRA Z, 0x23D6
2698:                  // DPARKER saturation error
2699:                  return_value = 0xFFFF;
0023D0  EB8200     SETM W4
0023D2  780F04     MOV W4, [W14]
0023D4  370002     BRA 0x23DA
2700:                } else {
2701:                  return_value = temp & 0xFFFF;
0023D6  90021E     MOV [W14+2], W4
0023D8  780F04     MOV W4, [W14]
2702:                }
2703:                return return_value;
0023DA  78021E     MOV [W14], W4
2704:              }
0023DC  780004     MOV W4, W0
0023DE  FA8000     ULNK
0023E0  060000     RETURN
2705:              
2706:              
2707:              unsigned int Scale16Bit(unsigned int value, unsigned int scale) {
0023E2  FA0008     LNK #0x8
0023E4  980720     MOV W0, [W14+4]
0023E6  980731     MOV W1, [W14+6]
2708:                unsigned long temp;
2709:                temp = value;
0023E8  90022E     MOV [W14+4], W4
0023EA  200005     MOV #0x0, W5
0023EC  BE8F04     MOV.D W4, [W14]
2710:                temp *= scale;
0023EE  90023E     MOV [W14+6], W4
0023F0  200005     MOV #0x0, W5
0023F2  90031E     MOV [W14+2], W6
0023F4  B9B304     MUL.SS W6, W4, W6
0023F6  780306     MOV W6, W6
0023F8  78039E     MOV [W14], W7
0023FA  B9B805     MUL.SS W7, W5, W0
0023FC  780380     MOV W0, W7
0023FE  430307     ADD W6, W7, W6
002400  78039E     MOV [W14], W7
002402  780204     MOV W4, W4
002404  B82207     MUL.UU W4, W7, W4
002406  430305     ADD W6, W5, W6
002408  780286     MOV W6, W5
00240A  BE8F04     MOV.D W4, [W14]
00240C  BE8F04     MOV.D W4, [W14]
2711:                temp = temp >> 13;
00240E  BE021E     MOV.D [W14], W4
002410  DD2B43     SL W5, #3, W6
002412  DE224D     LSR W4, #13, W4
002414  730204     IOR W6, W4, W4
002416  DE2ACD     LSR W5, #13, W5
002418  BE8F04     MOV.D W4, [W14]
2712:                if (temp > 0x0000FFFF) {
00241A  2FFFF4     MOV #0xFFFF, W4
00241C  200005     MOV #0x0, W5
00241E  BE031E     MOV.D [W14], W6
002420  530F84     SUB W6, W4, [W15]
002422  5B8F85     SUBB W7, W5, [W15]
002424  360006     BRA LEU, 0x2432
2713:                  temp = 0x0000FFFF;
002426  2FFFF4     MOV #0xFFFF, W4
002428  200005     MOV #0x0, W5
00242A  BE8F04     MOV.D W4, [W14]
2714:                  global_debug_counter.scale16bit_saturation++;
00242C  80C364     MOV 0x186C, W4
00242E  E80204     INC W4, W4
002430  88C364     MOV W4, 0x186C
2715:                }
2716:                value = temp & 0xFFFF;
002432  78021E     MOV [W14], W4
002434  980724     MOV W4, [W14+4]
2717:                return value;
002436  90022E     MOV [W14+4], W4
2718:              }
002438  780004     MOV W4, W0
00243A  FA8000     ULNK
00243C  060000     RETURN
2719:              
2720:              
2721:              
2722:              unsigned int RCFilter256Tau(unsigned int previous_value, unsigned int current_reading) {
00243E  FA000A     LNK #0xA
002440  980730     MOV W0, [W14+6]
002442  980741     MOV W1, [W14+8]
2723:                unsigned long temp32;
2724:                unsigned int temp16;
2725:                if (previous_value == 0) {
002444  90023E     MOV [W14+6], W4
002446  520FE0     SUB W4, #0x0, [W15]
002448  3A0002     BRA NZ, 0x244E
2726:                  previous_value = current_reading;
00244A  90024E     MOV [W14+8], W4
00244C  980734     MOV W4, [W14+6]
2727:                }
2728:                temp32 = previous_value;
00244E  90023E     MOV [W14+6], W4
002450  200005     MOV #0x0, W5
002452  980714     MOV W4, [W14+2]
002454  980725     MOV W5, [W14+4]
2729:                temp32 *= 255;
002456  9002AE     MOV [W14+4], W5
002458  200FF4     MOV #0xFF, W4
00245A  B9AA04     MUL.SS W5, W4, W4
00245C  780304     MOV W4, W6
00245E  90021E     MOV [W14+2], W4
002460  B92260     MUL.SU W4, #0, W4
002462  780204     MOV W4, W4
002464  430304     ADD W6, W4, W6
002466  90029E     MOV [W14+2], W5
002468  200FF4     MOV #0xFF, W4
00246A  B82A04     MUL.UU W5, W4, W4
00246C  430305     ADD W6, W5, W6
00246E  780286     MOV W6, W5
002470  980714     MOV W4, [W14+2]
002472  980725     MOV W5, [W14+4]
002474  980714     MOV W4, [W14+2]
002476  980725     MOV W5, [W14+4]
2730:                temp32 += current_reading;
002478  90024E     MOV [W14+8], W4
00247A  200005     MOV #0x0, W5
00247C  90031E     MOV [W14+2], W6
00247E  9003AE     MOV [W14+4], W7
002480  420206     ADD W4, W6, W4
002482  4A8287     ADDC W5, W7, W5
002484  980714     MOV W4, [W14+2]
002486  980725     MOV W5, [W14+4]
2731:                temp32 = temp32 >> 8;
002488  90021E     MOV [W14+2], W4
00248A  9002AE     MOV [W14+4], W5
00248C  DD2B48     SL W5, #8, W6
00248E  DE2248     LSR W4, #8, W4
002490  730204     IOR W6, W4, W4
002492  DE2AC8     LSR W5, #8, W5
002494  980714     MOV W4, [W14+2]
002496  980725     MOV W5, [W14+4]
2732:                temp16 = temp32;
002498  90021E     MOV [W14+2], W4
00249A  780F04     MOV W4, [W14]
2733:                if (current_reading > temp16) {
00249C  90024E     MOV [W14+8], W4
00249E  520F9E     SUB W4, [W14], [W15]
0024A0  360002     BRA LEU, 0x24A6
2734:                  temp16++;
0024A2  E80F1E     INC [W14], [W14]
0024A4  370004     BRA 0x24AE
2735:                } else if (current_reading < temp16) {
0024A6  90024E     MOV [W14+8], W4
0024A8  520F9E     SUB W4, [W14], [W15]
0024AA  310001     BRA C, 0x24AE
2736:                  temp16--;
0024AC  E90F1E     DEC [W14], [W14]
2737:                }
2738:                return temp16;
0024AE  78021E     MOV [W14], W4
2739:              }
0024B0  780004     MOV W4, W0
0024B2  FA8000     ULNK
0024B4  060000     RETURN
2740:              
2741:              
2742:              unsigned int RCFilter64Tau(unsigned int previous_value, unsigned int current_reading) {
0024B6  FA000A     LNK #0xA
0024B8  980730     MOV W0, [W14+6]
0024BA  980741     MOV W1, [W14+8]
2743:                unsigned long temp32;
2744:                unsigned int temp16;
2745:                if (previous_value == 0) {
0024BC  90023E     MOV [W14+6], W4
0024BE  520FE0     SUB W4, #0x0, [W15]
0024C0  3A0002     BRA NZ, 0x24C6
2746:                  previous_value = current_reading;
0024C2  90024E     MOV [W14+8], W4
0024C4  980734     MOV W4, [W14+6]
2747:                }
2748:                temp32 = previous_value;
0024C6  90023E     MOV [W14+6], W4
0024C8  200005     MOV #0x0, W5
0024CA  980714     MOV W4, [W14+2]
0024CC  980725     MOV W5, [W14+4]
2749:                temp32 *= 63;
0024CE  9002AE     MOV [W14+4], W5
0024D0  2003F4     MOV #0x3F, W4
0024D2  B9AA04     MUL.SS W5, W4, W4
0024D4  780304     MOV W4, W6
0024D6  90021E     MOV [W14+2], W4
0024D8  B92260     MUL.SU W4, #0, W4
0024DA  780204     MOV W4, W4
0024DC  430304     ADD W6, W4, W6
0024DE  90029E     MOV [W14+2], W5
0024E0  2003F4     MOV #0x3F, W4
0024E2  B82A04     MUL.UU W5, W4, W4
0024E4  430305     ADD W6, W5, W6
0024E6  780286     MOV W6, W5
0024E8  980714     MOV W4, [W14+2]
0024EA  980725     MOV W5, [W14+4]
0024EC  980714     MOV W4, [W14+2]
0024EE  980725     MOV W5, [W14+4]
2750:                temp32 += current_reading;
0024F0  90024E     MOV [W14+8], W4
0024F2  200005     MOV #0x0, W5
0024F4  90031E     MOV [W14+2], W6
0024F6  9003AE     MOV [W14+4], W7
0024F8  420206     ADD W4, W6, W4
0024FA  4A8287     ADDC W5, W7, W5
0024FC  980714     MOV W4, [W14+2]
0024FE  980725     MOV W5, [W14+4]
2751:                temp32 = temp32 >> 6;
002500  90021E     MOV [W14+2], W4
002502  9002AE     MOV [W14+4], W5
002504  DD2B4A     SL W5, #10, W6
002506  DE2246     LSR W4, #6, W4
002508  730204     IOR W6, W4, W4
00250A  DE2AC6     LSR W5, #6, W5
00250C  980714     MOV W4, [W14+2]
00250E  980725     MOV W5, [W14+4]
2752:                temp16 = temp32;
002510  90021E     MOV [W14+2], W4
002512  780F04     MOV W4, [W14]
2753:                if (current_reading > temp16) {
002514  90024E     MOV [W14+8], W4
002516  520F9E     SUB W4, [W14], [W15]
002518  360002     BRA LEU, 0x251E
2754:                  temp16++;
00251A  E80F1E     INC [W14], [W14]
00251C  370004     BRA 0x2526
2755:                } else if (current_reading < temp16) {
00251E  90024E     MOV [W14+8], W4
002520  520F9E     SUB W4, [W14], [W15]
002522  310001     BRA C, 0x2526
2756:                  temp16--;
002524  E90F1E     DEC [W14], [W14]
2757:                }
2758:                return temp16;
002526  78021E     MOV [W14], W4
2759:              }
002528  780004     MOV W4, W0
00252A  FA8000     ULNK
00252C  060000     RETURN
2760:              
2761:              
2762:              unsigned int RCFilter16Tau(unsigned int previous_value, unsigned int current_reading) {
00252E  FA000A     LNK #0xA
002530  980730     MOV W0, [W14+6]
002532  980741     MOV W1, [W14+8]
2763:                unsigned long temp32;
2764:                unsigned int temp16;
2765:                if (previous_value == 0) {
002534  90023E     MOV [W14+6], W4
002536  520FE0     SUB W4, #0x0, [W15]
002538  3A0002     BRA NZ, 0x253E
2766:                  previous_value = current_reading;
00253A  90024E     MOV [W14+8], W4
00253C  980734     MOV W4, [W14+6]
2767:                }
2768:                temp32 = previous_value;
00253E  90023E     MOV [W14+6], W4
002540  200005     MOV #0x0, W5
002542  980714     MOV W4, [W14+2]
002544  980725     MOV W5, [W14+4]
2769:                temp32 *= 15;
002546  90022E     MOV [W14+4], W4
002548  B9226F     MUL.SU W4, #15, W4
00254A  780304     MOV W4, W6
00254C  90021E     MOV [W14+2], W4
00254E  B92260     MUL.SU W4, #0, W4
002550  780204     MOV W4, W4
002552  430304     ADD W6, W4, W6
002554  90029E     MOV [W14+2], W5
002556  2000F4     MOV #0xF, W4
002558  B82A04     MUL.UU W5, W4, W4
00255A  430305     ADD W6, W5, W6
00255C  780286     MOV W6, W5
00255E  980714     MOV W4, [W14+2]
002560  980725     MOV W5, [W14+4]
002562  980714     MOV W4, [W14+2]
002564  980725     MOV W5, [W14+4]
2770:                temp32 += current_reading;
002566  90024E     MOV [W14+8], W4
002568  200005     MOV #0x0, W5
00256A  90031E     MOV [W14+2], W6
00256C  9003AE     MOV [W14+4], W7
00256E  420206     ADD W4, W6, W4
002570  4A8287     ADDC W5, W7, W5
002572  980714     MOV W4, [W14+2]
002574  980725     MOV W5, [W14+4]
2771:                temp32 = temp32 >> 4;
002576  90021E     MOV [W14+2], W4
002578  9002AE     MOV [W14+4], W5
00257A  DD2B4C     SL W5, #12, W6
00257C  DE2244     LSR W4, #4, W4
00257E  730204     IOR W6, W4, W4
002580  DE2AC4     LSR W5, #4, W5
002582  980714     MOV W4, [W14+2]
002584  980725     MOV W5, [W14+4]
2772:                temp16 = temp32;
002586  90021E     MOV [W14+2], W4
002588  780F04     MOV W4, [W14]
2773:                if (current_reading > temp16) {
00258A  90024E     MOV [W14+8], W4
00258C  520F9E     SUB W4, [W14], [W15]
00258E  360002     BRA LEU, 0x2594
2774:                  temp16++;
002590  E80F1E     INC [W14], [W14]
002592  370004     BRA 0x259C
2775:                } else if (current_reading < temp16) {
002594  90024E     MOV [W14+8], W4
002596  520F9E     SUB W4, [W14], [W15]
002598  310001     BRA C, 0x259C
2776:                  temp16--;
00259A  E90F1E     DEC [W14], [W14]
2777:                }
2778:                return temp16;
00259C  78021E     MOV [W14], W4
2779:              }
00259E  780004     MOV W4, W0
0025A0  FA8000     ULNK
0025A2  060000     RETURN
2780:              
2781:              
2782:              
2783:              
2784:              
2785:              
2786:              
2787:              
2788:              
2789:              
2790:              void _ISRFASTNOPSV _INT1Interrupt(void) {
0025A4  FEA000     PUSH.S
0025A6  BE9F84     MOV.D W4, [W15++]
0025A8  FA0000     LNK #0x0
2791:                /*
2792:                  This interrupt does NOTHING TO CONTROL THE TYHRATRON TRIGGER
2793:                  By the time this interrupt is called, the trigger has already been routed to the thyratron
2794:                  This interrupt just schedules data acquisition and prepares for the NEXT pulse.
2795:                  
2796:                  This interrupt is enabled when the PIN_THYRATRON_TRIGGER_ENABLE is set (and disabled when that output is cleared).
2797:                  Therefore, if this interrupt has been entered then a trigger pulse was probably sent to the thyratron.
2798:                  It is possible that a trigger pulse was masked by a hardware fault BEFORE the software could detect it.
2799:                  If this were to happen then, the hardware faults will be detected in the next flow through the control loop
2800:                  and the system will detect Magnetron Undervoltage Undercurrent faults (because it is expecting a pulse that does not happen)
2801:                  
2802:                  Assuming a sucessful trigger, this interupt will do the following conecptual steps
2803:                  (1) Wait a set amount of time to sample the Magnetron Voltage, Magnetron Current, and PFN Fault Current at the approriate time
2804:                  (2) Wait for the pulse EMI to pass
2805:                  (2) Read the Magnetron Voltage and Magnetron Current into RAM.
2806:                  (3) Inhibit the HV supply a set amount of time.
2807:                  (4) After the inhibt time has passed, !Inhibit the power supply, and start the EOC timer
2808:                  (5) Set the status bit that indicates a pulse occured
2809:                */ 
2810:              
2811:                PIN_HV_LAMBDA_INHIBIT = OLL_HV_LAMBDA_INHIBITED;  
0025AA  A802D6     BSET LATD, #0
2812:              
2813:                // Trigger Delay is 800ns
2814:                // ADC Trigger Delay Across barrier is 950ns (this should be made faster)
2815:                // ISR Call Delay from trigger to output going high is 10 TCy
2816:                // Repeat stament will exexute N+1 Times
2817:                // Repeate statement itself is 1 Cycle
2818:                // There fore to calculate the trigger delay (from the start of the pulse)
2819:                // ((PFN_Sample_Point_US + 800ns (trigger delay) - 950ns (ADC Trigger Delay)) = Total Delay
2820:                // Total Delay/Tcy = Total Clock Delay
2821:                // Repeat Call = Total Clock Delay - 10 - 2
2822:              
2823:                Nop();
0025AC  000000     NOP
2824:                Nop();
0025AE  000000     NOP
2825:                Nop();
0025B0  000000     NOP
2826:                Nop();
0025B2  000000     NOP
2827:              
2828:              
2829:                PIN_PULSE_ADC_TRIGGER = OLL_TRIGGER_PULSE_ADCS;                  // Trigger the conversion process on both ADCs
0025B4  A822C5     BSET 0x2C5, #1
2830:                _INT1IF = 0;
0025B6  A90086     BCLR IFS1, #0
2831:                _INT1IE = 0;
0025B8  A9008E     BCLR IEC1, #0
2832:              
2833:                last_known_action = LAST_ACTION_INT1_INT;
0025BA  200044     MOV #0x4, W4
0025BC  88C6B4     MOV W4, last_known_action
2834:              
2835:                // Setup timer1 to time the time it takes the PFN EMI to dissipate
2836:                T1CONbits.TON = 0;
0025BE  A9E105     BCLR 0x105, #7
2837:                TMR1 = 0;
0025C0  EB0200     CLR W4
0025C2  880804     MOV W4, TMR1
2838:                PR1 = TMR1_DELAY_HOLDOFF;
0025C4  200084     MOV #0x8, W4
0025C6  880814     MOV W4, PR1
2839:                _T1IE = 0;
0025C8  A9608C     BCLR IEC0, #3
2840:                _T1IF = 0;
0025CA  A96084     BCLR IFS0, #3
2841:                T1CONbits.TON = 1;
0025CC  A8E105     BSET 0x105, #7
2842:                
2843:                false_trigger = 0;
0025CE  EB0200     CLR W4
0025D0  884174     MOV W4, false_trigger
2844:              
2845:                while (TMR1 < 2);  // 128 clock cycles, 12.8uS
0025D2  000000     NOP
0025D4  800804     MOV TMR1, W4
0025D6  520FE1     SUB W4, #0x1, [W15]
0025D8  36FFFD     BRA LEU, 0x25D4
2846:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
0025DA  801615     MOV PORTA, W5
0025DC  210004     MOV #0x1000, W4
0025DE  628204     AND W5, W4, W4
0025E0  520FE0     SUB W4, #0x0, [W15]
0025E2  3A0003     BRA NZ, 0x25EA
2847:                  false_trigger = 1;
0025E4  200014     MOV #0x1, W4
0025E6  884174     MOV W4, false_trigger
2848:                }
2849:              
2850:                while (TMR1 < 3);  // 192 clock cycles, 19.2uS
0025E8  370001     BRA 0x25EC
0025EA  000000     NOP
0025EC  800804     MOV TMR1, W4
0025EE  520FE2     SUB W4, #0x2, [W15]
0025F0  36FFFD     BRA LEU, 0x25EC
2851:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
0025F2  801615     MOV PORTA, W5
0025F4  210004     MOV #0x1000, W4
0025F6  628204     AND W5, W4, W4
0025F8  520FE0     SUB W4, #0x0, [W15]
0025FA  3A0003     BRA NZ, 0x2602
2852:                  false_trigger = 1;
0025FC  200014     MOV #0x1, W4
0025FE  884174     MOV W4, false_trigger
2853:                }
2854:              
2855:                while (TMR1 < 3);  // 256 clock cycles, 25.6uS
002600  370001     BRA 0x2604
002602  000000     NOP
002604  800804     MOV TMR1, W4
002606  520FE2     SUB W4, #0x2, [W15]
002608  36FFFD     BRA LEU, 0x2604
2856:                if (PIN_MODULATOR_DRIVE_INPUT != ILL_MODULATOR_DRIVE_ACTIVE) {
00260A  801615     MOV PORTA, W5
00260C  210004     MOV #0x1000, W4
00260E  628204     AND W5, W4, W4
002610  520FE0     SUB W4, #0x0, [W15]
002612  3A0002     BRA NZ, 0x2618
2857:                  false_trigger = 1;
002614  200014     MOV #0x1, W4
002616  884174     MOV W4, false_trigger
2858:                }
2859:              
2860:                arc_detected = 0;
002618  EB0200     CLR W4
00261A  884064     MOV W4, arc_detected
2861:                if ((PIN_PULSE_OVER_CUR_LATCH == ILL_PULSE_OVER_CURRENT_FAULT) || (PIN_PULSE_MIN_CUR_LATCH == ILL_PULSE_MIN_CURRENT_FAULT)) {
00261C  8016A4     MOV PORTD, W4
00261E  620270     AND W4, #0x10, W4
002620  520FE0     SUB W4, #0x0, [W15]
002622  320005     BRA Z, 0x262E
002624  8016A5     MOV PORTD, W5
002626  200804     MOV #0x80, W4
002628  628204     AND W5, W4, W4
00262A  520FE0     SUB W4, #0x0, [W15]
00262C  320002     BRA Z, 0x2632
2862:                  arc_detected = 1;
00262E  200014     MOV #0x1, W4
002630  884064     MOV W4, arc_detected
2863:                }
2864:              
2865:                PIN_PULSE_LATCH_RESET = OLL_PULSE_LATCH_RESET;  // Clear the pulse latches so we can detect a false trigger
002632  A9A2E2     BCLR LATF, #5
2866:              
2867:                // Calculate the PRF
2868:                last_period = TMR3;
002634  800854     MOV TMR3, W4
002636  88C534     MOV W4, 0x18A6
2869:                TMR3 = 0;
002638  EB0200     CLR W4
00263A  880854     MOV W4, TMR3
2870:                if (_T3IF) {
00263C  800425     MOV IFS0, W5
00263E  200804     MOV #0x80, W4
002640  628204     AND W5, W4, W4
002642  520FE0     SUB W4, #0x0, [W15]
002644  320002     BRA Z, 0x264A
2871:                  // The timer exceed it's period of 400ms - Will happen if the PRF is less than 2.5 Hz
2872:                  last_period = 62501;  // This will indicate that the PRF is less than 2,5 Hz
002646  2F4254     MOV #0xF425, W4
002648  88C534     MOV W4, 0x18A6
2873:                }
2874:                _T3IF = 0;
00264A  A9E084     BCLR IFS0, #7
2875:              
2876:                while(!_T1IF);                                                   // what for the holdoff time to pass
00264C  000000     NOP
00264E  800424     MOV IFS0, W4
002650  620268     AND W4, #0x8, W4
002652  520FE0     SUB W4, #0x0, [W15]
002654  32FFFC     BRA Z, 0x264E
2877:              
2878:              
2879:                // Read the state of the A_B select Optical input and adjust the system as nesseasry
2880:                if (PIN_A_B_MODE_SELECT == ILL_A_MODE_SELECTED) {
002656  801615     MOV PORTA, W5
002658  220004     MOV #0x2000, W4
00265A  628204     AND W5, W4, W4
00265C  520FE0     SUB W4, #0x0, [W15]
00265E  320005     BRA Z, 0x266A
2881:                  next_pulse_a_b_selected_mode = PULSE_MODE_A;
002660  EB4200     CLR.B W4
002662  784004     MOV.B W4, W0
002664  B7F6DD     MOV.B WREG, next_pulse_a_b_selected_mode
2882:                  PIN_LAMBDA_VOLTAGE_SELECT = OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002666  A9C2CB     BCLR 0x2CB, #6
002668  370004     BRA 0x2672
2883:                } else {
2884:                  next_pulse_a_b_selected_mode = PULSE_MODE_B;
00266A  B3C014     MOV.B #0x1, W4
00266C  784004     MOV.B W4, W0
00266E  B7F6DD     MOV.B WREG, next_pulse_a_b_selected_mode
2885:                  PIN_LAMBDA_VOLTAGE_SELECT = !OLL_SELECT_LAMBDA_MODE_A_VOLTAGE;
002670  A8C2CB     BSET 0x2CB, #6
2886:                }
2887:              
2888:              
2889:                PIN_THYRATRON_TRIGGER_ENABLE = !OLL_THYRATRON_TRIGGER_ENABLED;   // Disable the Pic trigger signal gate
002672  A9C2C4     BCLR LATA, #6
2890:                PIN_HV_LAMBDA_INHIBIT = !OLL_HV_LAMBDA_INHIBITED;                // Start the lambda charge process
002674  A902D6     BCLR LATD, #0
2891:              
2892:                // Set up Timer1 to produce interupt at end of charge period
2893:                T1CONbits.TON = 0;
002676  A9E105     BCLR 0x105, #7
2894:                TMR1 = 0;
002678  EB0200     CLR W4
00267A  880804     MOV W4, TMR1
2895:                _T1IF = 0;
00267C  A96084     BCLR IFS0, #3
2896:                _T1IE = 1;
00267E  A8608C     BSET IEC0, #3
2897:                PR1 = (TMR1_LAMBDA_CHARGE_PERIOD - TMR1_DELAY_HOLDOFF);
002680  200AB4     MOV #0xAB, W4
002682  880814     MOV W4, PR1
2898:                T1CONbits.TON = 1;
002684  A8E105     BSET 0x105, #7
2899:              
2900:                // Wait for the pulse latches to clear
2901:                while ((PIN_PULSE_OVER_CUR_LATCH == ILL_PULSE_OVER_CURRENT_FAULT) && (TMR1 < 20));
002686  000000     NOP
002688  8016A4     MOV PORTD, W4
00268A  620270     AND W4, #0x10, W4
00268C  520FE0     SUB W4, #0x0, [W15]
00268E  3A0004     BRA NZ, 0x2698
002690  800804     MOV TMR1, W4
002692  520FF3     SUB W4, #0x13, [W15]
002694  36FFF9     BRA LEU, 0x2688
2902:                while ((PIN_PULSE_MIN_CUR_LATCH == ILL_PULSE_MIN_CURRENT_FAULT) && (TMR1 < 20));
002696  370001     BRA 0x269A
002698  000000     NOP
00269A  8016A5     MOV PORTD, W5
00269C  200804     MOV #0x80, W4
00269E  628204     AND W5, W4, W4
0026A0  520FE0     SUB W4, #0x0, [W15]
0026A2  320003     BRA Z, 0x26AA
0026A4  800804     MOV TMR1, W4
0026A6  520FF3     SUB W4, #0x13, [W15]
0026A8  36FFF8     BRA LEU, 0x269A
2903:                
2904:                if (TMR1 >= 20) {
0026AA  800804     MOV TMR1, W4
0026AC  520FF3     SUB W4, #0x13, [W15]
0026AE  360003     BRA LEU, 0x26B6
2905:                  // there was an error with the pulse latch reset 
2906:                  global_debug_counter.pulse_latch_reset_error++; 
0026B0  80C384     MOV 0x1870, W4
0026B2  E80204     INC W4, W4
0026B4  88C384     MOV W4, 0x1870
2907:                }
2908:              	 
2909:              	 
2910:              
2911:                PIN_PULSE_LATCH_RESET = !OLL_PULSE_LATCH_RESET;
0026B6  A8A2E2     BSET LATF, #5
2912:                
2913:                // Clear the Change Notification data that is used to detect a false trigger
2914:                if (PIN_PULSE_MIN_CUR_LATCH); // We need to read this port in order to clear CN data
0026B8  8016A4     MOV PORTD, W4
2915:                _CNIF = 0; // Clear the interrupt flag that gets set when we have a valid pulse
0026BA  A9E085     BCLR 0x85, #7
2916:                
2917:                
2918:                
2919:                if (global_run_post_pulse_process) {
0026BC  216DA4     MOV #0x16DA, W4
0026BE  784214     MOV.B [W4], W4
0026C0  524FE0     SUB.B W4, #0x0, [W15]
0026C2  320003     BRA Z, 0x26CA
2920:                  timing_error_int1_count++;
0026C4  80C554     MOV 0x18AA, W4
0026C6  E80204     INC W4, W4
0026C8  88C554     MOV W4, 0x18AA
2921:                }
2922:              
2923:                global_run_post_pulse_process = 1; // This tells the main control loop that a pulse has occured and that it should run the post pulse process once (and only once) 
0026CA  B3C014     MOV.B #0x1, W4
0026CC  784004     MOV.B W4, W0
0026CE  B7F6DA     MOV.B WREG, global_run_post_pulse_process
2924:                global_adc_ignore_this_sample = 1;  // This allows the internal ADC ISR to know that there was a pulse and to discard all the data from the sequence where the pulse occured
0026D0  B3C014     MOV.B #0x1, W4
0026D2  784004     MOV.B W4, W0
0026D4  B7F6DB     MOV.B WREG, global_adc_ignore_this_sample
2925:              }
0026D6  FA8000     ULNK
0026D8  BE024F     MOV.D [--W15], W4
0026DA  FE8000     POP.S
0026DC  064000     RETFIE
2926:              
2927:              
2928:              
2929:              void _ISRNOPSV _T1Interrupt(void) {
0026DE  F80036     PUSH RCOUNT
0026E0  BE9F80     MOV.D W0, [W15++]
0026E2  BE9F82     MOV.D W2, [W15++]
0026E4  BE9F84     MOV.D W4, [W15++]
0026E6  BE9F86     MOV.D W6, [W15++]
0026E8  FA0002     LNK #0x2
2930:                /*
2931:                  This interrupt indicates that the cap charger should have finished charging and it is time to enable the trigger pulse.
2932:              
2933:                  This interrupt is called X us after charging starts
2934:                  If the lambda is not at EOC, it does not enable the trigger and sets the Lambda EOC Timeout Fault bit
2935:                  If the lambda is at EOC, It enables the trigger & sets status bits to show that the lambda is not charging and that the system is ready to fire.    
2936:                */
2937:                unsigned char lambda_eoc_fault;
2938:              
2939:                last_known_action = LAST_ACTION_T1_INT;
0026EA  200034     MOV #0x3, W4
0026EC  88C6B4     MOV W4, last_known_action
2940:                
2941:                _T1IF = 0;         // Clear the interrupt flag
0026EE  A96084     BCLR IFS0, #3
2942:                _T1IE = 0;         // Disable the interrupt (This will be enabled the next time that a capacitor charging sequence starts)
0026F0  A9608C     BCLR IEC0, #3
2943:                T1CONbits.TON = 0;   // Stop the timer from incrementing (Again this will be restarted with the next time the capacitor charge sequence starts)
0026F2  A9E105     BCLR 0x105, #7
2944:                
2945:                // DPARKER - Consider adding more checks - Magnet Current, Actual Lambda Voltage, Check all the fault registers to confirm good to go!!!!
2946:              
2947:                lambda_eoc_fault = 0;
0026F4  EB4200     CLR.B W4
0026F6  784F04     MOV.B W4, [W14]
2948:                if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
0026F8  8016A4     MOV PORTD, W4
0026FA  620264     AND W4, #0x4, W4
0026FC  520FE0     SUB W4, #0x0, [W15]
0026FE  32001E     BRA Z, 0x273C
2949:                  __delay32(DELAY_TCY_10US);
002700  200640     MOV #0x64, W0
002702  200001     MOV #0x0, W1
002704  07153E     RCALL ___delay32
2950:                  if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002706  8016A4     MOV PORTD, W4
002708  620264     AND W4, #0x4, W4
00270A  520FE0     SUB W4, #0x0, [W15]
00270C  320017     BRA Z, 0x273C
2951:                    __delay32(DELAY_TCY_10US);
00270E  200640     MOV #0x64, W0
002710  200001     MOV #0x0, W1
002712  071537     RCALL ___delay32
2952:                    if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002714  8016A4     MOV PORTD, W4
002716  620264     AND W4, #0x4, W4
002718  520FE0     SUB W4, #0x0, [W15]
00271A  320010     BRA Z, 0x273C
2953:              	__delay32(DELAY_TCY_10US);
00271C  200640     MOV #0x64, W0
00271E  200001     MOV #0x0, W1
002720  071530     RCALL ___delay32
2954:              	if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002722  8016A4     MOV PORTD, W4
002724  620264     AND W4, #0x4, W4
002726  520FE0     SUB W4, #0x0, [W15]
002728  320009     BRA Z, 0x273C
2955:              	  __delay32(DELAY_TCY_10US);
00272A  200640     MOV #0x64, W0
00272C  200001     MOV #0x0, W1
00272E  071529     RCALL ___delay32
2956:              	  if (PIN_HV_LAMBDA_EOC_INPUT != ILL_HV_LAMBDA_AT_EOC) {
002730  8016A4     MOV PORTD, W4
002732  620264     AND W4, #0x4, W4
002734  520FE0     SUB W4, #0x0, [W15]
002736  320002     BRA Z, 0x273C
2957:              	    RecordThisHighVoltageFault(FAULT_HV_LAMBDA_EOC_TIMEOUT);
002738  202000     MOV #0x200, W0
00273A  070DE6     RCALL RecordThisHighVoltageFault
2958:              	  }
2959:              	} 
2960:                    }
2961:                  }
2962:                }
2963:              
2964:                // Enable the the thyratron trigger and Enable the Trigger Interrupt 
2965:                PIN_THYRATRON_TRIGGER_ENABLE = OLL_THYRATRON_TRIGGER_ENABLED; // Enable the thyratron trigger pass through.
00273C  A8C2C4     BSET LATA, #6
2966:                _INT1IF = 0;                                                  // Enable INT1 (thyratron trigger) interrupt
00273E  A90086     BCLR IFS1, #0
2967:                _INT1IE = 1;
002740  A8008E     BSET IEC1, #0
2968:              
2969:              }  
002742  FA8000     ULNK
002744  BE034F     MOV.D [--W15], W6
002746  BE024F     MOV.D [--W15], W4
002748  BE014F     MOV.D [--W15], W2
00274A  BE004F     MOV.D [--W15], W0
00274C  F90036     POP RCOUNT
00274E  064000     RETFIE
2970:              
2971:              
2972:              void _ISRNOPSV _ADCInterrupt(void) {
002750  781F80     MOV W0, [W15++]
002752  BE9F84     MOV.D W4, [W15++]
002754  781F86     MOV W6, [W15++]
002756  FA0000     LNK #0x0
2973:                _ASAM = 0; // Stop Auto Sampling
002758  A942A0     BCLR ADCON1, #2
2974:                _ADIF = 0;
00275A  A96085     BCLR 0x85, #3
2975:                
2976:                // Switch the sate of PIN_UART2_TX (debugging info)
2977:                if (PIN_UART2_TX) {
00275C  801655     MOV LATB, W5
00275E  200404     MOV #0x40, W4
002760  628204     AND W5, W4, W4
002762  520FE0     SUB W4, #0x0, [W15]
002764  320002     BRA Z, 0x276A
2978:                  PIN_UART2_TX = 0;
002766  A9C2CA     BCLR LATB, #6
002768  370001     BRA 0x276C
2979:                } else {
2980:                  PIN_UART2_TX = 1;
00276A  A8C2CA     BSET LATB, #6
2981:                }
2982:              
2983:                last_known_action = LAST_ACTION_ADC_INTERRUPT;
00276C  200014     MOV #0x1, W4
00276E  88C6B4     MOV W4, last_known_action
2984:                // DPARKER what for the conversion to complete???
2985:                
2986:                if (global_adc_ignore_this_sample) {
002770  216DB4     MOV #0x16DB, W4
002772  784214     MOV.B [W4], W4
002774  524FE0     SUB.B W4, #0x0, [W15]
002776  320004     BRA Z, 0x2780
2987:                  // There was a pulse durring the sample sequence.  Throw the data away!!!
2988:                  global_adc_ignore_this_sample = 0;
002778  EB4200     CLR.B W4
00277A  784004     MOV.B W4, W0
00277C  B7F6DB     MOV.B WREG, global_adc_ignore_this_sample
00277E  370062     BRA 0x2844
2989:                } else {
2990:                  // Copy Data From Buffer to RAM
2991:                  pfn_rev_current_array[adc_result_index] = ADCBUF0;
002780  20BD84     MOV #0xBD8, W4
002782  784214     MOV.B [W4], W4
002784  FB8204     ZE W4, W4
002786  801405     MOV ADCBUF0, W5
002788  420304     ADD W4, W4, W6
00278A  20BDA4     MOV #0xBDA, W4
00278C  430204     ADD W6, W4, W4
00278E  780A05     MOV W5, [W4]
2992:                  
2993:                  pac_1_array[adc_result_index] = ADCBUF1;
002790  20BD84     MOV #0xBD8, W4
002792  784214     MOV.B [W4], W4
002794  FB8204     ZE W4, W4
002796  801415     MOV ADCBUF1, W5
002798  420304     ADD W4, W4, W6
00279A  20CDA4     MOV #0xCDA, W4
00279C  430204     ADD W6, W4, W4
00279E  780A05     MOV W5, [W4]
2994:                  pac_2_array[adc_result_index] = ADCBUF2;
0027A0  20BD84     MOV #0xBD8, W4
0027A2  784214     MOV.B [W4], W4
0027A4  FB8204     ZE W4, W4
0027A6  801425     MOV ADCBUF2, W5
0027A8  420304     ADD W4, W4, W6
0027AA  20DDA4     MOV #0xDDA, W4
0027AC  430204     ADD W6, W4, W4
0027AE  780A05     MOV W5, [W4]
2995:                  
2996:                  thyratron_cathode_heater_voltage_array[adc_result_index] = ADCBUF3;
0027B0  20BD84     MOV #0xBD8, W4
0027B2  784214     MOV.B [W4], W4
0027B4  FB8204     ZE W4, W4
0027B6  801435     MOV ADCBUF3, W5
0027B8  420304     ADD W4, W4, W6
0027BA  20EDA4     MOV #0xEDA, W4
0027BC  430204     ADD W6, W4, W4
0027BE  780A05     MOV W5, [W4]
2997:                  thyratron_reservoir_heater_voltage_array[adc_result_index] = ADCBUF4;
0027C0  20BD84     MOV #0xBD8, W4
0027C2  784214     MOV.B [W4], W4
0027C4  FB8204     ZE W4, W4
0027C6  801445     MOV ADCBUF4, W5
0027C8  420304     ADD W4, W4, W6
0027CA  20FDA4     MOV #0xFDA, W4
0027CC  430204     ADD W6, W4, W4
0027CE  780A05     MOV W5, [W4]
2998:                  
2999:                  magnetron_magnet_current_array[adc_result_index]= ADCBUF5;
0027D0  20BD84     MOV #0xBD8, W4
0027D2  784214     MOV.B [W4], W4
0027D4  FB8204     ZE W4, W4
0027D6  801455     MOV ADCBUF5, W5
0027D8  420304     ADD W4, W4, W6
0027DA  210DA4     MOV #0x10DA, W4
0027DC  430204     ADD W6, W4, W4
0027DE  780A05     MOV W5, [W4]
3000:                  magnetron_magnet_voltage_array[adc_result_index]= ADCBUF6;
0027E0  20BD84     MOV #0xBD8, W4
0027E2  784214     MOV.B [W4], W4
0027E4  FB8204     ZE W4, W4
0027E6  801465     MOV ADCBUF6, W5
0027E8  420304     ADD W4, W4, W6
0027EA  211DA4     MOV #0x11DA, W4
0027EC  430204     ADD W6, W4, W4
0027EE  780A05     MOV W5, [W4]
3001:                  
3002:                  magnetron_filament_voltage_array[adc_result_index] = ADCBUF7;
0027F0  20BD84     MOV #0xBD8, W4
0027F2  784214     MOV.B [W4], W4
0027F4  FB8204     ZE W4, W4
0027F6  801475     MOV ADCBUF7, W5
0027F8  420304     ADD W4, W4, W6
0027FA  213DA4     MOV #0x13DA, W4
0027FC  430204     ADD W6, W4, W4
0027FE  780A05     MOV W5, [W4]
3003:                  magnetron_filament_current_array[adc_result_index] = ADCBUF8;
002800  20BD84     MOV #0xBD8, W4
002802  784214     MOV.B [W4], W4
002804  FB8204     ZE W4, W4
002806  801485     MOV ADCBUF8, W5
002808  420304     ADD W4, W4, W6
00280A  212DA4     MOV #0x12DA, W4
00280C  430204     ADD W6, W4, W4
00280E  780A05     MOV W5, [W4]
3004:              
3005:                  
3006:                  lambda_vpeak_array[adc_result_index] = ADCBUF9;
002810  20BD84     MOV #0xBD8, W4
002812  784214     MOV.B [W4], W4
002814  FB8204     ZE W4, W4
002816  801495     MOV ADCBUF9, W5
002818  420304     ADD W4, W4, W6
00281A  214DA4     MOV #0x14DA, W4
00281C  430204     ADD W6, W4, W4
00281E  780A05     MOV W5, [W4]
3007:                  lambda_vmon_array[adc_result_index] = ADCBUFA;
002820  20BD84     MOV #0xBD8, W4
002822  784214     MOV.B [W4], W4
002824  FB8204     ZE W4, W4
002826  8014A5     MOV ADCBUFA, W5
002828  420304     ADD W4, W4, W6
00282A  215DA4     MOV #0x15DA, W4
00282C  430204     ADD W6, W4, W4
00282E  780A05     MOV W5, [W4]
3008:                  
3009:                  adc_result_index++;
002830  20BD84     MOV #0xBD8, W4
002832  784214     MOV.B [W4], W4
002834  E84204     INC.B W4, W4
002836  784004     MOV.B W4, W0
002838  B7EBD8     MOV.B WREG, adc_result_index
3010:                  adc_result_index &= 0b01111111;
00283A  20BD84     MOV #0xBD8, W4
00283C  784214     MOV.B [W4], W4
00283E  A17404     BCLR.B W4, #7
002840  784004     MOV.B W4, W0
002842  B7EBD8     MOV.B WREG, adc_result_index
3011:                }
3012:                _ASAM = 1; // Start Auto Sampling
002844  A842A0     BSET ADCON1, #2
3013:              }
002846  FA8000     ULNK
002848  78034F     MOV [--W15], W6
00284A  BE024F     MOV.D [--W15], W4
00284C  78004F     MOV [--W15], W0
00284E  064000     RETFIE
3014:              
3015:              
3016:              void _ISRNOPSV _CNInterrupt(void) {
002850  F80036     PUSH RCOUNT
002852  BE9F80     MOV.D W0, [W15++]
002854  BE9F82     MOV.D W2, [W15++]
002856  BE9F84     MOV.D W4, [W15++]
002858  BE9F86     MOV.D W6, [W15++]
00285A  FA0000     LNK #0x0
3017:                if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
00285C  8016A5     MOV PORTD, W5
00285E  200804     MOV #0x80, W4
002860  628204     AND W5, W4, W4
002862  520FE0     SUB W4, #0x0, [W15]
002864  3A0012     BRA NZ, 0x288A
3018:                  __delay32(100); // 10uS
002866  200640     MOV #0x64, W0
002868  200001     MOV #0x0, W1
00286A  07148B     RCALL ___delay32
3019:                  if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
00286C  8016A5     MOV PORTD, W5
00286E  200804     MOV #0x80, W4
002870  628204     AND W5, W4, W4
002872  520FE0     SUB W4, #0x0, [W15]
002874  3A000A     BRA NZ, 0x288A
3020:                    __delay32(100); // 10uS
002876  200640     MOV #0x64, W0
002878  200001     MOV #0x0, W1
00287A  071483     RCALL ___delay32
3021:                    if (PIN_PULSE_MIN_CUR_LATCH == !ILL_PULSE_MIN_CURRENT_FAULT) {
00287C  8016A5     MOV PORTD, W5
00287E  200804     MOV #0x80, W4
002880  628204     AND W5, W4, W4
002882  520FE0     SUB W4, #0x0, [W15]
002884  3A0002     BRA NZ, 0x288A
3022:              	RecordThisThyratronFault(FAULT_THYR_FALSE_TRIGGER);
002886  204000     MOV #0x400, W0
002888  070D5B     RCALL RecordThisThyratronFault
3023:                    }
3024:                  }
3025:                }
3026:                _CNIF = 0;
00288A  A9E085     BCLR 0x85, #7
3027:              }
00288C  FA8000     ULNK
00288E  BE034F     MOV.D [--W15], W6
002890  BE024F     MOV.D [--W15], W4
002892  BE014F     MOV.D [--W15], W2
002894  BE004F     MOV.D [--W15], W0
002896  F90036     POP RCOUNT
002898  064000     RETFIE
3028:              
3029:              
3030:              void _ISRNOPSV _LVDInterrupt(void) {
00289A  781F84     MOV W4, [W15++]
00289C  FA0000     LNK #0x0
3031:                last_known_action = LAST_ACTION_LVD_INT;
00289E  200024     MOV #0x2, W4
0028A0  88C6B4     MOV W4, last_known_action
3032:                _LVDIF = 0;
0028A2  A94089     BCLR 0x89, #2
3033:                lvdinterrupt_counter++;
0028A4  80C574     MOV 0x18AE, W4
0028A6  E80204     INC W4, W4
0028A8  88C574     MOV W4, 0x18AE
3034:              }
0028AA  FA8000     ULNK
0028AC  78024F     MOV [--W15], W4
0028AE  064000     RETFIE
3035:              
3036:              
3037:              void _ISRNOPSV _OscillatorFail(void) {
0028B0  781F84     MOV W4, [W15++]
0028B2  FA0000     LNK #0x0
3038:               last_known_action = LAST_ACTION_OSC_FAIL;
0028B4  2000D4     MOV #0xD, W4
0028B6  88C6B4     MOV W4, last_known_action
3039:               last_osccon = OSCCON;
0028B8  803A14     MOV OSCCON, W4
0028BA  88C6C4     MOV W4, last_osccon
3040:                Nop();
0028BC  000000     NOP
3041:                Nop();
0028BE  000000     NOP
3042:                __asm__ ("Reset");
0028C0  FE0000     RESET
3043:              }
0028C2  FA8000     ULNK
0028C4  78024F     MOV [--W15], W4
0028C6  064000     RETFIE
3044:              
3045:              void _ISRNOPSV _AddressError(void) {
0028C8  781F84     MOV W4, [W15++]
0028CA  FA0000     LNK #0x0
3046:               last_known_action = LAST_ACTION_ADDRESS_ERROR;
0028CC  2000E4     MOV #0xE, W4
0028CE  88C6B4     MOV W4, last_known_action
3047:                Nop();
0028D0  000000     NOP
3048:                Nop();
0028D2  000000     NOP
3049:                __asm__ ("Reset");
0028D4  FE0000     RESET
3050:              }
0028D6  FA8000     ULNK
0028D8  78024F     MOV [--W15], W4
0028DA  064000     RETFIE
3051:              
3052:              void _ISRNOPSV _StackError(void) {
0028DC  781F84     MOV W4, [W15++]
0028DE  FA0000     LNK #0x0
3053:               last_known_action = LAST_ACTION_STACK_ERROR;
0028E0  2000F4     MOV #0xF, W4
0028E2  88C6B4     MOV W4, last_known_action
3054:                Nop();
0028E4  000000     NOP
3055:                Nop();
0028E6  000000     NOP
3056:                __asm__ ("Reset");
0028E8  FE0000     RESET
3057:              }
0028EA  FA8000     ULNK
0028EC  78024F     MOV [--W15], W4
0028EE  064000     RETFIE
3058:              
3059:              void _ISRNOPSV _MathError(void) {
0028F0  781F84     MOV W4, [W15++]
0028F2  FA0000     LNK #0x0
3060:               last_known_action = LAST_ACTION_MATH_ERROR;
0028F4  200104     MOV #0x10, W4
0028F6  88C6B4     MOV W4, last_known_action
3061:                Nop();
0028F8  000000     NOP
3062:                Nop();
0028FA  000000     NOP
3063:                __asm__ ("Reset");
0028FC  FE0000     RESET
3064:              }
0028FE  FA8000     ULNK
002900  78024F     MOV [--W15], W4
002902  064000     RETFIE
3065:              
3066:              
3067:              
3068:              // DPARKER THIS FUNCTION FOR DEBUGGING ONLY
3069:              void _ISRNOPSV _DefaultInterrupt(void) {
002904  781F84     MOV W4, [W15++]
002906  FA0000     LNK #0x0
3070:                /*
3071:                control_state = STATE_FAULT_ILLEGAL_INTERRUPT;
3072:                global_debug_counter.magnetron_current_adc_glitch = IFS0;
3073:                global_debug_counter.magnetron_voltage_adc_glitch = IFS1;
3074:                global_debug_counter.i2c_bus_error = IFS2;
3075:              
3076:                global_debug_counter.spi1_bus_error = IEC0;
3077:                global_debug_counter.spi2_bus_error = IEC1;
3078:                global_debug_counter.external_adc_false_trigger = IEC2;
3079:              
3080:                while (1) {
3081:                  ClrWdt();
3082:                  DoSerialCommand();
3083:                }
3084:                */
3085:                last_known_action = LAST_ACTION_DEFAULT_INT;
002908  2FABC4     MOV #0xFABC, W4
00290A  88C6B4     MOV W4, last_known_action
3086:                Nop();
00290C  000000     NOP
3087:                Nop();
00290E  000000     NOP
3088:                __asm__ ("Reset");
002910  FE0000     RESET
3089:              }
002912  FA8000     ULNK
002914  78024F     MOV [--W15], W4
002916  064000     RETFIE
3090:              
3091:              
3092:              
3093:              
3094:              unsigned int CalculatePoly(unsigned int set_point) {
002918  FA000C     LNK #0xC
00291A  980750     MOV W0, [W14+10]
3095:              
3096:                signed long sum;
3097:                signed long temp;
3098:                unsigned int value;
3099:              
3100:                temp = set_point;
00291C  90025E     MOV [W14+10], W4
00291E  200005     MOV #0x0, W5
002920  BE8F04     MOV.D W4, [W14]
3101:                temp *= set_point;
002922  90025E     MOV [W14+10], W4
002924  200005     MOV #0x0, W5
002926  90031E     MOV [W14+2], W6
002928  B9B304     MUL.SS W6, W4, W6
00292A  780306     MOV W6, W6
00292C  78039E     MOV [W14], W7
00292E  B9B805     MUL.SS W7, W5, W0
002930  780380     MOV W0, W7
002932  430307     ADD W6, W7, W6
002934  78039E     MOV [W14], W7
002936  780204     MOV W4, W4
002938  B82207     MUL.UU W4, W7, W4
00293A  430305     ADD W6, W5, W6
00293C  780286     MOV W6, W5
00293E  BE8F04     MOV.D W4, [W14]
002940  BE8F04     MOV.D W4, [W14]
3102:                temp = temp >> 14;
002942  BE021E     MOV.D [W14], W4
002944  DD2B42     SL W5, #2, W6
002946  DE224E     LSR W4, #14, W4
002948  730204     IOR W6, W4, W4
00294A  DEAACE     ASR W5, #14, W5
00294C  BE8F04     MOV.D W4, [W14]
3103:                temp *= control_loop_cal_data_ram_copy[EEPROM_CNTRL_MAGNET_FACTOR_SQUARE];
00294E  80C1E4     MOV control_loop_cal_data_ram_copy, W4
002950  DEA2CF     ASR W4, #15, W5
002952  90031E     MOV [W14+2], W6
002954  B9B304     MUL.SS W6, W4, W6
002956  780306     MOV W6, W6
002958  78039E     MOV [W14], W7
00295A  B9B805     MUL.SS W7, W5, W0
00295C  780380     MOV W0, W7
00295E  430307     ADD W6, W7, W6
002960  78039E     MOV [W14], W7
002962  780204     MOV W4, W4
002964  B82207     MUL.UU W4, W7, W4
002966  430305     ADD W6, W5, W6
002968  780286     MOV W6, W5
00296A  BE8F04     MOV.D W4, [W14]
00296C  BE8F04     MOV.D W4, [W14]
3104:                temp = temp >> 10;
00296E  BE021E     MOV.D [W14], W4
002970  DD2BC6     SL W5, #6, W7
002972  DE224A     LSR W4, #10, W4
002974  738204     IOR W7, W4, W4
002976  DEAACA     ASR W5, #10, W5
002978  BE8F04     MOV.D W4, [W14]
3105:                sum = temp;
00297A  BE021E     MOV.D [W14], W4
00297C  980724     MOV W4, [W14+4]
00297E  980735     MOV W5, [W14+6]
3106:              
3107:                temp = set_point;
002980  90025E     MOV [W14+10], W4
002982  200005     MOV #0x0, W5
002984  BE8F04     MOV.D W4, [W14]
3108:                temp *= control_loop_cal_data_ram_copy[EEPROM_CNTRL_MAGNET_FACTOR_LINEAR];
002986  80C1F4     MOV 0x183E, W4
002988  DEA2CF     ASR W4, #15, W5
00298A  90031E     MOV [W14+2], W6
00298C  B9B304     MUL.SS W6, W4, W6
00298E  780306     MOV W6, W6
002990  78039E     MOV [W14], W7
002992  B9B805     MUL.SS W7, W5, W0
002994  780380     MOV W0, W7
002996  430307     ADD W6, W7, W6
002998  78039E     MOV [W14], W7
00299A  780204     MOV W4, W4
00299C  B82207     MUL.UU W4, W7, W4
00299E  430305     ADD W6, W5, W6
0029A0  780286     MOV W6, W5
0029A2  BE8F04     MOV.D W4, [W14]
0029A4  BE8F04     MOV.D W4, [W14]
3109:                temp = temp >> 10;
0029A6  BE021E     MOV.D [W14], W4
0029A8  DD2B46     SL W5, #6, W6
0029AA  DE224A     LSR W4, #10, W4
0029AC  730204     IOR W6, W4, W4
0029AE  DEAACA     ASR W5, #10, W5
0029B0  BE8F04     MOV.D W4, [W14]
3110:              
3111:                sum += temp;
0029B2  90022E     MOV [W14+4], W4
0029B4  9002BE     MOV [W14+6], W5
0029B6  42033E     ADD W4, [W14++], W6
0029B8  4A83AE     ADDC W5, [W14--], W7
0029BA  BE0206     MOV.D W6, W4
0029BC  980724     MOV W4, [W14+4]
0029BE  980735     MOV W5, [W14+6]
3112:              
3113:                temp = control_loop_cal_data_ram_copy[EEPROM_CNTRL_MAGNET_FACTOR_CONST];
0029C0  80C204     MOV 0x1840, W4
0029C2  DEA2CF     ASR W4, #15, W5
0029C4  BE8F04     MOV.D W4, [W14]
3114:                
3115:                temp = temp << 2;
0029C6  BE031E     MOV.D [W14], W6
0029C8  DD3A42     SL W7, #2, W4
0029CA  DE32CE     LSR W6, #14, W5
0029CC  720285     IOR W4, W5, W5
0029CE  DD3242     SL W6, #2, W4
0029D0  BE8F04     MOV.D W4, [W14]
3116:              
3117:                sum += temp;
0029D2  90022E     MOV [W14+4], W4
0029D4  9002BE     MOV [W14+6], W5
0029D6  42033E     ADD W4, [W14++], W6
0029D8  4A83AE     ADDC W5, [W14--], W7
0029DA  BE0206     MOV.D W6, W4
0029DC  980724     MOV W4, [W14+4]
0029DE  980735     MOV W5, [W14+6]
3118:              
3119:                value = (sum & 0xFFFF);
0029E0  9003AE     MOV [W14+4], W7
0029E2  980747     MOV W7, [W14+8]
3120:                
3121:                return value; 
0029E4  90024E     MOV [W14+8], W4
3122:              }
0029E6  780004     MOV W4, W0
0029E8  FA8000     ULNK
0029EA  060000     RETURN
3123:              
3124:              
3125:              
